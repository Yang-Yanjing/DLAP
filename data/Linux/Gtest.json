[
    {
        "code": "static int sb1054_get_register(struct sb_uart_port *port, int page, int reg)\n{\n\tint ret = 0;\n\tunsigned int lcr = 0;\n\tunsigned int mcr = 0;\n\tunsigned int tmp = 0;\n\n\tif( page <= 0)\n\t{\n\t\tprintk(\" page 0 can not use this fuction\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch(page)\n\t{\n\t\tcase 1:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_DLAB;\n\t\t\tSB105X_PUT_LCR(port, tmp);\n\n\t\t\ttmp = SB105X_GET_LCR(port);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmcr = SB105X_GET_MCR(port);\n\t\t\ttmp = mcr | SB105X_MCR_P2S;\n\t\t\tSB105X_PUT_MCR(port,tmp);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_MCR(port,mcr);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P3KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P4KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\" error invalid page number \\n\");\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
        "vul_func_with_fix": "static int sb1054_get_register(struct sb_uart_port *port, int page, int reg)\n{\n\tint ret = 0;\n\tunsigned int lcr = 0;\n\tunsigned int mcr = 0;\n\tunsigned int tmp = 0;\n\n\tif( page <= 0)\n\t{\n\t\tprintk(\" page 0 can not use this fuction\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch(page)\n\t{\n\t\tcase 1:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_DLAB;\n\t\t\tSB105X_PUT_LCR(port, tmp);\n\n\t\t\ttmp = SB105X_GET_LCR(port);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmcr = SB105X_GET_MCR(port);\n\t\t\ttmp = mcr | SB105X_MCR_P2S;\n\t\t\tSB105X_PUT_MCR(port,tmp);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_MCR(port,mcr);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P3KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlcr = SB105X_GET_LCR(port);\n\t\t\ttmp = lcr | SB105X_LCR_BF;\n\t\t\tSB105X_PUT_LCR(port,tmp);\n\t\t\tSB105X_PUT_REG(port,SB105X_PSR,SB105X_PSR_P4KEY);\n\n\t\t\tret = SB105X_GET_REG(port,reg);\n\n\t\t\tSB105X_PUT_LCR(port,lcr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\" error invalid page number \\n\");\n\t\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 6.837459659436718e-05,
        "sysevr": 0.13549700379371643,
        "devign": 7.809189832682122e-31
    },
    {
        "code": "static int tcp_v4_md5_add_func(struct sock *sk, struct sock *addr_sk,\n\t\t\t       u8 *newkey, u8 newkeylen)\n{\n\treturn tcp_v4_md5_do_add(sk, inet_sk(addr_sk)->inet_daddr,\n\t\t\t\t newkey, newkeylen);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static int tcp_v4_md5_add_func(struct sock *sk, struct sock *addr_sk,\n\t\t\t       u8 *newkey, u8 newkeylen)\n{\n\treturn tcp_v4_md5_do_add(sk, inet_sk(addr_sk)->inet_daddr,\n\t\t\t\t newkey, newkeylen);\n}\n",
        "linevul": 7.316345727303997e-05,
        "sysevr": 0.12331385910511017,
        "devign": 3.9860231781929656e-10
    },
    {
        "code": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n \tint size;\n \n \tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n \t\treturn;\n \tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n \t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_exit *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->exit_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/086ba77a6db00ed858ff07451bedee197df868c9",
        "vul_func_with_fix": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n \tint size;\n \n \tsyscall_nr = trace_get_syscall_nr(current, regs);\n//flaw_line_below:\n\tif (syscall_nr < 0)\n//fix_flaw_line_below:\n//\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n \t\treturn;\n \tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n \t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\t/* We can probably do that at build time */\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_exit *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->exit_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}\n",
        "linevul": 0.9995926022529602,
        "sysevr": 0.13972584903240204,
        "devign": 0.44710180163383484
    },
    {
        "code": "int handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55",
        "vul_func_with_fix": "int handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}\n",
        "linevul": 0.000819795357529074,
        "sysevr": 0.25335800647735596,
        "devign": 1.7365806570524e-06
    },
    {
        "code": "static void change_port_settings(struct tty_struct *tty,\n\t\tstruct edgeport_port *edge_port, struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct ump_uart_config *config;\n\tint baud;\n\tunsigned cflag;\n\tint status;\n\tint port_number = edge_port->port->port_number;\n\n\tconfig = kmalloc (sizeof (*config), GFP_KERNEL);\n\tif (!config) {\n\t\ttty->termios = *old_termios;\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tconfig->wFlags = 0;\n\n\t/* These flags must be set */\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\n\tconfig->bUartMode = (__u8)(edge_port->bUartMode);\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\t    config->bDataBits = UMP_UART_CHAR5BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\t    break;\n\tcase CS6:\n\t\t    config->bDataBits = UMP_UART_CHAR6BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\t    break;\n\tcase CS7:\n\t\t    config->bDataBits = UMP_UART_CHAR7BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\t    break;\n\tdefault:\n\tcase CS8:\n\t\t    config->bDataBits = UMP_UART_CHAR8BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\t\t    break;\n\t}\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_ODDPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_EVENPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tconfig->bParity = UMP_UART_NOPARITY;\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t\trestart_read(edge_port);\n\t}\n\n\t/*\n\t * if we are implementing XON/XOFF, set the start and stop\n\t * character in the device\n\t */\n\tconfig->cXon  = START_CHAR(tty);\n\tconfig->cXoff = STOP_CHAR(tty);\n\n\t/* if we are implementing INBOUND XON/XOFF */\n\tif (I_IXOFF(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\n\t/* if we are implementing OUTBOUND XON/XOFF */\n\tif (I_IXON(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t/* Round the baud rate */\n\tbaud = tty_get_baud_rate(tty);\n \tif (!baud) {\n \t\t/* pick a default, any default... */\n \t\tbaud = 9600;\n\t} else\n \t\ttty_encode_baud_rate(tty, baud, baud);\n \n \tedge_port->baud_rate = baud;\n \tconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\n\n\t/* FIXME: Recompute actual baud from divisor here */\n\n\tdev_dbg(dev, \"%s - baud rate = %d, wBaudRate = %d\\n\", __func__, baud, config->wBaudRate);\n\n\tdev_dbg(dev, \"wBaudRate:   %d\\n\", (int)(461550L / config->wBaudRate));\n\tdev_dbg(dev, \"wFlags:    0x%x\\n\", config->wFlags);\n\tdev_dbg(dev, \"bDataBits:   %d\\n\", config->bDataBits);\n\tdev_dbg(dev, \"bParity:     %d\\n\", config->bParity);\n\tdev_dbg(dev, \"bStopBits:   %d\\n\", config->bStopBits);\n\tdev_dbg(dev, \"cXon:        %d\\n\", config->cXon);\n\tdev_dbg(dev, \"cXoff:       %d\\n\", config->cXoff);\n\tdev_dbg(dev, \"bUartMode:   %d\\n\", config->bUartMode);\n\n\t/* move the word values into big endian mode */\n\tcpu_to_be16s(&config->wFlags);\n\tcpu_to_be16s(&config->wBaudRate);\n\n\tstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\n\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t0, (__u8 *)config, sizeof(*config));\n\tif (status)\n\t\tdev_dbg(dev, \"%s - error %d when trying to write config to device\\n\",\n\t\t\t__func__, status);\n\tkfree(config);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6aeb75e6adfaed16e58780309613a578fe1ee90b",
        "vul_func_with_fix": "static void change_port_settings(struct tty_struct *tty,\n\t\tstruct edgeport_port *edge_port, struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct ump_uart_config *config;\n\tint baud;\n\tunsigned cflag;\n\tint status;\n\tint port_number = edge_port->port->port_number;\n\n\tconfig = kmalloc (sizeof (*config), GFP_KERNEL);\n\tif (!config) {\n\t\ttty->termios = *old_termios;\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tconfig->wFlags = 0;\n\n\t/* These flags must be set */\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\n\tconfig->bUartMode = (__u8)(edge_port->bUartMode);\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\t    config->bDataBits = UMP_UART_CHAR5BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\t    break;\n\tcase CS6:\n\t\t    config->bDataBits = UMP_UART_CHAR6BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\t    break;\n\tcase CS7:\n\t\t    config->bDataBits = UMP_UART_CHAR7BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\t    break;\n\tdefault:\n\tcase CS8:\n\t\t    config->bDataBits = UMP_UART_CHAR8BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\t\t    break;\n\t}\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_ODDPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_EVENPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tconfig->bParity = UMP_UART_NOPARITY;\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t\trestart_read(edge_port);\n\t}\n\n\t/*\n\t * if we are implementing XON/XOFF, set the start and stop\n\t * character in the device\n\t */\n\tconfig->cXon  = START_CHAR(tty);\n\tconfig->cXoff = STOP_CHAR(tty);\n\n\t/* if we are implementing INBOUND XON/XOFF */\n\tif (I_IXOFF(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\n\t/* if we are implementing OUTBOUND XON/XOFF */\n\tif (I_IXON(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t/* Round the baud rate */\n\tbaud = tty_get_baud_rate(tty);\n \tif (!baud) {\n \t\t/* pick a default, any default... */\n \t\tbaud = 9600;\n//flaw_line_below:\n\t} else\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\t/* Avoid a zero divisor. */\n//fix_flaw_line_below:\n//\t\tbaud = min(baud, 461550);\n \t\ttty_encode_baud_rate(tty, baud, baud);\n//fix_flaw_line_below:\n//\t}\n \n \tedge_port->baud_rate = baud;\n \tconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\n\n\t/* FIXME: Recompute actual baud from divisor here */\n\n\tdev_dbg(dev, \"%s - baud rate = %d, wBaudRate = %d\\n\", __func__, baud, config->wBaudRate);\n\n\tdev_dbg(dev, \"wBaudRate:   %d\\n\", (int)(461550L / config->wBaudRate));\n\tdev_dbg(dev, \"wFlags:    0x%x\\n\", config->wFlags);\n\tdev_dbg(dev, \"bDataBits:   %d\\n\", config->bDataBits);\n\tdev_dbg(dev, \"bParity:     %d\\n\", config->bParity);\n\tdev_dbg(dev, \"bStopBits:   %d\\n\", config->bStopBits);\n\tdev_dbg(dev, \"cXon:        %d\\n\", config->cXon);\n\tdev_dbg(dev, \"cXoff:       %d\\n\", config->cXoff);\n\tdev_dbg(dev, \"bUartMode:   %d\\n\", config->bUartMode);\n\n\t/* move the word values into big endian mode */\n\tcpu_to_be16s(&config->wFlags);\n\tcpu_to_be16s(&config->wBaudRate);\n\n\tstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\n\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t0, (__u8 *)config, sizeof(*config));\n\tif (status)\n\t\tdev_dbg(dev, \"%s - error %d when trying to write config to device\\n\",\n\t\t\t__func__, status);\n\tkfree(config);\n}\n",
        "linevul": 6.918382860021666e-05,
        "sysevr": 0.17265985906124115,
        "devign": 1.0432468282509646e-33
    },
    {
        "code": "static void mdiobus_release(struct device *d)\n{\n\tstruct mii_bus *bus = to_mii_bus(d);\n\tBUG_ON(bus->state != MDIOBUS_RELEASED &&\n\t       /* for compatibility with error handling in drivers */\n\t       bus->state != MDIOBUS_ALLOCATED);\n\tkfree(bus);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb",
        "vul_func_with_fix": "static void mdiobus_release(struct device *d)\n{\n\tstruct mii_bus *bus = to_mii_bus(d);\n\tBUG_ON(bus->state != MDIOBUS_RELEASED &&\n\t       /* for compatibility with error handling in drivers */\n\t       bus->state != MDIOBUS_ALLOCATED);\n\tkfree(bus);\n}\n",
        "linevul": 5.9199901443207636e-05,
        "sysevr": 0.12341431528329849,
        "devign": 5.844927319920146e-10
    },
    {
        "code": "int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,now))\n\t\tclp->cl_last_renewal = now;\n\tspin_unlock(&clp->cl_lock);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, 0);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,now))\n\t\tclp->cl_last_renewal = now;\n\tspin_unlock(&clp->cl_lock);\n\treturn 0;\n}\n",
        "linevul": 4.914994860882871e-05,
        "sysevr": 0.16208013892173767,
        "devign": 7.204534191451728e-11
    },
    {
        "code": "static bool access_pmu_evtyper(struct kvm_vcpu *vcpu, struct sys_reg_params *p,\n\t\t\t       const struct sys_reg_desc *r)\n{\n\tu64 idx, reg;\n\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\n\tif (pmu_access_el0_disabled(vcpu))\n\t\treturn false;\n\n\tif (r->CRn == 9 && r->CRm == 13 && r->Op2 == 1) {\n\t\t/* PMXEVTYPER_EL0 */\n\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0) & ARMV8_PMU_COUNTER_MASK;\n\t\treg = PMEVTYPER0_EL0 + idx;\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 12) {\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t\tif (idx == ARMV8_PMU_CYCLE_IDX)\n\t\t\treg = PMCCFILTR_EL0;\n\t\telse\n\t\t\t/* PMEVTYPERn_EL0 */\n\t\t\treg = PMEVTYPER0_EL0 + idx;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\n\tif (p->is_write) {\n\t\tkvm_pmu_set_counter_event_type(vcpu, p->regval, idx);\n\t\tvcpu_sys_reg(vcpu, reg) = p->regval & ARMV8_PMU_EVTYPE_MASK;\n\t} else {\n\t\tp->regval = vcpu_sys_reg(vcpu, reg) & ARMV8_PMU_EVTYPE_MASK;\n\t}\n\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9e3f7a29694049edd728e2400ab57ad7553e5aa9",
        "vul_func_with_fix": "static bool access_pmu_evtyper(struct kvm_vcpu *vcpu, struct sys_reg_params *p,\n\t\t\t       const struct sys_reg_desc *r)\n{\n\tu64 idx, reg;\n\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\n\tif (pmu_access_el0_disabled(vcpu))\n\t\treturn false;\n\n\tif (r->CRn == 9 && r->CRm == 13 && r->Op2 == 1) {\n\t\t/* PMXEVTYPER_EL0 */\n\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0) & ARMV8_PMU_COUNTER_MASK;\n\t\treg = PMEVTYPER0_EL0 + idx;\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 12) {\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t\tif (idx == ARMV8_PMU_CYCLE_IDX)\n\t\t\treg = PMCCFILTR_EL0;\n\t\telse\n\t\t\t/* PMEVTYPERn_EL0 */\n\t\t\treg = PMEVTYPER0_EL0 + idx;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\n\tif (p->is_write) {\n\t\tkvm_pmu_set_counter_event_type(vcpu, p->regval, idx);\n\t\tvcpu_sys_reg(vcpu, reg) = p->regval & ARMV8_PMU_EVTYPE_MASK;\n\t} else {\n\t\tp->regval = vcpu_sys_reg(vcpu, reg) & ARMV8_PMU_EVTYPE_MASK;\n\t}\n\n\treturn true;\n}\n",
        "linevul": 4.969382280251011e-05,
        "sysevr": 0.1735890507698059,
        "devign": 5.717639153578018e-17
    },
    {
        "code": "sctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tsctp_cwrhdr_t *cwr;\n\tstruct sctp_chunk *chunk = arg;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (sctp_cwrhdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f2815633504b442ca0b0605c16bf3d88a3a0fcea",
        "vul_func_with_fix": "sctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tsctp_cwrhdr_t *cwr;\n\tstruct sctp_chunk *chunk = arg;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (sctp_cwrhdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n",
        "linevul": 0.00019850986427627504,
        "sysevr": 0.2736256718635559,
        "devign": 2.8547331599321213e-12
    },
    {
        "code": "void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *ary,\n\t\t\t\t     int chunk_no,\n\t\t\t\t     __be32 rs_handle,\n\t\t\t\t     __be64 rs_offset,\n\t\t\t\t     u32 write_len)\n{\n\tstruct rpcrdma_segment *seg = &ary->wc_array[chunk_no].wc_target;\n\tseg->rs_handle = rs_handle;\n\tseg->rs_offset = rs_offset;\n\tseg->rs_length = cpu_to_be32(write_len);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *ary,\n//flaw_line_below:\n\t\t\t\t     int chunk_no,\n//flaw_line_below:\n\t\t\t\t     __be32 rs_handle,\n//flaw_line_below:\n\t\t\t\t     __be64 rs_offset,\n//flaw_line_below:\n\t\t\t\t     u32 write_len)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tstruct rpcrdma_segment *seg = &ary->wc_array[chunk_no].wc_target;\n//flaw_line_below:\n\tseg->rs_handle = rs_handle;\n//flaw_line_below:\n\tseg->rs_offset = rs_offset;\n//flaw_line_below:\n\tseg->rs_length = cpu_to_be32(write_len);\n//flaw_line_below:\n}\n",
        "linevul": 0.9729771614074707,
        "sysevr": 0.1729384809732437,
        "devign": 4.1260309444624e-06
    },
    {
        "code": "static int br_nf_pre_routing_finish(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct rtable *rt;\n\tint err;\n\n\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t}\n\tnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\n\tif (dnat_took_place(skb)) {\n\t\tif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\n\t\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\t\t/* If err equals -EHOSTUNREACH the error is due to a\n\t\t\t * martian destination or due to the fact that\n\t\t\t * forwarding is disabled. For most martian packets,\n\t\t\t * ip_route_output_key() will fail. It won't fail for 2 types of\n\t\t\t * martian destinations: loopback destinations and destination\n\t\t\t * 0.0.0.0. In both cases the packet will be dropped because the\n\t\t\t * destination is the loopback device and not the bridge. */\n\t\t\tif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\n\t\t\t\tgoto free_skb;\n\n\t\t\trt = ip_route_output(dev_net(dev), iph->daddr, 0,\n\t\t\t\t\t     RT_TOS(iph->tos), 0);\n\t\t\tif (!IS_ERR(rt)) {\n\t\t\t\t/* - Bridged-and-DNAT'ed traffic doesn't\n\t\t\t\t *   require ip_forwarding. */\n\t\t\t\tif (rt->dst.dev == dev) {\n\t\t\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\t\t\tgoto bridged_dnat;\n\t\t\t\t}\n\t\t\t\tip_rt_put(rt);\n\t\t\t}\nfree_skb:\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (skb_dst(skb)->dev == dev) {\nbridged_dnat:\n\t\t\t\tskb->dev = nf_bridge->physindev;\n\t\t\t\tnf_bridge_update_protocol(skb);\n\t\t\t\tnf_bridge_push_encap_header(skb);\n\t\t\t\tNF_HOOK_THRESH(NFPROTO_BRIDGE,\n\t\t\t\t\t       NF_BR_PRE_ROUTING,\n\t\t\t\t\t       skb, skb->dev, NULL,\n\t\t\t\t\t       br_nf_pre_routing_finish_bridge,\n\t\t\t\t\t       1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(eth_hdr(skb)->h_dest, dev->dev_addr, ETH_ALEN);\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t}\n\t} else {\n\t\trt = bridge_parent_rtable(nf_bridge->physindev);\n\t\tif (!rt) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\t}\n\n\tskb->dev = nf_bridge->physindev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\n\t\t       br_handle_frame_finish, 1);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64",
        "vul_func_with_fix": "static int br_nf_pre_routing_finish(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct nf_bridge_info *nf_bridge = skb->nf_bridge;\n\tstruct rtable *rt;\n\tint err;\n\n\tif (nf_bridge->mask & BRNF_PKT_TYPE) {\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tnf_bridge->mask ^= BRNF_PKT_TYPE;\n\t}\n\tnf_bridge->mask ^= BRNF_NF_BRIDGE_PREROUTING;\n\tif (dnat_took_place(skb)) {\n\t\tif ((err = ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))) {\n\t\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\t\t/* If err equals -EHOSTUNREACH the error is due to a\n\t\t\t * martian destination or due to the fact that\n\t\t\t * forwarding is disabled. For most martian packets,\n\t\t\t * ip_route_output_key() will fail. It won't fail for 2 types of\n\t\t\t * martian destinations: loopback destinations and destination\n\t\t\t * 0.0.0.0. In both cases the packet will be dropped because the\n\t\t\t * destination is the loopback device and not the bridge. */\n\t\t\tif (err != -EHOSTUNREACH || !in_dev || IN_DEV_FORWARD(in_dev))\n\t\t\t\tgoto free_skb;\n\n\t\t\trt = ip_route_output(dev_net(dev), iph->daddr, 0,\n\t\t\t\t\t     RT_TOS(iph->tos), 0);\n\t\t\tif (!IS_ERR(rt)) {\n\t\t\t\t/* - Bridged-and-DNAT'ed traffic doesn't\n\t\t\t\t *   require ip_forwarding. */\n\t\t\t\tif (rt->dst.dev == dev) {\n\t\t\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\t\t\tgoto bridged_dnat;\n\t\t\t\t}\n\t\t\t\tip_rt_put(rt);\n\t\t\t}\nfree_skb:\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (skb_dst(skb)->dev == dev) {\nbridged_dnat:\n\t\t\t\tskb->dev = nf_bridge->physindev;\n\t\t\t\tnf_bridge_update_protocol(skb);\n\t\t\t\tnf_bridge_push_encap_header(skb);\n\t\t\t\tNF_HOOK_THRESH(NFPROTO_BRIDGE,\n\t\t\t\t\t       NF_BR_PRE_ROUTING,\n\t\t\t\t\t       skb, skb->dev, NULL,\n\t\t\t\t\t       br_nf_pre_routing_finish_bridge,\n\t\t\t\t\t       1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(eth_hdr(skb)->h_dest, dev->dev_addr, ETH_ALEN);\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t}\n\t} else {\n\t\trt = bridge_parent_rtable(nf_bridge->physindev);\n\t\tif (!rt) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_dst_set_noref(skb, &rt->dst);\n\t}\n\n\tskb->dev = nf_bridge->physindev;\n\tnf_bridge_update_protocol(skb);\n\tnf_bridge_push_encap_header(skb);\n\tNF_HOOK_THRESH(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\n\t\t       br_handle_frame_finish, 1);\n\n\treturn 0;\n}\n",
        "linevul": 9.331289038527757e-05,
        "sysevr": 0.168072909116745,
        "devign": 0.0
    },
    {
        "code": "static int decode_open(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n        __be32 *p;\n\tuint32_t savewords, bmlen, i;\n        int status;\n\n        status = decode_op_hdr(xdr, OP_OPEN);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n        if (status)\n                return status;\n        READ_BUF(NFS4_STATEID_SIZE);\n        COPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\n        decode_change_info(xdr, &res->cinfo);\n\n        READ_BUF(8);\n        READ32(res->rflags);\n        READ32(bmlen);\n        if (bmlen > 10)\n                goto xdr_error;\n\n        READ_BUF(bmlen << 2);\n\tsavewords = min_t(uint32_t, bmlen, NFS4_BITMAP_SIZE);\n\tfor (i = 0; i < savewords; ++i)\n\t\tREAD32(res->attrset[i]);\n\tfor (; i < NFS4_BITMAP_SIZE; i++)\n\t\tres->attrset[i] = 0;\n\n\treturn decode_delegation(xdr, res);\nxdr_error:\n\tdprintk(\"%s: Bitmap too large! Length = %u\\n\", __func__, bmlen);\n\treturn -EIO;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int decode_open(struct xdr_stream *xdr, struct nfs_openres *res)\n{\n        __be32 *p;\n\tuint32_t savewords, bmlen, i;\n        int status;\n\n        status = decode_op_hdr(xdr, OP_OPEN);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n        if (status)\n                return status;\n        READ_BUF(NFS4_STATEID_SIZE);\n        COPYMEM(res->stateid.data, NFS4_STATEID_SIZE);\n\n        decode_change_info(xdr, &res->cinfo);\n\n        READ_BUF(8);\n        READ32(res->rflags);\n        READ32(bmlen);\n        if (bmlen > 10)\n                goto xdr_error;\n\n        READ_BUF(bmlen << 2);\n\tsavewords = min_t(uint32_t, bmlen, NFS4_BITMAP_SIZE);\n\tfor (i = 0; i < savewords; ++i)\n\t\tREAD32(res->attrset[i]);\n\tfor (; i < NFS4_BITMAP_SIZE; i++)\n\t\tres->attrset[i] = 0;\n\n\treturn decode_delegation(xdr, res);\nxdr_error:\n\tdprintk(\"%s: Bitmap too large! Length = %u\\n\", __func__, bmlen);\n\treturn -EIO;\n}\n",
        "linevul": 0.005013432819396257,
        "sysevr": 0.12248119711875916,
        "devign": 0.10063634067773819
    },
    {
        "code": "static inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "vul_func_with_fix": "static inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);\n}\n",
        "linevul": 5.773704469902441e-05,
        "sysevr": 0.1259136199951172,
        "devign": 1.9463363059912808e-05
    },
    {
        "code": "static int sg_proc_open_debug(struct inode *inode, struct file *file)\n{\n        return seq_open(file, &debug_seq_ops);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/451a2886b6bf90e2fb378f7c46c655450fb96e81",
        "vul_func_with_fix": "static int sg_proc_open_debug(struct inode *inode, struct file *file)\n{\n        return seq_open(file, &debug_seq_ops);\n}\n",
        "linevul": 0.0001849236141424626,
        "sysevr": 0.12425761669874191,
        "devign": 0.0002928999892901629
    },
    {
        "code": "static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n \t\treturn 0;\n \t}\n \n\tlen = bt_sock_stream_recvmsg(iocb, sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e11e0455c0d7d3d62276a0c55d9dfbc16779d691",
        "vul_func_with_fix": "static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n//fix_flaw_line_below:\n//\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \n\tlen = bt_sock_stream_recvmsg(iocb, sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}\n",
        "linevul": 0.9995846152305603,
        "sysevr": 0.1358809918165207,
        "devign": 1.716761889757465e-22
    },
    {
        "code": "int ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3e4c56d41eef5595035872a2ec5a483f42e8917f",
        "vul_func_with_fix": "int ocfs2_read_inline_data(struct inode *inode, struct page *page,\n\t\t\t   struct buffer_head *di_bh)\n{\n\tvoid *kaddr;\n\tloff_t size;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {\n\t\tocfs2_error(inode->i_sb, \"Inode %llu lost inline data flag\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\treturn -EROFS;\n\t}\n\n\tsize = i_size_read(inode);\n\n\tif (size > PAGE_SIZE ||\n\t    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has with inline data has bad size: %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)size);\n\t\treturn -EROFS;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tif (size)\n\t\tmemcpy(kaddr, di->id2.i_data.id_data, size);\n\t/* Clear the remaining part of the page */\n\tmemset(kaddr + size, 0, PAGE_SIZE - size);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tSetPageUptodate(page);\n\n\treturn 0;\n}\n",
        "linevul": 0.0022355173714458942,
        "sysevr": 0.20645345747470856,
        "devign": 1.395434440741583e-12
    },
    {
        "code": " parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int regard_xa)\n {\n \tint symlink_len = 0;\n \tint cnt, sig;\n \tstruct inode *reloc;\n \tstruct rock_ridge *rr;\n \tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n \n \tinit_rock_state(&rs, inode);\n \tsetup_rock_ridge(de, inode, &rs);\n\tif (regard_xa) {\n \t\trs.chr += 14;\n \t\trs.len -= 14;\n \t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n \t\t\t\t\t\"relocated directory\\n\");\n \t\t\tgoto out;\n \t\tcase SIG('C', 'L'):\n\t\t\tISOFS_I(inode)->i_first_extent =\n\t\t\t    isonum_733(rr->u.CL.location);\n\t\t\treloc =\n\t\t\t    isofs_iget(inode->i_sb,\n\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n\t\t\t\t       0);\n \t\t\tif (IS_ERR(reloc)) {\n \t\t\t\tret = PTR_ERR(reloc);\n \t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4",
        "vul_func_with_fix": " parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n//flaw_line_below:\n\t\t\t\tstruct inode *inode, int regard_xa)\n//fix_flaw_line_below:\n//\t\t\t\tstruct inode *inode, int flags)\n {\n \tint symlink_len = 0;\n \tint cnt, sig;\n//fix_flaw_line_below:\n//\tunsigned int reloc_block;\n \tstruct inode *reloc;\n \tstruct rock_ridge *rr;\n \tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n \n \tinit_rock_state(&rs, inode);\n \tsetup_rock_ridge(de, inode, &rs);\n//flaw_line_below:\n\tif (regard_xa) {\n//fix_flaw_line_below:\n//\tif (flags & RR_REGARD_XA) {\n \t\trs.chr += 14;\n \t\trs.len -= 14;\n \t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n \t\t\t\t\t\"relocated directory\\n\");\n \t\t\tgoto out;\n \t\tcase SIG('C', 'L'):\n//flaw_line_below:\n\t\t\tISOFS_I(inode)->i_first_extent =\n//flaw_line_below:\n\t\t\t    isonum_733(rr->u.CL.location);\n//flaw_line_below:\n\t\t\treloc =\n//flaw_line_below:\n\t\t\t    isofs_iget(inode->i_sb,\n//flaw_line_below:\n\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n//flaw_line_below:\n\t\t\t\t       0);\n//fix_flaw_line_below:\n//\t\t\tif (flags & RR_RELOC_DE) {\n//fix_flaw_line_below:\n//\t\t\t\tprintk(KERN_ERR\n//fix_flaw_line_below:\n//\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n//fix_flaw_line_below:\n//\t\t\t\t       \"is not supported\\n\");\n//fix_flaw_line_below:\n//\t\t\t\tgoto eio;\n//fix_flaw_line_below:\n//\t\t\t}\n//fix_flaw_line_below:\n//\t\t\treloc_block = isonum_733(rr->u.CL.location);\n//fix_flaw_line_below:\n//\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n//fix_flaw_line_below:\n//\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n//fix_flaw_line_below:\n//\t\t\t\tprintk(KERN_ERR\n//fix_flaw_line_below:\n//\t\t\t\t       \"ISOFS: Directory relocation points to \"\n//fix_flaw_line_below:\n//\t\t\t\t       \"itself\\n\");\n//fix_flaw_line_below:\n//\t\t\t\tgoto eio;\n//fix_flaw_line_below:\n//\t\t\t}\n//fix_flaw_line_below:\n//\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n//fix_flaw_line_below:\n//\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n \t\t\tif (IS_ERR(reloc)) {\n \t\t\t\tret = PTR_ERR(reloc);\n \t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n",
        "linevul": 0.9995219707489014,
        "sysevr": 0.31314200162887573,
        "devign": 0.010785804130136967
    },
    {
        "code": "void blk_mq_freeze_queue(struct request_queue *q)\n{\n\tblk_mq_freeze_queue_start(q);\n\tblk_mq_freeze_queue_wait(q);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9",
        "vul_func_with_fix": "void blk_mq_freeze_queue(struct request_queue *q)\n{\n\tblk_mq_freeze_queue_start(q);\n\tblk_mq_freeze_queue_wait(q);\n}\n",
        "linevul": 0.0001022953656502068,
        "sysevr": 0.15661542117595673,
        "devign": 0.0030580335296690464
    },
    {
        "code": "static int select_idle_cpu(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\tstruct sched_domain *this_sd;\n\tu64 avg_cost, avg_idle;\n\tu64 time, cost;\n\ts64 delta;\n\tint cpu, nr = INT_MAX;\n\n\tthis_sd = rcu_dereference(*this_cpu_ptr(&sd_llc));\n\tif (!this_sd)\n\t\treturn -1;\n\n\t/*\n\t * Due to large variance we need a large fuzz factor; hackbench in\n\t * particularly is sensitive here.\n\t */\n\tavg_idle = this_rq()->avg_idle / 512;\n\tavg_cost = this_sd->avg_scan_cost + 1;\n\n\tif (sched_feat(SIS_AVG_CPU) && avg_idle < avg_cost)\n\t\treturn -1;\n\n\tif (sched_feat(SIS_PROP)) {\n\t\tu64 span_avg = sd->span_weight * avg_idle;\n\t\tif (span_avg > 4*avg_cost)\n\t\t\tnr = div_u64(span_avg, avg_cost);\n\t\telse\n\t\t\tnr = 4;\n\t}\n\n\ttime = local_clock();\n\n\tfor_each_cpu_wrap(cpu, sched_domain_span(sd), target) {\n\t\tif (!--nr)\n\t\t\treturn -1;\n\t\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\t\tcontinue;\n\t\tif (available_idle_cpu(cpu))\n\t\t\tbreak;\n\t}\n\n\ttime = local_clock() - time;\n\tcost = this_sd->avg_scan_cost;\n\tdelta = (s64)(time - cost) / 8;\n\tthis_sd->avg_scan_cost += delta;\n\n\treturn cpu;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static int select_idle_cpu(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\tstruct sched_domain *this_sd;\n\tu64 avg_cost, avg_idle;\n\tu64 time, cost;\n\ts64 delta;\n\tint cpu, nr = INT_MAX;\n\n\tthis_sd = rcu_dereference(*this_cpu_ptr(&sd_llc));\n\tif (!this_sd)\n\t\treturn -1;\n\n\t/*\n\t * Due to large variance we need a large fuzz factor; hackbench in\n\t * particularly is sensitive here.\n\t */\n\tavg_idle = this_rq()->avg_idle / 512;\n\tavg_cost = this_sd->avg_scan_cost + 1;\n\n\tif (sched_feat(SIS_AVG_CPU) && avg_idle < avg_cost)\n\t\treturn -1;\n\n\tif (sched_feat(SIS_PROP)) {\n\t\tu64 span_avg = sd->span_weight * avg_idle;\n\t\tif (span_avg > 4*avg_cost)\n\t\t\tnr = div_u64(span_avg, avg_cost);\n\t\telse\n\t\t\tnr = 4;\n\t}\n\n\ttime = local_clock();\n\n\tfor_each_cpu_wrap(cpu, sched_domain_span(sd), target) {\n\t\tif (!--nr)\n\t\t\treturn -1;\n\t\tif (!cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\t\tcontinue;\n\t\tif (available_idle_cpu(cpu))\n\t\t\tbreak;\n\t}\n\n\ttime = local_clock() - time;\n\tcost = this_sd->avg_scan_cost;\n\tdelta = (s64)(time - cost) / 8;\n\tthis_sd->avg_scan_cost += delta;\n\n\treturn cpu;\n}\n",
        "linevul": 9.690273145679384e-05,
        "sysevr": 0.1470528542995453,
        "devign": 1.1093855165980323e-21
    },
    {
        "code": "static int ceph_x_should_authenticate(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint need;\n\n\tceph_x_validate_tickets(ac, &need);\n\tdout(\"ceph_x_should_authenticate want=%d need=%d have=%d\\n\",\n\t     ac->want_keys, need, xi->have_keys);\n\treturn need != 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8",
        "vul_func_with_fix": "static int ceph_x_should_authenticate(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint need;\n\n\tceph_x_validate_tickets(ac, &need);\n\tdout(\"ceph_x_should_authenticate want=%d need=%d have=%d\\n\",\n\t     ac->want_keys, need, xi->have_keys);\n\treturn need != 0;\n}\n",
        "linevul": 4.716905823443085e-05,
        "sysevr": 0.12682127952575684,
        "devign": 0.008380631916224957
    },
    {
        "code": "static void sctp_cmd_adaptation_ind(sctp_cmd_seq_t *commands,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e",
        "vul_func_with_fix": "static void sctp_cmd_adaptation_ind(sctp_cmd_seq_t *commands,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\n\tif (ev)\n\t\tsctp_ulpq_tail_event(&asoc->ulpq, ev);\n}\n",
        "linevul": 4.755114423460327e-05,
        "sysevr": 0.12936094403266907,
        "devign": 2.0308759118847775e-08
    },
    {
        "code": "void msg_init_ns(struct ipc_namespace *ns)\n{\n\tns->msg_ctlmax = MSGMAX;\n\tns->msg_ctlmnb = MSGMNB;\n\n\trecompute_msgmni(ns);\n\n\tatomic_set(&ns->msg_bytes, 0);\n\tatomic_set(&ns->msg_hdrs, 0);\n\tipc_init_ids(&ns->ids[IPC_MSG_IDS]);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": "void msg_init_ns(struct ipc_namespace *ns)\n{\n\tns->msg_ctlmax = MSGMAX;\n\tns->msg_ctlmnb = MSGMNB;\n\n\trecompute_msgmni(ns);\n\n\tatomic_set(&ns->msg_bytes, 0);\n\tatomic_set(&ns->msg_hdrs, 0);\n\tipc_init_ids(&ns->ids[IPC_MSG_IDS]);\n}\n",
        "linevul": 0.00013641927216667682,
        "sysevr": 0.15898171067237854,
        "devign": 4.260089099261677e-07
    },
    {
        "code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = disconnect_mount(p, how);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n//fix_flaw_line_below:\n//\t\tstruct mnt_namespace *ns;\n \t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n//flaw_line_below:\n\t\t__touch_mnt_namespace(p->mnt_ns);\n//fix_flaw_line_below:\n//\t\tns = p->mnt_ns;\n//fix_flaw_line_below:\n//\t\tif (ns) {\n//fix_flaw_line_below:\n//\t\t\tns->mounts--;\n//fix_flaw_line_below:\n//\t\t\t__touch_mnt_namespace(ns);\n//fix_flaw_line_below:\n//\t\t}\n \t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = disconnect_mount(p, how);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}\n",
        "linevul": 0.999573290348053,
        "sysevr": 0.12527567148208618,
        "devign": 0.9986602067947388
    },
    {
        "code": "static void ip4_frag_init(struct inet_frag_queue *q, void *a)\n{\n\tstruct ipq *qp = container_of(q, struct ipq, q);\n\tstruct ip4_create_arg *arg = a;\n\n\tqp->protocol = arg->iph->protocol;\n\tqp->id = arg->iph->id;\n\tqp->ecn = ip4_frag_ecn(arg->iph->tos);\n\tqp->saddr = arg->iph->saddr;\n\tqp->daddr = arg->iph->daddr;\n\tqp->user = arg->user;\n\tqp->peer = sysctl_ipfrag_max_dist ?\n\t\tinet_getpeer_v4(arg->iph->saddr, 1) : NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/64f3b9e203bd06855072e295557dca1485a2ecba",
        "vul_func_with_fix": "static void ip4_frag_init(struct inet_frag_queue *q, void *a)\n{\n\tstruct ipq *qp = container_of(q, struct ipq, q);\n\tstruct ip4_create_arg *arg = a;\n\n\tqp->protocol = arg->iph->protocol;\n\tqp->id = arg->iph->id;\n\tqp->ecn = ip4_frag_ecn(arg->iph->tos);\n\tqp->saddr = arg->iph->saddr;\n\tqp->daddr = arg->iph->daddr;\n\tqp->user = arg->user;\n\tqp->peer = sysctl_ipfrag_max_dist ?\n\t\tinet_getpeer_v4(arg->iph->saddr, 1) : NULL;\n}\n",
        "linevul": 5.032321860198863e-05,
        "sysevr": 0.16518856585025787,
        "devign": 1.724904677757877e-06
    },
    {
        "code": "static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))\n\t\treturn -EINVAL;\n\n\tif (len < 4 || len > HCI_MAX_FRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\tbreak;\n\tcase HCI_CHANNEL_CONTROL:\n\t\terr = mgmt_control(sk, msg, len);\n\t\tgoto done;\n\tcase HCI_CHANNEL_MONITOR:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\thdev = hci_pi(sk)->hdev;\n\tif (!hdev) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = -ENETDOWN;\n\t\tgoto done;\n\t}\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\terr = -EFAULT;\n\t\tgoto drop;\n\t}\n\n\tbt_cb(skb)->pkt_type = *((unsigned char *) skb->data);\n\tskb_pull(skb, 1);\n\tskb->dev = (void *) hdev;\n\n\tif (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {\n\t\tu16 opcode = get_unaligned_le16(skb->data);\n\t\tu16 ogf = hci_opcode_ogf(opcode);\n\t\tu16 ocf = hci_opcode_ocf(opcode);\n\n\t\tif (((ogf > HCI_SFLT_MAX_OGF) ||\n\t\t     !hci_test_bit(ocf & HCI_FLT_OCF_BITS,\n\t\t\t\t   &hci_sec_filter.ocf_mask[ogf])) &&\n\t\t    !capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {\n\t\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t\t} else {\n\t\t\tskb_queue_tail(&hdev->cmd_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n\t\t}\n\t} else {\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t}\n\n\terr = len;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n\ndrop:\n\tkfree_skb(skb);\n\tgoto done;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e15ca9a0ef9a86f0477530b0f44a725d67f889ee",
        "vul_func_with_fix": "static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))\n\t\treturn -EINVAL;\n\n\tif (len < 4 || len > HCI_MAX_FRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\tbreak;\n\tcase HCI_CHANNEL_CONTROL:\n\t\terr = mgmt_control(sk, msg, len);\n\t\tgoto done;\n\tcase HCI_CHANNEL_MONITOR:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\thdev = hci_pi(sk)->hdev;\n\tif (!hdev) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = -ENETDOWN;\n\t\tgoto done;\n\t}\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\terr = -EFAULT;\n\t\tgoto drop;\n\t}\n\n\tbt_cb(skb)->pkt_type = *((unsigned char *) skb->data);\n\tskb_pull(skb, 1);\n\tskb->dev = (void *) hdev;\n\n\tif (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {\n\t\tu16 opcode = get_unaligned_le16(skb->data);\n\t\tu16 ogf = hci_opcode_ogf(opcode);\n\t\tu16 ocf = hci_opcode_ocf(opcode);\n\n\t\tif (((ogf > HCI_SFLT_MAX_OGF) ||\n\t\t     !hci_test_bit(ocf & HCI_FLT_OCF_BITS,\n\t\t\t\t   &hci_sec_filter.ocf_mask[ogf])) &&\n\t\t    !capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {\n\t\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t\t} else {\n\t\t\tskb_queue_tail(&hdev->cmd_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n\t\t}\n\t} else {\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t}\n\n\terr = len;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n\ndrop:\n\tkfree_skb(skb);\n\tgoto done;\n}\n",
        "linevul": 7.894787995610386e-05,
        "sysevr": 0.18531858921051025,
        "devign": 7.978642077472982e-35
    },
    {
        "code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae",
        "vul_func_with_fix": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n//flaw_line_below:\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n//fix_flaw_line_below:\n//\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n//fix_flaw_line_below:\n//\t\tcomplete(&task->slow_task->completion);\n//fix_flaw_line_below:\n//\t}\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n//flaw_line_below:\n\n//flaw_line_below:\n\tcomplete(&task->slow_task->completion);\n }\n",
        "linevul": 0.9996020197868347,
        "sysevr": 0.1273820549249649,
        "devign": 0.9999992847442627
    },
    {
        "code": "static size_t rtnl_port_size(const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tsize_t port_size = nla_total_size(4)\t\t/* PORT_VF */\n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t/* PORT_PROFILE */\n\t\t+ nla_total_size(sizeof(struct ifla_port_vsi))\n\t\t\t\t\t\t\t/* PORT_VSI_TYPE */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_INSTANCE_UUID */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_HOST_UUID */\n\t\t+ nla_total_size(1)\t\t\t/* PROT_VDP_REQUEST */\n\t\t+ nla_total_size(2);\t\t\t/* PORT_VDP_RESPONSE */\n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f8e44741f9f216e33736ea4ec65ca9ac03036e6",
        "vul_func_with_fix": "static size_t rtnl_port_size(const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tsize_t port_size = nla_total_size(4)\t\t/* PORT_VF */\n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t/* PORT_PROFILE */\n\t\t+ nla_total_size(sizeof(struct ifla_port_vsi))\n\t\t\t\t\t\t\t/* PORT_VSI_TYPE */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_INSTANCE_UUID */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_HOST_UUID */\n\t\t+ nla_total_size(1)\t\t\t/* PROT_VDP_REQUEST */\n\t\t+ nla_total_size(2);\t\t\t/* PORT_VDP_RESPONSE */\n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n",
        "linevul": 6.276062777033076e-05,
        "sysevr": 0.13005614280700684,
        "devign": 1.2279191552444502e-10
    },
    {
        "code": "bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout)\n{\n\tunsigned long now, token;\n\tbool rc = false;\n\n\tif (!peer)\n\t\treturn true;\n\n\ttoken = peer->rate_tokens;\n\tnow = jiffies;\n\ttoken += now - peer->rate_last;\n\tpeer->rate_last = now;\n\tif (token > XRLIM_BURST_FACTOR * timeout)\n\t\ttoken = XRLIM_BURST_FACTOR * timeout;\n\tif (token >= timeout) {\n\t\ttoken -= timeout;\n\t\trc = true;\n\t}\n\tpeer->rate_tokens = token;\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
        "vul_func_with_fix": "bool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout)\n{\n\tunsigned long now, token;\n\tbool rc = false;\n\n\tif (!peer)\n\t\treturn true;\n\n\ttoken = peer->rate_tokens;\n\tnow = jiffies;\n\ttoken += now - peer->rate_last;\n\tpeer->rate_last = now;\n\tif (token > XRLIM_BURST_FACTOR * timeout)\n\t\ttoken = XRLIM_BURST_FACTOR * timeout;\n\tif (token >= timeout) {\n\t\ttoken -= timeout;\n\t\trc = true;\n\t}\n\tpeer->rate_tokens = token;\n\treturn rc;\n}\n",
        "linevul": 5.9745947510236874e-05,
        "sysevr": 0.16865256428718567,
        "devign": 2.12500017369166e-05
    },
    {
        "code": " static int install_process_keyring(void)\n {\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n \tret = install_process_keyring_to_cred(new);\n \tif (ret < 0) {\n \t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n \t}\n \n \treturn commit_creds(new);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b",
        "vul_func_with_fix": " static int install_process_keyring(void)\n {\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n \tret = install_process_keyring_to_cred(new);\n \tif (ret < 0) {\n \t\tabort_creds(new);\n//flaw_line_below:\n\t\treturn ret != -EEXIST ? ret : 0;\n//fix_flaw_line_below:\n//\t\treturn ret;\n \t}\n \n \treturn commit_creds(new);\n }\n",
        "linevul": 0.9994446635246277,
        "sysevr": 0.12555621564388275,
        "devign": 0.9999384880065918
    },
    {
        "code": "static struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tstruct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->label = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(data->label))\n\t\t\tgoto out_free;\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = nfs4_bitmask(server, data->label);\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tdata->res.label = data->label;\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\treturn data;\nout_free:\n\tkfree(data);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tstruct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->label = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(data->label))\n\t\t\tgoto out_free;\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = nfs4_bitmask(server, data->label);\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tdata->res.label = data->label;\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\treturn data;\nout_free:\n\tkfree(data);\n\treturn NULL;\n}\n",
        "linevul": 0.00024003448197618127,
        "sysevr": 0.21002666652202606,
        "devign": 0.12045198678970337
    },
    {
        "code": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (d_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (d_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\n",
        "linevul": 7.623954297741875e-05,
        "sysevr": 0.17008037865161896,
        "devign": 9.447508331206222e-10
    },
    {
        "code": "intel_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tc = intel_bts_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_pebs_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_percore_constraints(cpuc, event);\n\tif (c)\n\t\treturn c;\n\n\treturn x86_get_event_constraints(cpuc, event);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "intel_get_event_constraints(struct cpu_hw_events *cpuc, struct perf_event *event)\n{\n\tstruct event_constraint *c;\n\n\tc = intel_bts_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_pebs_constraints(event);\n\tif (c)\n\t\treturn c;\n\n\tc = intel_percore_constraints(cpuc, event);\n\tif (c)\n\t\treturn c;\n\n\treturn x86_get_event_constraints(cpuc, event);\n}\n",
        "linevul": 4.7729507059557363e-05,
        "sysevr": 0.16806186735630035,
        "devign": 1.1030599880978633e-21
    },
    {
        "code": "static inline struct net_device** get_dev_p(pvc_device *pvc, int type)\n{\n\tif (type == ARPHRD_ETHER)\n\t\treturn &pvc->ether;\n\telse\n\t\treturn &pvc->main;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static inline struct net_device** get_dev_p(pvc_device *pvc, int type)\n{\n\tif (type == ARPHRD_ETHER)\n\t\treturn &pvc->ether;\n\telse\n\t\treturn &pvc->main;\n}\n",
        "linevul": 6.106810906203464e-05,
        "sysevr": 0.12490178644657135,
        "devign": 1.044267428085277e-08
    },
    {
        "code": "static const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static const char *nfsd4_op_name(unsigned opnum)\n{\n\tif (opnum < ARRAY_SIZE(nfsd4_ops))\n\t\treturn nfsd4_ops[opnum].op_name;\n\treturn \"unknown_operation\";\n}\n",
        "linevul": 5.742778012063354e-05,
        "sysevr": 0.1266055703163147,
        "devign": 1.7059557100296274e-09
    },
    {
        "code": "static int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tif (unlikely(f->f_flags & O_PATH))\n\t\tf->f_mode = FMODE_PATH;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tif (f->f_mode & FMODE_WRITE) {\n\t\terror = __get_file_write_access(inode, f->f_path.mnt);\n\t\tif (error)\n\t\t\tgoto cleanup_file;\n\t\tif (!special_file(inode->i_mode))\n\t\t\tfile_take_write(f);\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n \n cleanup_all:\n \tfops_put(f->f_op);\n\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We don't consider this a real\n\t\t\t * mnt_want/drop_write() pair\n\t\t\t * because it all happenend right\n\t\t\t * here, so just reset the state.\n\t\t\t */\n\t\t\tfile_reset_write(f);\n\t\t\t__mnt_drop_write(f->f_path.mnt);\n\t\t}\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87",
        "vul_func_with_fix": "static int do_dentry_open(struct file *f,\n\t\t\t  int (*open)(struct inode *, struct file *),\n\t\t\t  const struct cred *cred)\n{\n\tstatic const struct file_operations empty_fops = {};\n\tstruct inode *inode;\n\tint error;\n\n\tf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\n\t\t\t\tFMODE_PREAD | FMODE_PWRITE;\n\n\tif (unlikely(f->f_flags & O_PATH))\n\t\tf->f_mode = FMODE_PATH;\n\n\tpath_get(&f->f_path);\n\tinode = f->f_inode = f->f_path.dentry->d_inode;\n\tif (f->f_mode & FMODE_WRITE) {\n\t\terror = __get_file_write_access(inode, f->f_path.mnt);\n\t\tif (error)\n\t\t\tgoto cleanup_file;\n\t\tif (!special_file(inode->i_mode))\n\t\t\tfile_take_write(f);\n \t}\n \n \tf->f_mapping = inode->i_mapping;\n//flaw_line_below:\n\tfile_sb_list_add(f, inode->i_sb);\n \n \tif (unlikely(f->f_mode & FMODE_PATH)) {\n \t\tf->f_op = &empty_fops;\n\t\treturn 0;\n\t}\n\n\tf->f_op = fops_get(inode->i_fop);\n\tif (unlikely(WARN_ON(!f->f_op))) {\n\t\terror = -ENODEV;\n\t\tgoto cleanup_all;\n\t}\n\n\terror = security_file_open(f, cred);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\terror = break_lease(inode, f->f_flags);\n\tif (error)\n\t\tgoto cleanup_all;\n\n\tif (!open)\n\t\topen = f->f_op->open;\n\tif (open) {\n\t\terror = open(inode, f);\n\t\tif (error)\n\t\t\tgoto cleanup_all;\n\t}\n\tif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(inode);\n\n\tf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\n\n\tfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\n\n\treturn 0;\n \n cleanup_all:\n \tfops_put(f->f_op);\n//flaw_line_below:\n\tfile_sb_list_del(f);\n \tif (f->f_mode & FMODE_WRITE) {\n \t\tput_write_access(inode);\n \t\tif (!special_file(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * We don't consider this a real\n\t\t\t * mnt_want/drop_write() pair\n\t\t\t * because it all happenend right\n\t\t\t * here, so just reset the state.\n\t\t\t */\n\t\t\tfile_reset_write(f);\n\t\t\t__mnt_drop_write(f->f_path.mnt);\n\t\t}\n\t}\ncleanup_file:\n\tpath_put(&f->f_path);\n\tf->f_path.mnt = NULL;\n\tf->f_path.dentry = NULL;\n\tf->f_inode = NULL;\n\treturn error;\n}\n",
        "linevul": 8.871844329405576e-05,
        "sysevr": 0.20054280757904053,
        "devign": 0.9963086247444153
    },
    {
        "code": "static int em_btc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btc\");\n\treturn X86EMUL_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84",
        "vul_func_with_fix": "static int em_btc(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV_nobyte(ctxt, \"btc\");\n\treturn X86EMUL_CONTINUE;\n}\n",
        "linevul": 5.1480932597769424e-05,
        "sysevr": 0.13021333515644073,
        "devign": 0.0007154178456403315
    },
    {
        "code": "int kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tint objects = oo_objects(s->max);\n\tstruct list_head *slabs_by_inuse =\n\t\tkmalloc(sizeof(struct list_head) * objects, GFP_KERNEL);\n\tunsigned long flags;\n\n\tif (!slabs_by_inuse)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tn = get_node(s, node);\n\n\t\tif (!n->nr_partial)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < objects; i++)\n\t\t\tINIT_LIST_HEAD(slabs_by_inuse + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists indexed by the items in use in each slab.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tif (!page->inuse && slab_trylock(page)) {\n\t\t\t\t/*\n\t\t\t\t * Must hold slab lock here because slab_free\n\t\t\t\t * may have freed the last object and be\n\t\t\t\t * waiting to release the slab.\n\t\t\t\t */\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\tn->nr_partial--;\n\t\t\t\tslab_unlock(page);\n\t\t\t\tdiscard_slab(s, page);\n\t\t\t} else {\n\t\t\t\tlist_move(&page->lru,\n\t\t\t\tslabs_by_inuse + page->inuse);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Rebuild the partial list with the slabs filled up most\n\t\t * first and the least used slabs at the end.\n\t\t */\n\t\tfor (i = objects - 1; i >= 0; i--)\n\t\t\tlist_splice(slabs_by_inuse + i, n->partial.prev);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tkfree(slabs_by_inuse);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "int kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tint objects = oo_objects(s->max);\n\tstruct list_head *slabs_by_inuse =\n\t\tkmalloc(sizeof(struct list_head) * objects, GFP_KERNEL);\n\tunsigned long flags;\n\n\tif (!slabs_by_inuse)\n\t\treturn -ENOMEM;\n\n\tflush_all(s);\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tn = get_node(s, node);\n\n\t\tif (!n->nr_partial)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < objects; i++)\n\t\t\tINIT_LIST_HEAD(slabs_by_inuse + i);\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\n\t\t/*\n\t\t * Build lists indexed by the items in use in each slab.\n\t\t *\n\t\t * Note that concurrent frees may occur while we hold the\n\t\t * list_lock. page->inuse here is the upper limit.\n\t\t */\n\t\tlist_for_each_entry_safe(page, t, &n->partial, lru) {\n\t\t\tif (!page->inuse && slab_trylock(page)) {\n\t\t\t\t/*\n\t\t\t\t * Must hold slab lock here because slab_free\n\t\t\t\t * may have freed the last object and be\n\t\t\t\t * waiting to release the slab.\n\t\t\t\t */\n\t\t\t\tlist_del(&page->lru);\n\t\t\t\tn->nr_partial--;\n\t\t\t\tslab_unlock(page);\n\t\t\t\tdiscard_slab(s, page);\n\t\t\t} else {\n\t\t\t\tlist_move(&page->lru,\n\t\t\t\tslabs_by_inuse + page->inuse);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Rebuild the partial list with the slabs filled up most\n\t\t * first and the least used slabs at the end.\n\t\t */\n\t\tfor (i = objects - 1; i >= 0; i--)\n\t\t\tlist_splice(slabs_by_inuse + i, n->partial.prev);\n\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tkfree(slabs_by_inuse);\n\treturn 0;\n}\n",
        "linevul": 0.002269125310704112,
        "sysevr": 0.22099141776561737,
        "devign": 1.2290075623866414e-08
    },
    {
        "code": "static int orinoco_set_key(struct orinoco_private *priv, int index,\n\t\t\t   enum orinoco_alg alg, const u8 *key, int key_len,\n\t\t\t   const u8 *seq, int seq_len)\n{\n\tkzfree(priv->keys[index].key);\n\tkzfree(priv->keys[index].seq);\n\n\tif (key_len) {\n\t\tpriv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].key)\n\t\t\tgoto nomem;\n\t} else\n\t\tpriv->keys[index].key = NULL;\n\n\tif (seq_len) {\n\t\tpriv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].seq)\n\t\t\tgoto free_key;\n\t} else\n\t\tpriv->keys[index].seq = NULL;\n\n\tpriv->keys[index].key_len = key_len;\n\tpriv->keys[index].seq_len = seq_len;\n\n\tif (key_len)\n\t\tmemcpy(priv->keys[index].key, key, key_len);\n\tif (seq_len)\n\t\tmemcpy(priv->keys[index].seq, seq, seq_len);\n\n\tswitch (alg) {\n\tcase ORINOCO_ALG_TKIP:\n\t\tpriv->keys[index].cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_WEP:\n\t\tpriv->keys[index].cipher = (key_len > SMALL_KEY_SIZE) ?\n\t\t\tWLAN_CIPHER_SUITE_WEP104 : WLAN_CIPHER_SUITE_WEP40;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_NONE:\n\tdefault:\n\t\tpriv->keys[index].cipher = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nfree_key:\n\tkfree(priv->keys[index].key);\n\tpriv->keys[index].key = NULL;\n\nnomem:\n\tpriv->keys[index].key_len = 0;\n\tpriv->keys[index].seq_len = 0;\n\tpriv->keys[index].cipher = 0;\n\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0a54917c3fc295cb61f3fb52373c173fd3b69f48",
        "vul_func_with_fix": "static int orinoco_set_key(struct orinoco_private *priv, int index,\n\t\t\t   enum orinoco_alg alg, const u8 *key, int key_len,\n\t\t\t   const u8 *seq, int seq_len)\n{\n\tkzfree(priv->keys[index].key);\n\tkzfree(priv->keys[index].seq);\n\n\tif (key_len) {\n\t\tpriv->keys[index].key = kzalloc(key_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].key)\n\t\t\tgoto nomem;\n\t} else\n\t\tpriv->keys[index].key = NULL;\n\n\tif (seq_len) {\n\t\tpriv->keys[index].seq = kzalloc(seq_len, GFP_ATOMIC);\n\t\tif (!priv->keys[index].seq)\n\t\t\tgoto free_key;\n\t} else\n\t\tpriv->keys[index].seq = NULL;\n\n\tpriv->keys[index].key_len = key_len;\n\tpriv->keys[index].seq_len = seq_len;\n\n\tif (key_len)\n\t\tmemcpy(priv->keys[index].key, key, key_len);\n\tif (seq_len)\n\t\tmemcpy(priv->keys[index].seq, seq, seq_len);\n\n\tswitch (alg) {\n\tcase ORINOCO_ALG_TKIP:\n\t\tpriv->keys[index].cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_WEP:\n\t\tpriv->keys[index].cipher = (key_len > SMALL_KEY_SIZE) ?\n\t\t\tWLAN_CIPHER_SUITE_WEP104 : WLAN_CIPHER_SUITE_WEP40;\n\t\tbreak;\n\n\tcase ORINOCO_ALG_NONE:\n\tdefault:\n\t\tpriv->keys[index].cipher = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nfree_key:\n\tkfree(priv->keys[index].key);\n\tpriv->keys[index].key = NULL;\n\nnomem:\n\tpriv->keys[index].key_len = 0;\n\tpriv->keys[index].seq_len = 0;\n\tpriv->keys[index].cipher = 0;\n\n\treturn -ENOMEM;\n}\n",
        "linevul": 0.00010099810606334358,
        "sysevr": 0.17005077004432678,
        "devign": 5.7719828916447113e-11
    },
    {
        "code": "static void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static void ext4_blkdev_remove(struct ext4_sb_info *sbi)\n{\n\tstruct block_device *bdev;\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\text4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n}\n",
        "linevul": 0.00013335705443751067,
        "sysevr": 0.12772943079471588,
        "devign": 3.182976104909585e-10
    },
    {
        "code": "static int xts_fallback_encrypt(struct blkcipher_desc *desc,\n\t\tstruct scatterlist *dst, struct scatterlist *src,\n\t\tunsigned int nbytes)\n{\n\tstruct s390_xts_ctx *xts_ctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct crypto_blkcipher *tfm;\n\tunsigned int ret;\n\n\ttfm = desc->tfm;\n\tdesc->tfm = xts_ctx->fallback;\n\n\tret = crypto_blkcipher_encrypt_iv(desc, dst, src, nbytes);\n\n\tdesc->tfm = tfm;\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int xts_fallback_encrypt(struct blkcipher_desc *desc,\n\t\tstruct scatterlist *dst, struct scatterlist *src,\n\t\tunsigned int nbytes)\n{\n\tstruct s390_xts_ctx *xts_ctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct crypto_blkcipher *tfm;\n\tunsigned int ret;\n\n\ttfm = desc->tfm;\n\tdesc->tfm = xts_ctx->fallback;\n\n\tret = crypto_blkcipher_encrypt_iv(desc, dst, src, nbytes);\n\n\tdesc->tfm = tfm;\n\treturn ret;\n}\n",
        "linevul": 4.873353827861138e-05,
        "sysevr": 0.1341666281223297,
        "devign": 1.1582678566268712e-10
    },
    {
        "code": "int compat_ip_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tip_setsockopt);\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tlock_sock(sk);\n\t\terr = compat_nf_setsockopt(sk, PF_INET, optname,\n\t\t\t\t\t   optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "int compat_ip_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tip_setsockopt);\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tlock_sock(sk);\n\t\terr = compat_nf_setsockopt(sk, PF_INET, optname,\n\t\t\t\t\t   optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\n",
        "linevul": 4.7522131353616714e-05,
        "sysevr": 0.15434719622135162,
        "devign": 0.4532277286052704
    },
    {
        "code": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958",
        "vul_func_with_fix": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}\n",
        "linevul": 6.789729377487674e-05,
        "sysevr": 0.1289246827363968,
        "devign": 0.4559541642665863
    },
    {
        "code": "static int __find_interface(struct device *dev, void *data)\n{\n\tstruct find_interface_arg *arg = data;\n\tstruct usb_interface *intf;\n\n\tif (!is_usb_interface(dev))\n\t\treturn 0;\n\n\tif (dev->driver != arg->drv)\n\t\treturn 0;\n\tintf = to_usb_interface(dev);\n\treturn intf->minor == arg->minor;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf",
        "vul_func_with_fix": "static int __find_interface(struct device *dev, void *data)\n{\n\tstruct find_interface_arg *arg = data;\n\tstruct usb_interface *intf;\n\n\tif (!is_usb_interface(dev))\n\t\treturn 0;\n\n\tif (dev->driver != arg->drv)\n\t\treturn 0;\n\tintf = to_usb_interface(dev);\n\treturn intf->minor == arg->minor;\n}\n",
        "linevul": 5.1973522204207256e-05,
        "sysevr": 0.12635201215744019,
        "devign": 3.8132384361233562e-06
    },
    {
        "code": " inline void update_rq_clock(struct rq *rq)\n {\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n \n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n \n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": " inline void update_rq_clock(struct rq *rq)\n {\n//flaw_line_below:\n\tif (!rq->skip_clock_update) {\n//flaw_line_below:\n\t\tint cpu = cpu_of(rq);\n//flaw_line_below:\n\t\tu64 irq_time;\n//fix_flaw_line_below:\n//\tint cpu = cpu_of(rq);\n//fix_flaw_line_below:\n//\tu64 irq_time;\n \n//flaw_line_below:\n\t\trq->clock = sched_clock_cpu(cpu);\n//flaw_line_below:\n\t\tirq_time = irq_time_cpu(cpu);\n//flaw_line_below:\n\t\tif (rq->clock - irq_time > rq->clock_task)\n//flaw_line_below:\n\t\t\trq->clock_task = rq->clock - irq_time;\n//fix_flaw_line_below:\n//\tif (rq->skip_clock_update)\n//fix_flaw_line_below:\n//\t\treturn;\n \n//flaw_line_below:\n\t\tsched_irq_time_avg_update(rq, irq_time);\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\trq->clock = sched_clock_cpu(cpu);\n//fix_flaw_line_below:\n//\tirq_time = irq_time_cpu(cpu);\n//fix_flaw_line_below:\n//\tif (rq->clock - irq_time > rq->clock_task)\n//fix_flaw_line_below:\n//\t\trq->clock_task = rq->clock - irq_time;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tsched_irq_time_avg_update(rq, irq_time);\n }\n",
        "linevul": 0.016758425161242485,
        "sysevr": 0.1483738273382187,
        "devign": 0.0012470530346035957
    },
    {
        "code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n \t */\n \tsvm->nmi_singlestep = true;\n \tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d",
        "vul_func_with_fix": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n \t */\n \tsvm->nmi_singlestep = true;\n \tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n//flaw_line_below:\n\tupdate_db_bp_intercept(vcpu);\n }\n",
        "linevul": 0.9871828556060791,
        "sysevr": 0.12416613101959229,
        "devign": 0.9891080856323242
    },
    {
        "code": "static void icmp_address(struct sk_buff *skb)\n{\n#if 0\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"a guy asks for address mask. Who is it?\\n\");\n#endif\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static void icmp_address(struct sk_buff *skb)\n{\n#if 0\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"a guy asks for address mask. Who is it?\\n\");\n#endif\n}\n",
        "linevul": 5.5295327911153436e-05,
        "sysevr": 0.11996867507696152,
        "devign": 4.467733205615332e-08
    },
    {
        "code": "static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n \tunsigned int lci_i, lci_o;\n \n \twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n \t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n \t\tframetype = skb->data[2];\n\t\tdest      = (rose_address *)(skb->data + 4);\n \t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n \n \t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52",
        "vul_func_with_fix": "static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n \tunsigned int lci_i, lci_o;\n \n \twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n//fix_flaw_line_below:\n//\t\tif (skb->len < ROSE_MIN_LEN) {\n//fix_flaw_line_below:\n//\t\t\tkfree_skb(skb);\n//fix_flaw_line_below:\n//\t\t\tcontinue;\n//fix_flaw_line_below:\n//\t\t}\n \t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n \t\tframetype = skb->data[2];\n//flaw_line_below:\n\t\tdest      = (rose_address *)(skb->data + 4);\n//fix_flaw_line_below:\n//\t\tif (frametype == ROSE_CALL_REQUEST &&\n//fix_flaw_line_below:\n//\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n//fix_flaw_line_below:\n//\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n//fix_flaw_line_below:\n//\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n//fix_flaw_line_below:\n//\t\t\tkfree_skb(skb);\n//fix_flaw_line_below:\n//\t\t\tcontinue;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n \t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n \n \t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n",
        "linevul": 0.9996702671051025,
        "sysevr": 0.14508281648159027,
        "devign": 0.9998316764831543
    },
    {
        "code": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tif ((length > mtu) && dontfrag && (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t\t\t   sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tskb = skb_peek_tail(&sk->sk_write_queue);\n\tcork->length += length;\n\tif (((length > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b",
        "vul_func_with_fix": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tif ((length > mtu) && dontfrag && (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t\t\t   sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tskb = skb_peek_tail(&sk->sk_write_queue);\n\tcork->length += length;\n\tif (((length > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n",
        "linevul": 0.004059343598783016,
        "sysevr": 0.4251970946788788,
        "devign": 0.9363023638725281
    },
    {
        "code": "ext2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here, *last;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t/*\n\t * header -- Points either into bh, or to a temporarily\n\t *           allocated buffer.\n\t * here -- The named entry found, or the place for inserting, within\n\t *         the block pointed to by header.\n\t * last -- Points right after the last named entry within the block\n\t *         pointed to by header.\n\t * min_offs -- The offset of the first value (values are aligned\n\t *             towards the end of the block).\n\t * end -- Points right after the block pointed to by header.\n\t */\n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t\t    header->h_blocks != cpu_to_le32(1)) {\nbad_block:\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\there = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(here)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tnot_found = name_index - here->e_name_index;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = name_len - here->e_name_len;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = memcmp(name, here->e_name,name_len);\n\t\t\tif (not_found <= 0)\n\t\t\t\tbreak;\n\t\t\there = next;\n\t\t}\n\t\tlast = here;\n\t\t/* We still need to compute min_offs and last. */\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\t/* Check whether we have enough space left. */\n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t/* We will use a new extended attribute block. */\n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t\there = last = NULL;  /* avoid gcc uninitialized warning. */\n\t}\n\n\tif (not_found) {\n\t\t/* Request to remove a nonexistent attribute? */\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t/* Request to create an existing attribute? */\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(here->e_value_size);\n\n\t\t\tif (le16_to_cpu(here->e_value_offs) + size > \n\t\t\t    sb->s_blocksize || size > sb->s_blocksize)\n\t\t\t\tgoto bad_block;\n\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n \t/* Here we know that we can set the new attribute. */\n \n \tif (header) {\n\t\tstruct mb_cache_entry *ce;\n \t\t/* assert(header == HDR(bh)); */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n \t\tlock_buffer(bh);\n \t\tif (header->h_refcount == cpu_to_le32(1)) {\n \t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n \t\t\t/* keep the buffer locked while modifying it. */\n \t\t} else {\n \t\t\tint offset;\n \n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n \t\t\tunlock_buffer(bh);\n \t\t\tea_bdebug(bh, \"cloning\");\n \t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;\n\t\t\there = ENTRY((char *)header + offset);\n\t\t\toffset = (char *)last - bh->b_data;\n\t\t\tlast = ENTRY((char *)header + offset);\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\tend = (char *)header + sb->s_blocksize;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\n\t/* Iff we are modifying the block in-place, bh is locked here. */\n\n\tif (not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\there->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t/* Insert the new value. */\n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t/* This block is now empty. */\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tbrelse(bh);\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
        "vul_func_with_fix": "ext2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here, *last;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t/*\n\t * header -- Points either into bh, or to a temporarily\n\t *           allocated buffer.\n\t * here -- The named entry found, or the place for inserting, within\n\t *         the block pointed to by header.\n\t * last -- Points right after the last named entry within the block\n\t *         pointed to by header.\n\t * min_offs -- The offset of the first value (values are aligned\n\t *             towards the end of the block).\n\t * end -- Points right after the block pointed to by header.\n\t */\n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t\t    header->h_blocks != cpu_to_le32(1)) {\nbad_block:\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\there = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(here)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tnot_found = name_index - here->e_name_index;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = name_len - here->e_name_len;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = memcmp(name, here->e_name,name_len);\n\t\t\tif (not_found <= 0)\n\t\t\t\tbreak;\n\t\t\there = next;\n\t\t}\n\t\tlast = here;\n\t\t/* We still need to compute min_offs and last. */\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\t/* Check whether we have enough space left. */\n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t/* We will use a new extended attribute block. */\n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t\there = last = NULL;  /* avoid gcc uninitialized warning. */\n\t}\n\n\tif (not_found) {\n\t\t/* Request to remove a nonexistent attribute? */\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t/* Request to create an existing attribute? */\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(here->e_value_size);\n\n\t\t\tif (le16_to_cpu(here->e_value_offs) + size > \n\t\t\t    sb->s_blocksize || size > sb->s_blocksize)\n\t\t\t\tgoto bad_block;\n\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n \t/* Here we know that we can set the new attribute. */\n \n \tif (header) {\n//flaw_line_below:\n\t\tstruct mb_cache_entry *ce;\n//flaw_line_below:\n\n \t\t/* assert(header == HDR(bh)); */\n//flaw_line_below:\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n//flaw_line_below:\n\t\t\t\t\tbh->b_blocknr);\n \t\tlock_buffer(bh);\n \t\tif (header->h_refcount == cpu_to_le32(1)) {\n//fix_flaw_line_below:\n//\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n//fix_flaw_line_below:\n//\n \t\t\tea_bdebug(bh, \"modifying in-place\");\n//flaw_line_below:\n\t\t\tif (ce)\n//flaw_line_below:\n\t\t\t\tmb_cache_entry_free(ce);\n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * This must happen under buffer lock for\n//fix_flaw_line_below:\n//\t\t\t * ext2_xattr_set2() to reliably detect modified block\n//fix_flaw_line_below:\n//\t\t\t */\n//fix_flaw_line_below:\n//\t\t\tmb2_cache_entry_delete_block(EXT2_SB(sb)->s_mb_cache,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t     hash, bh->b_blocknr);\n//fix_flaw_line_below:\n//\n \t\t\t/* keep the buffer locked while modifying it. */\n \t\t} else {\n \t\t\tint offset;\n \n//flaw_line_below:\n\t\t\tif (ce)\n//flaw_line_below:\n\t\t\t\tmb_cache_entry_release(ce);\n \t\t\tunlock_buffer(bh);\n \t\t\tea_bdebug(bh, \"cloning\");\n \t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;\n\t\t\there = ENTRY((char *)header + offset);\n\t\t\toffset = (char *)last - bh->b_data;\n\t\t\tlast = ENTRY((char *)header + offset);\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\tend = (char *)header + sb->s_blocksize;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\n\t/* Iff we are modifying the block in-place, bh is locked here. */\n\n\tif (not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\there->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t/* Insert the new value. */\n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t/* This block is now empty. */\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tbrelse(bh);\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n",
        "linevul": 0.004715234972536564,
        "sysevr": 0.3388380706310272,
        "devign": 0.49932143092155457
    },
    {
        "code": "static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876",
        "vul_func_with_fix": "static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,\n\t\tsize_t num_bytes, struct fuse_io_priv *io)\n{\n\tspin_lock(&io->lock);\n\tio->size += num_bytes;\n\tio->reqs++;\n\tspin_unlock(&io->lock);\n\n\treq->io = io;\n\treq->end = fuse_aio_complete_req;\n\n\t__fuse_get_request(req);\n\tfuse_request_send_background(fc, req);\n\n\treturn num_bytes;\n}\n",
        "linevul": 4.933910531690344e-05,
        "sysevr": 0.12981989979743958,
        "devign": 2.32581483030638e-15
    },
    {
        "code": "static int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tREAD_BUF(8);\n\t\tREAD64(maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int decode_attr_maxread(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\n\t*res = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXREAD - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXREAD)) {\n\t\tuint64_t maxread;\n\t\tREAD_BUF(8);\n\t\tREAD64(maxread);\n\t\tif (maxread > 0x7FFFFFFF)\n\t\t\tmaxread = 0x7FFFFFFF;\n\t\t*res = (uint32_t)maxread;\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXREAD;\n\t}\n\tdprintk(\"%s: maxread=%lu\\n\", __func__, (unsigned long)*res);\n\treturn status;\n}\n",
        "linevul": 5.378637069952674e-05,
        "sysevr": 0.12479577213525772,
        "devign": 2.2259300305749186e-11
    },
    {
        "code": "static inline void ccid3_hc_tx_update_s(struct ccid3_hc_tx_sock *hc, int len)\n{\n\tconst u16 old_s = hc->tx_s;\n\n\thc->tx_s = tfrc_ewma(hc->tx_s, len, 9);\n\n\tif (hc->tx_s != old_s)\n\t\tccid3_update_send_interval(hc);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7b07f8eb75aa3097cdfd4f6eac3da49db787381d",
        "vul_func_with_fix": "static inline void ccid3_hc_tx_update_s(struct ccid3_hc_tx_sock *hc, int len)\n{\n\tconst u16 old_s = hc->tx_s;\n\n\thc->tx_s = tfrc_ewma(hc->tx_s, len, 9);\n\n\tif (hc->tx_s != old_s)\n\t\tccid3_update_send_interval(hc);\n}\n",
        "linevul": 8.278447785414755e-05,
        "sysevr": 0.12628071010112762,
        "devign": 2.7223848175772503e-12
    },
    {
        "code": "void sas_ata_schedule_reset(struct domain_device *dev)\n{\n\tstruct ata_eh_info *ehi;\n\tstruct ata_port *ap;\n\tunsigned long flags;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tehi = &ap->link.eh_info;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tehi->err_mask |= AC_ERR_TIMEOUT;\n\tehi->action |= ATA_EH_RESET;\n\tata_port_schedule_eh(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d",
        "vul_func_with_fix": "void sas_ata_schedule_reset(struct domain_device *dev)\n{\n\tstruct ata_eh_info *ehi;\n\tstruct ata_port *ap;\n\tunsigned long flags;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tehi = &ap->link.eh_info;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tehi->err_mask |= AC_ERR_TIMEOUT;\n\tehi->action |= ATA_EH_RESET;\n\tata_port_schedule_eh(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\n",
        "linevul": 5.429045995697379e-05,
        "sysevr": 0.16435518860816956,
        "devign": 5.353678942900857e-15
    },
    {
        "code": "static int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct packet_command cgc;\n\tstruct mrw_feature_desc *mfd;\n\tunsigned char buffer[16];\n\tint ret;\n\n\t*write = 0;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_MRW;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\n\t\treturn 1;\n\t*write = mfd->write;\n\n\tif ((ret = cdrom_mrw_probe_pc(cdi))) {\n\t\t*write = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276",
        "vul_func_with_fix": "static int cdrom_is_mrw(struct cdrom_device_info *cdi, int *write)\n{\n\tstruct packet_command cgc;\n\tstruct mrw_feature_desc *mfd;\n\tunsigned char buffer[16];\n\tint ret;\n\n\t*write = 0;\n\n\tinit_cdrom_command(&cgc, buffer, sizeof(buffer), CGC_DATA_READ);\n\n\tcgc.cmd[0] = GPCMD_GET_CONFIGURATION;\n\tcgc.cmd[3] = CDF_MRW;\n\tcgc.cmd[8] = sizeof(buffer);\n\tcgc.quiet = 1;\n\n\tif ((ret = cdi->ops->generic_packet(cdi, &cgc)))\n\t\treturn ret;\n\n\tmfd = (struct mrw_feature_desc *)&buffer[sizeof(struct feature_header)];\n\tif (be16_to_cpu(mfd->feature_code) != CDF_MRW)\n\t\treturn 1;\n\t*write = mfd->write;\n\n\tif ((ret = cdrom_mrw_probe_pc(cdi))) {\n\t\t*write = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 5.892808985663578e-05,
        "sysevr": 0.16187873482704163,
        "devign": 1.8001656845837206e-31
    },
    {
        "code": "static void rb_set_list_to_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\tstruct list_head *list)\n{\n\tunsigned long *ptr;\n\n\tptr = (unsigned long *)&list->next;\n\t*ptr |= RB_PAGE_HEAD;\n\t*ptr &= ~RB_PAGE_UPDATE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "vul_func_with_fix": "static void rb_set_list_to_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\tstruct list_head *list)\n{\n\tunsigned long *ptr;\n\n\tptr = (unsigned long *)&list->next;\n\t*ptr |= RB_PAGE_HEAD;\n\t*ptr &= ~RB_PAGE_UPDATE;\n}\n",
        "linevul": 6.447454506997019e-05,
        "sysevr": 0.13093861937522888,
        "devign": 0.0009136204025708139
    },
    {
        "code": "\t__acquires(ax25_list_lock)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\treturn seq_hlist_start(&ax25_list, *pos);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ef3313e84acbf349caecae942ab3ab731471f1a1",
        "vul_func_with_fix": "\t__acquires(ax25_list_lock)\n{\n\tspin_lock_bh(&ax25_list_lock);\n\treturn seq_hlist_start(&ax25_list, *pos);\n}\n",
        "linevul": 6.473749090218917e-05,
        "sysevr": 0.16206617653369904,
        "devign": 0.6603632569313049
    },
    {
        "code": "static inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "static inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}\n",
        "linevul": 5.6328684877371415e-05,
        "sysevr": 0.12975874543190002,
        "devign": 8.40589200379327e-06
    },
    {
        "code": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045",
        "vul_func_with_fix": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n//flaw_line_below:\n\t\t\tint atomic)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tunsigned long copy;\n//flaw_line_below:\n\n//flaw_line_below:\n\twhile (len > 0) {\n//flaw_line_below:\n\t\twhile (!iov->iov_len)\n//flaw_line_below:\n\t\t\tiov++;\n//flaw_line_below:\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tif (atomic) {\n//flaw_line_below:\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n//flaw_line_below:\n\t\t\t\treturn -EFAULT;\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n//flaw_line_below:\n\t\t\t\treturn -EFAULT;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t\tto += copy;\n//flaw_line_below:\n\t\tlen -= copy;\n//flaw_line_below:\n\t\tiov->iov_base += copy;\n//flaw_line_below:\n\t\tiov->iov_len -= copy;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\treturn 0;\n//flaw_line_below:\n}\n",
        "linevul": 0.9716759920120239,
        "sysevr": 0.1536034196615219,
        "devign": 0.9999963045120239
    },
    {
        "code": "static void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item, *n;\n\tlist_for_each_entry_safe(item, n, &vmx->nested.vmcs02_pool, list) {\n\t\tif (vmx->loaded_vmcs != &item->vmcs02)\n\t\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\tlist_del(&item->list);\n\t\tkfree(item);\n\t}\n\tvmx->nested.vmcs02_num = 0;\n\n\tif (vmx->loaded_vmcs != &vmx->vmcs01)\n\t\tfree_loaded_vmcs(&vmx->vmcs01);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs02_list *item, *n;\n\tlist_for_each_entry_safe(item, n, &vmx->nested.vmcs02_pool, list) {\n\t\tif (vmx->loaded_vmcs != &item->vmcs02)\n\t\t\tfree_loaded_vmcs(&item->vmcs02);\n\t\tlist_del(&item->list);\n\t\tkfree(item);\n\t}\n\tvmx->nested.vmcs02_num = 0;\n\n\tif (vmx->loaded_vmcs != &vmx->vmcs01)\n\t\tfree_loaded_vmcs(&vmx->vmcs01);\n}\n",
        "linevul": 5.5064901971491054e-05,
        "sysevr": 0.12496275454759598,
        "devign": 1.3022254752585562e-18
    },
    {
        "code": "static long kvm_vcpu_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tstruct kvm_fpu *fpu = NULL;\n\tstruct kvm_sregs *kvm_sregs = NULL;\n\n\tif (vcpu->kvm->mm != current->mm)\n\t\treturn -EIO;\n\n\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Some architectures have vcpu ioctls that are asynchronous to vcpu\n\t * execution; mutex_lock() would break them.\n\t */\n\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);\n\tif (r != -ENOIOCTLCMD)\n\t\treturn r;\n\n\tif (mutex_lock_killable(&vcpu->mutex))\n\t\treturn -EINTR;\n\tswitch (ioctl) {\n\tcase KVM_RUN: {\n\t\tstruct pid *oldpid;\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\toldpid = rcu_access_pointer(vcpu->pid);\n\t\tif (unlikely(oldpid != task_pid(current))) {\n\t\t\t/* The thread running this VCPU changed. */\n\t\t\tstruct pid *newpid;\n\n\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\n\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);\n\t\t\trcu_assign_pointer(vcpu->pid, newpid);\n\t\t\tif (oldpid)\n\t\t\t\tsynchronize_rcu();\n\t\t\tput_pid(oldpid);\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run);\n\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);\n\t\tbreak;\n\t}\n\tcase KVM_GET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tr = -ENOMEM;\n\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL);\n\t\tif (!kvm_regs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);\n\t\tif (r)\n\t\t\tgoto out_free1;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))\n\t\t\tgoto out_free1;\n\t\tr = 0;\nout_free1:\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tr = -ENOMEM;\n\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));\n\t\tif (IS_ERR(kvm_regs)) {\n\t\t\tr = PTR_ERR(kvm_regs);\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_SREGS: {\n\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!kvm_sregs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_SREGS: {\n\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));\n\t\tif (IS_ERR(kvm_sregs)) {\n\t\t\tr = PTR_ERR(kvm_sregs);\n\t\t\tkvm_sregs = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);\n\t\tbreak;\n\t}\n\tcase KVM_TRANSLATE: {\n\t\tstruct kvm_translation tr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tr, argp, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tr, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_GUEST_DEBUG: {\n\t\tstruct kvm_guest_debug dbg;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);\n\t\tbreak;\n\t}\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tsigset_t sigset, *p;\n\n\t\tp = NULL;\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(sigset))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,\n\t\t\t\t\t   sizeof(sigset)))\n\t\t\t\tgoto out;\n\t\t\tp = &sigset;\n\t\t}\n\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);\n\t\tbreak;\n\t}\n\tcase KVM_GET_FPU: {\n\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!fpu)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_FPU: {\n\t\tfpu = memdup_user(argp, sizeof(*fpu));\n\t\tif (IS_ERR(fpu)) {\n\t\t\tr = PTR_ERR(fpu);\n\t\t\tfpu = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);\n\t}\nout:\n\tmutex_unlock(&vcpu->mutex);\n\tkfree(fpu);\n\tkfree(kvm_sregs);\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9",
        "vul_func_with_fix": "static long kvm_vcpu_ioctl(struct file *filp,\n\t\t\t   unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tstruct kvm_fpu *fpu = NULL;\n\tstruct kvm_sregs *kvm_sregs = NULL;\n\n\tif (vcpu->kvm->mm != current->mm)\n\t\treturn -EIO;\n\n\tif (unlikely(_IOC_TYPE(ioctl) != KVMIO))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Some architectures have vcpu ioctls that are asynchronous to vcpu\n\t * execution; mutex_lock() would break them.\n\t */\n\tr = kvm_arch_vcpu_async_ioctl(filp, ioctl, arg);\n\tif (r != -ENOIOCTLCMD)\n\t\treturn r;\n\n\tif (mutex_lock_killable(&vcpu->mutex))\n\t\treturn -EINTR;\n\tswitch (ioctl) {\n\tcase KVM_RUN: {\n\t\tstruct pid *oldpid;\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\toldpid = rcu_access_pointer(vcpu->pid);\n\t\tif (unlikely(oldpid != task_pid(current))) {\n\t\t\t/* The thread running this VCPU changed. */\n\t\t\tstruct pid *newpid;\n\n\t\t\tr = kvm_arch_vcpu_run_pid_change(vcpu);\n\t\t\tif (r)\n\t\t\t\tbreak;\n\n\t\t\tnewpid = get_task_pid(current, PIDTYPE_PID);\n\t\t\trcu_assign_pointer(vcpu->pid, newpid);\n\t\t\tif (oldpid)\n\t\t\t\tsynchronize_rcu();\n\t\t\tput_pid(oldpid);\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run);\n\t\ttrace_kvm_userspace_exit(vcpu->run->exit_reason, r);\n\t\tbreak;\n\t}\n\tcase KVM_GET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tr = -ENOMEM;\n\t\tkvm_regs = kzalloc(sizeof(struct kvm_regs), GFP_KERNEL);\n\t\tif (!kvm_regs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_regs(vcpu, kvm_regs);\n\t\tif (r)\n\t\t\tgoto out_free1;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_regs, sizeof(struct kvm_regs)))\n\t\t\tgoto out_free1;\n\t\tr = 0;\nout_free1:\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_REGS: {\n\t\tstruct kvm_regs *kvm_regs;\n\n\t\tr = -ENOMEM;\n\t\tkvm_regs = memdup_user(argp, sizeof(*kvm_regs));\n\t\tif (IS_ERR(kvm_regs)) {\n\t\t\tr = PTR_ERR(kvm_regs);\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_regs(vcpu, kvm_regs);\n\t\tkfree(kvm_regs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_SREGS: {\n\t\tkvm_sregs = kzalloc(sizeof(struct kvm_sregs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!kvm_sregs)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_sregs(vcpu, kvm_sregs);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, kvm_sregs, sizeof(struct kvm_sregs)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_SREGS: {\n\t\tkvm_sregs = memdup_user(argp, sizeof(*kvm_sregs));\n\t\tif (IS_ERR(kvm_sregs)) {\n\t\t\tr = PTR_ERR(kvm_sregs);\n\t\t\tkvm_sregs = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = kvm_arch_vcpu_ioctl_get_mpstate(vcpu, &mp_state);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &mp_state, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_MP_STATE: {\n\t\tstruct kvm_mp_state mp_state;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mp_state, argp, sizeof(mp_state)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_mpstate(vcpu, &mp_state);\n\t\tbreak;\n\t}\n\tcase KVM_TRANSLATE: {\n\t\tstruct kvm_translation tr;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tr, argp, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_translate(vcpu, &tr);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tr, sizeof(tr)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_GUEST_DEBUG: {\n\t\tstruct kvm_guest_debug dbg;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbg, argp, sizeof(dbg)))\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_set_guest_debug(vcpu, &dbg);\n\t\tbreak;\n\t}\n\tcase KVM_SET_SIGNAL_MASK: {\n\t\tstruct kvm_signal_mask __user *sigmask_arg = argp;\n\t\tstruct kvm_signal_mask kvm_sigmask;\n\t\tsigset_t sigset, *p;\n\n\t\tp = NULL;\n\t\tif (argp) {\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&kvm_sigmask, argp,\n\t\t\t\t\t   sizeof(kvm_sigmask)))\n\t\t\t\tgoto out;\n\t\t\tr = -EINVAL;\n\t\t\tif (kvm_sigmask.len != sizeof(sigset))\n\t\t\t\tgoto out;\n\t\t\tr = -EFAULT;\n\t\t\tif (copy_from_user(&sigset, sigmask_arg->sigset,\n\t\t\t\t\t   sizeof(sigset)))\n\t\t\t\tgoto out;\n\t\t\tp = &sigset;\n\t\t}\n\t\tr = kvm_vcpu_ioctl_set_sigmask(vcpu, p);\n\t\tbreak;\n\t}\n\tcase KVM_GET_FPU: {\n\t\tfpu = kzalloc(sizeof(struct kvm_fpu), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!fpu)\n\t\t\tgoto out;\n\t\tr = kvm_arch_vcpu_ioctl_get_fpu(vcpu, fpu);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, fpu, sizeof(struct kvm_fpu)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_FPU: {\n\t\tfpu = memdup_user(argp, sizeof(*fpu));\n\t\tif (IS_ERR(fpu)) {\n\t\t\tr = PTR_ERR(fpu);\n\t\t\tfpu = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = kvm_arch_vcpu_ioctl(filp, ioctl, arg);\n\t}\nout:\n\tmutex_unlock(&vcpu->mutex);\n\tkfree(fpu);\n\tkfree(kvm_sregs);\n\treturn r;\n}\n",
        "linevul": 5.530983253265731e-05,
        "sysevr": 0.1967296600341797,
        "devign": 4.923529574492325e-13
    },
    {
        "code": "static int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_server_caps_arg args = {\n\t\t.fhandle = fhandle,\n\t};\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\t/* Sanity check the server answers */\n\t\tswitch (server->nfs_client->cl_minorversion) {\n\t\tcase 0:\n\t\t\tres.attr_bitmask[1] &= FATTR4_WORD1_NFS40_MASK;\n\t\t\tres.attr_bitmask[2] = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS41_MASK;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS42_MASK;\n\t\t}\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tserver->caps &= ~(NFS_CAP_ACLS|NFS_CAP_HARDLINKS|\n\t\t\t\tNFS_CAP_SYMLINKS|NFS_CAP_FILEID|\n\t\t\t\tNFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|\n\t\t\t\tNFS_CAP_OWNER_GROUP|NFS_CAP_ATIME|\n\t\t\t\tNFS_CAP_CTIME|NFS_CAP_MTIME|\n\t\t\t\tNFS_CAP_SECURITY_LABEL);\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL &&\n\t\t\t\tres.acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_FILEID)\n\t\t\tserver->caps |= NFS_CAP_FILEID;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_MODE)\n\t\t\tserver->caps |= NFS_CAP_MODE;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS)\n\t\t\tserver->caps |= NFS_CAP_NLINK;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER)\n\t\t\tserver->caps |= NFS_CAP_OWNER;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\t\tserver->caps |= NFS_CAP_OWNER_GROUP;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS)\n\t\t\tserver->caps |= NFS_CAP_ATIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA)\n\t\t\tserver->caps |= NFS_CAP_CTIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY)\n\t\t\tserver->caps |= NFS_CAP_MTIME;\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t\tif (res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL)\n\t\t\tserver->caps |= NFS_CAP_SECURITY_LABEL;\n#endif\n\t\tmemcpy(server->attr_bitmask_nl, res.attr_bitmask,\n\t\t\t\tsizeof(server->attr_bitmask));\n\t\tserver->attr_bitmask_nl[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\t\tmemcpy(server->cache_consistency_bitmask, res.attr_bitmask, sizeof(server->cache_consistency_bitmask));\n\t\tserver->cache_consistency_bitmask[0] &= FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE;\n\t\tserver->cache_consistency_bitmask[1] &= FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tserver->cache_consistency_bitmask[2] = 0;\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t\tserver->fh_expire_type = res.fh_expire_type;\n\t}\n\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_server_caps_arg args = {\n\t\t.fhandle = fhandle,\n\t};\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\t/* Sanity check the server answers */\n\t\tswitch (server->nfs_client->cl_minorversion) {\n\t\tcase 0:\n\t\t\tres.attr_bitmask[1] &= FATTR4_WORD1_NFS40_MASK;\n\t\t\tres.attr_bitmask[2] = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS41_MASK;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS42_MASK;\n\t\t}\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tserver->caps &= ~(NFS_CAP_ACLS|NFS_CAP_HARDLINKS|\n\t\t\t\tNFS_CAP_SYMLINKS|NFS_CAP_FILEID|\n\t\t\t\tNFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|\n\t\t\t\tNFS_CAP_OWNER_GROUP|NFS_CAP_ATIME|\n\t\t\t\tNFS_CAP_CTIME|NFS_CAP_MTIME|\n\t\t\t\tNFS_CAP_SECURITY_LABEL);\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL &&\n\t\t\t\tres.acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_FILEID)\n\t\t\tserver->caps |= NFS_CAP_FILEID;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_MODE)\n\t\t\tserver->caps |= NFS_CAP_MODE;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS)\n\t\t\tserver->caps |= NFS_CAP_NLINK;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER)\n\t\t\tserver->caps |= NFS_CAP_OWNER;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\t\tserver->caps |= NFS_CAP_OWNER_GROUP;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS)\n\t\t\tserver->caps |= NFS_CAP_ATIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA)\n\t\t\tserver->caps |= NFS_CAP_CTIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY)\n\t\t\tserver->caps |= NFS_CAP_MTIME;\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t\tif (res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL)\n\t\t\tserver->caps |= NFS_CAP_SECURITY_LABEL;\n#endif\n\t\tmemcpy(server->attr_bitmask_nl, res.attr_bitmask,\n\t\t\t\tsizeof(server->attr_bitmask));\n\t\tserver->attr_bitmask_nl[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\t\tmemcpy(server->cache_consistency_bitmask, res.attr_bitmask, sizeof(server->cache_consistency_bitmask));\n\t\tserver->cache_consistency_bitmask[0] &= FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE;\n\t\tserver->cache_consistency_bitmask[1] &= FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tserver->cache_consistency_bitmask[2] = 0;\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t\tserver->fh_expire_type = res.fh_expire_type;\n\t}\n\n\treturn status;\n}\n",
        "linevul": 6.378168473020196e-05,
        "sysevr": 0.311124712228775,
        "devign": 2.2793386960984208e-05
    },
    {
        "code": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n \n \t   First: no IPv4 options.\n \t */\n\tnewinet->opt = NULL;\n \tnewnp->ipv6_fl_list = NULL;\n \n \t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet6_request_sock *treq;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n\tstruct ipv6_txoptions *opt;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst);\n\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);\n\n\t\tipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);\n\n\t\tipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\ttreq = inet6_rsk(req);\n\topt = np->opt;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, req);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tipv6_addr_copy(&newnp->daddr, &treq->rmt_addr);\n\tipv6_addr_copy(&newnp->saddr, &treq->loc_addr);\n\tipv6_addr_copy(&newnp->rcv_saddr, &treq->loc_addr);\n\tnewsk->sk_bound_dev_if = treq->iif;\n\n\t/* Now IPv6 options...\n \n \t   First: no IPv4 options.\n \t */\n//flaw_line_below:\n\tnewinet->opt = NULL;\n//fix_flaw_line_below:\n//\tnewinet->inet_opt = NULL;\n \tnewnp->ipv6_fl_list = NULL;\n \n \t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\t/* Clone pktoptions received with SYN */\n\tnewnp->pktoptions = NULL;\n\tif (treq->pktopts != NULL) {\n\t\tnewnp->pktoptions = skb_clone(treq->pktopts, GFP_ATOMIC);\n\t\tkfree_skb(treq->pktopts);\n\t\ttreq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (opt) {\n\t\tnewnp->opt = ipv6_dup_options(newsk, opt);\n\t\tif (opt != np->opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t}\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tif ((key = tcp_v6_md5_do_lookup(sk, &newnp->daddr)) != NULL) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v6_md5_do_add(newsk, &newnp->daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto out;\n\t}\n\t__inet6_hash(newsk, NULL);\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tif (opt && opt != np->opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "linevul": 0.0018899902934208512,
        "sysevr": 0.2268424928188324,
        "devign": 0.0
    },
    {
        "code": "void DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tif (debug_status & DBSR_IC) {\t/* instruction completion */\n\t\tregs->msr &= ~MSR_DE;\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.dbcr0 &= ~DBCR0_IC;\n\t\t} else {\n\t\t\t/* Disable instruction completion */\n\t\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t\t/* Clear the instruction completion event */\n\t\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\t\t\tif (debugger_sstep(regs))\n\t\t\t\treturn;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6c4841c2b6c32a134f9f36e5e08857138cc12b10",
        "vul_func_with_fix": "void DebugException(struct pt_regs *regs, unsigned long debug_status)\n{\n\tif (debug_status & DBSR_IC) {\t/* instruction completion */\n\t\tregs->msr &= ~MSR_DE;\n\t\tif (user_mode(regs)) {\n\t\t\tcurrent->thread.dbcr0 &= ~DBCR0_IC;\n\t\t} else {\n\t\t\t/* Disable instruction completion */\n\t\t\tmtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_IC);\n\t\t\t/* Clear the instruction completion event */\n\t\t\tmtspr(SPRN_DBSR, DBSR_IC);\n\t\t\tif (debugger_sstep(regs))\n\t\t\t\treturn;\n\t\t}\n\t\t_exception(SIGTRAP, regs, TRAP_TRACE, 0);\n\t}\n}\n",
        "linevul": 4.9748159653972834e-05,
        "sysevr": 0.20273707807064056,
        "devign": 2.308565936071788e-14
    },
    {
        "code": "static inline u8 swap_bits_in_byte(u8 b)\n{\n#define R_SHIFT_4_MASK  0xc0 /* Bits 6 and 7, right shift 4 */\n#define R_SHIFT_2_MASK  0x28 /* (After right shift 4) Bits 3 and 5,\n\t\t\t\t  right shift 2 */\n#define R_SHIFT_1_MASK  0x1e /* (After right shift 2) Bits 1-4,\n\t\t\t\t  right shift 1 */\n#define L_SHIFT_4_MASK  0x03 /* Bits 0 and 1, left shift 4 */\n#define L_SHIFT_2_MASK  0x14 /* (After left shift 4) Bits 2 and 4,\n\t\t\t\t  left shift 2 */\n#define L_SHIFT_1_MASK  0x78 /* (After left shift 1) Bits 3-6,\n\t\t\t\t  left shift 1 */\n\n\tu8 n1;\n\tu8 n2;\n\n\t/* Swap most significant nibble */\n\t/* Right shift 4, bits 6 and 7 */\n\tn1 = ((b  & R_SHIFT_4_MASK) >> 4) | (b  & ~(R_SHIFT_4_MASK >> 4));\n\t/* Right shift 2, bits 3 and 5 */\n\tn1 = ((n1 & R_SHIFT_2_MASK) >> 2) | (n1 & ~(R_SHIFT_2_MASK >> 2));\n\t/* Right shift 1, bits 1-4 */\n\tn1 = (n1  & R_SHIFT_1_MASK) >> 1;\n\n\t/* Swap least significant nibble */\n\t/* Left shift 4, bits 0 and 1 */\n\tn2 = ((b  & L_SHIFT_4_MASK) << 4) | (b  & ~(L_SHIFT_4_MASK << 4));\n\t/* Left shift 2, bits 2 and 4 */\n\tn2 = ((n2 & L_SHIFT_2_MASK) << 2) | (n2 & ~(L_SHIFT_2_MASK << 2));\n\t/* Left shift 1, bits 3-6 */\n\tn2 = (n2  & L_SHIFT_1_MASK) << 1;\n\n\treturn n1 | n2;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static inline u8 swap_bits_in_byte(u8 b)\n{\n#define R_SHIFT_4_MASK  0xc0 /* Bits 6 and 7, right shift 4 */\n#define R_SHIFT_2_MASK  0x28 /* (After right shift 4) Bits 3 and 5,\n\t\t\t\t  right shift 2 */\n#define R_SHIFT_1_MASK  0x1e /* (After right shift 2) Bits 1-4,\n\t\t\t\t  right shift 1 */\n#define L_SHIFT_4_MASK  0x03 /* Bits 0 and 1, left shift 4 */\n#define L_SHIFT_2_MASK  0x14 /* (After left shift 4) Bits 2 and 4,\n\t\t\t\t  left shift 2 */\n#define L_SHIFT_1_MASK  0x78 /* (After left shift 1) Bits 3-6,\n\t\t\t\t  left shift 1 */\n\n\tu8 n1;\n\tu8 n2;\n\n\t/* Swap most significant nibble */\n\t/* Right shift 4, bits 6 and 7 */\n\tn1 = ((b  & R_SHIFT_4_MASK) >> 4) | (b  & ~(R_SHIFT_4_MASK >> 4));\n\t/* Right shift 2, bits 3 and 5 */\n\tn1 = ((n1 & R_SHIFT_2_MASK) >> 2) | (n1 & ~(R_SHIFT_2_MASK >> 2));\n\t/* Right shift 1, bits 1-4 */\n\tn1 = (n1  & R_SHIFT_1_MASK) >> 1;\n\n\t/* Swap least significant nibble */\n\t/* Left shift 4, bits 0 and 1 */\n\tn2 = ((b  & L_SHIFT_4_MASK) << 4) | (b  & ~(L_SHIFT_4_MASK << 4));\n\t/* Left shift 2, bits 2 and 4 */\n\tn2 = ((n2 & L_SHIFT_2_MASK) << 2) | (n2 & ~(L_SHIFT_2_MASK << 2));\n\t/* Left shift 1, bits 3-6 */\n\tn2 = (n2  & L_SHIFT_1_MASK) << 1;\n\n\treturn n1 | n2;\n}\n",
        "linevul": 0.0001160033862106502,
        "sysevr": 0.2174167037010193,
        "devign": 4.584868928958485e-09
    },
    {
        "code": "void user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data;\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tkfree_rcu(upayload, rcu);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "void user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data;\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tkfree_rcu(upayload, rcu);\n\t}\n}\n",
        "linevul": 0.00015849740884732455,
        "sysevr": 0.17627348005771637,
        "devign": 0.13027392327785492
    },
    {
        "code": "static void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t    SAS_ADDR(child->sas_addr)) {\n\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4",
        "vul_func_with_fix": "static void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t    SAS_ADDR(child->sas_addr)) {\n\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n",
        "linevul": 5.714436338166706e-05,
        "sysevr": 0.15401101112365723,
        "devign": 3.448165290351322e-23
    },
    {
        "code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n \n \tret = key->type->update(key, prep);\n \tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n \n \tup_write(&key->sem);\n \n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n \n \tret = key->type->update(key, prep);\n \tif (ret == 0)\n//flaw_line_below:\n\t\t/* updating a negative key instantiates it */\n//flaw_line_below:\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n//fix_flaw_line_below:\n//\t\t/* Updating a negative key positively instantiates it */\n//fix_flaw_line_below:\n//\t\tmark_key_instantiated(key, 0);\n \n \tup_write(&key->sem);\n \n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n",
        "linevul": 0.9996333122253418,
        "sysevr": 0.14248719811439514,
        "devign": 0.9999728202819824
    },
    {
        "code": "static inline void perf_event__state_init(struct perf_event *event)\n{\n\tevent->state = event->attr.disabled ? PERF_EVENT_STATE_OFF :\n\t\t\t\t\t      PERF_EVENT_STATE_INACTIVE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8176cced706b5e5d15887584150764894e94e02f",
        "vul_func_with_fix": "static inline void perf_event__state_init(struct perf_event *event)\n{\n\tevent->state = event->attr.disabled ? PERF_EVENT_STATE_OFF :\n\t\t\t\t\t      PERF_EVENT_STATE_INACTIVE;\n}\n",
        "linevul": 5.00030982948374e-05,
        "sysevr": 0.1283852607011795,
        "devign": 6.847303279933215e-11
    },
    {
        "code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n",
        "linevul": 0.000152340522618033,
        "sysevr": 0.1711737960577011,
        "devign": 0.9956502318382263
    },
    {
        "code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);\n\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/373c4557d2aa362702c4c2d41288fb1e54990b7c",
        "vul_func_with_fix": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n//flaw_line_below:\n\t\tif (pte && walk->hugetlb_entry)\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (pte)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n//fix_flaw_line_below:\n//\t\telse if (walk->pte_hole)\n//fix_flaw_line_below:\n//\t\t\terr = walk->pte_hole(addr, next, walk);\n//fix_flaw_line_below:\n//\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);\n\n\treturn err;\n}\n",
        "linevul": 0.9987601041793823,
        "sysevr": 0.129611998796463,
        "devign": 0.9999818801879883
    },
    {
        "code": "static int crypto_cbcmac_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\tif (ctx->len)\n\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\n\tmemcpy(out, dg, bs);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3b30460c5b0ed762be75a004e924ec3f8711e032",
        "vul_func_with_fix": "static int crypto_cbcmac_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\tif (ctx->len)\n\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\n\tmemcpy(out, dg, bs);\n\treturn 0;\n}\n",
        "linevul": 4.9979549658019096e-05,
        "sysevr": 0.1483665257692337,
        "devign": 6.290013510046322e-10
    },
    {
        "code": "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146",
        "vul_func_with_fix": "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}\n",
        "linevul": 7.586973515572026e-05,
        "sysevr": 0.14024579524993896,
        "devign": 3.2915410397293954e-09
    },
    {
        "code": "bool exist_trim_candidates(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\t__u64 trim_start = cpc->trim_start;\n\tbool has_candidate = false;\n\n\tmutex_lock(&SIT_I(sbi)->sentry_lock);\n\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++) {\n\t\tif (add_discard_addrs(sbi, cpc, true)) {\n\t\t\thas_candidate = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&SIT_I(sbi)->sentry_lock);\n\n\tcpc->trim_start = trim_start;\n\treturn has_candidate;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982",
        "vul_func_with_fix": "bool exist_trim_candidates(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\t__u64 trim_start = cpc->trim_start;\n\tbool has_candidate = false;\n\n\tmutex_lock(&SIT_I(sbi)->sentry_lock);\n\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++) {\n\t\tif (add_discard_addrs(sbi, cpc, true)) {\n\t\t\thas_candidate = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&SIT_I(sbi)->sentry_lock);\n\n\tcpc->trim_start = trim_start;\n\treturn has_candidate;\n}\n",
        "linevul": 5.643143231282011e-05,
        "sysevr": 0.15417394042015076,
        "devign": 0.00043733042548410594
    },
    {
        "code": "struct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\tif (WARN_ON(!rdev->testmode_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen,\n\t\t\t\trdev->testmode_info->snd_pid,\n\t\t\t\trdev->testmode_info->snd_seq,\n\t\t\t\tGFP_KERNEL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
        "vul_func_with_fix": "struct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\tif (WARN_ON(!rdev->testmode_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen,\n\t\t\t\trdev->testmode_info->snd_pid,\n\t\t\t\trdev->testmode_info->snd_seq,\n\t\t\t\tGFP_KERNEL);\n}\n",
        "linevul": 4.5300868805497885e-05,
        "sysevr": 0.14072497189044952,
        "devign": 0.00037393069942481816
    },
    {
        "code": "static int sco_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_sco);\n\n\tif (peer)\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86",
        "vul_func_with_fix": "static int sco_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_sco);\n\n\tif (peer)\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->sco_bdaddr, &bt_sk(sk)->src);\n\n\treturn 0;\n}\n",
        "linevul": 4.8913356295088306e-05,
        "sysevr": 0.12952663004398346,
        "devign": 8.722019551044013e-09
    },
    {
        "code": "static int do_monotonic(struct timespec *ts, cycle_t *cycle_now)\n{\n\tunsigned long seq;\n\tu64 ns;\n\tint mode;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tts->tv_nsec = 0;\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tts->tv_sec = gtod->monotonic_time_sec;\n\t\tns = gtod->monotonic_time_snsec;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\ttimespec_add_ns(ts, ns);\n\n\treturn mode;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd",
        "vul_func_with_fix": "static int do_monotonic(struct timespec *ts, cycle_t *cycle_now)\n{\n\tunsigned long seq;\n\tu64 ns;\n\tint mode;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tts->tv_nsec = 0;\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tmode = gtod->clock.vclock_mode;\n\t\tts->tv_sec = gtod->monotonic_time_sec;\n\t\tns = gtod->monotonic_time_snsec;\n\t\tns += vgettsc(cycle_now);\n\t\tns >>= gtod->clock.shift;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\ttimespec_add_ns(ts, ns);\n\n\treturn mode;\n}\n",
        "linevul": 4.682941653300077e-05,
        "sysevr": 0.14140357077121735,
        "devign": 4.832362808515622e-13
    },
    {
        "code": "int user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\treturn filename_lookup(dfd, getname_flags(name, flags, empty),\n\t\t\t       flags, path, NULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "vul_func_with_fix": "int user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\treturn filename_lookup(dfd, getname_flags(name, flags, empty),\n\t\t\t       flags, path, NULL);\n}\n",
        "linevul": 6.024265894666314e-05,
        "sysevr": 0.16542337834835052,
        "devign": 0.23378612101078033
    },
    {
        "code": "long keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b4a1b4f5047e4f54e194681125c74c0aa64d637d",
        "vul_func_with_fix": "long keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n",
        "linevul": 0.0005187693168409169,
        "sysevr": 0.2165517359972,
        "devign": 0.6433761119842529
    },
    {
        "code": "static int veth_set_rx_csum(struct net_device *dev, u32 data)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tpriv->ip_summed = data ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867",
        "vul_func_with_fix": "static int veth_set_rx_csum(struct net_device *dev, u32 data)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tpriv->ip_summed = data ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE;\n\treturn 0;\n}\n",
        "linevul": 4.703475133283064e-05,
        "sysevr": 0.1359841227531433,
        "devign": 1.3754495320483784e-08
    },
    {
        "code": "void ip_mc_init_dev(struct in_device *in_dev)\n{\n\tASSERT_RTNL();\n\n\tin_dev->mc_tomb = NULL;\n#ifdef CONFIG_IP_MULTICAST\n\tin_dev->mr_gq_running = 0;\n\tsetup_timer(&in_dev->mr_gq_timer, igmp_gq_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_ifc_count = 0;\n\tin_dev->mc_count     = 0;\n\tsetup_timer(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_qrv = IGMP_Unsolicited_Report_Count;\n#endif\n\n\tspin_lock_init(&in_dev->mc_tomb_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27",
        "vul_func_with_fix": "void ip_mc_init_dev(struct in_device *in_dev)\n{\n\tASSERT_RTNL();\n\n\tin_dev->mc_tomb = NULL;\n#ifdef CONFIG_IP_MULTICAST\n\tin_dev->mr_gq_running = 0;\n\tsetup_timer(&in_dev->mr_gq_timer, igmp_gq_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_ifc_count = 0;\n\tin_dev->mc_count     = 0;\n\tsetup_timer(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_qrv = IGMP_Unsolicited_Report_Count;\n#endif\n\n\tspin_lock_init(&in_dev->mc_tomb_lock);\n}\n",
        "linevul": 5.151398363523185e-05,
        "sysevr": 0.18193261325359344,
        "devign": 3.926210792249476e-17
    },
    {
        "code": "static void pmcraid_get_fwversion(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu16 data_size = sizeof(struct pmcraid_inquiry_data);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = INQUIRY;\n\tioarcb->cdb[1] = 1;\n\tioarcb->cdb[2] = 0xD0;\n\tioarcb->cdb[3] = (data_size >> 8) & 0xFF;\n\tioarcb->cdb[4] = data_size & 0xFF;\n\n\t/* Since entire inquiry data it can be part of IOARCB itself\n\t */\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(data_size);\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->inq_data_baddr);\n\tioadl->data_len = cpu_to_le32(data_size);\n\n\tpmcraid_send_cmd(cmd, pmcraid_get_fwversion_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d",
        "vul_func_with_fix": "static void pmcraid_get_fwversion(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tu16 data_size = sizeof(struct pmcraid_inquiry_data);\n\n\tpmcraid_reinit_cmdblk(cmd);\n\tioarcb->request_type = REQ_TYPE_SCSI;\n\tioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\n\tioarcb->cdb[0] = INQUIRY;\n\tioarcb->cdb[1] = 1;\n\tioarcb->cdb[2] = 0xD0;\n\tioarcb->cdb[3] = (data_size >> 8) & 0xFF;\n\tioarcb->cdb[4] = data_size & 0xFF;\n\n\t/* Since entire inquiry data it can be part of IOARCB itself\n\t */\n\tioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\n\t\t\t\t\toffsetof(struct pmcraid_ioarcb,\n\t\t\t\t\t\tadd_data.u.ioadl[0]));\n\tioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\n\tioarcb->ioarcb_bus_addr &= ~(0x1FULL);\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(data_size);\n\tioadl = &(ioarcb->add_data.u.ioadl[0]);\n\tioadl->flags = IOADL_FLAGS_LAST_DESC;\n\tioadl->address = cpu_to_le64(pinstance->inq_data_baddr);\n\tioadl->data_len = cpu_to_le32(data_size);\n\n\tpmcraid_send_cmd(cmd, pmcraid_get_fwversion_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\n}\n",
        "linevul": 4.9833059165393934e-05,
        "sysevr": 0.16931596398353577,
        "devign": 1.4289795217337087e-05
    },
    {
        "code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/2def2ef2ae5f3990aabdbe8a755911902707d268",
        "vul_func_with_fix": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n//flaw_line_below:\n\tif (COMPAT_USE_64BIT_TIME)\n//flaw_line_below:\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n//flaw_line_below:\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n//flaw_line_below:\n\t\t\t\t      (struct timespec *) timeout);\n//flaw_line_below:\n\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n//flaw_line_below:\n\tif (get_compat_timespec(&ktspec, timeout))\n//fix_flaw_line_below:\n//\tif (compat_get_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n//flaw_line_below:\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n//fix_flaw_line_below:\n//\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n",
        "linevul": 0.998875081539154,
        "sysevr": 0.17870916426181793,
        "devign": 0.5974478721618652
    },
    {
        "code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\n\tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n \n \tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d661684cf6820331feae71146c35da83d794467e",
        "vul_func_with_fix": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\n\tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n \n \tif ((creds->pid == task_tgid_vnr(current) ||\n//flaw_line_below:\n\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n//fix_flaw_line_below:\n//\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}\n",
        "linevul": 0.9995995163917542,
        "sysevr": 0.13029305636882782,
        "devign": 0.9898698925971985
    },
    {
        "code": "static int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > sizeof(struct sctp_event_subscribe))\n\t\tlen = sizeof(struct sctp_event_subscribe);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->subscribe, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "vul_func_with_fix": "static int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > sizeof(struct sctp_event_subscribe))\n\t\tlen = sizeof(struct sctp_event_subscribe);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->subscribe, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "linevul": 5.046845762990415e-05,
        "sysevr": 0.1261913776397705,
        "devign": 0.44530853629112244
    },
    {
        "code": "static unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn 1ULL << 20;\n\n\treturn div64_u64(runtime << 20, period);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": "static unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn 1ULL << 20;\n\n\treturn div64_u64(runtime << 20, period);\n}\n",
        "linevul": 5.118111948831938e-05,
        "sysevr": 0.13341037929058075,
        "devign": 9.877294360194355e-07
    },
    {
        "code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "vul_func_with_fix": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!res.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n//flaw_line_below:\n\t\t\t\tres.acl_len);\n//fix_flaw_line_below:\n//\t\t\t\tacl_len);\n \t}\n \tret = acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}\n",
        "linevul": 0.0002929829352069646,
        "sysevr": 0.15336249768733978,
        "devign": 0.9998165965080261
    },
    {
        "code": "void atmpvc_exit(void)\n{\n\tsock_unregister(PF_ATMPVC);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3c0c5cfdcd4d69ffc4b9c0907cec99039f30a50a",
        "vul_func_with_fix": "void atmpvc_exit(void)\n{\n\tsock_unregister(PF_ATMPVC);\n}\n",
        "linevul": 9.033911919686943e-05,
        "sysevr": 0.15830755233764648,
        "devign": 4.842385607078947e-12
    },
    {
        "code": "static void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkzfree(p);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkzfree(p);\n}\n",
        "linevul": 5.02702641824726e-05,
        "sysevr": 0.12675967812538147,
        "devign": 0.0003551337867975235
    },
    {
        "code": "static void remove_full(struct kmem_cache *s, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tn = get_node(s, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tlist_del(&page->lru);\n\tspin_unlock(&n->list_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static void remove_full(struct kmem_cache *s, struct page *page)\n{\n\tstruct kmem_cache_node *n;\n\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\n\tn = get_node(s, page_to_nid(page));\n\n\tspin_lock(&n->list_lock);\n\tlist_del(&page->lru);\n\tspin_unlock(&n->list_lock);\n}\n",
        "linevul": 6.266834679991007e-05,
        "sysevr": 0.11784563958644867,
        "devign": 7.869505047608527e-09
    },
    {
        "code": "static int dcbnl_notify(struct net_device *dev, int event, int cmd,\n\t\t\tu32 seq, u32 portid, int dcbx_ver)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = dcbnl_newmsg(event, cmd, portid, seq, 0, &nlh);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\n\t\terr = dcbnl_ieee_fill(skb, dev);\n\telse\n\t\terr = dcbnl_cee_fill(skb, dev);\n\n\tif (err < 0) {\n\t\t/* Report error to broadcast listeners */\n\t\tnlmsg_free(skb);\n\t\trtnl_set_sk_err(net, RTNLGRP_DCB, err);\n\t} else {\n\t\t/* End nlmsg and notify broadcast listeners */\n\t\tnlmsg_end(skb, nlh);\n\t\trtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\n\t}\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/29cd8ae0e1a39e239a3a7b67da1986add1199fc0",
        "vul_func_with_fix": "static int dcbnl_notify(struct net_device *dev, int event, int cmd,\n\t\t\tu32 seq, u32 portid, int dcbx_ver)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tconst struct dcbnl_rtnl_ops *ops = dev->dcbnl_ops;\n\tint err;\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = dcbnl_newmsg(event, cmd, portid, seq, 0, &nlh);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (dcbx_ver == DCB_CAP_DCBX_VER_IEEE)\n\t\terr = dcbnl_ieee_fill(skb, dev);\n\telse\n\t\terr = dcbnl_cee_fill(skb, dev);\n\n\tif (err < 0) {\n\t\t/* Report error to broadcast listeners */\n\t\tnlmsg_free(skb);\n\t\trtnl_set_sk_err(net, RTNLGRP_DCB, err);\n\t} else {\n\t\t/* End nlmsg and notify broadcast listeners */\n\t\tnlmsg_end(skb, nlh);\n\t\trtnl_notify(skb, net, 0, RTNLGRP_DCB, NULL, GFP_KERNEL);\n\t}\n\n\treturn err;\n}\n",
        "linevul": 6.201512587722391e-05,
        "sysevr": 0.12075643986463547,
        "devign": 1.560190517397711e-17
    },
    {
        "code": "static int whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->mcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->mcr |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tinfo->mcr &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->mcr &= ~UART_MCR_DTR;\n\n\tfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\n\tfirm_set_rts(port, info->mcr & UART_MCR_RTS);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818",
        "vul_func_with_fix": "static int whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->mcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->mcr |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tinfo->mcr &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->mcr &= ~UART_MCR_DTR;\n\n\tfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\n\tfirm_set_rts(port, info->mcr & UART_MCR_RTS);\n\treturn 0;\n}\n",
        "linevul": 5.2493200200842693e-05,
        "sysevr": 0.1894725263118744,
        "devign": 1.4222271360608829e-08
    },
    {
        "code": "long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase DIGI_GETDD:\n\t{\n\t\t/*\n\t\t * This returns the total number of boards\n\t\t * in the system, as well as driver version\n\t\t * and has space for a reserved entry\n\t\t */\n\t\tstruct digi_dinfo ddi;\n \n \t\tspin_lock_irqsave(&dgnc_global_lock, flags);\n \n \t\tddi.dinfo_nboards = dgnc_NumBoards;\n \t\tsprintf(ddi.dinfo_version, \"%s\", DG_PART);\n \n\t\tspin_unlock_irqrestore(&dgnc_global_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ddi, sizeof(ddi)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GETBD:\n\t{\n\t\tint brd;\n\n\t\tstruct digi_info di;\n\n\t\tif (copy_from_user(&brd, uarg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (brd < 0 || brd >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&di, 0, sizeof(di));\n\n\t\tdi.info_bdnum = brd;\n\n\t\tspin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tdi.info_bdtype = dgnc_Board[brd]->dpatype;\n\t\tdi.info_bdstate = dgnc_Board[brd]->dpastatus;\n\t\tdi.info_ioport = 0;\n\t\tdi.info_physaddr = (ulong)dgnc_Board[brd]->membase;\n\t\tdi.info_physsize = (ulong)dgnc_Board[brd]->membase\n\t\t\t- dgnc_Board[brd]->membase_end;\n\t\tif (dgnc_Board[brd]->state != BOARD_FAILED)\n\t\t\tdi.info_nports = dgnc_Board[brd]->nasync;\n\t\telse\n\t\t\tdi.info_nports = 0;\n\n\t\tspin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tif (copy_to_user(uarg, &di, sizeof(di)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GET_NI_INFO:\n\t{\n\t\tstruct channel_t *ch;\n\t\tstruct ni_info ni;\n\t\tunsigned char mstat = 0;\n\t\tuint board = 0;\n\t\tuint channel = 0;\n\n\t\tif (copy_from_user(&ni, uarg, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tboard = ni.board;\n\t\tchannel = ni.channel;\n\n\t\t/* Verify boundaries on board */\n\t\tif (board >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\t/* Verify boundaries on channel */\n\t\tif (channel >= dgnc_Board[board]->nasync)\n\t\t\treturn -ENODEV;\n\n\t\tch = dgnc_Board[board]->channels[channel];\n\n\t\tif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&ni, 0, sizeof(ni));\n\t\tni.board = board;\n\t\tni.channel = channel;\n\n\t\tspin_lock_irqsave(&ch->ch_lock, flags);\n\n\t\tmstat = (ch->ch_mostat | ch->ch_mistat);\n\n\t\tif (mstat & UART_MCR_DTR) {\n\t\t\tni.mstat |= TIOCM_DTR;\n\t\t\tni.dtr = TIOCM_DTR;\n\t\t}\n\t\tif (mstat & UART_MCR_RTS) {\n\t\t\tni.mstat |= TIOCM_RTS;\n\t\t\tni.rts = TIOCM_RTS;\n\t\t}\n\t\tif (mstat & UART_MSR_CTS) {\n\t\t\tni.mstat |= TIOCM_CTS;\n\t\t\tni.cts = TIOCM_CTS;\n\t\t}\n\t\tif (mstat & UART_MSR_RI) {\n\t\t\tni.mstat |= TIOCM_RI;\n\t\t\tni.ri = TIOCM_RI;\n\t\t}\n\t\tif (mstat & UART_MSR_DCD) {\n\t\t\tni.mstat |= TIOCM_CD;\n\t\t\tni.dcd = TIOCM_CD;\n\t\t}\n\t\tif (mstat & UART_MSR_DSR)\n\t\t\tni.mstat |= TIOCM_DSR;\n\n\t\tni.iflag = ch->ch_c_iflag;\n\t\tni.oflag = ch->ch_c_oflag;\n\t\tni.cflag = ch->ch_c_cflag;\n\t\tni.lflag = ch->ch_c_lflag;\n\n\t\tif (ch->ch_digi.digi_flags & CTSPACE ||\n\t\t    ch->ch_c_cflag & CRTSCTS)\n\t\t\tni.hflow = 1;\n\t\telse\n\t\t\tni.hflow = 0;\n\n\t\tif ((ch->ch_flags & CH_STOPI) ||\n\t\t    (ch->ch_flags & CH_FORCED_STOPI))\n\t\t\tni.recv_stopped = 1;\n\t\telse\n\t\t\tni.recv_stopped = 0;\n\n\t\tif ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))\n\t\t\tni.xmit_stopped = 1;\n\t\telse\n\t\t\tni.xmit_stopped = 0;\n\n\t\tni.curtx = ch->ch_txcount;\n\t\tni.currx = ch->ch_rxcount;\n\n\t\tni.baud = ch->ch_old_baud;\n\n\t\tspin_unlock_irqrestore(&ch->ch_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ni, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4b6184336ebb5c8dc1eae7f7ab46ee608a748b05",
        "vul_func_with_fix": "long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned long flags;\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase DIGI_GETDD:\n\t{\n\t\t/*\n\t\t * This returns the total number of boards\n\t\t * in the system, as well as driver version\n\t\t * and has space for a reserved entry\n\t\t */\n\t\tstruct digi_dinfo ddi;\n \n \t\tspin_lock_irqsave(&dgnc_global_lock, flags);\n \n//fix_flaw_line_below:\n//\t\tmemset(&ddi, 0, sizeof(ddi));\n \t\tddi.dinfo_nboards = dgnc_NumBoards;\n \t\tsprintf(ddi.dinfo_version, \"%s\", DG_PART);\n \n\t\tspin_unlock_irqrestore(&dgnc_global_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ddi, sizeof(ddi)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GETBD:\n\t{\n\t\tint brd;\n\n\t\tstruct digi_info di;\n\n\t\tif (copy_from_user(&brd, uarg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tif (brd < 0 || brd >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&di, 0, sizeof(di));\n\n\t\tdi.info_bdnum = brd;\n\n\t\tspin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tdi.info_bdtype = dgnc_Board[brd]->dpatype;\n\t\tdi.info_bdstate = dgnc_Board[brd]->dpastatus;\n\t\tdi.info_ioport = 0;\n\t\tdi.info_physaddr = (ulong)dgnc_Board[brd]->membase;\n\t\tdi.info_physsize = (ulong)dgnc_Board[brd]->membase\n\t\t\t- dgnc_Board[brd]->membase_end;\n\t\tif (dgnc_Board[brd]->state != BOARD_FAILED)\n\t\t\tdi.info_nports = dgnc_Board[brd]->nasync;\n\t\telse\n\t\t\tdi.info_nports = 0;\n\n\t\tspin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);\n\n\t\tif (copy_to_user(uarg, &di, sizeof(di)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase DIGI_GET_NI_INFO:\n\t{\n\t\tstruct channel_t *ch;\n\t\tstruct ni_info ni;\n\t\tunsigned char mstat = 0;\n\t\tuint board = 0;\n\t\tuint channel = 0;\n\n\t\tif (copy_from_user(&ni, uarg, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tboard = ni.board;\n\t\tchannel = ni.channel;\n\n\t\t/* Verify boundaries on board */\n\t\tif (board >= dgnc_NumBoards)\n\t\t\treturn -ENODEV;\n\n\t\t/* Verify boundaries on channel */\n\t\tif (channel >= dgnc_Board[board]->nasync)\n\t\t\treturn -ENODEV;\n\n\t\tch = dgnc_Board[board]->channels[channel];\n\n\t\tif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\n\t\t\treturn -ENODEV;\n\n\t\tmemset(&ni, 0, sizeof(ni));\n\t\tni.board = board;\n\t\tni.channel = channel;\n\n\t\tspin_lock_irqsave(&ch->ch_lock, flags);\n\n\t\tmstat = (ch->ch_mostat | ch->ch_mistat);\n\n\t\tif (mstat & UART_MCR_DTR) {\n\t\t\tni.mstat |= TIOCM_DTR;\n\t\t\tni.dtr = TIOCM_DTR;\n\t\t}\n\t\tif (mstat & UART_MCR_RTS) {\n\t\t\tni.mstat |= TIOCM_RTS;\n\t\t\tni.rts = TIOCM_RTS;\n\t\t}\n\t\tif (mstat & UART_MSR_CTS) {\n\t\t\tni.mstat |= TIOCM_CTS;\n\t\t\tni.cts = TIOCM_CTS;\n\t\t}\n\t\tif (mstat & UART_MSR_RI) {\n\t\t\tni.mstat |= TIOCM_RI;\n\t\t\tni.ri = TIOCM_RI;\n\t\t}\n\t\tif (mstat & UART_MSR_DCD) {\n\t\t\tni.mstat |= TIOCM_CD;\n\t\t\tni.dcd = TIOCM_CD;\n\t\t}\n\t\tif (mstat & UART_MSR_DSR)\n\t\t\tni.mstat |= TIOCM_DSR;\n\n\t\tni.iflag = ch->ch_c_iflag;\n\t\tni.oflag = ch->ch_c_oflag;\n\t\tni.cflag = ch->ch_c_cflag;\n\t\tni.lflag = ch->ch_c_lflag;\n\n\t\tif (ch->ch_digi.digi_flags & CTSPACE ||\n\t\t    ch->ch_c_cflag & CRTSCTS)\n\t\t\tni.hflow = 1;\n\t\telse\n\t\t\tni.hflow = 0;\n\n\t\tif ((ch->ch_flags & CH_STOPI) ||\n\t\t    (ch->ch_flags & CH_FORCED_STOPI))\n\t\t\tni.recv_stopped = 1;\n\t\telse\n\t\t\tni.recv_stopped = 0;\n\n\t\tif ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))\n\t\t\tni.xmit_stopped = 1;\n\t\telse\n\t\t\tni.xmit_stopped = 0;\n\n\t\tni.curtx = ch->ch_txcount;\n\t\tni.currx = ch->ch_rxcount;\n\n\t\tni.baud = ch->ch_old_baud;\n\n\t\tspin_unlock_irqrestore(&ch->ch_lock, flags);\n\n\t\tif (copy_to_user(uarg, &ni, sizeof(ni)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 0.9995678067207336,
        "sysevr": 0.40446674823760986,
        "devign": 2.202094284697864e-09
    },
    {
        "code": "static struct dentry *shmem_get_parent(struct dentry *child)\n{\n\treturn ERR_PTR(-ESTALE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "static struct dentry *shmem_get_parent(struct dentry *child)\n{\n\treturn ERR_PTR(-ESTALE);\n}\n",
        "linevul": 6.073028998798691e-05,
        "sysevr": 0.1212427020072937,
        "devign": 5.1742234063567594e-05
    },
    {
        "code": "void ldsem_up_write(struct ld_semaphore *sem)\n{\n\tlong count;\n\n\tlockdep_release(sem, 1, _RET_IP_);\n\n\tcount = ldsem_atomic_update(-LDSEM_WRITE_BIAS, sem);\n\tif (count < 0)\n\t\tldsem_wake(sem);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cf872776fc84128bb779ce2b83a37c884c3203ae",
        "vul_func_with_fix": "void ldsem_up_write(struct ld_semaphore *sem)\n{\n\tlong count;\n\n\tlockdep_release(sem, 1, _RET_IP_);\n\n\tcount = ldsem_atomic_update(-LDSEM_WRITE_BIAS, sem);\n\tif (count < 0)\n\t\tldsem_wake(sem);\n}\n",
        "linevul": 0.00011378292401786894,
        "sysevr": 0.1541507989168167,
        "devign": 4.5283742072322546e-18
    },
    {
        "code": "static int vr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.vr_state, 0,\n\t\t\t\t 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the first word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\n\t\tvrsave.word = target->thread.vrsave;\n\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.vrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c1fa0768a8713b135848f78fd43ffc208d8ded70",
        "vul_func_with_fix": "static int vr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.vr_state, 0,\n\t\t\t\t 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the first word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\n\t\tvrsave.word = target->thread.vrsave;\n\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.vrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 8.65260444697924e-05,
        "sysevr": 0.15829217433929443,
        "devign": 0.5852042436599731
    },
    {
        "code": "static int pf_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\tint ret;\n\n\tmutex_lock(&pf_mutex);\n\tpf_identify(pf);\n\n\tret = -ENODEV;\n\tif (pf->media_status == PF_NM)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif ((pf->media_status == PF_RO) && (mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = 0;\n\tpf->access++;\n\tif (pf->removable)\n\t\tpf_lock(pf, 1);\nout:\n\tmutex_unlock(&pf_mutex);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/58ccd2d31e502c37e108b285bf3d343eb00c235b",
        "vul_func_with_fix": "static int pf_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct pf_unit *pf = bdev->bd_disk->private_data;\n\tint ret;\n\n\tmutex_lock(&pf_mutex);\n\tpf_identify(pf);\n\n\tret = -ENODEV;\n\tif (pf->media_status == PF_NM)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif ((pf->media_status == PF_RO) && (mode & FMODE_WRITE))\n\t\tgoto out;\n\n\tret = 0;\n\tpf->access++;\n\tif (pf->removable)\n\t\tpf_lock(pf, 1);\nout:\n\tmutex_unlock(&pf_mutex);\n\treturn ret;\n}\n",
        "linevul": 4.973507020622492e-05,
        "sysevr": 0.13021503388881683,
        "devign": 6.318717555751311e-17
    },
    {
        "code": "rpc_init_mempool(void)\n{\n\t/*\n\t * The following is not strictly a mempool initialisation,\n\t * but there is no harm in doing it here\n\t */\n\trpc_init_wait_queue(&delay_queue, \"delayq\");\n\tif (!rpciod_start())\n\t\tgoto err_nomem;\n\n\trpc_task_slabp = kmem_cache_create(\"rpc_tasks\",\n\t\t\t\t\t     sizeof(struct rpc_task),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (!rpc_task_slabp)\n\t\tgoto err_nomem;\n\trpc_buffer_slabp = kmem_cache_create(\"rpc_buffers\",\n\t\t\t\t\t     RPC_BUFFER_MAXSIZE,\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (!rpc_buffer_slabp)\n\t\tgoto err_nomem;\n\trpc_task_mempool = mempool_create_slab_pool(RPC_TASK_POOLSIZE,\n\t\t\t\t\t\t    rpc_task_slabp);\n\tif (!rpc_task_mempool)\n\t\tgoto err_nomem;\n\trpc_buffer_mempool = mempool_create_slab_pool(RPC_BUFFER_POOLSIZE,\n\t\t\t\t\t\t      rpc_buffer_slabp);\n\tif (!rpc_buffer_mempool)\n\t\tgoto err_nomem;\n\treturn 0;\nerr_nomem:\n\trpc_destroy_mempool();\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f",
        "vul_func_with_fix": "rpc_init_mempool(void)\n{\n\t/*\n\t * The following is not strictly a mempool initialisation,\n\t * but there is no harm in doing it here\n\t */\n\trpc_init_wait_queue(&delay_queue, \"delayq\");\n\tif (!rpciod_start())\n\t\tgoto err_nomem;\n\n\trpc_task_slabp = kmem_cache_create(\"rpc_tasks\",\n\t\t\t\t\t     sizeof(struct rpc_task),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (!rpc_task_slabp)\n\t\tgoto err_nomem;\n\trpc_buffer_slabp = kmem_cache_create(\"rpc_buffers\",\n\t\t\t\t\t     RPC_BUFFER_MAXSIZE,\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (!rpc_buffer_slabp)\n\t\tgoto err_nomem;\n\trpc_task_mempool = mempool_create_slab_pool(RPC_TASK_POOLSIZE,\n\t\t\t\t\t\t    rpc_task_slabp);\n\tif (!rpc_task_mempool)\n\t\tgoto err_nomem;\n\trpc_buffer_mempool = mempool_create_slab_pool(RPC_BUFFER_POOLSIZE,\n\t\t\t\t\t\t      rpc_buffer_slabp);\n\tif (!rpc_buffer_mempool)\n\t\tgoto err_nomem;\n\treturn 0;\nerr_nomem:\n\trpc_destroy_mempool();\n\treturn -ENOMEM;\n}\n",
        "linevul": 5.1292419811943546e-05,
        "sysevr": 0.15461058914661407,
        "devign": 1.7254897954899207e-08
    },
    {
        "code": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}\n",
        "linevul": 4.957804412697442e-05,
        "sysevr": 0.12127826362848282,
        "devign": 1.0023533738486248e-21
    },
    {
        "code": "void netif_tx_stop_all_queues(struct net_device *dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\n\t\tnetif_tx_stop_queue(txq);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d",
        "vul_func_with_fix": "void netif_tx_stop_all_queues(struct net_device *dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\n\t\tnetif_tx_stop_queue(txq);\n\t}\n}\n",
        "linevul": 4.96827342431061e-05,
        "sysevr": 0.14874756336212158,
        "devign": 3.5826630697495185e-14
    },
    {
        "code": "static bool blk_pm_allow_request(struct request *rq)\n{\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "vul_func_with_fix": "static bool blk_pm_allow_request(struct request *rq)\n{\n\treturn true;\n}\n",
        "linevul": 5.334655361366458e-05,
        "sysevr": 0.13063694536685944,
        "devign": 4.0124060324275845e-11
    },
    {
        "code": " static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n\tunsigned int random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77",
        "vul_func_with_fix": " static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n//flaw_line_below:\n\tunsigned int random_variable = 0;\n//fix_flaw_line_below:\n//\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n//flaw_line_below:\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n//fix_flaw_line_below:\n//\t\trandom_variable = (unsigned long) get_random_int();\n//fix_flaw_line_below:\n//\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}\n",
        "linevul": 0.9995020627975464,
        "sysevr": 0.13373541831970215,
        "devign": 0.00012596846499945968
    },
    {
        "code": "static void kill_f2fs_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\tset_sbi_flag(F2FS_SB(sb), SBI_IS_CLOSE);\n\tkill_block_super(sb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/15d3042a937c13f5d9244241c7a9c8416ff6e82a",
        "vul_func_with_fix": "static void kill_f2fs_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\tset_sbi_flag(F2FS_SB(sb), SBI_IS_CLOSE);\n\tkill_block_super(sb);\n}\n",
        "linevul": 7.635187648702413e-05,
        "sysevr": 0.1299644410610199,
        "devign": 1.2346614539637812e-06
    },
    {
        "code": "int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=\n\t    (unsigned int)sk->sk_rcvbuf)\n\t\treturn -ENOMEM;\n\n\tskb_orphan(skb);\n \tskb->sk = sk;\n \tskb->destructor = sock_rmem_free;\n \tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n \n \t/* before exiting rcu section, make sure dst is refcounted */\n \tskb_dst_force(skb);\n\n\tskb_queue_tail(&sk->sk_error_queue, skb);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/8605330aac5a5785630aec8f64378a54891937cc",
        "vul_func_with_fix": "int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=\n\t    (unsigned int)sk->sk_rcvbuf)\n\t\treturn -ENOMEM;\n\n\tskb_orphan(skb);\n \tskb->sk = sk;\n \tskb->destructor = sock_rmem_free;\n \tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n//fix_flaw_line_below:\n//\tskb_set_err_queue(skb);\n \n \t/* before exiting rcu section, make sure dst is refcounted */\n \tskb_dst_force(skb);\n\n\tskb_queue_tail(&sk->sk_error_queue, skb);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\treturn 0;\n}\n",
        "linevul": 0.9996071457862854,
        "sysevr": 0.157221719622612,
        "devign": 0.9843952655792236
    },
    {
        "code": "rpc_setbufsize(struct rpc_clnt *clnt, unsigned int sndsize, unsigned int rcvsize)\n{\n\tstruct rpc_xprt *xprt = clnt->cl_xprt;\n\tif (xprt->ops->set_buffer_size)\n\t\txprt->ops->set_buffer_size(xprt, sndsize, rcvsize);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f",
        "vul_func_with_fix": "rpc_setbufsize(struct rpc_clnt *clnt, unsigned int sndsize, unsigned int rcvsize)\n{\n\tstruct rpc_xprt *xprt = clnt->cl_xprt;\n\tif (xprt->ops->set_buffer_size)\n\t\txprt->ops->set_buffer_size(xprt, sndsize, rcvsize);\n}\n",
        "linevul": 6.483263132395223e-05,
        "sysevr": 0.15364503860473633,
        "devign": 7.029863913210477e-10
    },
    {
        "code": "static void op32_set_current_rxslot(struct b43_dmaring *ring, int slot)\n{\n\tb43_dma_write(ring, B43_DMA32_RXINDEX,\n\t\t      (u32) (slot * sizeof(struct b43_dmadesc32)));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a",
        "vul_func_with_fix": "static void op32_set_current_rxslot(struct b43_dmaring *ring, int slot)\n{\n\tb43_dma_write(ring, B43_DMA32_RXINDEX,\n\t\t      (u32) (slot * sizeof(struct b43_dmadesc32)));\n}\n",
        "linevul": 5.1623359468067065e-05,
        "sysevr": 0.12216472625732422,
        "devign": 5.740836694911877e-10
    },
    {
        "code": "static int tcp_send_mss(struct sock *sk, int *size_goal, int flags)\n{\n\tint mss_now;\n\n\tmss_now = tcp_current_mss(sk);\n\t*size_goal = tcp_xmit_size_goal(sk, mss_now, !(flags & MSG_OOB));\n\n\treturn mss_now;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/baff42ab1494528907bf4d5870359e31711746ae",
        "vul_func_with_fix": "static int tcp_send_mss(struct sock *sk, int *size_goal, int flags)\n{\n\tint mss_now;\n\n\tmss_now = tcp_current_mss(sk);\n\t*size_goal = tcp_xmit_size_goal(sk, mss_now, !(flags & MSG_OOB));\n\n\treturn mss_now;\n}\n",
        "linevul": 4.831458136322908e-05,
        "sysevr": 0.123686783015728,
        "devign": 4.716358553702449e-11
    },
    {
        "code": "static int ctr_crypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t     struct scatterlist *src, unsigned int nbytes)\n{\n\treturn glue_ctr_crypt_128bit(&twofish_ctr, desc, dst, src, nbytes);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int ctr_crypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t     struct scatterlist *src, unsigned int nbytes)\n{\n\treturn glue_ctr_crypt_128bit(&twofish_ctr, desc, dst, src, nbytes);\n}\n",
        "linevul": 5.1480881666066125e-05,
        "sysevr": 0.12506310641765594,
        "devign": 1.3341700650926214e-05
    },
    {
        "code": "static int lg_dinovo_mapping(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\n\tcase 0x00d: lg_map_key_clear(KEY_MEDIA);\tbreak;\n\tdefault:\n\t\treturn 0;\n\n\t}\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214",
        "vul_func_with_fix": "static int lg_dinovo_mapping(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\n\tcase 0x00d: lg_map_key_clear(KEY_MEDIA);\tbreak;\n\tdefault:\n\t\treturn 0;\n\n\t}\n\treturn 1;\n}\n",
        "linevul": 5.253837298369035e-05,
        "sysevr": 0.13107839226722717,
        "devign": 4.444462627750614e-19
    },
    {
        "code": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending_unlocked;\n \t} else {\n \t\tstatus = count;\n \t}\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\nrelease_write_pending_unlocked:\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/072684e8c58d17e853f8e8b9f6d9ce2e58d2b036",
        "vul_func_with_fix": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n//fix_flaw_line_below:\n//\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n//fix_flaw_line_below:\n//\n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n//flaw_line_below:\n\t\tgoto release_write_pending_unlocked;\n//fix_flaw_line_below:\n//\t\tgoto release_write_pending;\n \t} else {\n \t\tstatus = count;\n \t}\n//flaw_line_below:\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\n//flaw_line_below:\nrelease_write_pending_unlocked:\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n",
        "linevul": 0.0005005113780498505,
        "sysevr": 0.15285265445709229,
        "devign": 0.6699246168136597
    },
    {
        "code": "SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\n tcon_error_exit:\n \tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n \t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\ttcon->bad_network_name = true;\n \t}\n \tgoto tcon_exit;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/18f39e7be0121317550d03e267e3ebd4dbfbb3ce",
        "vul_func_with_fix": "SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\n\trsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\n tcon_error_exit:\n \tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n \t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n//flaw_line_below:\n\t\ttcon->bad_network_name = true;\n//fix_flaw_line_below:\n//\t\tif (tcon)\n//fix_flaw_line_below:\n//\t\t\ttcon->bad_network_name = true;\n \t}\n \tgoto tcon_exit;\n }\n",
        "linevul": 5.6998505897354335e-05,
        "sysevr": 0.2439863532781601,
        "devign": 5.325363902023567e-16
    },
    {
        "code": "static int dispatch_other_io(struct xen_blkif *blkif,\n\t\t\t     struct blkif_request *req,\n\t\t\t     struct pending_req *pending_req)\n{\n\tfree_req(blkif, pending_req);\n\tmake_response(blkif, req->u.other.id, req->operation,\n\t\t      BLKIF_RSP_EOPNOTSUPP);\n\treturn -EIO;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/604c499cbbcc3d5fe5fb8d53306aa0fae1990109",
        "vul_func_with_fix": "static int dispatch_other_io(struct xen_blkif *blkif,\n\t\t\t     struct blkif_request *req,\n\t\t\t     struct pending_req *pending_req)\n{\n\tfree_req(blkif, pending_req);\n\tmake_response(blkif, req->u.other.id, req->operation,\n\t\t      BLKIF_RSP_EOPNOTSUPP);\n\treturn -EIO;\n}\n",
        "linevul": 4.9084930651588365e-05,
        "sysevr": 0.12766514718532562,
        "devign": 2.842500862243469e-06
    },
    {
        "code": "ssize_t cifs_user_readv(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t       unsigned long nr_segs, loff_t pos)\n{\n\tssize_t read;\n\n\tread = cifs_iovec_read(iocb->ki_filp, iov, nr_segs, &pos);\n\tif (read > 0)\n\t\tiocb->ki_pos = pos;\n\n\treturn read;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f",
        "vul_func_with_fix": "ssize_t cifs_user_readv(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t       unsigned long nr_segs, loff_t pos)\n{\n\tssize_t read;\n\n\tread = cifs_iovec_read(iocb->ki_filp, iov, nr_segs, &pos);\n\tif (read > 0)\n\t\tiocb->ki_pos = pos;\n\n\treturn read;\n}\n",
        "linevul": 4.7088793508009985e-05,
        "sysevr": 0.1635960340499878,
        "devign": 7.008078839465526e-11
    },
    {
        "code": "mark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n\t\t\t    visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
        "vul_func_with_fix": "mark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n//flaw_line_below:\n\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n//fix_flaw_line_below:\n//\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n//flaw_line_below:\n\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n//flaw_line_below:\n\t\t\t    visited) {\n//fix_flaw_line_below:\n//\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}\n",
        "linevul": 6.56139527563937e-05,
        "sysevr": 0.19279557466506958,
        "devign": 0.985140323638916
    },
    {
        "code": "static int tcm_loop_shutdown_session(struct se_session *se_sess)\n{\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8",
        "vul_func_with_fix": "static int tcm_loop_shutdown_session(struct se_session *se_sess)\n{\n\treturn 0;\n}\n",
        "linevul": 5.4326654208125547e-05,
        "sysevr": 0.13017579913139343,
        "devign": 1.493982715317088e-11
    },
    {
        "code": "xfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_cancel;\n\t\t}\n\t}\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((inode->i_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tinode->i_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n \n out_cancel:\n \txfs_trans_cancel(tp);\n out_dqrele:\n \txfs_qm_dqrele(udqp);\n \txfs_qm_dqrele(gdqp);\n\treturn error;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee",
        "vul_func_with_fix": "xfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_cancel;\n\t\t}\n\t}\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((inode->i_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tinode->i_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n \n out_cancel:\n \txfs_trans_cancel(tp);\n//fix_flaw_line_below:\n//\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n out_dqrele:\n \txfs_qm_dqrele(udqp);\n \txfs_qm_dqrele(gdqp);\n\treturn error;\n}\n",
        "linevul": 0.12682850658893585,
        "sysevr": 0.3594394326210022,
        "devign": 0.9990386962890625
    },
    {
        "code": "static void give_pages(struct receive_queue *rq, struct page *page)\n{\n\tstruct page *end;\n\n\t/* Find end of list, sew whole thing into vi->rq.pages. */\n\tfor (end = page; end->private; end = (struct page *)end->private);\n\tend->private = (unsigned long)rq->pages;\n\trq->pages = page;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39",
        "vul_func_with_fix": "static void give_pages(struct receive_queue *rq, struct page *page)\n{\n\tstruct page *end;\n\n\t/* Find end of list, sew whole thing into vi->rq.pages. */\n\tfor (end = page; end->private; end = (struct page *)end->private);\n\tend->private = (unsigned long)rq->pages;\n\trq->pages = page;\n}\n",
        "linevul": 5.7950954214902595e-05,
        "sysevr": 0.12793764472007751,
        "devign": 0.49920839071273804
    },
    {
        "code": "static int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, __be32 *p, struct nfs_writeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(&xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, __be32 *p, struct nfs_writeres *res)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(&xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(&xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}\n",
        "linevul": 5.3326311899581924e-05,
        "sysevr": 0.1318790465593338,
        "devign": 2.148750409303117e-27
    },
    {
        "code": "rb_event_length(struct ring_buffer_event *event)\n{\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event))\n\t\t\t/* undefined */\n\t\t\treturn -1;\n\t\treturn  event->array[0] + RB_EVNT_HDR_SIZE;\n\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\treturn RB_LEN_TIME_EXTEND;\n\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\treturn RB_LEN_TIME_STAMP;\n\n\tcase RINGBUF_TYPE_DATA:\n\t\treturn rb_event_data_length(event);\n\tdefault:\n\t\tBUG();\n\t}\n\t/* not hit */\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "vul_func_with_fix": "rb_event_length(struct ring_buffer_event *event)\n{\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event))\n\t\t\t/* undefined */\n\t\t\treturn -1;\n\t\treturn  event->array[0] + RB_EVNT_HDR_SIZE;\n\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\treturn RB_LEN_TIME_EXTEND;\n\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\treturn RB_LEN_TIME_STAMP;\n\n\tcase RINGBUF_TYPE_DATA:\n\t\treturn rb_event_data_length(event);\n\tdefault:\n\t\tBUG();\n\t}\n\t/* not hit */\n\treturn 0;\n}\n",
        "linevul": 4.648122558137402e-05,
        "sysevr": 0.16786140203475952,
        "devign": 1.1779247022225547e-10
    },
    {
        "code": "static ssize_t slab_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\terr = attribute->store(s, buf, len);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static ssize_t slab_attr_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\n\tif (!attribute->store)\n\t\treturn -EIO;\n\n\terr = attribute->store(s, buf, len);\n\n\treturn err;\n}\n",
        "linevul": 6.439282151404768e-05,
        "sysevr": 0.12629055976867676,
        "devign": 8.324097742785115e-25
    },
    {
        "code": "static inline int qeth_fill_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf, struct sk_buff *skb,\n\t\tstruct qeth_hdr *hdr, int offset, int hd_len)\n{\n\tstruct qdio_buffer *buffer;\n\tint flush_cnt = 0, hdr_len, large_send = 0;\n\n\tbuffer = buf->buffer;\n\tatomic_inc(&skb->users);\n\tskb_queue_tail(&buf->skb_list, skb);\n\n\t/*check first on TSO ....*/\n\tif (hdr->hdr.l3.id == QETH_HEADER_TYPE_TSO) {\n\t\tint element = buf->next_element_to_fill;\n\n\t\thdr_len = sizeof(struct qeth_hdr_tso) +\n\t\t\t((struct qeth_hdr_tso *)hdr)->ext.dg_hdr_len;\n\t\t/*fill first buffer entry only with header information */\n\t\tbuffer->element[element].addr = skb->data;\n\t\tbuffer->element[element].length = hdr_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->next_element_to_fill++;\n\t\tskb->data += hdr_len;\n\t\tskb->len  -= hdr_len;\n\t\tlarge_send = 1;\n\t}\n\n\tif (offset >= 0) {\n\t\tint element = buf->next_element_to_fill;\n\t\tbuffer->element[element].addr = hdr;\n\t\tbuffer->element[element].length = sizeof(struct qeth_hdr) +\n\t\t\t\t\t\t\thd_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->is_header[element] = 1;\n\t\tbuf->next_element_to_fill++;\n\t}\n\n\t__qeth_fill_buffer(skb, buffer, large_send,\n\t\t(int *)&buf->next_element_to_fill, offset);\n\n\tif (!queue->do_pack) {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfnp\");\n\t\t/* set state to PRIMED -> will be flushed */\n\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\tflush_cnt = 1;\n\t} else {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfpa\");\n\t\tif (queue->card->options.performance_stats)\n\t\t\tqueue->card->perf_stats.skbs_sent_pack++;\n\t\tif (buf->next_element_to_fill >=\n\t\t\t\tQETH_MAX_BUFFER_ELEMENTS(queue->card)) {\n\t\t\t/*\n\t\t\t * packed buffer if full -> set state PRIMED\n\t\t\t * -> will be flushed\n\t\t\t */\n\t\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_cnt = 1;\n\t\t}\n\t}\n\treturn flush_cnt;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62",
        "vul_func_with_fix": "static inline int qeth_fill_buffer(struct qeth_qdio_out_q *queue,\n\t\tstruct qeth_qdio_out_buffer *buf, struct sk_buff *skb,\n\t\tstruct qeth_hdr *hdr, int offset, int hd_len)\n{\n\tstruct qdio_buffer *buffer;\n\tint flush_cnt = 0, hdr_len, large_send = 0;\n\n\tbuffer = buf->buffer;\n\tatomic_inc(&skb->users);\n\tskb_queue_tail(&buf->skb_list, skb);\n\n\t/*check first on TSO ....*/\n\tif (hdr->hdr.l3.id == QETH_HEADER_TYPE_TSO) {\n\t\tint element = buf->next_element_to_fill;\n\n\t\thdr_len = sizeof(struct qeth_hdr_tso) +\n\t\t\t((struct qeth_hdr_tso *)hdr)->ext.dg_hdr_len;\n\t\t/*fill first buffer entry only with header information */\n\t\tbuffer->element[element].addr = skb->data;\n\t\tbuffer->element[element].length = hdr_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->next_element_to_fill++;\n\t\tskb->data += hdr_len;\n\t\tskb->len  -= hdr_len;\n\t\tlarge_send = 1;\n\t}\n\n\tif (offset >= 0) {\n\t\tint element = buf->next_element_to_fill;\n\t\tbuffer->element[element].addr = hdr;\n\t\tbuffer->element[element].length = sizeof(struct qeth_hdr) +\n\t\t\t\t\t\t\thd_len;\n\t\tbuffer->element[element].eflags = SBAL_EFLAGS_FIRST_FRAG;\n\t\tbuf->is_header[element] = 1;\n\t\tbuf->next_element_to_fill++;\n\t}\n\n\t__qeth_fill_buffer(skb, buffer, large_send,\n\t\t(int *)&buf->next_element_to_fill, offset);\n\n\tif (!queue->do_pack) {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfnp\");\n\t\t/* set state to PRIMED -> will be flushed */\n\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\tflush_cnt = 1;\n\t} else {\n\t\tQETH_CARD_TEXT(queue->card, 6, \"fillbfpa\");\n\t\tif (queue->card->options.performance_stats)\n\t\t\tqueue->card->perf_stats.skbs_sent_pack++;\n\t\tif (buf->next_element_to_fill >=\n\t\t\t\tQETH_MAX_BUFFER_ELEMENTS(queue->card)) {\n\t\t\t/*\n\t\t\t * packed buffer if full -> set state PRIMED\n\t\t\t * -> will be flushed\n\t\t\t */\n\t\t\tatomic_set(&buf->state, QETH_QDIO_BUF_PRIMED);\n\t\t\tflush_cnt = 1;\n\t\t}\n\t}\n\treturn flush_cnt;\n}\n",
        "linevul": 0.012055903673171997,
        "sysevr": 0.15773309767246246,
        "devign": 3.906466816694376e-10
    },
    {
        "code": "static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed",
        "vul_func_with_fix": "static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}\n",
        "linevul": 6.78117576171644e-05,
        "sysevr": 0.11938603222370148,
        "devign": 5.544559371628566e-06
    },
    {
        "code": "static ssize_t show_tabletWheel(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\tif (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {\n\t\treturn snprintf(buf, PAGE_SIZE, \"disable\\n\");\n\t} else {\n\t\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t\taiptek->curSetting.wheel);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96",
        "vul_func_with_fix": "static ssize_t show_tabletWheel(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\tif (aiptek->curSetting.wheel == AIPTEK_WHEEL_DISABLE) {\n\t\treturn snprintf(buf, PAGE_SIZE, \"disable\\n\");\n\t} else {\n\t\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t\taiptek->curSetting.wheel);\n\t}\n}\n",
        "linevul": 5.109147969051264e-05,
        "sysevr": 0.11915506422519684,
        "devign": 3.0269918624981074e-06
    },
    {
        "code": "isdn_net_ciscohdlck_disconnected(isdn_net_local *lp)\n{\n\tdel_timer(&lp->cisco_timer);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "isdn_net_ciscohdlck_disconnected(isdn_net_local *lp)\n{\n\tdel_timer(&lp->cisco_timer);\n}\n",
        "linevul": 5.1993501983815804e-05,
        "sysevr": 0.16206617653369904,
        "devign": 0.00022271642228588462
    },
    {
        "code": "static inline void armv8pmu_write_counter(int idx, u32 value)\n{\n\tif (!armv8pmu_counter_valid(idx))\n\t\tpr_err(\"CPU%u writing wrong counter %d\\n\",\n\t\t\tsmp_processor_id(), idx);\n\telse if (idx == ARMV8_IDX_CYCLE_COUNTER)\n\t\tasm volatile(\"msr pmccntr_el0, %0\" :: \"r\" (value));\n\telse if (armv8pmu_select_counter(idx) == idx)\n\t\tasm volatile(\"msr pmxevcntr_el0, %0\" :: \"r\" (value));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071",
        "vul_func_with_fix": "static inline void armv8pmu_write_counter(int idx, u32 value)\n{\n\tif (!armv8pmu_counter_valid(idx))\n\t\tpr_err(\"CPU%u writing wrong counter %d\\n\",\n\t\t\tsmp_processor_id(), idx);\n\telse if (idx == ARMV8_IDX_CYCLE_COUNTER)\n\t\tasm volatile(\"msr pmccntr_el0, %0\" :: \"r\" (value));\n\telse if (armv8pmu_select_counter(idx) == idx)\n\t\tasm volatile(\"msr pmxevcntr_el0, %0\" :: \"r\" (value));\n}\n",
        "linevul": 5.100921043776907e-05,
        "sysevr": 0.11809448152780533,
        "devign": 2.114127276020561e-11
    },
    {
        "code": "static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t\t\t\tchan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&sec, 0, sizeof(sec));\n\t\tif (chan->conn)\n\t\t\tsec.level = chan->conn->hcon->sec_level;\n\t\telse\n\t\t\tsec.level = chan->sec_level;\n\n\t\tif (sk->sk_state == BT_CONNECTED)\n\t\t\tsec.key_size = chan->conn->hcon->enc_key_size;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),\n\t\t\t\t\t\t(u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM\n\t\t\t\t&& sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\n\t\tlen = min_t(unsigned int, len, sizeof(pwr));\n\t\tif (copy_to_user(optval, (char *) &pwr, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (!enable_hs) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->chan_policy, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/792039c73cf176c8e39a6e8beef2c94ff46522ed",
        "vul_func_with_fix": "static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t\t\t\tchan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&sec, 0, sizeof(sec));\n\t\tif (chan->conn)\n\t\t\tsec.level = chan->conn->hcon->sec_level;\n\t\telse\n\t\t\tsec.level = chan->sec_level;\n\n\t\tif (sk->sk_state == BT_CONNECTED)\n\t\t\tsec.key_size = chan->conn->hcon->enc_key_size;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),\n\t\t\t\t\t\t(u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM\n\t\t\t\t&& sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\n\t\tlen = min_t(unsigned int, len, sizeof(pwr));\n\t\tif (copy_to_user(optval, (char *) &pwr, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (!enable_hs) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->chan_policy, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "linevul": 4.995829294784926e-05,
        "sysevr": 0.13864333927631378,
        "devign": 0.5990321040153503
    },
    {
        "code": "ar6000_txPwr_rx(void *devt, u8 txPwr)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arTxPwr = txPwr;\n    wake_up(&arEvent);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "ar6000_txPwr_rx(void *devt, u8 txPwr)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arTxPwr = txPwr;\n    wake_up(&arEvent);\n}\n",
        "linevul": 4.6532142732758075e-05,
        "sysevr": 0.16083239018917084,
        "devign": 9.029166303520242e-12
    },
    {
        "code": "static int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    ((val & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON))\n\t\t\treturn 1;\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed",
        "vul_func_with_fix": "static int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    ((val & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON))\n\t\t\treturn 1;\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n",
        "linevul": 5.116218380862847e-05,
        "sysevr": 0.2632429599761963,
        "devign": 1.199336278724024e-19
    },
    {
        "code": "brcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\n\t\t      struct cfg80211_ibss_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size = 0;\n\ts32 err = 0;\n\ts32 wsec = 0;\n\ts32 bcnprd;\n\tu16 chanspec;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (params->ssid)\n\t\tbrcmf_dbg(CONN, \"SSID: %s\\n\", params->ssid);\n\telse {\n\t\tbrcmf_dbg(CONN, \"SSID: NULL, Not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (params->bssid)\n\t\tbrcmf_dbg(CONN, \"BSSID: %pM\\n\", params->bssid);\n\telse\n\t\tbrcmf_dbg(CONN, \"No BSSID specified\\n\");\n\n\tif (params->chandef.chan)\n\t\tbrcmf_dbg(CONN, \"channel: %d\\n\",\n\t\t\t  params->chandef.chan->center_freq);\n\telse\n\t\tbrcmf_dbg(CONN, \"no channel specified\\n\");\n\n\tif (params->channel_fixed)\n\t\tbrcmf_dbg(CONN, \"fixed channel required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no fixed channel required\\n\");\n\n\tif (params->ie && params->ie_len)\n\t\tbrcmf_dbg(CONN, \"ie len: %d\\n\", params->ie_len);\n\telse\n\t\tbrcmf_dbg(CONN, \"no ie specified\\n\");\n\n\tif (params->beacon_interval)\n\t\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\",\n\t\t\t  params->beacon_interval);\n\telse\n\t\tbrcmf_dbg(CONN, \"no beacon interval specified\\n\");\n\n\tif (params->basic_rates)\n\t\tbrcmf_dbg(CONN, \"basic rates: %08X\\n\", params->basic_rates);\n\telse\n\t\tbrcmf_dbg(CONN, \"no basic rates specified\\n\");\n\n\tif (params->privacy)\n\t\tbrcmf_dbg(CONN, \"privacy required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no privacy required\\n\");\n\n\t/* Configure Privacy for starter */\n\tif (params->privacy)\n\t\twsec |= WEP_ENABLED;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"wsec failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure Beacon Interval for starter */\n\tif (params->beacon_interval)\n\t\tbcnprd = params->beacon_interval;\n\telse\n\t\tbcnprd = 100;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_BCNPRD failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure required join parameter */\n\tmemset(&join_params, 0, sizeof(struct brcmf_join_params));\n\n\t/* SSID */\n\tssid_len = min_t(u32, params->ssid_len, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(join_params.ssid_le.SSID, params->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\t/* BSSID */\n\tif (params->bssid) {\n\t\tmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\n\t\tjoin_params_size += BRCMF_ASSOC_PARAMS_FIXED_SIZE;\n\t\tmemcpy(profile->bssid, params->bssid, ETH_ALEN);\n\t} else {\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\t\teth_zero_addr(profile->bssid);\n\t}\n\n\t/* Channel */\n\tif (params->chandef.chan) {\n\t\tu32 target_channel;\n\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(\n\t\t\t\tparams->chandef.chan->center_freq);\n\t\tif (params->channel_fixed) {\n\t\t\t/* adding chanspec */\n\t\t\tchanspec = chandef_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       &params->chandef);\n\t\t\tjoin_params.params_le.chanspec_list[0] =\n\t\t\t\tcpu_to_le16(chanspec);\n\t\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\t\tjoin_params_size += sizeof(join_params.params_le);\n\t\t}\n\n\t\t/* set channel for starter */\n\t\ttarget_channel = cfg->channel;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,\n\t\t\t\t\t    target_channel);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_CHANNEL failed (%d)\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tcfg->channel = 0;\n\n\tcfg->ibss_starter = false;\n\n\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_SSID failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ded89912156b1a47d940a0c954c43afbabd0c42c",
        "vul_func_with_fix": "brcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\n\t\t      struct cfg80211_ibss_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size = 0;\n\ts32 err = 0;\n\ts32 wsec = 0;\n\ts32 bcnprd;\n\tu16 chanspec;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (params->ssid)\n\t\tbrcmf_dbg(CONN, \"SSID: %s\\n\", params->ssid);\n\telse {\n\t\tbrcmf_dbg(CONN, \"SSID: NULL, Not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (params->bssid)\n\t\tbrcmf_dbg(CONN, \"BSSID: %pM\\n\", params->bssid);\n\telse\n\t\tbrcmf_dbg(CONN, \"No BSSID specified\\n\");\n\n\tif (params->chandef.chan)\n\t\tbrcmf_dbg(CONN, \"channel: %d\\n\",\n\t\t\t  params->chandef.chan->center_freq);\n\telse\n\t\tbrcmf_dbg(CONN, \"no channel specified\\n\");\n\n\tif (params->channel_fixed)\n\t\tbrcmf_dbg(CONN, \"fixed channel required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no fixed channel required\\n\");\n\n\tif (params->ie && params->ie_len)\n\t\tbrcmf_dbg(CONN, \"ie len: %d\\n\", params->ie_len);\n\telse\n\t\tbrcmf_dbg(CONN, \"no ie specified\\n\");\n\n\tif (params->beacon_interval)\n\t\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\",\n\t\t\t  params->beacon_interval);\n\telse\n\t\tbrcmf_dbg(CONN, \"no beacon interval specified\\n\");\n\n\tif (params->basic_rates)\n\t\tbrcmf_dbg(CONN, \"basic rates: %08X\\n\", params->basic_rates);\n\telse\n\t\tbrcmf_dbg(CONN, \"no basic rates specified\\n\");\n\n\tif (params->privacy)\n\t\tbrcmf_dbg(CONN, \"privacy required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no privacy required\\n\");\n\n\t/* Configure Privacy for starter */\n\tif (params->privacy)\n\t\twsec |= WEP_ENABLED;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbrcmf_err(\"wsec failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure Beacon Interval for starter */\n\tif (params->beacon_interval)\n\t\tbcnprd = params->beacon_interval;\n\telse\n\t\tbcnprd = 100;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_BCNPRD failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure required join parameter */\n\tmemset(&join_params, 0, sizeof(struct brcmf_join_params));\n\n\t/* SSID */\n\tssid_len = min_t(u32, params->ssid_len, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(join_params.ssid_le.SSID, params->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\t/* BSSID */\n\tif (params->bssid) {\n\t\tmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\n\t\tjoin_params_size += BRCMF_ASSOC_PARAMS_FIXED_SIZE;\n\t\tmemcpy(profile->bssid, params->bssid, ETH_ALEN);\n\t} else {\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\t\teth_zero_addr(profile->bssid);\n\t}\n\n\t/* Channel */\n\tif (params->chandef.chan) {\n\t\tu32 target_channel;\n\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(\n\t\t\t\tparams->chandef.chan->center_freq);\n\t\tif (params->channel_fixed) {\n\t\t\t/* adding chanspec */\n\t\t\tchanspec = chandef_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       &params->chandef);\n\t\t\tjoin_params.params_le.chanspec_list[0] =\n\t\t\t\tcpu_to_le16(chanspec);\n\t\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\t\tjoin_params_size += sizeof(join_params.params_le);\n\t\t}\n\n\t\t/* set channel for starter */\n\t\ttarget_channel = cfg->channel;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,\n\t\t\t\t\t    target_channel);\n\t\tif (err) {\n\t\t\tbrcmf_err(\"WLC_SET_CHANNEL failed (%d)\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tcfg->channel = 0;\n\n\tcfg->ibss_starter = false;\n\n\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err) {\n\t\tbrcmf_err(\"WLC_SET_SSID failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n",
        "linevul": 5.7729881518753245e-05,
        "sysevr": 0.17796194553375244,
        "devign": 1.244591977633679e-29
    },
    {
        "code": "int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,\n\t\t     struct xdr_buf *xdr,\n\t\t     struct svc_rdma_req_map *vec,\n\t\t     bool write_chunk_present)\n {\n\tint sge_no;\n\tu32 sge_bytes;\n\tu32 page_bytes;\n\tu32 page_off;\n\tint page_no;\n\tif (xdr->len !=\n\t    (xdr->head[0].iov_len + xdr->page_len + xdr->tail[0].iov_len)) {\n\t\tpr_err(\"svcrdma: %s: XDR buffer length error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n \n\t/* Skip the first sge, this is for the RPCRDMA header */\n\tsge_no = 1;\n \n\t/* Head SGE */\n\tvec->sge[sge_no].iov_base = xdr->head[0].iov_base;\n\tvec->sge[sge_no].iov_len = xdr->head[0].iov_len;\n\tsge_no++;\n\t/* pages SGE */\n\tpage_no = 0;\n\tpage_bytes = xdr->page_len;\n\tpage_off = xdr->page_base;\n\twhile (page_bytes) {\n\t\tvec->sge[sge_no].iov_base =\n\t\t\tpage_address(xdr->pages[page_no]) + page_off;\n\t\tsge_bytes = min_t(u32, page_bytes, (PAGE_SIZE - page_off));\n\t\tpage_bytes -= sge_bytes;\n\t\tvec->sge[sge_no].iov_len = sge_bytes;\n\t\tsge_no++;\n\t\tpage_no++;\n\t\tpage_off = 0; /* reset for next time through loop */\n \t}\n \n\t/* Tail SGE */\n\tif (xdr->tail[0].iov_len) {\n\t\tunsigned char *base = xdr->tail[0].iov_base;\n\t\tsize_t len = xdr->tail[0].iov_len;\n\t\tu32 xdr_pad = xdr_padsize(xdr->page_len);\n \n\t\tif (write_chunk_present && xdr_pad) {\n\t\t\tbase += xdr_pad;\n\t\t\tlen -= xdr_pad;\n\t\t}\n \n\t\tif (len) {\n\t\t\tvec->sge[sge_no].iov_base = base;\n\t\t\tvec->sge[sge_no].iov_len = len;\n\t\t\tsge_no++;\n \t\t}\n\t}\n \n\tdprintk(\"svcrdma: %s: sge_no %d page_no %d \"\n\t\t\"page_base %u page_len %u head_len %zu tail_len %zu\\n\",\n\t\t__func__, sge_no, page_no, xdr->page_base, xdr->page_len,\n\t\txdr->head[0].iov_len, xdr->tail[0].iov_len);\n \n\tvec->count = sge_no;\n\treturn 0;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,\n//flaw_line_below:\n\t\t     struct xdr_buf *xdr,\n//flaw_line_below:\n\t\t     struct svc_rdma_req_map *vec,\n//flaw_line_below:\n\t\t     bool write_chunk_present)\n//fix_flaw_line_below:\n///* Returns length of transport header, in bytes.\n//fix_flaw_line_below:\n// */\n//fix_flaw_line_below:\n//static unsigned int svc_rdma_reply_hdr_len(__be32 *rdma_resp)\n {\n//flaw_line_below:\n\tint sge_no;\n//flaw_line_below:\n\tu32 sge_bytes;\n//flaw_line_below:\n\tu32 page_bytes;\n//flaw_line_below:\n\tu32 page_off;\n//flaw_line_below:\n\tint page_no;\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (xdr->len !=\n//flaw_line_below:\n\t    (xdr->head[0].iov_len + xdr->page_len + xdr->tail[0].iov_len)) {\n//flaw_line_below:\n\t\tpr_err(\"svcrdma: %s: XDR buffer length error\\n\", __func__);\n//flaw_line_below:\n\t\treturn -EIO;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\tunsigned int nsegs;\n//fix_flaw_line_below:\n//\t__be32 *p;\n \n//flaw_line_below:\n\t/* Skip the first sge, this is for the RPCRDMA header */\n//flaw_line_below:\n\tsge_no = 1;\n//fix_flaw_line_below:\n//\tp = rdma_resp;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* RPC-over-RDMA V1 replies never have a Read list. */\n//fix_flaw_line_below:\n//\tp += rpcrdma_fixed_maxsz + 1;\n \n//flaw_line_below:\n\t/* Head SGE */\n//flaw_line_below:\n\tvec->sge[sge_no].iov_base = xdr->head[0].iov_base;\n//flaw_line_below:\n\tvec->sge[sge_no].iov_len = xdr->head[0].iov_len;\n//flaw_line_below:\n\tsge_no++;\n//flaw_line_below:\n\n//flaw_line_below:\n\t/* pages SGE */\n//flaw_line_below:\n\tpage_no = 0;\n//flaw_line_below:\n\tpage_bytes = xdr->page_len;\n//flaw_line_below:\n\tpage_off = xdr->page_base;\n//flaw_line_below:\n\twhile (page_bytes) {\n//flaw_line_below:\n\t\tvec->sge[sge_no].iov_base =\n//flaw_line_below:\n\t\t\tpage_address(xdr->pages[page_no]) + page_off;\n//flaw_line_below:\n\t\tsge_bytes = min_t(u32, page_bytes, (PAGE_SIZE - page_off));\n//flaw_line_below:\n\t\tpage_bytes -= sge_bytes;\n//flaw_line_below:\n\t\tvec->sge[sge_no].iov_len = sge_bytes;\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tsge_no++;\n//flaw_line_below:\n\t\tpage_no++;\n//flaw_line_below:\n\t\tpage_off = 0; /* reset for next time through loop */\n//fix_flaw_line_below:\n//\t/* Skip Write list. */\n//fix_flaw_line_below:\n//\twhile (*p++ != xdr_zero) {\n//fix_flaw_line_below:\n//\t\tnsegs = be32_to_cpup(p++);\n//fix_flaw_line_below:\n//\t\tp += nsegs * rpcrdma_segment_maxsz;\n \t}\n \n//flaw_line_below:\n\t/* Tail SGE */\n//flaw_line_below:\n\tif (xdr->tail[0].iov_len) {\n//flaw_line_below:\n\t\tunsigned char *base = xdr->tail[0].iov_base;\n//flaw_line_below:\n\t\tsize_t len = xdr->tail[0].iov_len;\n//flaw_line_below:\n\t\tu32 xdr_pad = xdr_padsize(xdr->page_len);\n//fix_flaw_line_below:\n//\t/* Skip Reply chunk. */\n//fix_flaw_line_below:\n//\tif (*p++ != xdr_zero) {\n//fix_flaw_line_below:\n//\t\tnsegs = be32_to_cpup(p++);\n//fix_flaw_line_below:\n//\t\tp += nsegs * rpcrdma_segment_maxsz;\n//fix_flaw_line_below:\n//\t}\n \n//flaw_line_below:\n\t\tif (write_chunk_present && xdr_pad) {\n//flaw_line_below:\n\t\t\tbase += xdr_pad;\n//flaw_line_below:\n\t\t\tlen -= xdr_pad;\n//flaw_line_below:\n\t\t}\n//fix_flaw_line_below:\n//\treturn (unsigned long)p - (unsigned long)rdma_resp;\n//fix_flaw_line_below:\n//}\n \n//flaw_line_below:\n\t\tif (len) {\n//flaw_line_below:\n\t\t\tvec->sge[sge_no].iov_base = base;\n//flaw_line_below:\n\t\t\tvec->sge[sge_no].iov_len = len;\n//flaw_line_below:\n\t\t\tsge_no++;\n//fix_flaw_line_below:\n///* One Write chunk is copied from Call transport header to Reply\n//fix_flaw_line_below:\n// * transport header. Each segment's length field is updated to\n//fix_flaw_line_below:\n// * reflect number of bytes consumed in the segment.\n//fix_flaw_line_below:\n// *\n//fix_flaw_line_below:\n// * Returns number of segments in this chunk.\n//fix_flaw_line_below:\n// */\n//fix_flaw_line_below:\n//static unsigned int xdr_encode_write_chunk(__be32 *dst, __be32 *src,\n//fix_flaw_line_below:\n//\t\t\t\t\t   unsigned int remaining)\n//fix_flaw_line_below:\n//{\n//fix_flaw_line_below:\n//\tunsigned int i, nsegs;\n//fix_flaw_line_below:\n//\tu32 seg_len;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* Write list discriminator */\n//fix_flaw_line_below:\n//\t*dst++ = *src++;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* number of segments in this chunk */\n//fix_flaw_line_below:\n//\tnsegs = be32_to_cpup(src);\n//fix_flaw_line_below:\n//\t*dst++ = *src++;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tfor (i = nsegs; i; i--) {\n//fix_flaw_line_below:\n//\t\t/* segment's RDMA handle */\n//fix_flaw_line_below:\n//\t\t*dst++ = *src++;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* bytes returned in this segment */\n//fix_flaw_line_below:\n//\t\tseg_len = be32_to_cpu(*src);\n//fix_flaw_line_below:\n//\t\tif (remaining >= seg_len) {\n//fix_flaw_line_below:\n//\t\t\t/* entire segment was consumed */\n//fix_flaw_line_below:\n//\t\t\t*dst = *src;\n//fix_flaw_line_below:\n//\t\t\tremaining -= seg_len;\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\t/* segment only partly filled */\n//fix_flaw_line_below:\n//\t\t\t*dst = cpu_to_be32(remaining);\n//fix_flaw_line_below:\n//\t\t\tremaining = 0;\n \t\t}\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\t\tdst++; src++;\n \n//flaw_line_below:\n\tdprintk(\"svcrdma: %s: sge_no %d page_no %d \"\n//flaw_line_below:\n\t\t\"page_base %u page_len %u head_len %zu tail_len %zu\\n\",\n//flaw_line_below:\n\t\t__func__, sge_no, page_no, xdr->page_base, xdr->page_len,\n//flaw_line_below:\n\t\txdr->head[0].iov_len, xdr->tail[0].iov_len);\n//fix_flaw_line_below:\n//\t\t/* segment's RDMA offset */\n//fix_flaw_line_below:\n//\t\t*dst++ = *src++;\n//fix_flaw_line_below:\n//\t\t*dst++ = *src++;\n//fix_flaw_line_below:\n//\t}\n \n//flaw_line_below:\n\tvec->count = sge_no;\n//flaw_line_below:\n\treturn 0;\n//fix_flaw_line_below:\n//\treturn nsegs;\n }\n",
        "linevul": 0.04418783262372017,
        "sysevr": 0.2500654458999634,
        "devign": 0.989465594291687
    },
    {
        "code": "static int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\n\t\t\t unsigned long tstamp, u32 preferred, u32 valid)\n{\n\tstruct ifa_cacheinfo ci;\n\n\tci.cstamp = cstamp_delta(cstamp);\n\tci.tstamp = cstamp_delta(tstamp);\n\tci.ifa_prefered = preferred;\n\tci.ifa_valid = valid;\n\n\treturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77751427a1ff25b27d47a4c36b12c3c8667855ac",
        "vul_func_with_fix": "static int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\n\t\t\t unsigned long tstamp, u32 preferred, u32 valid)\n{\n\tstruct ifa_cacheinfo ci;\n\n\tci.cstamp = cstamp_delta(cstamp);\n\tci.tstamp = cstamp_delta(tstamp);\n\tci.ifa_prefered = preferred;\n\tci.ifa_valid = valid;\n\n\treturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\n}\n",
        "linevul": 4.721032382803969e-05,
        "sysevr": 0.13658060133457184,
        "devign": 1.6050778397427214e-28
    },
    {
        "code": "static void intel_pmu_drain_pebs_nhm(struct pt_regs *iregs)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct debug_store *ds = cpuc->ds;\n\tstruct pebs_record_nhm *at, *top;\n\tstruct perf_event *event = NULL;\n\tu64 status = 0;\n\tint bit, n;\n\n\tif (!x86_pmu.pebs_active)\n\t\treturn;\n\n\tat  = (struct pebs_record_nhm *)(unsigned long)ds->pebs_buffer_base;\n\ttop = (struct pebs_record_nhm *)(unsigned long)ds->pebs_index;\n\n\tds->pebs_index = ds->pebs_buffer_base;\n\n\tn = top - at;\n\tif (n <= 0)\n\t\treturn;\n\n\t/*\n\t * Should not happen, we program the threshold at 1 and do not\n\t * set a reset value.\n\t */\n\tWARN_ON_ONCE(n > MAX_PEBS_EVENTS);\n\n\tfor ( ; at < top; at++) {\n\t\tfor_each_set_bit(bit, (unsigned long *)&at->status, MAX_PEBS_EVENTS) {\n\t\t\tevent = cpuc->events[bit];\n\t\t\tif (!test_bit(bit, cpuc->active_mask))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(!event);\n\n\t\t\tif (!event->attr.precise_ip)\n\t\t\t\tcontinue;\n\n\t\t\tif (__test_and_set_bit(bit, (unsigned long *)&status))\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!event || bit >= MAX_PEBS_EVENTS)\n\t\t\tcontinue;\n\n\t\t__intel_pmu_pebs_event(event, iregs, at);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void intel_pmu_drain_pebs_nhm(struct pt_regs *iregs)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tstruct debug_store *ds = cpuc->ds;\n\tstruct pebs_record_nhm *at, *top;\n\tstruct perf_event *event = NULL;\n\tu64 status = 0;\n\tint bit, n;\n\n\tif (!x86_pmu.pebs_active)\n\t\treturn;\n\n\tat  = (struct pebs_record_nhm *)(unsigned long)ds->pebs_buffer_base;\n\ttop = (struct pebs_record_nhm *)(unsigned long)ds->pebs_index;\n\n\tds->pebs_index = ds->pebs_buffer_base;\n\n\tn = top - at;\n\tif (n <= 0)\n\t\treturn;\n\n\t/*\n\t * Should not happen, we program the threshold at 1 and do not\n\t * set a reset value.\n\t */\n\tWARN_ON_ONCE(n > MAX_PEBS_EVENTS);\n\n\tfor ( ; at < top; at++) {\n\t\tfor_each_set_bit(bit, (unsigned long *)&at->status, MAX_PEBS_EVENTS) {\n\t\t\tevent = cpuc->events[bit];\n\t\t\tif (!test_bit(bit, cpuc->active_mask))\n\t\t\t\tcontinue;\n\n\t\t\tWARN_ON_ONCE(!event);\n\n\t\t\tif (!event->attr.precise_ip)\n\t\t\t\tcontinue;\n\n\t\t\tif (__test_and_set_bit(bit, (unsigned long *)&status))\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!event || bit >= MAX_PEBS_EVENTS)\n\t\t\tcontinue;\n\n\t\t__intel_pmu_pebs_event(event, iregs, at);\n\t}\n}\n",
        "linevul": 5.4754651500843465e-05,
        "sysevr": 0.1414695680141449,
        "devign": 9.672239578543702e-16
    },
    {
        "code": "xfs_setfilesize_trans_alloc(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tioend->io_append_trans = tp;\n\n\t/*\n\t * We may pass freeze protection with a transaction.  So tell lockdep\n\t * we released it.\n\t */\n\t__sb_writers_release(ioend->io_inode->i_sb, SB_FREEZE_FS);\n\t/*\n\t * We hand off the transaction to the completion thread now, so\n\t * clear the flag here.\n\t */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04197b341f23b908193308b8d63d17ff23232598",
        "vul_func_with_fix": "xfs_setfilesize_trans_alloc(\n\tstruct xfs_ioend\t*ioend)\n{\n\tstruct xfs_mount\t*mp = XFS_I(ioend->io_inode)->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\n\tif (error)\n\t\treturn error;\n\n\tioend->io_append_trans = tp;\n\n\t/*\n\t * We may pass freeze protection with a transaction.  So tell lockdep\n\t * we released it.\n\t */\n\t__sb_writers_release(ioend->io_inode->i_sb, SB_FREEZE_FS);\n\t/*\n\t * We hand off the transaction to the completion thread now, so\n\t * clear the flag here.\n\t */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\treturn 0;\n}\n",
        "linevul": 9.572203271090984e-05,
        "sysevr": 0.1888672262430191,
        "devign": 0.7004168629646301
    },
    {
        "code": "static void nci_add_new_target(struct nci_dev *ndev,\n\t\t\t       struct nci_rf_discover_ntf *ntf)\n{\n\tstruct nfc_target *target;\n\tint i, rc;\n\n\tfor (i = 0; i < ndev->n_targets; i++) {\n\t\ttarget = &ndev->targets[i];\n\t\tif (target->logical_idx == ntf->rf_discovery_id) {\n\t\t\t/* This target already exists, add the new protocol */\n\t\t\tnci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t\t     ntf->rf_tech_and_mode,\n\t\t\t\t\t     &ntf->rf_tech_specific_params);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* This is a new target, check if we've enough room */\n\tif (ndev->n_targets == NCI_MAX_DISCOVERED_TARGETS) {\n\t\tpr_debug(\"not enough room, ignoring new target...\\n\");\n\t\treturn;\n\t}\n\n\ttarget = &ndev->targets[ndev->n_targets];\n\n\trc = nci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t  ntf->rf_tech_and_mode,\n\t\t\t\t  &ntf->rf_tech_specific_params);\n\tif (!rc) {\n\t\ttarget->logical_idx = ntf->rf_discovery_id;\n\t\tndev->n_targets++;\n\n\t\tpr_debug(\"logical idx %d, n_targets %d\\n\", target->logical_idx,\n\t\t\t ndev->n_targets);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
        "vul_func_with_fix": "static void nci_add_new_target(struct nci_dev *ndev,\n\t\t\t       struct nci_rf_discover_ntf *ntf)\n{\n\tstruct nfc_target *target;\n\tint i, rc;\n\n\tfor (i = 0; i < ndev->n_targets; i++) {\n\t\ttarget = &ndev->targets[i];\n\t\tif (target->logical_idx == ntf->rf_discovery_id) {\n\t\t\t/* This target already exists, add the new protocol */\n\t\t\tnci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t\t     ntf->rf_tech_and_mode,\n\t\t\t\t\t     &ntf->rf_tech_specific_params);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* This is a new target, check if we've enough room */\n\tif (ndev->n_targets == NCI_MAX_DISCOVERED_TARGETS) {\n\t\tpr_debug(\"not enough room, ignoring new target...\\n\");\n\t\treturn;\n\t}\n\n\ttarget = &ndev->targets[ndev->n_targets];\n\n\trc = nci_add_new_protocol(ndev, target, ntf->rf_protocol,\n\t\t\t\t  ntf->rf_tech_and_mode,\n\t\t\t\t  &ntf->rf_tech_specific_params);\n\tif (!rc) {\n\t\ttarget->logical_idx = ntf->rf_discovery_id;\n\t\tndev->n_targets++;\n\n\t\tpr_debug(\"logical idx %d, n_targets %d\\n\", target->logical_idx,\n\t\t\t ndev->n_targets);\n\t}\n}\n",
        "linevul": 5.725378287024796e-05,
        "sysevr": 0.14263570308685303,
        "devign": 8.031521513119071e-15
    },
    {
        "code": "static void ndisc_send_skb(struct sk_buff *skb,\n\t\t\t   const struct in6_addr *daddr,\n\t\t\t   const struct in6_addr *saddr)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk = net->ipv6.ndisc_sk;\n\tstruct inet6_dev *idev;\n\tint err;\n\tstruct icmp6hdr *icmp6h = icmp6_hdr(skb);\n\tu8 type;\n\n\ttype = icmp6h->icmp6_type;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\ticmpv6_flow_init(sk, &fl6, type, saddr, daddr, skb->dev->ifindex);\n\t\tdst = icmp6_dst_alloc(skb->dev, &fl6);\n\t\tif (IS_ERR(dst)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_dst_set(skb, dst);\n\t}\n\n\ticmp6h->icmp6_cksum = csum_ipv6_magic(saddr, daddr, skb->len,\n\t\t\t\t\t      IPPROTO_ICMPV6,\n\t\t\t\t\t      csum_partial(icmp6h,\n\t\t\t\t\t\t\t   skb->len, 0));\n\n\tip6_nd_hdr(skb, saddr, daddr, inet6_sk(sk)->hop_limit, skb->len);\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, dst->dev,\n\t\t      dst_output);\n\tif (!err) {\n\t\tICMP6MSGOUT_INC_STATS(net, idev, type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\trcu_read_unlock();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fd99094de2b83d1d4c8457f2c83483b2828e75a",
        "vul_func_with_fix": "static void ndisc_send_skb(struct sk_buff *skb,\n\t\t\t   const struct in6_addr *daddr,\n\t\t\t   const struct in6_addr *saddr)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk = net->ipv6.ndisc_sk;\n\tstruct inet6_dev *idev;\n\tint err;\n\tstruct icmp6hdr *icmp6h = icmp6_hdr(skb);\n\tu8 type;\n\n\ttype = icmp6h->icmp6_type;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\ticmpv6_flow_init(sk, &fl6, type, saddr, daddr, skb->dev->ifindex);\n\t\tdst = icmp6_dst_alloc(skb->dev, &fl6);\n\t\tif (IS_ERR(dst)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_dst_set(skb, dst);\n\t}\n\n\ticmp6h->icmp6_cksum = csum_ipv6_magic(saddr, daddr, skb->len,\n\t\t\t\t\t      IPPROTO_ICMPV6,\n\t\t\t\t\t      csum_partial(icmp6h,\n\t\t\t\t\t\t\t   skb->len, 0));\n\n\tip6_nd_hdr(skb, saddr, daddr, inet6_sk(sk)->hop_limit, skb->len);\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL, dst->dev,\n\t\t      dst_output);\n\tif (!err) {\n\t\tICMP6MSGOUT_INC_STATS(net, idev, type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\trcu_read_unlock();\n}\n",
        "linevul": 0.00025712556089274585,
        "sysevr": 0.2077210545539856,
        "devign": 2.8855235222871655e-25
    },
    {
        "code": "static void sctp_generate_t5_shutdown_guard_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *)data;\n\tsctp_generate_timeout_event(asoc,\n\t\t\t\t    SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD);\n\n} /* sctp_generate_t5_shutdown_guard_event() */\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e",
        "vul_func_with_fix": "static void sctp_generate_t5_shutdown_guard_event(unsigned long data)\n{\n\tstruct sctp_association *asoc = (struct sctp_association *)data;\n\tsctp_generate_timeout_event(asoc,\n\t\t\t\t    SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD);\n\n} /* sctp_generate_t5_shutdown_guard_event() */\n",
        "linevul": 5.032557237427682e-05,
        "sysevr": 0.13331635296344757,
        "devign": 5.513042713317651e-12
    },
    {
        "code": "static int get_filter(void __user *arg, struct sock_filter **p)\n{\n\tstruct sock_fprog uprog;\n\tstruct sock_filter *code = NULL;\n\tint len;\n\n\tif (copy_from_user(&uprog, arg, sizeof(uprog)))\n\t\treturn -EFAULT;\n\n\tif (!uprog.len) {\n\t\t*p = NULL;\n\t\treturn 0;\n\t}\n\n\tlen = uprog.len * sizeof(struct sock_filter);\n\tcode = memdup_user(uprog.filter, len);\n\tif (IS_ERR(code))\n\t\treturn PTR_ERR(code);\n\n\t*p = code;\n\treturn uprog.len;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "vul_func_with_fix": "static int get_filter(void __user *arg, struct sock_filter **p)\n{\n\tstruct sock_fprog uprog;\n\tstruct sock_filter *code = NULL;\n\tint len;\n\n\tif (copy_from_user(&uprog, arg, sizeof(uprog)))\n\t\treturn -EFAULT;\n\n\tif (!uprog.len) {\n\t\t*p = NULL;\n\t\treturn 0;\n\t}\n\n\tlen = uprog.len * sizeof(struct sock_filter);\n\tcode = memdup_user(uprog.filter, len);\n\tif (IS_ERR(code))\n\t\treturn PTR_ERR(code);\n\n\t*p = code;\n\treturn uprog.len;\n}\n",
        "linevul": 5.103012881590985e-05,
        "sysevr": 0.13118863105773926,
        "devign": 0.5599123239517212
    },
    {
        "code": "int crypto_hash_walk_first_compat(struct hash_desc *hdesc,\n\t\t\t\t  struct crypto_hash_walk *walk,\n\t\t\t\t  struct scatterlist *sg, unsigned int len)\n{\n\twalk->total = len;\n\n\tif (!walk->total)\n\t\treturn 0;\n\n\twalk->alignmask = crypto_hash_alignmask(hdesc->tfm);\n\twalk->sg = sg;\n\twalk->flags = hdesc->flags;\n\n\treturn hash_walk_new_entry(walk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "vul_func_with_fix": "int crypto_hash_walk_first_compat(struct hash_desc *hdesc,\n\t\t\t\t  struct crypto_hash_walk *walk,\n\t\t\t\t  struct scatterlist *sg, unsigned int len)\n{\n\twalk->total = len;\n\n\tif (!walk->total)\n\t\treturn 0;\n\n\twalk->alignmask = crypto_hash_alignmask(hdesc->tfm);\n\twalk->sg = sg;\n\twalk->flags = hdesc->flags;\n\n\treturn hash_walk_new_entry(walk);\n}\n",
        "linevul": 5.2248182328185067e-05,
        "sysevr": 0.1639195680618286,
        "devign": 4.649592397691309e-26
    },
    {
        "code": "static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_net_xmit %d\\n\", skb->len);\n\n\t/* Drop packet if interface is not attached */\n\tif (!tun->tfile)\n\t\tgoto drop;\n\n\t/* Drop if the filter does not like it.\n\t * This is a noop if the filter is disabled.\n\t * Filter can be enabled only for the TAP devices. */\n\tif (!check_filter(&tun->txflt, skb))\n\t\tgoto drop;\n\n\tif (tun->socket.sk->sk_filter &&\n\t    sk_filter(tun->socket.sk, skb))\n\t\tgoto drop;\n\n\tif (skb_queue_len(&tun->socket.sk->sk_receive_queue) >= dev->tx_queue_len) {\n\t\tif (!(tun->flags & TUN_ONE_QUEUE)) {\n\t\t\t/* Normal queueing mode. */\n\t\t\t/* Packet scheduler handles dropping of further packets. */\n\t\t\tnetif_stop_queue(dev);\n\n\t\t\t/* We won't see all dropped packets individually, so overrun\n\t\t\t * error is more appropriate. */\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t} else {\n\t\t\t/* Single queue mode.\n\t\t\t * Driver handles dropping of all packets itself. */\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t/* Orphan the skb - required as we might hang on to it\n\t * for indefinite time. */\n\tskb_orphan(skb);\n\n\t/* Enqueue packet */\n\tskb_queue_tail(&tun->socket.sk->sk_receive_queue, skb);\n\n\t/* Notify and wake up reader process */\n\tif (tun->flags & TUN_FASYNC)\n\t\tkill_fasync(&tun->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible_poll(&tun->wq.wait, POLLIN |\n\t\t\t\t   POLLRDNORM | POLLRDBAND);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_net_xmit %d\\n\", skb->len);\n\n\t/* Drop packet if interface is not attached */\n\tif (!tun->tfile)\n\t\tgoto drop;\n\n\t/* Drop if the filter does not like it.\n\t * This is a noop if the filter is disabled.\n\t * Filter can be enabled only for the TAP devices. */\n\tif (!check_filter(&tun->txflt, skb))\n\t\tgoto drop;\n\n\tif (tun->socket.sk->sk_filter &&\n\t    sk_filter(tun->socket.sk, skb))\n\t\tgoto drop;\n\n\tif (skb_queue_len(&tun->socket.sk->sk_receive_queue) >= dev->tx_queue_len) {\n\t\tif (!(tun->flags & TUN_ONE_QUEUE)) {\n\t\t\t/* Normal queueing mode. */\n\t\t\t/* Packet scheduler handles dropping of further packets. */\n\t\t\tnetif_stop_queue(dev);\n\n\t\t\t/* We won't see all dropped packets individually, so overrun\n\t\t\t * error is more appropriate. */\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t} else {\n\t\t\t/* Single queue mode.\n\t\t\t * Driver handles dropping of all packets itself. */\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t/* Orphan the skb - required as we might hang on to it\n\t * for indefinite time. */\n\tskb_orphan(skb);\n\n\t/* Enqueue packet */\n\tskb_queue_tail(&tun->socket.sk->sk_receive_queue, skb);\n\n\t/* Notify and wake up reader process */\n\tif (tun->flags & TUN_FASYNC)\n\t\tkill_fasync(&tun->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible_poll(&tun->wq.wait, POLLIN |\n\t\t\t\t   POLLRDNORM | POLLRDBAND);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n",
        "linevul": 6.271235906751826e-05,
        "sysevr": 0.15083223581314087,
        "devign": 2.914873092265913e-26
    },
    {
        "code": "int cifs_lock(struct file *file, int cmd, struct file_lock *flock)\n{\n\tint rc, xid;\n\tint lock = 0, unlock = 0;\n\tbool wait_flag = false;\n\tbool posix_lck = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\t__u16 netfid;\n\t__u32 type;\n\n\trc = -EACCES;\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld\\n\",\n\t\t cmd, flock->fl_flags, flock->fl_type,\n\t\t flock->fl_start, flock->fl_end);\n\n\tcfile = (struct cifsFileInfo *)file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tcifs_read_flock(flock, &type, &lock, &unlock, &wait_flag,\n\t\t\ttcon->ses->server);\n\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\tnetfid = cfile->fid.netfid;\n\tcinode = CIFS_I(file_inode(file));\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\tposix_lck = true;\n\t/*\n\t * BB add code here to normalize offset and length to account for\n\t * negative length which we can not accept over the wire.\n\t */\n\tif (IS_GETLK(cmd)) {\n\t\trc = cifs_getlk(file, flock, type, wait_flag, posix_lck, xid);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (!lock && !unlock) {\n\t\t/*\n\t\t * if no lock or unlock then nothing to do since we do not\n\t\t * know what it is\n\t\t */\n\t\tfree_xid(xid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = cifs_setlk(file, flock, type, wait_flag, posix_lck, lock, unlock,\n\t\t\txid);\n\tfree_xid(xid);\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f",
        "vul_func_with_fix": "int cifs_lock(struct file *file, int cmd, struct file_lock *flock)\n{\n\tint rc, xid;\n\tint lock = 0, unlock = 0;\n\tbool wait_flag = false;\n\tbool posix_lck = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\t__u16 netfid;\n\t__u32 type;\n\n\trc = -EACCES;\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld end: %lld\\n\",\n\t\t cmd, flock->fl_flags, flock->fl_type,\n\t\t flock->fl_start, flock->fl_end);\n\n\tcfile = (struct cifsFileInfo *)file->private_data;\n\ttcon = tlink_tcon(cfile->tlink);\n\n\tcifs_read_flock(flock, &type, &lock, &unlock, &wait_flag,\n\t\t\ttcon->ses->server);\n\n\tcifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\n\tnetfid = cfile->fid.netfid;\n\tcinode = CIFS_I(file_inode(file));\n\n\tif (cap_unix(tcon->ses) &&\n\t    (CIFS_UNIX_FCNTL_CAP & le64_to_cpu(tcon->fsUnixInfo.Capability)) &&\n\t    ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL) == 0))\n\t\tposix_lck = true;\n\t/*\n\t * BB add code here to normalize offset and length to account for\n\t * negative length which we can not accept over the wire.\n\t */\n\tif (IS_GETLK(cmd)) {\n\t\trc = cifs_getlk(file, flock, type, wait_flag, posix_lck, xid);\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (!lock && !unlock) {\n\t\t/*\n\t\t * if no lock or unlock then nothing to do since we do not\n\t\t * know what it is\n\t\t */\n\t\tfree_xid(xid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = cifs_setlk(file, flock, type, wait_flag, posix_lck, lock, unlock,\n\t\t\txid);\n\tfree_xid(xid);\n\treturn rc;\n}\n",
        "linevul": 5.257134762359783e-05,
        "sysevr": 0.19858048856258392,
        "devign": 0.0
    },
    {
        "code": "nfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n",
        "linevul": 0.00010560888040345162,
        "sysevr": 0.1591322422027588,
        "devign": 4.961854278145994e-12
    },
    {
        "code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "vul_func_with_fix": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n//fix_flaw_line_below:\n//\tq->fq = NULL;\n \treturn -ENOMEM;\n }\n",
        "linevul": 0.00022304602316580713,
        "sysevr": 0.143358513712883,
        "devign": 7.220913175842725e-06
    },
    {
        "code": "void vbg_put_gdev(struct vbg_dev *gdev)\n{\n\tWARN_ON(gdev != vbg_gdev);\n\tmutex_unlock(&vbg_gdev_mutex);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bd23a7269834dc7c1f93e83535d16ebc44b75eba",
        "vul_func_with_fix": "void vbg_put_gdev(struct vbg_dev *gdev)\n{\n\tWARN_ON(gdev != vbg_gdev);\n\tmutex_unlock(&vbg_gdev_mutex);\n}\n",
        "linevul": 4.831527257920243e-05,
        "sysevr": 0.1584126055240631,
        "devign": 0.41281020641326904
    },
    {
        "code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n \n \tif (is_guest_mode(vcpu))\n \t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n \t\tif (is_long_mode(vcpu))\n \t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n \t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f",
        "vul_func_with_fix": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n \n \tif (is_guest_mode(vcpu))\n \t\tmsr_bitmap = vmx_msr_bitmap_nested;\n//flaw_line_below:\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n//fix_flaw_line_below:\n//\telse if (cpu_has_secondary_exec_ctrls() &&\n//fix_flaw_line_below:\n//\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n//fix_flaw_line_below:\n//\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n \t\tif (is_long_mode(vcpu))\n \t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n \t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}\n",
        "linevul": 0.9994595646858215,
        "sysevr": 0.12833505868911743,
        "devign": 0.9999785423278809
    },
    {
        "code": "static void __bio_unmap_user(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tint i;\n\n\t/*\n\t * make sure we dirty pages we wrote to\n\t */\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tif (bio_data_dir(bio) == READ)\n\t\t\tset_page_dirty_lock(bvec->bv_page);\n\n\t\tput_page(bvec->bv_page);\n\t}\n\n\tbio_put(bio);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467",
        "vul_func_with_fix": "static void __bio_unmap_user(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tint i;\n\n\t/*\n\t * make sure we dirty pages we wrote to\n\t */\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tif (bio_data_dir(bio) == READ)\n\t\t\tset_page_dirty_lock(bvec->bv_page);\n\n\t\tput_page(bvec->bv_page);\n\t}\n\n\tbio_put(bio);\n}\n",
        "linevul": 6.949168164283037e-05,
        "sysevr": 0.12766467034816742,
        "devign": 4.4820411858381703e-05
    },
    {
        "code": "static bool efx_port_dummy_op_poll(struct efx_nic *efx)\n{\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "vul_func_with_fix": "static bool efx_port_dummy_op_poll(struct efx_nic *efx)\n{\n\treturn false;\n}\n",
        "linevul": 4.647058813134208e-05,
        "sysevr": 0.13162264227867126,
        "devign": 1.364385132651691e-10
    },
    {
        "code": " static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n {\n\tint ret;\n \t/* MBIM backwards compatible function? */\n \tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n \t\treturn -ENODEV;\n\n\t/* The NCM data altsetting is fixed, so we hard-coded it.\n \t * Additionally, generic NCM devices are assumed to accept arbitrarily\n \t * placed NDP.\n \t */\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\t/*\n\t * We should get an event when network connection is \"connected\" or\n\t * \"disconnected\". Set network connection in \"disconnected\" state\n\t * (carrier is OFF) during attach, so the IP network stack does not\n\t * start IPv6 negotiation and more.\n\t */\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4d06dd537f95683aba3651098ae288b7cbff8274",
        "vul_func_with_fix": " static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n {\n//flaw_line_below:\n\tint ret;\n//flaw_line_below:\n\n \t/* MBIM backwards compatible function? */\n \tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n \t\treturn -ENODEV;\n\n\t/* The NCM data altsetting is fixed, so we hard-coded it.\n \t * Additionally, generic NCM devices are assumed to accept arbitrarily\n \t * placed NDP.\n \t */\n//flaw_line_below:\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n//flaw_line_below:\n\n//flaw_line_below:\n\t/*\n//flaw_line_below:\n\t * We should get an event when network connection is \"connected\" or\n//flaw_line_below:\n\t * \"disconnected\". Set network connection in \"disconnected\" state\n//flaw_line_below:\n\t * (carrier is OFF) during attach, so the IP network stack does not\n//flaw_line_below:\n\t * start IPv6 negotiation and more.\n//flaw_line_below:\n\t */\n//flaw_line_below:\n\tusbnet_link_change(dev, 0, 0);\n//flaw_line_below:\n\treturn ret;\n//fix_flaw_line_below:\n//\treturn cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n }\n",
        "linevul": 0.9980539083480835,
        "sysevr": 0.1454557180404663,
        "devign": 0.00839424692094326
    },
    {
        "code": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23",
        "vul_func_with_fix": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}\n",
        "linevul": 5.684077041223645e-05,
        "sysevr": 0.12376842647790909,
        "devign": 1.195131549280859e-09
    },
    {
        "code": "static int unix_seq_show(struct seq_file *seq, void *v)\n{\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"Num       RefCount Protocol Flags    Type St \"\n\t\t\t \"Inode Path\\n\");\n\telse {\n\t\tstruct sock *s = v;\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tunix_state_lock(s);\n\n\t\tseq_printf(seq, \"%pK: %08X %08X %08X %04X %02X %5lu\",\n\t\t\ts,\n\t\t\tatomic_read(&s->sk_refcnt),\n\t\t\t0,\n\t\t\ts->sk_state == TCP_LISTEN ? __SO_ACCEPTCON : 0,\n\t\t\ts->sk_type,\n\t\t\ts->sk_socket ?\n\t\t\t(s->sk_state == TCP_ESTABLISHED ? SS_CONNECTED : SS_UNCONNECTED) :\n\t\t\t(s->sk_state == TCP_ESTABLISHED ? SS_CONNECTING : SS_DISCONNECTING),\n\t\t\tsock_i_ino(s));\n\n\t\tif (u->addr) {\n\t\t\tint i, len;\n\t\t\tseq_putc(seq, ' ');\n\n\t\t\ti = 0;\n\t\t\tlen = u->addr->len - sizeof(short);\n\t\t\tif (!UNIX_ABSTRACT(s))\n\t\t\t\tlen--;\n\t\t\telse {\n\t\t\t\tseq_putc(seq, '@');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor ( ; i < len; i++)\n\t\t\t\tseq_putc(seq, u->addr->name->sun_path[i]);\n\t\t}\n\t\tunix_state_unlock(s);\n\t\tseq_putc(seq, '\\n');\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "vul_func_with_fix": "static int unix_seq_show(struct seq_file *seq, void *v)\n{\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"Num       RefCount Protocol Flags    Type St \"\n\t\t\t \"Inode Path\\n\");\n\telse {\n\t\tstruct sock *s = v;\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tunix_state_lock(s);\n\n\t\tseq_printf(seq, \"%pK: %08X %08X %08X %04X %02X %5lu\",\n\t\t\ts,\n\t\t\tatomic_read(&s->sk_refcnt),\n\t\t\t0,\n\t\t\ts->sk_state == TCP_LISTEN ? __SO_ACCEPTCON : 0,\n\t\t\ts->sk_type,\n\t\t\ts->sk_socket ?\n\t\t\t(s->sk_state == TCP_ESTABLISHED ? SS_CONNECTED : SS_UNCONNECTED) :\n\t\t\t(s->sk_state == TCP_ESTABLISHED ? SS_CONNECTING : SS_DISCONNECTING),\n\t\t\tsock_i_ino(s));\n\n\t\tif (u->addr) {\n\t\t\tint i, len;\n\t\t\tseq_putc(seq, ' ');\n\n\t\t\ti = 0;\n\t\t\tlen = u->addr->len - sizeof(short);\n\t\t\tif (!UNIX_ABSTRACT(s))\n\t\t\t\tlen--;\n\t\t\telse {\n\t\t\t\tseq_putc(seq, '@');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor ( ; i < len; i++)\n\t\t\t\tseq_putc(seq, u->addr->name->sun_path[i]);\n\t\t}\n\t\tunix_state_unlock(s);\n\t\tseq_putc(seq, '\\n');\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 0.00011714387801475823,
        "sysevr": 0.12449321895837784,
        "devign": 5.566625376684658e-23
    },
    {
        "code": "int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\n\t\t\t    struct mem_access *ma, int expected,\n\t\t\t    unsigned long address)\n{\n\tu_int rm;\n\tint ret, index;\n\n\t/*\n\t * XXX: We can't handle mixed 16/32-bit instructions yet\n\t */\n\tif (instruction_size(instruction) != 2)\n\t\treturn -EINVAL;\n\n\tindex = (instruction>>8)&15;\t/* 0x0F00 */\n\trm = regs->regs[index];\n\n\t/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n \t */\n \tif (!expected) {\n \t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n \t\t\t      regs, address);\n \t}\n \n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t/* rts */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs->pc = regs->pr;\n\t\t}\n\t\telse if ((instruction&0x00FF)==0x0023) {\n\t\t\t/* braf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs->pc += rm + 4;\n\t\t}\n\t\telse if ((instruction&0x00FF)==0x0003) {\n\t\t\t/* bsrf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs->pr = regs->pc + 4;\n\t\t\t\tregs->pc += rm + 4;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1000: /* mov.l Rm,@(disp,Rn) */\n\t\tgoto simple;\n\n\tcase 0x2000: /* mov.[bwl] to memory, possibly with pre-decrement */\n\t\tgoto simple;\n\n\tcase 0x4000:\n\t\tif ((instruction&0x00FF)==0x002B) {\n\t\t\t/* jmp @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs->pc = rm;\n\t\t}\n\t\telse if ((instruction&0x00FF)==0x000B) {\n\t\t\t/* jsr @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs->pr = regs->pc + 4;\n\t\t\t\tregs->pc = rm;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x5000: /* mov.l @(disp,Rm),Rn */\n\t\tgoto simple;\n\n\tcase 0x6000: /* mov.[bwl] from memory, possibly with post-increment */\n\t\tgoto simple;\n\n\tcase 0x8000: /* bf lab, bf/s lab, bt lab, bt/s lab */\n\t\tswitch (instruction&0x0F00) {\n\t\tcase 0x0100: /* mov.w R0,@(disp,Rm) */\n\t\t\tgoto simple;\n\t\tcase 0x0500: /* mov.w @(disp,Rm),R0 */\n\t\t\tgoto simple;\n\t\tcase 0x0B00: /* bf   lab - no delayslot*/\n\t\t\tbreak;\n\t\tcase 0x0F00: /* bf/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs->sr & 0x00000001) != 0)\n\t\t\t\t\tregs->pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs->pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0900: /* bt   lab - no delayslot */\n\t\t\tbreak;\n\t\tcase 0x0D00: /* bt/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs->sr & 0x00000001) == 0)\n\t\t\t\t\tregs->pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs->pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0xA000: /* bra label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0)\n\t\t\tregs->pc += SH_PC_12BIT_OFFSET(instruction);\n\t\tbreak;\n\n\tcase 0xB000: /* bsr label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0) {\n\t\t\tregs->pr = regs->pc + 4;\n\t\t\tregs->pc += SH_PC_12BIT_OFFSET(instruction);\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n\n\t/* handle non-delay-slot instruction */\n simple:\n\tret = handle_unaligned_ins(instruction, regs, ma);\n\tif (ret==0)\n\t\tregs->pc += instruction_size(instruction);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\n\t\t\t    struct mem_access *ma, int expected,\n\t\t\t    unsigned long address)\n{\n\tu_int rm;\n\tint ret, index;\n\n\t/*\n\t * XXX: We can't handle mixed 16/32-bit instructions yet\n\t */\n\tif (instruction_size(instruction) != 2)\n\t\treturn -EINVAL;\n\n\tindex = (instruction>>8)&15;\t/* 0x0F00 */\n\trm = regs->regs[index];\n\n\t/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n \t */\n \tif (!expected) {\n \t\tunaligned_fixups_notify(current, instruction, regs);\n//flaw_line_below:\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n//fix_flaw_line_below:\n//\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n \t\t\t      regs, address);\n \t}\n \n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t/* rts */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs->pc = regs->pr;\n\t\t}\n\t\telse if ((instruction&0x00FF)==0x0023) {\n\t\t\t/* braf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs->pc += rm + 4;\n\t\t}\n\t\telse if ((instruction&0x00FF)==0x0003) {\n\t\t\t/* bsrf @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs->pr = regs->pc + 4;\n\t\t\t\tregs->pc += rm + 4;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x1000: /* mov.l Rm,@(disp,Rn) */\n\t\tgoto simple;\n\n\tcase 0x2000: /* mov.[bwl] to memory, possibly with pre-decrement */\n\t\tgoto simple;\n\n\tcase 0x4000:\n\t\tif ((instruction&0x00FF)==0x002B) {\n\t\t\t/* jmp @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)\n\t\t\t\tregs->pc = rm;\n\t\t}\n\t\telse if ((instruction&0x00FF)==0x000B) {\n\t\t\t/* jsr @Rm */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n\t\t\t\tregs->pr = regs->pc + 4;\n\t\t\t\tregs->pc = rm;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* mov.[bwl] to/from memory via r0+rn */\n\t\t\tgoto simple;\n\t\t}\n\t\tbreak;\n\n\tcase 0x5000: /* mov.l @(disp,Rm),Rn */\n\t\tgoto simple;\n\n\tcase 0x6000: /* mov.[bwl] from memory, possibly with post-increment */\n\t\tgoto simple;\n\n\tcase 0x8000: /* bf lab, bf/s lab, bt lab, bt/s lab */\n\t\tswitch (instruction&0x0F00) {\n\t\tcase 0x0100: /* mov.w R0,@(disp,Rm) */\n\t\t\tgoto simple;\n\t\tcase 0x0500: /* mov.w @(disp,Rm),R0 */\n\t\t\tgoto simple;\n\t\tcase 0x0B00: /* bf   lab - no delayslot*/\n\t\t\tbreak;\n\t\tcase 0x0F00: /* bf/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs->sr & 0x00000001) != 0)\n\t\t\t\t\tregs->pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs->pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x0900: /* bt   lab - no delayslot */\n\t\t\tbreak;\n\t\tcase 0x0D00: /* bt/s lab */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0) {\n#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)\n\t\t\t\tif ((regs->sr & 0x00000001) == 0)\n\t\t\t\t\tregs->pc += 4; /* next after slot */\n\t\t\t\telse\n#endif\n\t\t\t\t\tregs->pc += SH_PC_8BIT_OFFSET(instruction);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0xA000: /* bra label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0)\n\t\t\tregs->pc += SH_PC_12BIT_OFFSET(instruction);\n\t\tbreak;\n\n\tcase 0xB000: /* bsr label */\n\t\tret = handle_delayslot(regs, instruction, ma);\n\t\tif (ret==0) {\n\t\t\tregs->pr = regs->pc + 4;\n\t\t\tregs->pc += SH_PC_12BIT_OFFSET(instruction);\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n\n\t/* handle non-delay-slot instruction */\n simple:\n\tret = handle_unaligned_ins(instruction, regs, ma);\n\tif (ret==0)\n\t\tregs->pc += instruction_size(instruction);\n\treturn ret;\n}\n",
        "linevul": 0.8780696988105774,
        "sysevr": 0.20813487470149994,
        "devign": 0.9934578537940979
    },
    {
        "code": "char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno == GDB_ORIG_AX) {\n\t\tmemcpy(mem, &regs->orig_ax, sizeof(regs->orig_ax));\n\t\treturn \"orig_ax\";\n\t}\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn NULL;\n\n\tif (dbg_reg_def[regno].offset != -1)\n\t\tmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\n\t\t       dbg_reg_def[regno].size);\n\n#ifdef CONFIG_X86_32\n\tswitch (regno) {\n\tcase GDB_SS:\n\t\tif (!user_mode_vm(regs))\n\t\t\t*(unsigned long *)mem = __KERNEL_DS;\n\t\tbreak;\n\tcase GDB_SP:\n\t\tif (!user_mode_vm(regs))\n\t\t\t*(unsigned long *)mem = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase GDB_GS:\n\tcase GDB_FS:\n\t\t*(unsigned long *)mem = 0xFFFF;\n\t\tbreak;\n\t}\n#endif\n\treturn dbg_reg_def[regno].name;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)\n{\n\tif (regno == GDB_ORIG_AX) {\n\t\tmemcpy(mem, &regs->orig_ax, sizeof(regs->orig_ax));\n\t\treturn \"orig_ax\";\n\t}\n\tif (regno >= DBG_MAX_REG_NUM || regno < 0)\n\t\treturn NULL;\n\n\tif (dbg_reg_def[regno].offset != -1)\n\t\tmemcpy(mem, (void *)regs + dbg_reg_def[regno].offset,\n\t\t       dbg_reg_def[regno].size);\n\n#ifdef CONFIG_X86_32\n\tswitch (regno) {\n\tcase GDB_SS:\n\t\tif (!user_mode_vm(regs))\n\t\t\t*(unsigned long *)mem = __KERNEL_DS;\n\t\tbreak;\n\tcase GDB_SP:\n\t\tif (!user_mode_vm(regs))\n\t\t\t*(unsigned long *)mem = kernel_stack_pointer(regs);\n\t\tbreak;\n\tcase GDB_GS:\n\tcase GDB_FS:\n\t\t*(unsigned long *)mem = 0xFFFF;\n\t\tbreak;\n\t}\n#endif\n\treturn dbg_reg_def[regno].name;\n}\n",
        "linevul": 6.379287515301257e-05,
        "sysevr": 0.18731486797332764,
        "devign": 7.89996556775739e-26
    },
    {
        "code": "state_show(struct md_rdev *rdev, char *page)\n{\n\tchar *sep = \"\";\n\tsize_t len = 0;\n\tunsigned long flags = ACCESS_ONCE(rdev->flags);\n\n\tif (test_bit(Faulty, &flags) ||\n\t    rdev->badblocks.unacked_exist) {\n\t\tlen+= sprintf(page+len, \"%sfaulty\",sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(In_sync, &flags)) {\n\t\tlen += sprintf(page+len, \"%sin_sync\",sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(WriteMostly, &flags)) {\n\t\tlen += sprintf(page+len, \"%swrite_mostly\",sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(Blocked, &flags) ||\n\t    (rdev->badblocks.unacked_exist\n\t     && !test_bit(Faulty, &flags))) {\n\t\tlen += sprintf(page+len, \"%sblocked\", sep);\n\t\tsep = \",\";\n\t}\n\tif (!test_bit(Faulty, &flags) &&\n\t    !test_bit(In_sync, &flags)) {\n\t\tlen += sprintf(page+len, \"%sspare\", sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(WriteErrorSeen, &flags)) {\n\t\tlen += sprintf(page+len, \"%swrite_error\", sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(WantReplacement, &flags)) {\n\t\tlen += sprintf(page+len, \"%swant_replacement\", sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(Replacement, &flags)) {\n\t\tlen += sprintf(page+len, \"%sreplacement\", sep);\n\t\tsep = \",\";\n\t}\n\n\treturn len+sprintf(page+len, \"\\n\");\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "state_show(struct md_rdev *rdev, char *page)\n{\n\tchar *sep = \"\";\n\tsize_t len = 0;\n\tunsigned long flags = ACCESS_ONCE(rdev->flags);\n\n\tif (test_bit(Faulty, &flags) ||\n\t    rdev->badblocks.unacked_exist) {\n\t\tlen+= sprintf(page+len, \"%sfaulty\",sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(In_sync, &flags)) {\n\t\tlen += sprintf(page+len, \"%sin_sync\",sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(WriteMostly, &flags)) {\n\t\tlen += sprintf(page+len, \"%swrite_mostly\",sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(Blocked, &flags) ||\n\t    (rdev->badblocks.unacked_exist\n\t     && !test_bit(Faulty, &flags))) {\n\t\tlen += sprintf(page+len, \"%sblocked\", sep);\n\t\tsep = \",\";\n\t}\n\tif (!test_bit(Faulty, &flags) &&\n\t    !test_bit(In_sync, &flags)) {\n\t\tlen += sprintf(page+len, \"%sspare\", sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(WriteErrorSeen, &flags)) {\n\t\tlen += sprintf(page+len, \"%swrite_error\", sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(WantReplacement, &flags)) {\n\t\tlen += sprintf(page+len, \"%swant_replacement\", sep);\n\t\tsep = \",\";\n\t}\n\tif (test_bit(Replacement, &flags)) {\n\t\tlen += sprintf(page+len, \"%sreplacement\", sep);\n\t\tsep = \",\";\n\t}\n\n\treturn len+sprintf(page+len, \"\\n\");\n}\n",
        "linevul": 0.00010062990622827783,
        "sysevr": 0.21562425792217255,
        "devign": 1.1805327194507674e-38
    },
    {
        "code": "SYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\n\treturn old;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9e146d8eb3b9ecae5086d373b50fa0c1f3e7f0f",
        "vul_func_with_fix": "SYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\n\treturn old;\n}\n",
        "linevul": 4.9394377128919587e-05,
        "sysevr": 0.150712251663208,
        "devign": 1.7612348528928123e-05
    },
    {
        "code": "static inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\treturn -1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\treturn -1;\n}\n",
        "linevul": 6.0645732446573675e-05,
        "sysevr": 0.12186583131551743,
        "devign": 0.0007098449277691543
    },
    {
        "code": "void hid_output_report(struct hid_report *report, __u8 *data)\n{\n\tunsigned n;\n\n\tif (report->id > 0)\n\t\t*data++ = report->id;\n\n\tmemset(data, 0, ((report->size - 1) >> 3) + 1);\n\tfor (n = 0; n < report->maxfield; n++)\n\t\thid_output_field(report->device, report->field[n], data);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f",
        "vul_func_with_fix": "void hid_output_report(struct hid_report *report, __u8 *data)\n{\n\tunsigned n;\n\n\tif (report->id > 0)\n\t\t*data++ = report->id;\n\n\tmemset(data, 0, ((report->size - 1) >> 3) + 1);\n\tfor (n = 0; n < report->maxfield; n++)\n\t\thid_output_field(report->device, report->field[n], data);\n}\n",
        "linevul": 0.00041471520671620965,
        "sysevr": 0.17949983477592468,
        "devign": 9.466618095432984e-16
    },
    {
        "code": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n {\n\tif (state->state == mode)\n \t\treturn;\n \t/* NB! List reordering - see the reclaim code for why.  */\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n \t\t\tlist_move(&state->open_states, &state->owner->so_states);\n \t\telse\n \t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n \t}\n\tstate->state = mode;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n//fix_flaw_line_below:\n//nfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n {\n//flaw_line_below:\n\tif (state->state == mode)\n//fix_flaw_line_below:\n//\tif (state->state == fmode)\n \t\treturn;\n \t/* NB! List reordering - see the reclaim code for why.  */\n//flaw_line_below:\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n//flaw_line_below:\n\t\tif (mode & FMODE_WRITE)\n//fix_flaw_line_below:\n//\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n//fix_flaw_line_below:\n//\t\tif (fmode & FMODE_WRITE)\n \t\t\tlist_move(&state->open_states, &state->owner->so_states);\n \t\telse\n \t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n \t}\n//flaw_line_below:\n\tstate->state = mode;\n//fix_flaw_line_below:\n//\tstate->state = fmode;\n }\n",
        "linevul": 0.9988899827003479,
        "sysevr": 0.21517394483089447,
        "devign": 0.9981282353401184
    },
    {
        "code": "static int __init packet_init(void)\n{\n\tint rc = proto_register(&packet_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&packet_family_ops);\n\tregister_pernet_subsys(&packet_net_ops);\n\tregister_netdevice_notifier(&packet_netdev_notifier);\nout:\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6",
        "vul_func_with_fix": "static int __init packet_init(void)\n{\n\tint rc = proto_register(&packet_proto, 0);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&packet_family_ops);\n\tregister_pernet_subsys(&packet_net_ops);\n\tregister_netdevice_notifier(&packet_netdev_notifier);\nout:\n\treturn rc;\n}\n",
        "linevul": 0.00012163766223238781,
        "sysevr": 0.12405944615602493,
        "devign": 0.6070898175239563
    },
    {
        "code": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}\n",
        "linevul": 5.539634730666876e-05,
        "sysevr": 0.13829673826694489,
        "devign": 0.9635775089263916
    },
    {
        "code": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n \tint ret;\n \n\tspin_lock_irqsave(&dev->lock, flags);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n \t\tgoto fail;\n \t}\n \n\tspin_unlock_irqrestore(&dev->lock, flags);\n \n \t/*\n \t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n \treturn 0;\n \n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n \treturn ret < 0 ? ret : -EIO;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "vul_func_with_fix": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n//flaw_line_below:\n\tunsigned long flags;\n \tint ret;\n \n//flaw_line_below:\n\tspin_lock_irqsave(&dev->lock, flags);\n//fix_flaw_line_below:\n//\tmutex_lock(&dev->lock);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n \t\tgoto fail;\n \t}\n \n//flaw_line_below:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n//fix_flaw_line_below:\n//\tmutex_unlock(&dev->lock);\n \n \t/*\n \t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n \treturn 0;\n \n fail:\n//flaw_line_below:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n//fix_flaw_line_below:\n//\tmutex_unlock(&dev->lock);\n \treturn ret < 0 ? ret : -EIO;\n }\n",
        "linevul": 0.9995899796485901,
        "sysevr": 0.13725540041923523,
        "devign": 0.004923052620142698
    },
    {
        "code": "xfs_vm_readpages(\n\tstruct file\t\t*unused,\n\tstruct address_space\t*mapping,\n\tstruct list_head\t*pages,\n\tunsigned\t\tnr_pages)\n{\n\ttrace_xfs_vm_readpages(mapping->host, nr_pages);\n\treturn mpage_readpages(mapping, pages, nr_pages, xfs_get_blocks);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04197b341f23b908193308b8d63d17ff23232598",
        "vul_func_with_fix": "xfs_vm_readpages(\n\tstruct file\t\t*unused,\n\tstruct address_space\t*mapping,\n\tstruct list_head\t*pages,\n\tunsigned\t\tnr_pages)\n{\n\ttrace_xfs_vm_readpages(mapping->host, nr_pages);\n\treturn mpage_readpages(mapping, pages, nr_pages, xfs_get_blocks);\n}\n",
        "linevul": 0.0023616361431777477,
        "sysevr": 0.1565273404121399,
        "devign": 6.692485499115719e-08
    },
    {
        "code": "void ndisc_cleanup(void)\n{\n#ifdef CONFIG_SYSCTL\n\tneigh_sysctl_unregister(&nd_tbl.parms);\n#endif\n\tneigh_table_clear(NEIGH_ND_TABLE, &nd_tbl);\n\tunregister_pernet_subsys(&ndisc_net_ops);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fd99094de2b83d1d4c8457f2c83483b2828e75a",
        "vul_func_with_fix": "void ndisc_cleanup(void)\n{\n#ifdef CONFIG_SYSCTL\n\tneigh_sysctl_unregister(&nd_tbl.parms);\n#endif\n\tneigh_table_clear(NEIGH_ND_TABLE, &nd_tbl);\n\tunregister_pernet_subsys(&ndisc_net_ops);\n}\n",
        "linevul": 6.620816566282883e-05,
        "sysevr": 0.15830755233764648,
        "devign": 2.4809406085068986e-08
    },
    {
        "code": "long kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\treturn -EINVAL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "long kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\treturn -EINVAL;\n}\n",
        "linevul": 5.689727913704701e-05,
        "sysevr": 0.1828416883945465,
        "devign": 0.0019180504605174065
    },
    {
        "code": " __be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n {\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n \tstruct in6_addr buf[2];\n \tstruct in6_addr *addrs;\n \tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n \tif (!addrs)\n \t\treturn 0;\n \n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n \treturn htonl(id);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702",
        "vul_func_with_fix": " __be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n {\n//flaw_line_below:\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n \tstruct in6_addr buf[2];\n \tstruct in6_addr *addrs;\n \tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n \tif (!addrs)\n \t\treturn 0;\n \n//flaw_line_below:\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n//flaw_line_below:\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n//flaw_line_below:\n\n//flaw_line_below:\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n//flaw_line_below:\n\t\t\t\t &addrs[1], &addrs[0]);\n//fix_flaw_line_below:\n//\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n \treturn htonl(id);\n }\n",
        "linevul": 0.9994188547134399,
        "sysevr": 0.14444369077682495,
        "devign": 0.9999052286148071
    },
    {
        "code": "static int btrfs_readpage_end_io_hook(struct page *page, u64 start, u64 end,\n\t\t\t       struct extent_state *state, int mirror)\n{\n\tsize_t offset = start - ((u64)page->index << PAGE_CACHE_SHIFT);\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tchar *kaddr;\n\tu64 private = ~(u32)0;\n\tint ret;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu32 csum = ~(u32)0;\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tgoto good;\n\t}\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\tgoto good;\n\n\tif (root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID &&\n\t    test_range_bit(io_tree, start, end, EXTENT_NODATASUM, 1, NULL)) {\n\t\tclear_extent_bits(io_tree, start, end, EXTENT_NODATASUM,\n\t\t\t\t  GFP_NOFS);\n\t\treturn 0;\n\t}\n\n\tif (state && state->start == start) {\n\t\tprivate = state->private;\n\t\tret = 0;\n\t} else {\n\t\tret = get_state_private(io_tree, start, &private);\n\t}\n\tkaddr = kmap_atomic(page);\n\tif (ret)\n\t\tgoto zeroit;\n\n\tcsum = btrfs_csum_data(root, kaddr + offset, csum,  end - start + 1);\n\tbtrfs_csum_final(csum, (char *)&csum);\n\tif (csum != private)\n\t\tgoto zeroit;\n\n\tkunmap_atomic(kaddr);\ngood:\n\treturn 0;\n\nzeroit:\n\tprintk_ratelimited(KERN_INFO \"btrfs csum failed ino %llu off %llu csum %u \"\n\t\t       \"private %llu\\n\",\n\t\t       (unsigned long long)btrfs_ino(page->mapping->host),\n\t\t       (unsigned long long)start, csum,\n\t\t       (unsigned long long)private);\n\tmemset(kaddr + offset, 1, end - start + 1);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tif (private == 0)\n\t\treturn 0;\n\treturn -EIO;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "vul_func_with_fix": "static int btrfs_readpage_end_io_hook(struct page *page, u64 start, u64 end,\n\t\t\t       struct extent_state *state, int mirror)\n{\n\tsize_t offset = start - ((u64)page->index << PAGE_CACHE_SHIFT);\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tchar *kaddr;\n\tu64 private = ~(u32)0;\n\tint ret;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu32 csum = ~(u32)0;\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\tgoto good;\n\t}\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\tgoto good;\n\n\tif (root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID &&\n\t    test_range_bit(io_tree, start, end, EXTENT_NODATASUM, 1, NULL)) {\n\t\tclear_extent_bits(io_tree, start, end, EXTENT_NODATASUM,\n\t\t\t\t  GFP_NOFS);\n\t\treturn 0;\n\t}\n\n\tif (state && state->start == start) {\n\t\tprivate = state->private;\n\t\tret = 0;\n\t} else {\n\t\tret = get_state_private(io_tree, start, &private);\n\t}\n\tkaddr = kmap_atomic(page);\n\tif (ret)\n\t\tgoto zeroit;\n\n\tcsum = btrfs_csum_data(root, kaddr + offset, csum,  end - start + 1);\n\tbtrfs_csum_final(csum, (char *)&csum);\n\tif (csum != private)\n\t\tgoto zeroit;\n\n\tkunmap_atomic(kaddr);\ngood:\n\treturn 0;\n\nzeroit:\n\tprintk_ratelimited(KERN_INFO \"btrfs csum failed ino %llu off %llu csum %u \"\n\t\t       \"private %llu\\n\",\n\t\t       (unsigned long long)btrfs_ino(page->mapping->host),\n\t\t       (unsigned long long)start, csum,\n\t\t       (unsigned long long)private);\n\tmemset(kaddr + offset, 1, end - start + 1);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\tif (private == 0)\n\t\treturn 0;\n\treturn -EIO;\n}\n",
        "linevul": 0.0005225745844654739,
        "sysevr": 0.20333503186702728,
        "devign": 1.816197112662977e-22
    },
    {
        "code": "static inline unsigned long my_zero_pfn(unsigned long addr)\n{\n\treturn zero_pfn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static inline unsigned long my_zero_pfn(unsigned long addr)\n{\n\treturn zero_pfn;\n}\n",
        "linevul": 0.00013611237227451056,
        "sysevr": 0.12700766324996948,
        "devign": 1.3428685941008212e-10
    },
    {
        "code": "static struct dentry *__d_instantiate_unique(struct dentry *entry,\n\t\t\t\t\t     struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint len = entry->d_name.len;\n\tconst char *name = entry->d_name.name;\n\tunsigned int hash = entry->d_name.hash;\n\n\tif (!inode) {\n\t\t__d_instantiate(entry, NULL);\n\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\t/*\n\t\t * Don't need alias->d_lock here, because aliases with\n\t\t * d_parent == entry->d_parent are not subject to name or\n\t\t * parent changes, because the parent inode i_mutex is held.\n\t\t */\n\t\tif (alias->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (alias->d_parent != entry->d_parent)\n\t\t\tcontinue;\n\t\tif (alias->d_name.len != len)\n\t\t\tcontinue;\n\t\tif (dentry_cmp(alias, name, len))\n\t\t\tcontinue;\n\t\t__dget(alias);\n\t\treturn alias;\n\t}\n\n\t__d_instantiate(entry, inode);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cde93be45a8a90d8c264c776fab63487b5038a65",
        "vul_func_with_fix": "static struct dentry *__d_instantiate_unique(struct dentry *entry,\n\t\t\t\t\t     struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint len = entry->d_name.len;\n\tconst char *name = entry->d_name.name;\n\tunsigned int hash = entry->d_name.hash;\n\n\tif (!inode) {\n\t\t__d_instantiate(entry, NULL);\n\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\t/*\n\t\t * Don't need alias->d_lock here, because aliases with\n\t\t * d_parent == entry->d_parent are not subject to name or\n\t\t * parent changes, because the parent inode i_mutex is held.\n\t\t */\n\t\tif (alias->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (alias->d_parent != entry->d_parent)\n\t\t\tcontinue;\n\t\tif (alias->d_name.len != len)\n\t\t\tcontinue;\n\t\tif (dentry_cmp(alias, name, len))\n\t\t\tcontinue;\n\t\t__dget(alias);\n\t\treturn alias;\n\t}\n\n\t__d_instantiate(entry, inode);\n\treturn NULL;\n}\n",
        "linevul": 7.072582229739055e-05,
        "sysevr": 0.12245257943868637,
        "devign": 1.9108102686932193e-12
    },
    {
        "code": "static int snd_seq_ioctl_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\tif ((receiver = snd_seq_client_use_ptr(subs->dest.client)) == NULL)\n\t\tgoto __end;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tif ((dport = snd_seq_port_use_ptr(receiver, subs->dest.port)) == NULL)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\tresult = snd_seq_port_disconnect(client, sender, sport, receiver, dport, subs);\n\tif (! result) /* broadcast announce */\n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
        "vul_func_with_fix": "static int snd_seq_ioctl_unsubscribe_port(struct snd_seq_client *client,\n\t\t\t\t\t  void *arg)\n{\n\tstruct snd_seq_port_subscribe *subs = arg;\n\tint result = -ENXIO;\n\tstruct snd_seq_client *receiver = NULL, *sender = NULL;\n\tstruct snd_seq_client_port *sport = NULL, *dport = NULL;\n\n\tif ((receiver = snd_seq_client_use_ptr(subs->dest.client)) == NULL)\n\t\tgoto __end;\n\tif ((sender = snd_seq_client_use_ptr(subs->sender.client)) == NULL)\n\t\tgoto __end;\n\tif ((sport = snd_seq_port_use_ptr(sender, subs->sender.port)) == NULL)\n\t\tgoto __end;\n\tif ((dport = snd_seq_port_use_ptr(receiver, subs->dest.port)) == NULL)\n\t\tgoto __end;\n\n\tresult = check_subscription_permission(client, sport, dport, subs);\n\tif (result < 0)\n\t\tgoto __end;\n\n\tresult = snd_seq_port_disconnect(client, sender, sport, receiver, dport, subs);\n\tif (! result) /* broadcast announce */\n\t\tsnd_seq_client_notify_subscription(SNDRV_SEQ_ADDRESS_SUBSCRIBERS, 0,\n\t\t\t\t\t\t   subs, SNDRV_SEQ_EVENT_PORT_UNSUBSCRIBED);\n      __end:\n      \tif (sport)\n\t\tsnd_seq_port_unlock(sport);\n\tif (dport)\n\t\tsnd_seq_port_unlock(dport);\n\tif (sender)\n\t\tsnd_seq_client_unlock(sender);\n\tif (receiver)\n\t\tsnd_seq_client_unlock(receiver);\n\treturn result;\n}\n",
        "linevul": 6.071251118555665e-05,
        "sysevr": 0.16067112982273102,
        "devign": 1.4610736231990273e-11
    },
    {
        "code": "nfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfserr_notsupp;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfserr_notsupp;\n}\n",
        "linevul": 5.014147245674394e-05,
        "sysevr": 0.16029974818229675,
        "devign": 3.9400111645493396e-11
    },
    {
        "code": "static int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end)\n{\n\treturn __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
        "vul_func_with_fix": "static int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end)\n{\n\treturn __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);\n}\n",
        "linevul": 0.00010968771675834432,
        "sysevr": 0.1348462551832199,
        "devign": 1.1410551392643242e-09
    },
    {
        "code": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n \tgfp_t gfp_mask;\n \tlong timeo;\n \tint err;\n \n \tgfp_mask = sk->sk_allocation;\n \tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n \t\t\tskb = alloc_skb(header_len, gfp_mask);\n \t\t\tif (skb) {\n\t\t\t\tint npages;\n \t\t\t\tint i;\n \n \t\t\t\t/* No pages, we're done... */\n \t\t\t\tif (!data_len)\n \t\t\t\t\tbreak;\n \n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n \t\t\t\tskb->truesize += data_len;\n \t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n \t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\t}\n\n\t\t\t\t\t__skb_fill_page_desc(skb, i,\n\t\t\t\t\t\t\tpage, 0,\n\t\t\t\t\t\t\t(data_len >= PAGE_SIZE ?\n\t\t\t\t\t\t\t PAGE_SIZE :\n\t\t\t\t\t\t\t data_len));\n\t\t\t\t\tdata_len -= PAGE_SIZE;\n\t\t\t\t}\n\n\t\t\t\t/* Full success... */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto failure;\n\t\t}\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc",
        "vul_func_with_fix": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n \tgfp_t gfp_mask;\n \tlong timeo;\n \tint err;\n//fix_flaw_line_below:\n//\tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\terr = -EMSGSIZE;\n//fix_flaw_line_below:\n//\tif (npages > MAX_SKB_FRAGS)\n//fix_flaw_line_below:\n//\t\tgoto failure;\n \n \tgfp_mask = sk->sk_allocation;\n \tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n \t\t\tskb = alloc_skb(header_len, gfp_mask);\n \t\t\tif (skb) {\n//flaw_line_below:\n\t\t\t\tint npages;\n \t\t\t\tint i;\n \n \t\t\t\t/* No pages, we're done... */\n \t\t\t\tif (!data_len)\n \t\t\t\t\tbreak;\n \n//flaw_line_below:\n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n \t\t\t\tskb->truesize += data_len;\n \t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n \t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\t}\n\n\t\t\t\t\t__skb_fill_page_desc(skb, i,\n\t\t\t\t\t\t\tpage, 0,\n\t\t\t\t\t\t\t(data_len >= PAGE_SIZE ?\n\t\t\t\t\t\t\t PAGE_SIZE :\n\t\t\t\t\t\t\t data_len));\n\t\t\t\t\tdata_len -= PAGE_SIZE;\n\t\t\t\t}\n\n\t\t\t\t/* Full success... */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto failure;\n\t\t}\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}\n",
        "linevul": 0.9994489550590515,
        "sysevr": 0.14642807841300964,
        "devign": 4.738491214312948e-20
    },
    {
        "code": "static int update_raid_disks(struct mddev *mddev, int raid_disks)\n{\n\tint rv;\n\tstruct md_rdev *rdev;\n\t/* change the number of raid disks */\n\tif (mddev->pers->check_reshape == NULL)\n\t\treturn -EINVAL;\n\tif (mddev->ro)\n\t\treturn -EROFS;\n\tif (raid_disks <= 0 ||\n\t    (mddev->max_disks && raid_disks >= mddev->max_disks))\n\t\treturn -EINVAL;\n\tif (mddev->sync_thread ||\n\t    test_bit(MD_RECOVERY_RUNNING, &mddev->recovery) ||\n\t    mddev->reshape_position != MaxSector)\n\t\treturn -EBUSY;\n\n\trdev_for_each(rdev, mddev) {\n\t\tif (mddev->raid_disks < raid_disks &&\n\t\t    rdev->data_offset < rdev->new_data_offset)\n\t\t\treturn -EINVAL;\n\t\tif (mddev->raid_disks > raid_disks &&\n\t\t    rdev->data_offset > rdev->new_data_offset)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmddev->delta_disks = raid_disks - mddev->raid_disks;\n\tif (mddev->delta_disks < 0)\n\t\tmddev->reshape_backwards = 1;\n\telse if (mddev->delta_disks > 0)\n\t\tmddev->reshape_backwards = 0;\n\n\trv = mddev->pers->check_reshape(mddev);\n\tif (rv < 0) {\n\t\tmddev->delta_disks = 0;\n\t\tmddev->reshape_backwards = 0;\n\t}\n\treturn rv;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "static int update_raid_disks(struct mddev *mddev, int raid_disks)\n{\n\tint rv;\n\tstruct md_rdev *rdev;\n\t/* change the number of raid disks */\n\tif (mddev->pers->check_reshape == NULL)\n\t\treturn -EINVAL;\n\tif (mddev->ro)\n\t\treturn -EROFS;\n\tif (raid_disks <= 0 ||\n\t    (mddev->max_disks && raid_disks >= mddev->max_disks))\n\t\treturn -EINVAL;\n\tif (mddev->sync_thread ||\n\t    test_bit(MD_RECOVERY_RUNNING, &mddev->recovery) ||\n\t    mddev->reshape_position != MaxSector)\n\t\treturn -EBUSY;\n\n\trdev_for_each(rdev, mddev) {\n\t\tif (mddev->raid_disks < raid_disks &&\n\t\t    rdev->data_offset < rdev->new_data_offset)\n\t\t\treturn -EINVAL;\n\t\tif (mddev->raid_disks > raid_disks &&\n\t\t    rdev->data_offset > rdev->new_data_offset)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmddev->delta_disks = raid_disks - mddev->raid_disks;\n\tif (mddev->delta_disks < 0)\n\t\tmddev->reshape_backwards = 1;\n\telse if (mddev->delta_disks > 0)\n\t\tmddev->reshape_backwards = 0;\n\n\trv = mddev->pers->check_reshape(mddev);\n\tif (rv < 0) {\n\t\tmddev->delta_disks = 0;\n\t\tmddev->reshape_backwards = 0;\n\t}\n\treturn rv;\n}\n",
        "linevul": 7.316590199479833e-05,
        "sysevr": 0.14007693529129028,
        "devign": 7.227962095131235e-18
    },
    {
        "code": "int cifs_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tint rc = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\n\tcifs_dbg(FYI, \"Flush inode %p file %p rc %d\\n\", inode, file, rc);\n\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f",
        "vul_func_with_fix": "int cifs_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file_inode(file);\n\tint rc = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\trc = filemap_write_and_wait(inode->i_mapping);\n\n\tcifs_dbg(FYI, \"Flush inode %p file %p rc %d\\n\", inode, file, rc);\n\n\treturn rc;\n}\n",
        "linevul": 5.0310838560108095e-05,
        "sysevr": 0.17057828605175018,
        "devign": 4.148712378082564e-07
    },
    {
        "code": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1",
        "vul_func_with_fix": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n//fix_flaw_line_below:\n//\tif (sz < sizeof(*info))\n//fix_flaw_line_below:\n//\t\treturn NULL;\n//fix_flaw_line_below:\n//\n \t/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}\n",
        "linevul": 0.9994945526123047,
        "sysevr": 0.1666223257780075,
        "devign": 0.011506565846502781
    },
    {
        "code": "cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent, cpu);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp, cpu);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdestroy_sched_domains(tmp, cpu);\n\n\tupdate_top_cache_domain(cpu);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "cpu_attach_domain(struct sched_domain *sd, struct root_domain *rd, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct sched_domain *tmp;\n\n\t/* Remove the sched domains which do not contribute to scheduling. */\n\tfor (tmp = sd; tmp; ) {\n\t\tstruct sched_domain *parent = tmp->parent;\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tif (sd_parent_degenerate(tmp, parent)) {\n\t\t\ttmp->parent = parent->parent;\n\t\t\tif (parent->parent)\n\t\t\t\tparent->parent->child = tmp;\n\t\t\t/*\n\t\t\t * Transfer SD_PREFER_SIBLING down in case of a\n\t\t\t * degenerate parent; the spans match for this\n\t\t\t * so the property transfers.\n\t\t\t */\n\t\t\tif (parent->flags & SD_PREFER_SIBLING)\n\t\t\t\ttmp->flags |= SD_PREFER_SIBLING;\n\t\t\tdestroy_sched_domain(parent, cpu);\n\t\t} else\n\t\t\ttmp = tmp->parent;\n\t}\n\n\tif (sd && sd_degenerate(sd)) {\n\t\ttmp = sd;\n\t\tsd = sd->parent;\n\t\tdestroy_sched_domain(tmp, cpu);\n\t\tif (sd)\n\t\t\tsd->child = NULL;\n\t}\n\n\tsched_domain_debug(sd, cpu);\n\n\trq_attach_root(rq, rd);\n\ttmp = rq->sd;\n\trcu_assign_pointer(rq->sd, sd);\n\tdestroy_sched_domains(tmp, cpu);\n\n\tupdate_top_cache_domain(cpu);\n}\n",
        "linevul": 0.00010335431579733267,
        "sysevr": 0.1936892718076706,
        "devign": 2.3910420747911876e-18
    },
    {
        "code": "static inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminfo64 *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shminfo out;\n\n\t\tif (in->shmmax > INT_MAX)\n\t\t\tout.shmmax = INT_MAX;\n\t\telse\n\t\t\tout.shmmax = (int)in->shmmax;\n\n\t\tout.shmmin\t= in->shmmin;\n\t\tout.shmmni\t= in->shmmni;\n\t\tout.shmseg\t= in->shmseg;\n\t\tout.shmall\t= in->shmall;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf",
        "vul_func_with_fix": "static inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminfo64 *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shminfo out;\n\n\t\tif (in->shmmax > INT_MAX)\n\t\t\tout.shmmax = INT_MAX;\n\t\telse\n\t\t\tout.shmmax = (int)in->shmmax;\n\n\t\tout.shmmin\t= in->shmmin;\n\t\tout.shmmni\t= in->shmmni;\n\t\tout.shmseg\t= in->shmseg;\n\t\tout.shmall\t= in->shmall;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "linevul": 5.61829874641262e-05,
        "sysevr": 0.12806503474712372,
        "devign": 0.691655695438385
    },
    {
        "code": "megasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "vul_func_with_fix": "megasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n",
        "linevul": 4.987665670341812e-05,
        "sysevr": 0.16465969383716583,
        "devign": 9.854270501818974e-07
    },
    {
        "code": "static inline void pre_schedule(struct rq *rq, struct task_struct *p)\n{\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": "static inline void pre_schedule(struct rq *rq, struct task_struct *p)\n{\n}\n",
        "linevul": 7.877581083448604e-05,
        "sysevr": 0.12418583035469055,
        "devign": 1.429480445125364e-08
    },
    {
        "code": "static int lookup_chan_dst(u16 call_id, __be32 d_addr)\n{\n\tstruct pppox_sock *sock;\n\tstruct pptp_opt *opt;\n\tint i;\n\n\trcu_read_lock();\n\ti = 1;\n\tfor_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {\n\t\tsock = rcu_dereference(callid_sock[i]);\n\t\tif (!sock)\n\t\t\tcontinue;\n\t\topt = &sock->proto.pptp;\n\t\tif (opt->dst_addr.call_id == call_id &&\n\t\t\t  opt->dst_addr.sin_addr.s_addr == d_addr)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn i < MAX_CALLID;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/09ccfd238e5a0e670d8178cf50180ea81ae09ae1",
        "vul_func_with_fix": "static int lookup_chan_dst(u16 call_id, __be32 d_addr)\n{\n\tstruct pppox_sock *sock;\n\tstruct pptp_opt *opt;\n\tint i;\n\n\trcu_read_lock();\n\ti = 1;\n\tfor_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {\n\t\tsock = rcu_dereference(callid_sock[i]);\n\t\tif (!sock)\n\t\t\tcontinue;\n\t\topt = &sock->proto.pptp;\n\t\tif (opt->dst_addr.call_id == call_id &&\n\t\t\t  opt->dst_addr.sin_addr.s_addr == d_addr)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn i < MAX_CALLID;\n}\n",
        "linevul": 5.711853737011552e-05,
        "sysevr": 0.12845540046691895,
        "devign": 3.40385185572676e-21
    },
    {
        "code": "bool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "bool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}\n",
        "linevul": 9.446964395465329e-05,
        "sysevr": 0.13935737311840057,
        "devign": 1.5908375438265776e-29
    },
    {
        "code": "static int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (asoc->peer.ecn_capable && !chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af = SCTP_INPUT_CB(chunk->skb)->af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\tif (af->is_ce(sctp_gso_headskb(chunk->skb))) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf911e985d6bbaa328c20c3e05f4eb03de11fdd6",
        "vul_func_with_fix": "static int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (asoc->peer.ecn_capable && !chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af = SCTP_INPUT_CB(chunk->skb)->af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\tif (af->is_ce(sctp_gso_headskb(chunk->skb))) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n",
        "linevul": 0.0011007728753611445,
        "sysevr": 0.22413304448127747,
        "devign": 3.595141897941648e-14
    },
    {
        "code": "SCTP_STATIC int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tstruct sctp_af *af;\n\tunsigned short snum;\n\tint ret = 0;\n\n\t/* Common sockaddr verification. */\n\taf = sctp_sockaddr_af(sp, addr, len);\n\tif (!af) {\n\t\tSCTP_DEBUG_PRINTK(\"sctp_do_bind(sk: %p, newaddr: %p, len: %d) EINVAL\\n\",\n\t\t\t\t  sk, addr, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tSCTP_DEBUG_PRINTK_IPADDR(\"sctp_do_bind(sk: %p, new addr: \",\n\t\t\t\t \", port: %d, new port: %d, len: %d)\\n\",\n\t\t\t\t sk,\n\t\t\t\t addr,\n\t\t\t\t bp->port, snum,\n\t\t\t\t len);\n\n\t/* PF specific bind() address verification. */\n\tif (!sp->pf->bind_verify(sp, addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* We must either be unbound, or bind to the same port.\n\t * It's OK to allow 0 ports if we are already bound.\n\t * We'll just inhert an already bound port in this case\n\t */\n\tif (bp->port) {\n\t\tif (!snum)\n\t\t\tsnum = bp->port;\n\t\telse if (snum != bp->port) {\n\t\t\tSCTP_DEBUG_PRINTK(\"sctp_do_bind:\"\n\t\t\t\t  \" New port %d does not match existing port \"\n\t\t\t\t  \"%d.\\n\", snum, bp->port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (snum && snum < PROT_SOCK &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t/* See if the address matches any of the addresses we may have\n\t * already bound before checking against other endpoints.\n\t */\n\tif (sctp_bind_addr_match(bp, addr, sp))\n\t\treturn -EINVAL;\n\n\t/* Make sure we are allowed to bind here.\n\t * The function sctp_get_port_local() does duplicate address\n\t * detection.\n\t */\n\taddr->v4.sin_port = htons(snum);\n\tif ((ret = sctp_get_port_local(sk, addr))) {\n\t\treturn -EADDRINUSE;\n\t}\n\n\t/* Refresh ephemeral port.  */\n\tif (!bp->port)\n\t\tbp->port = inet_sk(sk)->inet_num;\n\n\t/* Add the address to the bind address list.\n\t * Use GFP_ATOMIC since BHs will be disabled.\n\t */\n\tret = sctp_add_bind_addr(bp, addr, SCTP_ADDR_SRC, GFP_ATOMIC);\n\n\t/* Copy back into socket for getsockname() use. */\n\tif (!ret) {\n\t\tinet_sk(sk)->inet_sport = htons(inet_sk(sk)->inet_num);\n\t\taf->to_sk_saddr(addr, sk);\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/726bc6b092da4c093eb74d13c07184b18c1af0f1",
        "vul_func_with_fix": "SCTP_STATIC int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tstruct sctp_af *af;\n\tunsigned short snum;\n\tint ret = 0;\n\n\t/* Common sockaddr verification. */\n\taf = sctp_sockaddr_af(sp, addr, len);\n\tif (!af) {\n\t\tSCTP_DEBUG_PRINTK(\"sctp_do_bind(sk: %p, newaddr: %p, len: %d) EINVAL\\n\",\n\t\t\t\t  sk, addr, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tSCTP_DEBUG_PRINTK_IPADDR(\"sctp_do_bind(sk: %p, new addr: \",\n\t\t\t\t \", port: %d, new port: %d, len: %d)\\n\",\n\t\t\t\t sk,\n\t\t\t\t addr,\n\t\t\t\t bp->port, snum,\n\t\t\t\t len);\n\n\t/* PF specific bind() address verification. */\n\tif (!sp->pf->bind_verify(sp, addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* We must either be unbound, or bind to the same port.\n\t * It's OK to allow 0 ports if we are already bound.\n\t * We'll just inhert an already bound port in this case\n\t */\n\tif (bp->port) {\n\t\tif (!snum)\n\t\t\tsnum = bp->port;\n\t\telse if (snum != bp->port) {\n\t\t\tSCTP_DEBUG_PRINTK(\"sctp_do_bind:\"\n\t\t\t\t  \" New port %d does not match existing port \"\n\t\t\t\t  \"%d.\\n\", snum, bp->port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (snum && snum < PROT_SOCK &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t/* See if the address matches any of the addresses we may have\n\t * already bound before checking against other endpoints.\n\t */\n\tif (sctp_bind_addr_match(bp, addr, sp))\n\t\treturn -EINVAL;\n\n\t/* Make sure we are allowed to bind here.\n\t * The function sctp_get_port_local() does duplicate address\n\t * detection.\n\t */\n\taddr->v4.sin_port = htons(snum);\n\tif ((ret = sctp_get_port_local(sk, addr))) {\n\t\treturn -EADDRINUSE;\n\t}\n\n\t/* Refresh ephemeral port.  */\n\tif (!bp->port)\n\t\tbp->port = inet_sk(sk)->inet_num;\n\n\t/* Add the address to the bind address list.\n\t * Use GFP_ATOMIC since BHs will be disabled.\n\t */\n\tret = sctp_add_bind_addr(bp, addr, SCTP_ADDR_SRC, GFP_ATOMIC);\n\n\t/* Copy back into socket for getsockname() use. */\n\tif (!ret) {\n\t\tinet_sk(sk)->inet_sport = htons(inet_sk(sk)->inet_num);\n\t\taf->to_sk_saddr(addr, sk);\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 7.128660945454612e-05,
        "sysevr": 0.23093514144420624,
        "devign": 2.505423992715805e-07
    },
    {
        "code": "ext2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n \tsize_t name_len, size;\n \tchar *end;\n \tint error;\n \n \tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n \t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* find named attribute */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next =\n\t\t\tEXT2_XATTR_NEXT(entry);\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tif (name_index == entry->e_name_index &&\n\t\t    name_len == entry->e_name_len &&\n\t\t    memcmp(name, entry->e_name, name_len) == 0)\n \t\t\tgoto found;\n \t\tentry = next;\n \t}\n\tif (ext2_xattr_cache_insert(bh))\n \t\tea_idebug(inode, \"cache insert failed\");\n \terror = -ENODATA;\n \tgoto cleanup;\nfound:\n\t/* check the buffer size */\n\tif (entry->e_value_block != 0)\n\t\tgoto bad_block;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > inode->i_sb->s_blocksize ||\n \t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n \t\tgoto bad_block;\n \n\tif (ext2_xattr_cache_insert(bh))\n \t\tea_idebug(inode, \"cache insert failed\");\n \tif (buffer) {\n \t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t/* return value of attribute */\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
        "vul_func_with_fix": "ext2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n \tsize_t name_len, size;\n \tchar *end;\n \tint error;\n//fix_flaw_line_below:\n//\tstruct mb2_cache *ext2_mb_cache = EXT2_SB(inode->i_sb)->s_mb_cache;\n \n \tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n \t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* find named attribute */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next =\n\t\t\tEXT2_XATTR_NEXT(entry);\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tif (name_index == entry->e_name_index &&\n\t\t    name_len == entry->e_name_len &&\n\t\t    memcmp(name, entry->e_name, name_len) == 0)\n \t\t\tgoto found;\n \t\tentry = next;\n \t}\n//flaw_line_below:\n\tif (ext2_xattr_cache_insert(bh))\n//fix_flaw_line_below:\n//\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n \t\tea_idebug(inode, \"cache insert failed\");\n \terror = -ENODATA;\n \tgoto cleanup;\nfound:\n\t/* check the buffer size */\n\tif (entry->e_value_block != 0)\n\t\tgoto bad_block;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > inode->i_sb->s_blocksize ||\n \t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n \t\tgoto bad_block;\n \n//flaw_line_below:\n\tif (ext2_xattr_cache_insert(bh))\n//fix_flaw_line_below:\n//\tif (ext2_xattr_cache_insert(ext2_mb_cache, bh))\n \t\tea_idebug(inode, \"cache insert failed\");\n \tif (buffer) {\n \t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t/* return value of attribute */\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}\n",
        "linevul": 0.9995965361595154,
        "sysevr": 0.1923704296350479,
        "devign": 0.9812848567962646
    },
    {
        "code": "int do_mathemu(struct pt_regs *regs, struct fpustate *f)\n{\n\tunsigned long pc = regs->tpc;\n\tunsigned long tstate = regs->tstate;\n\tu32 insn = 0;\n\tint type = 0;\n\t/* ftt tells which ftt it may happen in, r is rd, b is rs2 and a is rs1. The *u arg tells\n\t   whether the argument should be packed/unpacked (0 - do not unpack/pack, 1 - unpack/pack)\n\t   non-u args tells the size of the argument (0 - no argument, 1 - single, 2 - double, 3 - quad */\n#define TYPE(ftt, r, ru, b, bu, a, au) type = (au << 2) | (a << 0) | (bu << 5) | (b << 3) | (ru << 8) | (r << 6) | (ftt << 9)\n\tint freg;\n\tstatic u64 zero[2] = { 0L, 0L };\n\tint flags;\n\tFP_DECL_EX;\n\tFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\n\tFP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);\n\tFP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);\n\tint IR;\n\tlong XR, xfsr;\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"unfinished/unimplemented FPop from kernel\", regs);\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n\t\tif ((insn & 0xc1f80000) == 0x81a00000) /* FPOP1 */ {\n\t\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t\t/* QUAD - ftt == 3 */\n\t\t\tcase FMOVQ:\n\t\t\tcase FNEGQ:\n\t\t\tcase FABSQ: TYPE(3,3,0,3,0,0,0); break;\n\t\t\tcase FSQRTQ: TYPE(3,3,1,3,1,0,0); break;\n\t\t\tcase FADDQ:\n\t\t\tcase FSUBQ:\n\t\t\tcase FMULQ:\n\t\t\tcase FDIVQ: TYPE(3,3,1,3,1,3,1); break;\n\t\t\tcase FDMULQ: TYPE(3,3,1,2,1,2,1); break;\n\t\t\tcase FQTOX: TYPE(3,2,0,3,1,0,0); break;\n\t\t\tcase FXTOQ: TYPE(3,3,1,2,0,0,0); break;\n\t\t\tcase FQTOS: TYPE(3,1,1,3,1,0,0); break;\n\t\t\tcase FQTOD: TYPE(3,2,1,3,1,0,0); break;\n\t\t\tcase FITOQ: TYPE(3,3,1,1,0,0,0); break;\n\t\t\tcase FSTOQ: TYPE(3,3,1,1,1,0,0); break;\n\t\t\tcase FDTOQ: TYPE(3,3,1,2,1,0,0); break;\n\t\t\tcase FQTOI: TYPE(3,1,0,3,1,0,0); break;\n\n\t\t\t/* We can get either unimplemented or unfinished\n\t\t\t * for these cases.  Pre-Niagara systems generate\n\t\t\t * unfinished fpop for SUBNORMAL cases, and Niagara\n\t\t\t * always gives unimplemented fpop for fsqrt{s,d}.\n\t\t\t */\n\t\t\tcase FSQRTS: {\n\t\t\t\tunsigned long x = current_thread_info()->xfsr[0];\n\n\t\t\t\tx = (x >> 14) & 0xf;\n\t\t\t\tTYPE(x,1,1,1,1,0,0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase FSQRTD: {\n\t\t\t\tunsigned long x = current_thread_info()->xfsr[0];\n\n\t\t\t\tx = (x >> 14) & 0xf;\n\t\t\t\tTYPE(x,2,1,2,1,0,0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* SUBNORMAL - ftt == 2 */\n\t\t\tcase FADDD:\n\t\t\tcase FSUBD:\n\t\t\tcase FMULD:\n\t\t\tcase FDIVD: TYPE(2,2,1,2,1,2,1); break;\n\t\t\tcase FADDS:\n\t\t\tcase FSUBS:\n\t\t\tcase FMULS:\n\t\t\tcase FDIVS: TYPE(2,1,1,1,1,1,1); break;\n\t\t\tcase FSMULD: TYPE(2,2,1,1,1,1,1); break;\n\t\t\tcase FSTOX: TYPE(2,2,0,1,1,0,0); break;\n\t\t\tcase FDTOX: TYPE(2,2,0,2,1,0,0); break;\n\t\t\tcase FDTOS: TYPE(2,1,1,2,1,0,0); break;\n\t\t\tcase FSTOD: TYPE(2,2,1,1,1,0,0); break;\n\t\t\tcase FSTOI: TYPE(2,1,0,1,1,0,0); break;\n\t\t\tcase FDTOI: TYPE(2,1,0,2,1,0,0); break;\n\n\t\t\t/* Only Ultra-III generates these */\n\t\t\tcase FXTOS: TYPE(2,1,1,2,0,0,0); break;\n\t\t\tcase FXTOD: TYPE(2,2,1,2,0,0,0); break;\n#if 0\t\t\t/* Optimized inline in sparc64/kernel/entry.S */\n\t\t\tcase FITOS: TYPE(2,1,1,1,0,0,0); break;\n#endif\n\t\t\tcase FITOD: TYPE(2,2,1,1,0,0,0); break;\n\t\t\t}\n\t\t}\n\t\telse if ((insn & 0xc1f80000) == 0x81a80000) /* FPOP2 */ {\n\t\t\tIR = 2;\n\t\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t\tcase FCMPQ: TYPE(3,0,0,3,1,3,1); break;\n\t\t\tcase FCMPEQ: TYPE(3,0,0,3,1,3,1); break;\n\t\t\t/* Now the conditional fmovq support */\n\t\t\tcase FMOVQ0:\n\t\t\tcase FMOVQ1:\n\t\t\tcase FMOVQ2:\n\t\t\tcase FMOVQ3:\n\t\t\t\t/* fmovq %fccX, %fY, %fZ */\n\t\t\t\tif (!((insn >> 11) & 3))\n\t\t\t\t\tXR = current_thread_info()->xfsr[0] >> 10;\n\t\t\t\telse\n\t\t\t\t\tXR = current_thread_info()->xfsr[0] >> (30 + ((insn >> 10) & 0x6));\n\t\t\t\tXR &= 3;\n\t\t\t\tIR = 0;\n\t\t\t\tswitch ((insn >> 14) & 0x7) {\n\t\t\t\t/* case 0: IR = 0; break; */\t\t\t/* Never */\n\t\t\t\tcase 1: if (XR) IR = 1; break;\t\t\t/* Not Equal */\n\t\t\t\tcase 2: if (XR == 1 || XR == 2) IR = 1; break;\t/* Less or Greater */\n\t\t\t\tcase 3: if (XR & 1) IR = 1; break;\t\t/* Unordered or Less */\n\t\t\t\tcase 4: if (XR == 1) IR = 1; break;\t\t/* Less */\n\t\t\t\tcase 5: if (XR & 2) IR = 1; break;\t\t/* Unordered or Greater */\n\t\t\t\tcase 6: if (XR == 2) IR = 1; break;\t\t/* Greater */\n\t\t\t\tcase 7: if (XR == 3) IR = 1; break;\t\t/* Unordered */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 14) & 8)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\tcase FMOVQI:\n\t\t\tcase FMOVQX:\n\t\t\t\t/* fmovq %[ix]cc, %fY, %fZ */\n\t\t\t\tXR = regs->tstate >> 32;\n\t\t\t\tif ((insn >> 5) & 0x80)\n\t\t\t\t\tXR >>= 4;\n\t\t\t\tXR &= 0xf;\n\t\t\t\tIR = 0;\n\t\t\t\tfreg = ((XR >> 2) ^ XR) & 2;\n\t\t\t\tswitch ((insn >> 14) & 0x7) {\n\t\t\t\t/* case 0: IR = 0; break; */\t\t\t/* Never */\n\t\t\t\tcase 1: if (XR & 4) IR = 1; break;\t\t/* Equal */\n\t\t\t\tcase 2: if ((XR & 4) || freg) IR = 1; break;\t/* Less or Equal */\n\t\t\t\tcase 3: if (freg) IR = 1; break;\t\t/* Less */\n\t\t\t\tcase 4: if (XR & 5) IR = 1; break;\t\t/* Less or Equal Unsigned */\n\t\t\t\tcase 5: if (XR & 1) IR = 1; break;\t\t/* Carry Set */\n\t\t\t\tcase 6: if (XR & 8) IR = 1; break;\t\t/* Negative */\n\t\t\t\tcase 7: if (XR & 2) IR = 1; break;\t\t/* Overflow Set */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 14) & 8)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\tcase FMOVQZ:\n\t\t\tcase FMOVQLE:\n\t\t\tcase FMOVQLZ:\n\t\t\tcase FMOVQNZ:\n\t\t\tcase FMOVQGZ:\n\t\t\tcase FMOVQGE:\n\t\t\t\tfreg = (insn >> 14) & 0x1f;\n\t\t\t\tif (!freg)\n\t\t\t\t\tXR = 0;\n\t\t\t\telse if (freg < 16)\n\t\t\t\t\tXR = regs->u_regs[freg];\n\t\t\t\telse if (test_thread_flag(TIF_32BIT)) {\n\t\t\t\t\tstruct reg_window32 __user *win32;\n\t\t\t\t\tflushw_user ();\n\t\t\t\t\twin32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP]));\n\t\t\t\t\tget_user(XR, &win32->locals[freg - 16]);\n\t\t\t\t} else {\n\t\t\t\t\tstruct reg_window __user *win;\n\t\t\t\t\tflushw_user ();\n\t\t\t\t\twin = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS);\n\t\t\t\t\tget_user(XR, &win->locals[freg - 16]);\n\t\t\t\t}\n\t\t\t\tIR = 0;\n\t\t\t\tswitch ((insn >> 10) & 3) {\n\t\t\t\tcase 1: if (!XR) IR = 1; break;\t\t\t/* Register Zero */\n\t\t\t\tcase 2: if (XR <= 0) IR = 1; break;\t\t/* Register Less Than or Equal to Zero */\n\t\t\t\tcase 3: if (XR < 0) IR = 1; break;\t\t/* Register Less Than Zero */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 10) & 4)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IR == 0) {\n\t\t\t\t/* The fmov test was false. Do a nop instead */\n\t\t\t\tcurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\n\t\t\t\tregs->tpc = regs->tnpc;\n\t\t\t\tregs->tnpc += 4;\n\t\t\t\treturn 1;\n\t\t\t} else if (IR == 1) {\n\t\t\t\t/* Change the instruction into plain fmovq */\n\t\t\t\tinsn = (insn & 0x3e00001f) | 0x81a00060;\n\t\t\t\tTYPE(3,3,0,3,0,0,0); \n\t\t\t}\n\t\t}\n\t}\n\tif (type) {\n\t\targp rs1 = NULL, rs2 = NULL, rd = NULL;\n\t\t\n\t\tfreg = (current_thread_info()->xfsr[0] >> 14) & 0xf;\n\t\tif (freg != (type >> 9))\n\t\t\tgoto err;\n\t\tcurrent_thread_info()->xfsr[0] &= ~0x1c000;\n\t\tfreg = ((insn >> 14) & 0x1f);\n\t\tswitch (type & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rs1 = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags))\n\t\t\t\trs1 = (argp)&zero;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (type & 0x7) {\n\t\tcase 7: FP_UNPACK_QP (QA, rs1); break;\n\t\tcase 6: FP_UNPACK_DP (DA, rs1); break;\n\t\tcase 5: FP_UNPACK_SP (SA, rs1); break;\n\t\t}\n\t\tfreg = (insn & 0x1f);\n\t\tswitch ((type >> 3) & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rs2 = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags))\n\t\t\t\trs2 = (argp)&zero;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((type >> 3) & 0x7) {\n\t\tcase 7: FP_UNPACK_QP (QB, rs2); break;\n\t\tcase 6: FP_UNPACK_DP (DB, rs2); break;\n\t\tcase 5: FP_UNPACK_SP (SB, rs2); break;\n\t\t}\n\t\tfreg = ((insn >> 25) & 0x1f);\n\t\tswitch ((type >> 6) & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rd = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & FPRS_FEF)) {\n\t\t\t\tcurrent_thread_info()->fpsaved[0] = FPRS_FEF;\n\t\t\t\tcurrent_thread_info()->gsr[0] = 0;\n\t\t\t}\n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags)) {\n\t\t\t\tif (freg < 32)\n\t\t\t\t\tmemset(f->regs, 0, 32*sizeof(u32));\n\t\t\t\telse\n\t\t\t\t\tmemset(f->regs+32, 0, 32*sizeof(u32));\n\t\t\t}\n\t\t\tcurrent_thread_info()->fpsaved[0] |= flags;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t/* + */\n\t\tcase FADDS: FP_ADD_S (SR, SA, SB); break;\n\t\tcase FADDD: FP_ADD_D (DR, DA, DB); break;\n\t\tcase FADDQ: FP_ADD_Q (QR, QA, QB); break;\n\t\t/* - */\n\t\tcase FSUBS: FP_SUB_S (SR, SA, SB); break;\n\t\tcase FSUBD: FP_SUB_D (DR, DA, DB); break;\n\t\tcase FSUBQ: FP_SUB_Q (QR, QA, QB); break;\n\t\t/* * */\n\t\tcase FMULS: FP_MUL_S (SR, SA, SB); break;\n\t\tcase FSMULD: FP_CONV (D, S, 1, 1, DA, SA);\n\t\t\t     FP_CONV (D, S, 1, 1, DB, SB);\n\t\tcase FMULD: FP_MUL_D (DR, DA, DB); break;\n\t\tcase FDMULQ: FP_CONV (Q, D, 2, 1, QA, DA);\n\t\t\t     FP_CONV (Q, D, 2, 1, QB, DB);\n\t\tcase FMULQ: FP_MUL_Q (QR, QA, QB); break;\n\t\t/* / */\n\t\tcase FDIVS: FP_DIV_S (SR, SA, SB); break;\n\t\tcase FDIVD: FP_DIV_D (DR, DA, DB); break;\n\t\tcase FDIVQ: FP_DIV_Q (QR, QA, QB); break;\n\t\t/* sqrt */\n\t\tcase FSQRTS: FP_SQRT_S (SR, SB); break;\n\t\tcase FSQRTD: FP_SQRT_D (DR, DB); break;\n\t\tcase FSQRTQ: FP_SQRT_Q (QR, QB); break;\n\t\t/* mov */\n\t\tcase FMOVQ: rd->q[0] = rs2->q[0]; rd->q[1] = rs2->q[1]; break;\n\t\tcase FABSQ: rd->q[0] = rs2->q[0] & 0x7fffffffffffffffUL; rd->q[1] = rs2->q[1]; break;\n\t\tcase FNEGQ: rd->q[0] = rs2->q[0] ^ 0x8000000000000000UL; rd->q[1] = rs2->q[1]; break;\n\t\t/* float to int */\n\t\tcase FSTOI: FP_TO_INT_S (IR, SB, 32, 1); break;\n\t\tcase FDTOI: FP_TO_INT_D (IR, DB, 32, 1); break;\n\t\tcase FQTOI: FP_TO_INT_Q (IR, QB, 32, 1); break;\n\t\tcase FSTOX: FP_TO_INT_S (XR, SB, 64, 1); break;\n\t\tcase FDTOX: FP_TO_INT_D (XR, DB, 64, 1); break;\n\t\tcase FQTOX: FP_TO_INT_Q (XR, QB, 64, 1); break;\n\t\t/* int to float */\n\t\tcase FITOQ: IR = rs2->s; FP_FROM_INT_Q (QR, IR, 32, int); break;\n\t\tcase FXTOQ: XR = rs2->d; FP_FROM_INT_Q (QR, XR, 64, long); break;\n\t\t/* Only Ultra-III generates these */\n\t\tcase FXTOS: XR = rs2->d; FP_FROM_INT_S (SR, XR, 64, long); break;\n\t\tcase FXTOD: XR = rs2->d; FP_FROM_INT_D (DR, XR, 64, long); break;\n#if 0\t\t/* Optimized inline in sparc64/kernel/entry.S */\n\t\tcase FITOS: IR = rs2->s; FP_FROM_INT_S (SR, IR, 32, int); break;\n#endif\n\t\tcase FITOD: IR = rs2->s; FP_FROM_INT_D (DR, IR, 32, int); break;\n\t\t/* float to float */\n\t\tcase FSTOD: FP_CONV (D, S, 1, 1, DR, SB); break;\n\t\tcase FSTOQ: FP_CONV (Q, S, 2, 1, QR, SB); break;\n\t\tcase FDTOQ: FP_CONV (Q, D, 2, 1, QR, DB); break;\n\t\tcase FDTOS: FP_CONV (S, D, 1, 1, SR, DB); break;\n\t\tcase FQTOS: FP_CONV (S, Q, 1, 2, SR, QB); break;\n\t\tcase FQTOD: FP_CONV (D, Q, 1, 2, DR, QB); break;\n\t\t/* comparison */\n\t\tcase FCMPQ:\n\t\tcase FCMPEQ:\n\t\t\tFP_CMP_Q(XR, QB, QA, 3);\n\t\t\tif (XR == 3 &&\n\t\t\t    (((insn >> 5) & 0x1ff) == FCMPEQ ||\n\t\t\t     FP_ISSIGNAN_Q(QA) ||\n\t\t\t     FP_ISSIGNAN_Q(QB)))\n\t\t\t\tFP_SET_EXCEPTION (FP_EX_INVALID);\n\t\t}\n\t\tif (!FP_INHIBIT_RESULTS) {\n\t\t\tswitch ((type >> 6) & 0x7) {\n\t\t\tcase 0: xfsr = current_thread_info()->xfsr[0];\n\t\t\t\tif (XR == -1) XR = 2;\n\t\t\t\tswitch (freg & 3) {\n\t\t\t\t/* fcc0, 1, 2, 3 */\n\t\t\t\tcase 0: xfsr &= ~0xc00; xfsr |= (XR << 10); break;\n\t\t\t\tcase 1: xfsr &= ~0x300000000UL; xfsr |= (XR << 32); break;\n\t\t\t\tcase 2: xfsr &= ~0xc00000000UL; xfsr |= (XR << 34); break;\n\t\t\t\tcase 3: xfsr &= ~0x3000000000UL; xfsr |= (XR << 36); break;\n\t\t\t\t}\n\t\t\t\tcurrent_thread_info()->xfsr[0] = xfsr;\n\t\t\t\tbreak;\n\t\t\tcase 1: rd->s = IR; break;\n\t\t\tcase 2: rd->d = XR; break;\n\t\t\tcase 5: FP_PACK_SP (rd, SR); break;\n\t\t\tcase 6: FP_PACK_DP (rd, DR); break;\n\t\t\tcase 7: FP_PACK_QP (rd, QR); break;\n\t\t\t}\n\t\t}\n\n\t\tif(_fex != 0)\n\t\t\treturn record_exception(regs, _fex);\n\n\t\t/* Success and no exceptions detected. */\n\t\tcurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\n\t\tregs->tpc = regs->tnpc;\n\t\tregs->tnpc += 4;\n\t\treturn 1;\n\t}\nerr:\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "int do_mathemu(struct pt_regs *regs, struct fpustate *f)\n{\n\tunsigned long pc = regs->tpc;\n\tunsigned long tstate = regs->tstate;\n\tu32 insn = 0;\n\tint type = 0;\n\t/* ftt tells which ftt it may happen in, r is rd, b is rs2 and a is rs1. The *u arg tells\n\t   whether the argument should be packed/unpacked (0 - do not unpack/pack, 1 - unpack/pack)\n\t   non-u args tells the size of the argument (0 - no argument, 1 - single, 2 - double, 3 - quad */\n#define TYPE(ftt, r, ru, b, bu, a, au) type = (au << 2) | (a << 0) | (bu << 5) | (b << 3) | (ru << 8) | (r << 6) | (ftt << 9)\n\tint freg;\n\tstatic u64 zero[2] = { 0L, 0L };\n\tint flags;\n\tFP_DECL_EX;\n\tFP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);\n\tFP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);\n\tFP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);\n\tint IR;\n\tlong XR, xfsr;\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"unfinished/unimplemented FPop from kernel\", regs);\n//flaw_line_below:\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n//fix_flaw_line_below:\n//\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n\t\tif ((insn & 0xc1f80000) == 0x81a00000) /* FPOP1 */ {\n\t\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t\t/* QUAD - ftt == 3 */\n\t\t\tcase FMOVQ:\n\t\t\tcase FNEGQ:\n\t\t\tcase FABSQ: TYPE(3,3,0,3,0,0,0); break;\n\t\t\tcase FSQRTQ: TYPE(3,3,1,3,1,0,0); break;\n\t\t\tcase FADDQ:\n\t\t\tcase FSUBQ:\n\t\t\tcase FMULQ:\n\t\t\tcase FDIVQ: TYPE(3,3,1,3,1,3,1); break;\n\t\t\tcase FDMULQ: TYPE(3,3,1,2,1,2,1); break;\n\t\t\tcase FQTOX: TYPE(3,2,0,3,1,0,0); break;\n\t\t\tcase FXTOQ: TYPE(3,3,1,2,0,0,0); break;\n\t\t\tcase FQTOS: TYPE(3,1,1,3,1,0,0); break;\n\t\t\tcase FQTOD: TYPE(3,2,1,3,1,0,0); break;\n\t\t\tcase FITOQ: TYPE(3,3,1,1,0,0,0); break;\n\t\t\tcase FSTOQ: TYPE(3,3,1,1,1,0,0); break;\n\t\t\tcase FDTOQ: TYPE(3,3,1,2,1,0,0); break;\n\t\t\tcase FQTOI: TYPE(3,1,0,3,1,0,0); break;\n\n\t\t\t/* We can get either unimplemented or unfinished\n\t\t\t * for these cases.  Pre-Niagara systems generate\n\t\t\t * unfinished fpop for SUBNORMAL cases, and Niagara\n\t\t\t * always gives unimplemented fpop for fsqrt{s,d}.\n\t\t\t */\n\t\t\tcase FSQRTS: {\n\t\t\t\tunsigned long x = current_thread_info()->xfsr[0];\n\n\t\t\t\tx = (x >> 14) & 0xf;\n\t\t\t\tTYPE(x,1,1,1,1,0,0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase FSQRTD: {\n\t\t\t\tunsigned long x = current_thread_info()->xfsr[0];\n\n\t\t\t\tx = (x >> 14) & 0xf;\n\t\t\t\tTYPE(x,2,1,2,1,0,0);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* SUBNORMAL - ftt == 2 */\n\t\t\tcase FADDD:\n\t\t\tcase FSUBD:\n\t\t\tcase FMULD:\n\t\t\tcase FDIVD: TYPE(2,2,1,2,1,2,1); break;\n\t\t\tcase FADDS:\n\t\t\tcase FSUBS:\n\t\t\tcase FMULS:\n\t\t\tcase FDIVS: TYPE(2,1,1,1,1,1,1); break;\n\t\t\tcase FSMULD: TYPE(2,2,1,1,1,1,1); break;\n\t\t\tcase FSTOX: TYPE(2,2,0,1,1,0,0); break;\n\t\t\tcase FDTOX: TYPE(2,2,0,2,1,0,0); break;\n\t\t\tcase FDTOS: TYPE(2,1,1,2,1,0,0); break;\n\t\t\tcase FSTOD: TYPE(2,2,1,1,1,0,0); break;\n\t\t\tcase FSTOI: TYPE(2,1,0,1,1,0,0); break;\n\t\t\tcase FDTOI: TYPE(2,1,0,2,1,0,0); break;\n\n\t\t\t/* Only Ultra-III generates these */\n\t\t\tcase FXTOS: TYPE(2,1,1,2,0,0,0); break;\n\t\t\tcase FXTOD: TYPE(2,2,1,2,0,0,0); break;\n#if 0\t\t\t/* Optimized inline in sparc64/kernel/entry.S */\n\t\t\tcase FITOS: TYPE(2,1,1,1,0,0,0); break;\n#endif\n\t\t\tcase FITOD: TYPE(2,2,1,1,0,0,0); break;\n\t\t\t}\n\t\t}\n\t\telse if ((insn & 0xc1f80000) == 0x81a80000) /* FPOP2 */ {\n\t\t\tIR = 2;\n\t\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t\tcase FCMPQ: TYPE(3,0,0,3,1,3,1); break;\n\t\t\tcase FCMPEQ: TYPE(3,0,0,3,1,3,1); break;\n\t\t\t/* Now the conditional fmovq support */\n\t\t\tcase FMOVQ0:\n\t\t\tcase FMOVQ1:\n\t\t\tcase FMOVQ2:\n\t\t\tcase FMOVQ3:\n\t\t\t\t/* fmovq %fccX, %fY, %fZ */\n\t\t\t\tif (!((insn >> 11) & 3))\n\t\t\t\t\tXR = current_thread_info()->xfsr[0] >> 10;\n\t\t\t\telse\n\t\t\t\t\tXR = current_thread_info()->xfsr[0] >> (30 + ((insn >> 10) & 0x6));\n\t\t\t\tXR &= 3;\n\t\t\t\tIR = 0;\n\t\t\t\tswitch ((insn >> 14) & 0x7) {\n\t\t\t\t/* case 0: IR = 0; break; */\t\t\t/* Never */\n\t\t\t\tcase 1: if (XR) IR = 1; break;\t\t\t/* Not Equal */\n\t\t\t\tcase 2: if (XR == 1 || XR == 2) IR = 1; break;\t/* Less or Greater */\n\t\t\t\tcase 3: if (XR & 1) IR = 1; break;\t\t/* Unordered or Less */\n\t\t\t\tcase 4: if (XR == 1) IR = 1; break;\t\t/* Less */\n\t\t\t\tcase 5: if (XR & 2) IR = 1; break;\t\t/* Unordered or Greater */\n\t\t\t\tcase 6: if (XR == 2) IR = 1; break;\t\t/* Greater */\n\t\t\t\tcase 7: if (XR == 3) IR = 1; break;\t\t/* Unordered */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 14) & 8)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\tcase FMOVQI:\n\t\t\tcase FMOVQX:\n\t\t\t\t/* fmovq %[ix]cc, %fY, %fZ */\n\t\t\t\tXR = regs->tstate >> 32;\n\t\t\t\tif ((insn >> 5) & 0x80)\n\t\t\t\t\tXR >>= 4;\n\t\t\t\tXR &= 0xf;\n\t\t\t\tIR = 0;\n\t\t\t\tfreg = ((XR >> 2) ^ XR) & 2;\n\t\t\t\tswitch ((insn >> 14) & 0x7) {\n\t\t\t\t/* case 0: IR = 0; break; */\t\t\t/* Never */\n\t\t\t\tcase 1: if (XR & 4) IR = 1; break;\t\t/* Equal */\n\t\t\t\tcase 2: if ((XR & 4) || freg) IR = 1; break;\t/* Less or Equal */\n\t\t\t\tcase 3: if (freg) IR = 1; break;\t\t/* Less */\n\t\t\t\tcase 4: if (XR & 5) IR = 1; break;\t\t/* Less or Equal Unsigned */\n\t\t\t\tcase 5: if (XR & 1) IR = 1; break;\t\t/* Carry Set */\n\t\t\t\tcase 6: if (XR & 8) IR = 1; break;\t\t/* Negative */\n\t\t\t\tcase 7: if (XR & 2) IR = 1; break;\t\t/* Overflow Set */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 14) & 8)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\tcase FMOVQZ:\n\t\t\tcase FMOVQLE:\n\t\t\tcase FMOVQLZ:\n\t\t\tcase FMOVQNZ:\n\t\t\tcase FMOVQGZ:\n\t\t\tcase FMOVQGE:\n\t\t\t\tfreg = (insn >> 14) & 0x1f;\n\t\t\t\tif (!freg)\n\t\t\t\t\tXR = 0;\n\t\t\t\telse if (freg < 16)\n\t\t\t\t\tXR = regs->u_regs[freg];\n\t\t\t\telse if (test_thread_flag(TIF_32BIT)) {\n\t\t\t\t\tstruct reg_window32 __user *win32;\n\t\t\t\t\tflushw_user ();\n\t\t\t\t\twin32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP]));\n\t\t\t\t\tget_user(XR, &win32->locals[freg - 16]);\n\t\t\t\t} else {\n\t\t\t\t\tstruct reg_window __user *win;\n\t\t\t\t\tflushw_user ();\n\t\t\t\t\twin = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS);\n\t\t\t\t\tget_user(XR, &win->locals[freg - 16]);\n\t\t\t\t}\n\t\t\t\tIR = 0;\n\t\t\t\tswitch ((insn >> 10) & 3) {\n\t\t\t\tcase 1: if (!XR) IR = 1; break;\t\t\t/* Register Zero */\n\t\t\t\tcase 2: if (XR <= 0) IR = 1; break;\t\t/* Register Less Than or Equal to Zero */\n\t\t\t\tcase 3: if (XR < 0) IR = 1; break;\t\t/* Register Less Than Zero */\n\t\t\t\t}\n\t\t\t\tif ((insn >> 10) & 4)\n\t\t\t\t\tIR ^= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IR == 0) {\n\t\t\t\t/* The fmov test was false. Do a nop instead */\n\t\t\t\tcurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\n\t\t\t\tregs->tpc = regs->tnpc;\n\t\t\t\tregs->tnpc += 4;\n\t\t\t\treturn 1;\n\t\t\t} else if (IR == 1) {\n\t\t\t\t/* Change the instruction into plain fmovq */\n\t\t\t\tinsn = (insn & 0x3e00001f) | 0x81a00060;\n\t\t\t\tTYPE(3,3,0,3,0,0,0); \n\t\t\t}\n\t\t}\n\t}\n\tif (type) {\n\t\targp rs1 = NULL, rs2 = NULL, rd = NULL;\n\t\t\n\t\tfreg = (current_thread_info()->xfsr[0] >> 14) & 0xf;\n\t\tif (freg != (type >> 9))\n\t\t\tgoto err;\n\t\tcurrent_thread_info()->xfsr[0] &= ~0x1c000;\n\t\tfreg = ((insn >> 14) & 0x1f);\n\t\tswitch (type & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rs1 = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags))\n\t\t\t\trs1 = (argp)&zero;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (type & 0x7) {\n\t\tcase 7: FP_UNPACK_QP (QA, rs1); break;\n\t\tcase 6: FP_UNPACK_DP (DA, rs1); break;\n\t\tcase 5: FP_UNPACK_SP (SA, rs1); break;\n\t\t}\n\t\tfreg = (insn & 0x1f);\n\t\tswitch ((type >> 3) & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rs2 = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags))\n\t\t\t\trs2 = (argp)&zero;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((type >> 3) & 0x7) {\n\t\tcase 7: FP_UNPACK_QP (QB, rs2); break;\n\t\tcase 6: FP_UNPACK_DP (DB, rs2); break;\n\t\tcase 5: FP_UNPACK_SP (SB, rs2); break;\n\t\t}\n\t\tfreg = ((insn >> 25) & 0x1f);\n\t\tswitch ((type >> 6) & 0x3) {\n\t\tcase 3: if (freg & 2) {\n\t\t\t\tcurrent_thread_info()->xfsr[0] |= (6 << 14) /* invalid_fp_register */;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\tcase 2: freg = ((freg & 1) << 5) | (freg & 0x1e);\n\t\tcase 1: rd = (argp)&f->regs[freg];\n\t\t\tflags = (freg < 32) ? FPRS_DL : FPRS_DU; \n\t\t\tif (!(current_thread_info()->fpsaved[0] & FPRS_FEF)) {\n\t\t\t\tcurrent_thread_info()->fpsaved[0] = FPRS_FEF;\n\t\t\t\tcurrent_thread_info()->gsr[0] = 0;\n\t\t\t}\n\t\t\tif (!(current_thread_info()->fpsaved[0] & flags)) {\n\t\t\t\tif (freg < 32)\n\t\t\t\t\tmemset(f->regs, 0, 32*sizeof(u32));\n\t\t\t\telse\n\t\t\t\t\tmemset(f->regs+32, 0, 32*sizeof(u32));\n\t\t\t}\n\t\t\tcurrent_thread_info()->fpsaved[0] |= flags;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((insn >> 5) & 0x1ff) {\n\t\t/* + */\n\t\tcase FADDS: FP_ADD_S (SR, SA, SB); break;\n\t\tcase FADDD: FP_ADD_D (DR, DA, DB); break;\n\t\tcase FADDQ: FP_ADD_Q (QR, QA, QB); break;\n\t\t/* - */\n\t\tcase FSUBS: FP_SUB_S (SR, SA, SB); break;\n\t\tcase FSUBD: FP_SUB_D (DR, DA, DB); break;\n\t\tcase FSUBQ: FP_SUB_Q (QR, QA, QB); break;\n\t\t/* * */\n\t\tcase FMULS: FP_MUL_S (SR, SA, SB); break;\n\t\tcase FSMULD: FP_CONV (D, S, 1, 1, DA, SA);\n\t\t\t     FP_CONV (D, S, 1, 1, DB, SB);\n\t\tcase FMULD: FP_MUL_D (DR, DA, DB); break;\n\t\tcase FDMULQ: FP_CONV (Q, D, 2, 1, QA, DA);\n\t\t\t     FP_CONV (Q, D, 2, 1, QB, DB);\n\t\tcase FMULQ: FP_MUL_Q (QR, QA, QB); break;\n\t\t/* / */\n\t\tcase FDIVS: FP_DIV_S (SR, SA, SB); break;\n\t\tcase FDIVD: FP_DIV_D (DR, DA, DB); break;\n\t\tcase FDIVQ: FP_DIV_Q (QR, QA, QB); break;\n\t\t/* sqrt */\n\t\tcase FSQRTS: FP_SQRT_S (SR, SB); break;\n\t\tcase FSQRTD: FP_SQRT_D (DR, DB); break;\n\t\tcase FSQRTQ: FP_SQRT_Q (QR, QB); break;\n\t\t/* mov */\n\t\tcase FMOVQ: rd->q[0] = rs2->q[0]; rd->q[1] = rs2->q[1]; break;\n\t\tcase FABSQ: rd->q[0] = rs2->q[0] & 0x7fffffffffffffffUL; rd->q[1] = rs2->q[1]; break;\n\t\tcase FNEGQ: rd->q[0] = rs2->q[0] ^ 0x8000000000000000UL; rd->q[1] = rs2->q[1]; break;\n\t\t/* float to int */\n\t\tcase FSTOI: FP_TO_INT_S (IR, SB, 32, 1); break;\n\t\tcase FDTOI: FP_TO_INT_D (IR, DB, 32, 1); break;\n\t\tcase FQTOI: FP_TO_INT_Q (IR, QB, 32, 1); break;\n\t\tcase FSTOX: FP_TO_INT_S (XR, SB, 64, 1); break;\n\t\tcase FDTOX: FP_TO_INT_D (XR, DB, 64, 1); break;\n\t\tcase FQTOX: FP_TO_INT_Q (XR, QB, 64, 1); break;\n\t\t/* int to float */\n\t\tcase FITOQ: IR = rs2->s; FP_FROM_INT_Q (QR, IR, 32, int); break;\n\t\tcase FXTOQ: XR = rs2->d; FP_FROM_INT_Q (QR, XR, 64, long); break;\n\t\t/* Only Ultra-III generates these */\n\t\tcase FXTOS: XR = rs2->d; FP_FROM_INT_S (SR, XR, 64, long); break;\n\t\tcase FXTOD: XR = rs2->d; FP_FROM_INT_D (DR, XR, 64, long); break;\n#if 0\t\t/* Optimized inline in sparc64/kernel/entry.S */\n\t\tcase FITOS: IR = rs2->s; FP_FROM_INT_S (SR, IR, 32, int); break;\n#endif\n\t\tcase FITOD: IR = rs2->s; FP_FROM_INT_D (DR, IR, 32, int); break;\n\t\t/* float to float */\n\t\tcase FSTOD: FP_CONV (D, S, 1, 1, DR, SB); break;\n\t\tcase FSTOQ: FP_CONV (Q, S, 2, 1, QR, SB); break;\n\t\tcase FDTOQ: FP_CONV (Q, D, 2, 1, QR, DB); break;\n\t\tcase FDTOS: FP_CONV (S, D, 1, 1, SR, DB); break;\n\t\tcase FQTOS: FP_CONV (S, Q, 1, 2, SR, QB); break;\n\t\tcase FQTOD: FP_CONV (D, Q, 1, 2, DR, QB); break;\n\t\t/* comparison */\n\t\tcase FCMPQ:\n\t\tcase FCMPEQ:\n\t\t\tFP_CMP_Q(XR, QB, QA, 3);\n\t\t\tif (XR == 3 &&\n\t\t\t    (((insn >> 5) & 0x1ff) == FCMPEQ ||\n\t\t\t     FP_ISSIGNAN_Q(QA) ||\n\t\t\t     FP_ISSIGNAN_Q(QB)))\n\t\t\t\tFP_SET_EXCEPTION (FP_EX_INVALID);\n\t\t}\n\t\tif (!FP_INHIBIT_RESULTS) {\n\t\t\tswitch ((type >> 6) & 0x7) {\n\t\t\tcase 0: xfsr = current_thread_info()->xfsr[0];\n\t\t\t\tif (XR == -1) XR = 2;\n\t\t\t\tswitch (freg & 3) {\n\t\t\t\t/* fcc0, 1, 2, 3 */\n\t\t\t\tcase 0: xfsr &= ~0xc00; xfsr |= (XR << 10); break;\n\t\t\t\tcase 1: xfsr &= ~0x300000000UL; xfsr |= (XR << 32); break;\n\t\t\t\tcase 2: xfsr &= ~0xc00000000UL; xfsr |= (XR << 34); break;\n\t\t\t\tcase 3: xfsr &= ~0x3000000000UL; xfsr |= (XR << 36); break;\n\t\t\t\t}\n\t\t\t\tcurrent_thread_info()->xfsr[0] = xfsr;\n\t\t\t\tbreak;\n\t\t\tcase 1: rd->s = IR; break;\n\t\t\tcase 2: rd->d = XR; break;\n\t\t\tcase 5: FP_PACK_SP (rd, SR); break;\n\t\t\tcase 6: FP_PACK_DP (rd, DR); break;\n\t\t\tcase 7: FP_PACK_QP (rd, QR); break;\n\t\t\t}\n\t\t}\n\n\t\tif(_fex != 0)\n\t\t\treturn record_exception(regs, _fex);\n\n\t\t/* Success and no exceptions detected. */\n\t\tcurrent_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);\n\t\tregs->tpc = regs->tnpc;\n\t\tregs->tnpc += 4;\n\t\treturn 1;\n\t}\nerr:\treturn 0;\n}\n",
        "linevul": 9.081278403755277e-05,
        "sysevr": 0.5321882963180542,
        "devign": 0.9935187697410583
    },
    {
        "code": "queue_90percent_full(struct nvmet_fc_tgt_queue *q, u32 sqhd)\n{\n\tu32 sqtail, used;\n\n\t/* egad, this is ugly. And sqtail is just a best guess */\n\tsqtail = atomic_read(&q->sqtail) % q->sqsize;\n\n\tused = (sqtail < sqhd) ? (sqtail + q->sqsize - sqhd) : (sqtail - sqhd);\n\treturn ((used * 10) >= (((u32)(q->sqsize - 1) * 9)));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0c319d3a144d4b8f1ea2047fd614d2149b68f889",
        "vul_func_with_fix": "queue_90percent_full(struct nvmet_fc_tgt_queue *q, u32 sqhd)\n{\n\tu32 sqtail, used;\n\n\t/* egad, this is ugly. And sqtail is just a best guess */\n\tsqtail = atomic_read(&q->sqtail) % q->sqsize;\n\n\tused = (sqtail < sqhd) ? (sqtail + q->sqsize - sqhd) : (sqtail - sqhd);\n\treturn ((used * 10) >= (((u32)(q->sqsize - 1) * 9)));\n}\n",
        "linevul": 4.741339944303036e-05,
        "sysevr": 0.18460480868816376,
        "devign": 1.794679720589984e-13
    },
    {
        "code": "static int snd_seq_ioctl_set_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tint result;\n\n\tresult = snd_seq_set_queue_tempo(client->number, tempo);\n\treturn result < 0 ? result : 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
        "vul_func_with_fix": "static int snd_seq_ioctl_set_queue_tempo(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_tempo *tempo = arg;\n\tint result;\n\n\tresult = snd_seq_set_queue_tempo(client->number, tempo);\n\treturn result < 0 ? result : 0;\n}\n",
        "linevul": 4.760223600897007e-05,
        "sysevr": 0.12593816220760345,
        "devign": 1.273363969822583e-09
    },
    {
        "code": "static bool blk_mq_hctx_has_pending(struct blk_mq_hw_ctx *hctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hctx->ctx_map.size; i++)\n\t\tif (hctx->ctx_map.map[i].word)\n\t\t\treturn true;\n\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9",
        "vul_func_with_fix": "static bool blk_mq_hctx_has_pending(struct blk_mq_hw_ctx *hctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hctx->ctx_map.size; i++)\n\t\tif (hctx->ctx_map.map[i].word)\n\t\t\treturn true;\n\n\treturn false;\n}\n",
        "linevul": 5.052412234363146e-05,
        "sysevr": 0.12325265258550644,
        "devign": 6.891574623375826e-19
    },
    {
        "code": "static int check_eofblocks_fl(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_lblk_t lblk,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      unsigned int len)\n{\n\tint i, depth;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *last_ex;\n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))\n\t\treturn 0;\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\n\t/*\n\t * We're going to remove EOFBLOCKS_FL entirely in future so we\n\t * do not care for this case anymore. Simply remove the flag\n\t * if there are no extents.\n\t */\n\tif (unlikely(!eh->eh_entries))\n\t\tgoto out;\n\tlast_ex = EXT_LAST_EXTENT(eh);\n\t/*\n\t * We should clear the EOFBLOCKS_FL flag if we are writing the\n\t * last block in the last extent in the file.  We test this by\n\t * first checking to see if the caller to\n\t * ext4_ext_get_blocks() was interested in the last block (or\n\t * a block beyond the last block) in the current extent.  If\n\t * this turns out to be false, we can bail out from this\n\t * function immediately.\n\t */\n\tif (lblk + len < le32_to_cpu(last_ex->ee_block) +\n\t    ext4_ext_get_actual_len(last_ex))\n\t\treturn 0;\n\t/*\n\t * If the caller does appear to be planning to write at or\n\t * beyond the end of the current extent, we then test to see\n\t * if the current extent is the last extent in the file, by\n\t * checking to make sure it was reached via the rightmost node\n\t * at each level of the tree.\n\t */\n\tfor (i = depth-1; i >= 0; i--)\n\t\tif (path[i].p_idx != EXT_LAST_INDEX(path[i].p_hdr))\n\t\t\treturn 0;\nout:\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\treturn ext4_mark_inode_dirty(handle, inode);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "vul_func_with_fix": "static int check_eofblocks_fl(handle_t *handle, struct inode *inode,\n\t\t\t      ext4_lblk_t lblk,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      unsigned int len)\n{\n\tint i, depth;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *last_ex;\n\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))\n\t\treturn 0;\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\n\t/*\n\t * We're going to remove EOFBLOCKS_FL entirely in future so we\n\t * do not care for this case anymore. Simply remove the flag\n\t * if there are no extents.\n\t */\n\tif (unlikely(!eh->eh_entries))\n\t\tgoto out;\n\tlast_ex = EXT_LAST_EXTENT(eh);\n\t/*\n\t * We should clear the EOFBLOCKS_FL flag if we are writing the\n\t * last block in the last extent in the file.  We test this by\n\t * first checking to see if the caller to\n\t * ext4_ext_get_blocks() was interested in the last block (or\n\t * a block beyond the last block) in the current extent.  If\n\t * this turns out to be false, we can bail out from this\n\t * function immediately.\n\t */\n\tif (lblk + len < le32_to_cpu(last_ex->ee_block) +\n\t    ext4_ext_get_actual_len(last_ex))\n\t\treturn 0;\n\t/*\n\t * If the caller does appear to be planning to write at or\n\t * beyond the end of the current extent, we then test to see\n\t * if the current extent is the last extent in the file, by\n\t * checking to make sure it was reached via the rightmost node\n\t * at each level of the tree.\n\t */\n\tfor (i = depth-1; i >= 0; i--)\n\t\tif (path[i].p_idx != EXT_LAST_INDEX(path[i].p_hdr))\n\t\t\treturn 0;\nout:\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\treturn ext4_mark_inode_dirty(handle, inode);\n}\n",
        "linevul": 0.00015140966570470482,
        "sysevr": 0.1949925571680069,
        "devign": 2.3992529425871656e-13
    },
    {
        "code": "static int posix_get_boottime(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tget_monotonic_boottime64(tp);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cef31d9af908243421258f1df35a4a644604efbe",
        "vul_func_with_fix": "static int posix_get_boottime(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tget_monotonic_boottime64(tp);\n\treturn 0;\n}\n",
        "linevul": 5.2257753850426525e-05,
        "sysevr": 0.12918666005134583,
        "devign": 0.03013264387845993
    },
    {
        "code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n \tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n \n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n \tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d846f71195d57b0bbb143382647c2c6638b04c5a",
        "vul_func_with_fix": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* overflow check */\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n \tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n \n//fix_flaw_line_below:\n//\ttmp.name[sizeof(tmp.name) - 1] = 0;\n//fix_flaw_line_below:\n//\n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n \tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}\n",
        "linevul": 0.0007890884880907834,
        "sysevr": 0.16567713022232056,
        "devign": 0.6108028888702393
    },
    {
        "code": "static void irda_selective_discovery_indication(discinfo_t *discovery,\n\t\t\t\t\t\tDISCOVERY_MODE mode,\n\t\t\t\t\t\tvoid *priv)\n{\n\tstruct irda_sock *self;\n\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\n\tself = priv;\n\tif (!self) {\n\t\tIRDA_WARNING(\"%s: lost myself!\\n\", __func__);\n\t\treturn;\n\t}\n\n\t/* Pass parameter to the caller */\n\tself->cachedaddr = discovery->daddr;\n\n\t/* Wake up process if its waiting for device to be discovered */\n\twake_up_interruptible(&self->query_wait);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5ae94c0d2f0bed41d6718be743985d61b7f5c47d",
        "vul_func_with_fix": "static void irda_selective_discovery_indication(discinfo_t *discovery,\n\t\t\t\t\t\tDISCOVERY_MODE mode,\n\t\t\t\t\t\tvoid *priv)\n{\n\tstruct irda_sock *self;\n\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\n\tself = priv;\n\tif (!self) {\n\t\tIRDA_WARNING(\"%s: lost myself!\\n\", __func__);\n\t\treturn;\n\t}\n\n\t/* Pass parameter to the caller */\n\tself->cachedaddr = discovery->daddr;\n\n\t/* Wake up process if its waiting for device to be discovered */\n\twake_up_interruptible(&self->query_wait);\n}\n",
        "linevul": 4.6132543502608314e-05,
        "sysevr": 0.131258025765419,
        "devign": 9.409105672375517e-08
    },
    {
        "code": "static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t  struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;\n\tconst int nonblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tunsigned long cpu_flags;\n\tsize_t copied = 0;\n\tu32 peek_seq = 0;\n\tu32 *seq;\n\tunsigned long used;\n \tint target;\t/* Read at least this many bytes */\n \tlong timeo;\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\tseq = &llc->copied_seq;\n\tif (flags & MSG_PEEK) {\n\t\tpeek_seq = llc->copied_seq;\n\t\tseq = &peek_seq;\n\t}\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tcopied = 0;\n\n\tdo {\n\t\tu32 offset;\n\n\t\t/*\n\t\t * We need to check signals first, to get correct SIGURG\n\t\t * handling. FIXME: Need to check this doesn't impact 1003.1g\n\t\t * and move it down to the bottom of the loop\n\t\t */\n\t\tif (signal_pending(current)) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\tcopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Next get a buffer. */\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\toffset = *seq;\n\t\t\tgoto found_ok_skb;\n\t\t}\n\t\t/* Well, if we have backlog, try to process it now yet. */\n\n\t\tif (copied >= target && !sk->sk_backlog.tail)\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    (flags & MSG_PEEK))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This occurs when user tries to read\n\t\t\t\t\t * from never connected socket.\n\t\t\t\t\t */\n\t\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (copied >= target) { /* Do not sleep, just process backlog. */\n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tsk_wait_data(sk, &timeo);\n\n\t\tif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\n\t\t\tnet_dbg_ratelimited(\"LLC(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = llc->copied_seq;\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\t/* Ok so how much can we use? */\n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\tint rc = skb_copy_datagram_iovec(skb, offset,\n\t\t\t\t\t\t\t msg->msg_iov, used);\n\t\t\tif (rc) {\n\t\t\t\t/* Exception. Bailout! */\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\t/* For non stream protcols we get one packet per recvmsg call */\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\tgoto copy_uaddr;\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\tsk_eat_skb(sk, skb, false);\n\t\t\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\t*seq = 0;\n\t\t}\n\n\t\t/* Partial read */\n\t\tif (used + offset < skb->len)\n\t\t\tcontinue;\n\t} while (len > 0);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\ncopy_uaddr:\n\tif (uaddr != NULL && skb != NULL) {\n\t\tmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\n\t\tmsg->msg_namelen = sizeof(*uaddr);\n\t}\n\tif (llc_sk(sk)->cmsg_flags)\n\t\tllc_cmsg_rcv(msg, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\t\tspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\tsk_eat_skb(sk, skb, false);\n\t\t\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\t*seq = 0;\n\t}\n\n\tgoto out;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t  struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;\n\tconst int nonblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb = NULL;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tunsigned long cpu_flags;\n\tsize_t copied = 0;\n\tu32 peek_seq = 0;\n\tu32 *seq;\n\tunsigned long used;\n \tint target;\t/* Read at least this many bytes */\n \tlong timeo;\n \n//flaw_line_below:\n\tmsg->msg_namelen = 0;\n//flaw_line_below:\n\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\n\t\tgoto out;\n\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\n\tseq = &llc->copied_seq;\n\tif (flags & MSG_PEEK) {\n\t\tpeek_seq = llc->copied_seq;\n\t\tseq = &peek_seq;\n\t}\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tcopied = 0;\n\n\tdo {\n\t\tu32 offset;\n\n\t\t/*\n\t\t * We need to check signals first, to get correct SIGURG\n\t\t * handling. FIXME: Need to check this doesn't impact 1003.1g\n\t\t * and move it down to the bottom of the loop\n\t\t */\n\t\tif (signal_pending(current)) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\tcopied = timeo ? sock_intr_errno(timeo) : -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Next get a buffer. */\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\toffset = *seq;\n\t\t\tgoto found_ok_skb;\n\t\t}\n\t\t/* Well, if we have backlog, try to process it now yet. */\n\n\t\tif (copied >= target && !sk->sk_backlog.tail)\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    (flags & MSG_PEEK))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This occurs when user tries to read\n\t\t\t\t\t * from never connected socket.\n\t\t\t\t\t */\n\t\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (copied >= target) { /* Do not sleep, just process backlog. */\n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tsk_wait_data(sk, &timeo);\n\n\t\tif ((flags & MSG_PEEK) && peek_seq != llc->copied_seq) {\n\t\t\tnet_dbg_ratelimited(\"LLC(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = llc->copied_seq;\n\t\t}\n\t\tcontinue;\n\tfound_ok_skb:\n\t\t/* Ok so how much can we use? */\n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\tint rc = skb_copy_datagram_iovec(skb, offset,\n\t\t\t\t\t\t\t msg->msg_iov, used);\n\t\t\tif (rc) {\n\t\t\t\t/* Exception. Bailout! */\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*seq += used;\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\t/* For non stream protcols we get one packet per recvmsg call */\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\tgoto copy_uaddr;\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\tsk_eat_skb(sk, skb, false);\n\t\t\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\t*seq = 0;\n\t\t}\n\n\t\t/* Partial read */\n\t\tif (used + offset < skb->len)\n\t\t\tcontinue;\n\t} while (len > 0);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\ncopy_uaddr:\n\tif (uaddr != NULL && skb != NULL) {\n\t\tmemcpy(uaddr, llc_ui_skb_cb(skb), sizeof(*uaddr));\n\t\tmsg->msg_namelen = sizeof(*uaddr);\n\t}\n\tif (llc_sk(sk)->cmsg_flags)\n\t\tllc_cmsg_rcv(msg, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\t\tspin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\tsk_eat_skb(sk, skb, false);\n\t\t\tspin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);\n\t\t\t*seq = 0;\n\t}\n\n\tgoto out;\n}\n",
        "linevul": 0.9993261098861694,
        "sysevr": 0.2063995897769928,
        "devign": 0.9431068301200867
    },
    {
        "code": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\t/* note: a 0-length skb is used as an error indication */\n\tif (skb->len > 0) {\n\t\tskb_checksum_complete_unset(skb);\n#ifdef CONFIG_PPP_MULTILINK\n\t\t/* XXX do channel-level decompression here */\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif /* CONFIG_PPP_MULTILINK */\n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t\tppp_receive_error(ppp);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "vul_func_with_fix": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\t/* note: a 0-length skb is used as an error indication */\n\tif (skb->len > 0) {\n\t\tskb_checksum_complete_unset(skb);\n#ifdef CONFIG_PPP_MULTILINK\n\t\t/* XXX do channel-level decompression here */\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif /* CONFIG_PPP_MULTILINK */\n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t\tppp_receive_error(ppp);\n\t}\n}\n",
        "linevul": 4.757945134770125e-05,
        "sysevr": 0.1674197018146515,
        "devign": 0.0010284176096320152
    },
    {
        "code": "static int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\n{\n\tshort *nums = func->interfaces_nums;\n\tunsigned count = func->ffs->interfaces_count;\n\n\tfor (; count; --count, ++nums) {\n\t\tif (*nums >= 0 && *nums == intf)\n\t\t\treturn nums - func->interfaces_nums;\n\t}\n\n\treturn -EDOM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "vul_func_with_fix": "static int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\n{\n\tshort *nums = func->interfaces_nums;\n\tunsigned count = func->ffs->interfaces_count;\n\n\tfor (; count; --count, ++nums) {\n\t\tif (*nums >= 0 && *nums == intf)\n\t\t\treturn nums - func->interfaces_nums;\n\t}\n\n\treturn -EDOM;\n}\n",
        "linevul": 5.3554977057501674e-05,
        "sysevr": 0.12463396787643433,
        "devign": 2.9426456930881084e-12
    },
    {
        "code": "static int cxusb_mt352_demod_init(struct dvb_frontend* fe)\n{\t/* used in both lgz201 and th7579 */\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x29 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x24, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc",
        "vul_func_with_fix": "static int cxusb_mt352_demod_init(struct dvb_frontend* fe)\n{\t/* used in both lgz201 and th7579 */\n\tstatic u8 clock_config []  = { CLOCK_CTL,  0x38, 0x29 };\n\tstatic u8 reset []         = { RESET,      0x80 };\n\tstatic u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };\n\tstatic u8 agc_cfg []       = { AGC_TARGET, 0x24, 0x20 };\n\tstatic u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };\n\tstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\n\n\tmt352_write(fe, clock_config,   sizeof(clock_config));\n\tudelay(200);\n\tmt352_write(fe, reset,          sizeof(reset));\n\tmt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));\n\n\tmt352_write(fe, agc_cfg,        sizeof(agc_cfg));\n\tmt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));\n\tmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\n\treturn 0;\n}\n",
        "linevul": 4.659732439904474e-05,
        "sysevr": 0.1322004497051239,
        "devign": 4.555157986918523e-11
    },
    {
        "code": "static int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\n{\n\tint ret;\n\n\ttl_hba->dev.bus = &tcm_loop_lld_bus;\n\ttl_hba->dev.parent = tcm_loop_primary;\n\ttl_hba->dev.release = &tcm_loop_release_adapter;\n\tdev_set_name(&tl_hba->dev, \"tcm_loop_adapter_%d\", tcm_loop_host_id);\n\n\tret = device_register(&tl_hba->dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"device_register() failed for\"\n\t\t\t\t\" tl_hba->dev: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8",
        "vul_func_with_fix": "static int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\n{\n\tint ret;\n\n\ttl_hba->dev.bus = &tcm_loop_lld_bus;\n\ttl_hba->dev.parent = tcm_loop_primary;\n\ttl_hba->dev.release = &tcm_loop_release_adapter;\n\tdev_set_name(&tl_hba->dev, \"tcm_loop_adapter_%d\", tcm_loop_host_id);\n\n\tret = device_register(&tl_hba->dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"device_register() failed for\"\n\t\t\t\t\" tl_hba->dev: %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 5.554562812903896e-05,
        "sysevr": 0.13709047436714172,
        "devign": 1.1471082601594712e-13
    },
    {
        "code": "static int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n \tif (is_machine_check(intr_info))\n \t\treturn handle_machine_check(vcpu);\n \n\tif ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)\n \t\treturn 1;  /* already handled by vmx_vcpu_run() */\n \n \tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388",
        "vul_func_with_fix": "static int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n \tif (is_machine_check(intr_info))\n \t\treturn handle_machine_check(vcpu);\n \n//flaw_line_below:\n\tif ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)\n//fix_flaw_line_below:\n//\tif (is_nmi(intr_info))\n \t\treturn 1;  /* already handled by vmx_vcpu_run() */\n \n \tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "linevul": 0.9988771080970764,
        "sysevr": 0.18912678956985474,
        "devign": 0.9452205300331116
    },
    {
        "code": "int emulate_clts(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n\tkvm_x86_ops->fpu_activate(vcpu);\n\treturn X86EMUL_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fc3a9157d3148ab91039c75423da8ef97be3e105",
        "vul_func_with_fix": "int emulate_clts(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n\tkvm_x86_ops->fpu_activate(vcpu);\n\treturn X86EMUL_CONTINUE;\n}\n",
        "linevul": 4.843563510803506e-05,
        "sysevr": 0.15061059594154358,
        "devign": 0.0739767849445343
    },
    {
        "code": "SYSCALL_DEFINE3(execve,\n\t\tconst char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp)\n{\n\tstruct filename *path = getname(filename);\n\tint error = PTR_ERR(path);\n\tif (!IS_ERR(path)) {\n\t\terror = do_execve(path->name, argv, envp);\n\t\tputname(path);\n\t}\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348",
        "vul_func_with_fix": "SYSCALL_DEFINE3(execve,\n\t\tconst char __user *, filename,\n\t\tconst char __user *const __user *, argv,\n\t\tconst char __user *const __user *, envp)\n{\n\tstruct filename *path = getname(filename);\n\tint error = PTR_ERR(path);\n\tif (!IS_ERR(path)) {\n\t\terror = do_execve(path->name, argv, envp);\n\t\tputname(path);\n\t}\n\treturn error;\n}\n",
        "linevul": 7.776373240631074e-05,
        "sysevr": 0.19485697150230408,
        "devign": 0.38140180706977844
    },
    {
        "code": "static void init_sched_groups_power(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_domain *child;\n\tstruct sched_group *group;\n\tlong power;\n\tint weight;\n\n\tWARN_ON(!sd || !sd->groups);\n\n\tif (cpu != group_first_cpu(sd->groups))\n\t\treturn;\n\n\tsd->groups->group_weight = cpumask_weight(sched_group_cpus(sd->groups));\n\n\tchild = sd->child;\n\n\tsd->groups->cpu_power = 0;\n\n\tif (!child) {\n\t\tpower = SCHED_LOAD_SCALE;\n\t\tweight = cpumask_weight(sched_domain_span(sd));\n\t\t/*\n\t\t * SMT siblings share the power of a single core.\n\t\t * Usually multiple threads get a better yield out of\n\t\t * that one core than a single thread would have,\n\t\t * reflect that in sd->smt_gain.\n\t\t */\n\t\tif ((sd->flags & SD_SHARE_CPUPOWER) && weight > 1) {\n\t\t\tpower *= sd->smt_gain;\n\t\t\tpower /= weight;\n\t\t\tpower >>= SCHED_LOAD_SHIFT;\n\t\t}\n\t\tsd->groups->cpu_power += power;\n\t\treturn;\n\t}\n\n\t/*\n\t * Add cpu_power of each child group to this groups cpu_power.\n\t */\n\tgroup = child->groups;\n\tdo {\n\t\tsd->groups->cpu_power += group->cpu_power;\n\t\tgroup = group->next;\n\t} while (group != child->groups);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": "static void init_sched_groups_power(int cpu, struct sched_domain *sd)\n{\n\tstruct sched_domain *child;\n\tstruct sched_group *group;\n\tlong power;\n\tint weight;\n\n\tWARN_ON(!sd || !sd->groups);\n\n\tif (cpu != group_first_cpu(sd->groups))\n\t\treturn;\n\n\tsd->groups->group_weight = cpumask_weight(sched_group_cpus(sd->groups));\n\n\tchild = sd->child;\n\n\tsd->groups->cpu_power = 0;\n\n\tif (!child) {\n\t\tpower = SCHED_LOAD_SCALE;\n\t\tweight = cpumask_weight(sched_domain_span(sd));\n\t\t/*\n\t\t * SMT siblings share the power of a single core.\n\t\t * Usually multiple threads get a better yield out of\n\t\t * that one core than a single thread would have,\n\t\t * reflect that in sd->smt_gain.\n\t\t */\n\t\tif ((sd->flags & SD_SHARE_CPUPOWER) && weight > 1) {\n\t\t\tpower *= sd->smt_gain;\n\t\t\tpower /= weight;\n\t\t\tpower >>= SCHED_LOAD_SHIFT;\n\t\t}\n\t\tsd->groups->cpu_power += power;\n\t\treturn;\n\t}\n\n\t/*\n\t * Add cpu_power of each child group to this groups cpu_power.\n\t */\n\tgroup = child->groups;\n\tdo {\n\t\tsd->groups->cpu_power += group->cpu_power;\n\t\tgroup = group->next;\n\t} while (group != child->groups);\n}\n",
        "linevul": 4.961503145750612e-05,
        "sysevr": 0.14890117943286896,
        "devign": 5.116714419273194e-06
    },
    {
        "code": "static int send_abort(struct iwch_ep *ep, struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cpl_abort_req *req;\n\n\tPDBG(\"%s ep %p\\n\", __func__, ep);\n\tskb = get_skb(skb, sizeof(*req), gfp);\n\tif (!skb) {\n\t\tprintk(KERN_ERR MOD \"%s - failed to alloc skb.\\n\",\n\t\t       __func__);\n\t\treturn -ENOMEM;\n\t}\n\tskb->priority = CPL_PRIORITY_DATA;\n\tset_arp_failure_handler(skb, abort_arp_failure);\n\treq = (struct cpl_abort_req *) skb_put(skb, sizeof(*req));\n\tmemset(req, 0, sizeof(*req));\n\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ));\n\treq->wr.wr_lo = htonl(V_WR_TID(ep->hwtid));\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ABORT_REQ, ep->hwtid));\n\treq->cmd = CPL_ABORT_SEND_RST;\n\treturn iwch_l2t_send(ep->com.tdev, skb, ep->l2t);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3",
        "vul_func_with_fix": "static int send_abort(struct iwch_ep *ep, struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cpl_abort_req *req;\n\n\tPDBG(\"%s ep %p\\n\", __func__, ep);\n\tskb = get_skb(skb, sizeof(*req), gfp);\n\tif (!skb) {\n\t\tprintk(KERN_ERR MOD \"%s - failed to alloc skb.\\n\",\n\t\t       __func__);\n\t\treturn -ENOMEM;\n\t}\n\tskb->priority = CPL_PRIORITY_DATA;\n\tset_arp_failure_handler(skb, abort_arp_failure);\n\treq = (struct cpl_abort_req *) skb_put(skb, sizeof(*req));\n\tmemset(req, 0, sizeof(*req));\n\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ));\n\treq->wr.wr_lo = htonl(V_WR_TID(ep->hwtid));\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ABORT_REQ, ep->hwtid));\n\treq->cmd = CPL_ABORT_SEND_RST;\n\treturn iwch_l2t_send(ep->com.tdev, skb, ep->l2t);\n}\n",
        "linevul": 4.993352195015177e-05,
        "sysevr": 0.13995295763015747,
        "devign": 3.103387684445316e-18
    },
    {
        "code": "static void task_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t       struct perf_event_context *ctx,\n\t\t\t       enum event_type_t event_type)\n{\n\tif (!cpuctx->task_ctx)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(ctx != cpuctx->task_ctx))\n\t\treturn;\n\n\tctx_sched_out(ctx, cpuctx, event_type);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1572e45a924f254d9570093abde46430c3172e3d",
        "vul_func_with_fix": "static void task_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t       struct perf_event_context *ctx,\n\t\t\t       enum event_type_t event_type)\n{\n\tif (!cpuctx->task_ctx)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(ctx != cpuctx->task_ctx))\n\t\treturn;\n\n\tctx_sched_out(ctx, cpuctx, event_type);\n}\n",
        "linevul": 5.0738835852826014e-05,
        "sysevr": 0.13303422927856445,
        "devign": 2.291847600588426e-09
    },
    {
        "code": "static int bt_get(struct blk_mq_alloc_data *data,\n\t\tstruct blk_mq_bitmap_tags *bt,\n\t\tstruct blk_mq_hw_ctx *hctx,\n\t\tunsigned int *last_tag, struct blk_mq_tags *tags)\n{\n\tstruct bt_wait_state *bs;\n\tDEFINE_WAIT(wait);\n\tint tag;\n\n\ttag = __bt_get(hctx, bt, last_tag, tags);\n\tif (tag != -1)\n\t\treturn tag;\n\n\tif (!(data->gfp & __GFP_WAIT))\n\t\treturn -1;\n\n\tbs = bt_wait_ptr(bt, hctx);\n\tdo {\n\t\tprepare_to_wait(&bs->wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\ttag = __bt_get(hctx, bt, last_tag, tags);\n\t\tif (tag != -1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We're out of tags on this hardware queue, kick any\n\t\t * pending IO submits before going to sleep waiting for\n\t\t * some to complete. Note that hctx can be NULL here for\n\t\t * reserved tag allocation.\n\t\t */\n\t\tif (hctx)\n\t\t\tblk_mq_run_hw_queue(hctx, false);\n\n\t\t/*\n\t\t * Retry tag allocation after running the hardware queue,\n\t\t * as running the queue may also have found completions.\n\t\t */\n\t\ttag = __bt_get(hctx, bt, last_tag, tags);\n\t\tif (tag != -1)\n\t\t\tbreak;\n\n\t\tblk_mq_put_ctx(data->ctx);\n\n\t\tio_schedule();\n\n\t\tdata->ctx = blk_mq_get_ctx(data->q);\n\t\tdata->hctx = data->q->mq_ops->map_queue(data->q,\n\t\t\t\tdata->ctx->cpu);\n\t\tif (data->reserved) {\n\t\t\tbt = &data->hctx->tags->breserved_tags;\n\t\t} else {\n\t\t\tlast_tag = &data->ctx->last_tag;\n\t\t\thctx = data->hctx;\n\t\t\tbt = &hctx->tags->bitmap_tags;\n\t\t}\n\t\tfinish_wait(&bs->wait, &wait);\n\t\tbs = bt_wait_ptr(bt, hctx);\n\t} while (1);\n\n\tfinish_wait(&bs->wait, &wait);\n\treturn tag;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9",
        "vul_func_with_fix": "static int bt_get(struct blk_mq_alloc_data *data,\n\t\tstruct blk_mq_bitmap_tags *bt,\n\t\tstruct blk_mq_hw_ctx *hctx,\n\t\tunsigned int *last_tag, struct blk_mq_tags *tags)\n{\n\tstruct bt_wait_state *bs;\n\tDEFINE_WAIT(wait);\n\tint tag;\n\n\ttag = __bt_get(hctx, bt, last_tag, tags);\n\tif (tag != -1)\n\t\treturn tag;\n\n\tif (!(data->gfp & __GFP_WAIT))\n\t\treturn -1;\n\n\tbs = bt_wait_ptr(bt, hctx);\n\tdo {\n\t\tprepare_to_wait(&bs->wait, &wait, TASK_UNINTERRUPTIBLE);\n\n\t\ttag = __bt_get(hctx, bt, last_tag, tags);\n\t\tif (tag != -1)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We're out of tags on this hardware queue, kick any\n\t\t * pending IO submits before going to sleep waiting for\n\t\t * some to complete. Note that hctx can be NULL here for\n\t\t * reserved tag allocation.\n\t\t */\n\t\tif (hctx)\n\t\t\tblk_mq_run_hw_queue(hctx, false);\n\n\t\t/*\n\t\t * Retry tag allocation after running the hardware queue,\n\t\t * as running the queue may also have found completions.\n\t\t */\n\t\ttag = __bt_get(hctx, bt, last_tag, tags);\n\t\tif (tag != -1)\n\t\t\tbreak;\n\n\t\tblk_mq_put_ctx(data->ctx);\n\n\t\tio_schedule();\n\n\t\tdata->ctx = blk_mq_get_ctx(data->q);\n\t\tdata->hctx = data->q->mq_ops->map_queue(data->q,\n\t\t\t\tdata->ctx->cpu);\n\t\tif (data->reserved) {\n\t\t\tbt = &data->hctx->tags->breserved_tags;\n\t\t} else {\n\t\t\tlast_tag = &data->ctx->last_tag;\n\t\t\thctx = data->hctx;\n\t\t\tbt = &hctx->tags->bitmap_tags;\n\t\t}\n\t\tfinish_wait(&bs->wait, &wait);\n\t\tbs = bt_wait_ptr(bt, hctx);\n\t} while (1);\n\n\tfinish_wait(&bs->wait, &wait);\n\treturn tag;\n}\n",
        "linevul": 0.042916689068078995,
        "sysevr": 0.1759970486164093,
        "devign": 7.222737685719238e-11
    },
    {
        "code": "static int fanout_set_data(struct packet_sock *po, char __user *data,\n\t\t\t   unsigned int len)\n{\n\tswitch (po->fanout->type) {\n\tcase PACKET_FANOUT_CBPF:\n\t\treturn fanout_set_data_cbpf(po, data, len);\n\tcase PACKET_FANOUT_EBPF:\n\t\treturn fanout_set_data_ebpf(po, data, len);\n\tdefault:\n\t\treturn -EINVAL;\n\t};\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c",
        "vul_func_with_fix": "static int fanout_set_data(struct packet_sock *po, char __user *data,\n\t\t\t   unsigned int len)\n{\n\tswitch (po->fanout->type) {\n\tcase PACKET_FANOUT_CBPF:\n\t\treturn fanout_set_data_cbpf(po, data, len);\n\tcase PACKET_FANOUT_EBPF:\n\t\treturn fanout_set_data_ebpf(po, data, len);\n\tdefault:\n\t\treturn -EINVAL;\n\t};\n}\n",
        "linevul": 5.63250359846279e-05,
        "sysevr": 0.13158699870109558,
        "devign": 0.6026208996772766
    },
    {
        "code": "int dev_change_net_namespace(struct net_device *dev, struct net *net, const char *pat)\n{\n\tint err;\n\n\tASSERT_RTNL();\n\n\t/* Don't allow namespace local devices to be moved. */\n\terr = -EINVAL;\n\tif (dev->features & NETIF_F_NETNS_LOCAL)\n\t\tgoto out;\n\n\t/* Ensure the device has been registrered */\n\terr = -EINVAL;\n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\tgoto out;\n\n\t/* Get out if there is nothing todo */\n\terr = 0;\n\tif (net_eq(dev_net(dev), net))\n\t\tgoto out;\n\n\t/* Pick the destination device name, and ensure\n\t * we can use it in the destination network namespace.\n\t */\n\terr = -EEXIST;\n\tif (__dev_get_by_name(net, dev->name)) {\n\t\t/* We get here if we can't use the current device name */\n\t\tif (!pat)\n\t\t\tgoto out;\n\t\tif (dev_get_valid_name(dev, pat, 1))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * And now a mini version of register_netdevice unregister_netdevice.\n\t */\n\n\t/* If device is running close it first. */\n\tdev_close(dev);\n\n\t/* And unlink it from device chain */\n\terr = -ENODEV;\n\tunlist_netdevice(dev);\n\n\tsynchronize_net();\n\n\t/* Shutdown queueing discipline. */\n\tdev_shutdown(dev);\n\n\t/* Notify protocols, that we are about to destroy\n\t   this device. They should clean all the things.\n\t*/\n\tcall_netdevice_notifiers(NETDEV_UNREGISTER, dev);\n\tcall_netdevice_notifiers(NETDEV_UNREGISTER_BATCH, dev);\n\n\t/*\n\t *\tFlush the unicast and multicast chains\n\t */\n\tdev_uc_flush(dev);\n\tdev_mc_flush(dev);\n\n\t/* Actually switch the network namespace */\n\tdev_net_set(dev, net);\n\n\t/* If there is an ifindex conflict assign a new one */\n\tif (__dev_get_by_index(net, dev->ifindex)) {\n\t\tint iflink = (dev->iflink == dev->ifindex);\n\t\tdev->ifindex = dev_new_index(net);\n\t\tif (iflink)\n\t\t\tdev->iflink = dev->ifindex;\n\t}\n\n\t/* Fixup kobjects */\n\terr = device_rename(&dev->dev, dev->name);\n\tWARN_ON(err);\n\n\t/* Add the device back in the hashes */\n\tlist_netdevice(dev);\n\n\t/* Notify protocols, that a new device appeared. */\n\tcall_netdevice_notifiers(NETDEV_REGISTER, dev);\n\n\t/*\n\t *\tPrevent userspace races by waiting until the network\n\t *\tdevice is fully setup before sending notifications.\n\t */\n\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);\n\n\tsynchronize_net();\n\terr = 0;\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/256df2f3879efdb2e9808bdb1b54b16fbb11fa38",
        "vul_func_with_fix": "int dev_change_net_namespace(struct net_device *dev, struct net *net, const char *pat)\n{\n\tint err;\n\n\tASSERT_RTNL();\n\n\t/* Don't allow namespace local devices to be moved. */\n\terr = -EINVAL;\n\tif (dev->features & NETIF_F_NETNS_LOCAL)\n\t\tgoto out;\n\n\t/* Ensure the device has been registrered */\n\terr = -EINVAL;\n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\tgoto out;\n\n\t/* Get out if there is nothing todo */\n\terr = 0;\n\tif (net_eq(dev_net(dev), net))\n\t\tgoto out;\n\n\t/* Pick the destination device name, and ensure\n\t * we can use it in the destination network namespace.\n\t */\n\terr = -EEXIST;\n\tif (__dev_get_by_name(net, dev->name)) {\n\t\t/* We get here if we can't use the current device name */\n\t\tif (!pat)\n\t\t\tgoto out;\n\t\tif (dev_get_valid_name(dev, pat, 1))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * And now a mini version of register_netdevice unregister_netdevice.\n\t */\n\n\t/* If device is running close it first. */\n\tdev_close(dev);\n\n\t/* And unlink it from device chain */\n\terr = -ENODEV;\n\tunlist_netdevice(dev);\n\n\tsynchronize_net();\n\n\t/* Shutdown queueing discipline. */\n\tdev_shutdown(dev);\n\n\t/* Notify protocols, that we are about to destroy\n\t   this device. They should clean all the things.\n\t*/\n\tcall_netdevice_notifiers(NETDEV_UNREGISTER, dev);\n\tcall_netdevice_notifiers(NETDEV_UNREGISTER_BATCH, dev);\n\n\t/*\n\t *\tFlush the unicast and multicast chains\n\t */\n\tdev_uc_flush(dev);\n\tdev_mc_flush(dev);\n\n\t/* Actually switch the network namespace */\n\tdev_net_set(dev, net);\n\n\t/* If there is an ifindex conflict assign a new one */\n\tif (__dev_get_by_index(net, dev->ifindex)) {\n\t\tint iflink = (dev->iflink == dev->ifindex);\n\t\tdev->ifindex = dev_new_index(net);\n\t\tif (iflink)\n\t\t\tdev->iflink = dev->ifindex;\n\t}\n\n\t/* Fixup kobjects */\n\terr = device_rename(&dev->dev, dev->name);\n\tWARN_ON(err);\n\n\t/* Add the device back in the hashes */\n\tlist_netdevice(dev);\n\n\t/* Notify protocols, that a new device appeared. */\n\tcall_netdevice_notifiers(NETDEV_REGISTER, dev);\n\n\t/*\n\t *\tPrevent userspace races by waiting until the network\n\t *\tdevice is fully setup before sending notifications.\n\t */\n\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);\n\n\tsynchronize_net();\n\terr = 0;\nout:\n\treturn err;\n}\n",
        "linevul": 5.767562470282428e-05,
        "sysevr": 0.19056005775928497,
        "devign": 6.404861067474525e-27
    },
    {
        "code": "static int follow_automount(struct path *path, struct nameidata *nd,\n\t\t\t    bool *need_mntput)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!path->dentry->d_op || !path->dentry->d_op->d_automount)\n\t\treturn -EREMOTE;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(nd->flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t\t   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    path->dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tnd->total_link_count++;\n\tif (nd->total_link_count >= 40)\n\t\treturn -ELOOP;\n\n\tmnt = path->dentry->d_op->d_automount(path);\n\tif (IS_ERR(mnt)) {\n\t\t/*\n\t\t * The filesystem is allowed to return -EISDIR here to indicate\n\t\t * it doesn't want to automount.  For instance, autofs would do\n\t\t * this so that its userspace daemon can mount on this dentry.\n\t\t *\n\t\t * However, we can only permit this if it's a terminal point in\n\t\t * the path being looked up; if it wasn't then the remainder of\n\t\t * the path is inaccessible and we should say so.\n\t\t */\n\t\tif (PTR_ERR(mnt) == -EISDIR && (nd->flags & LOOKUP_PARENT))\n\t\t\treturn -EREMOTE;\n\t\treturn PTR_ERR(mnt);\n\t}\n\n\tif (!mnt) /* mount collision */\n\t\treturn 0;\n\n\tif (!*need_mntput) {\n\t\t/* lock_mount() may release path->mnt on error */\n\t\tmntget(path->mnt);\n\t\t*need_mntput = true;\n\t}\n\terr = finish_automount(mnt, path);\n\n\tswitch (err) {\n\tcase -EBUSY:\n\t\t/* Someone else made a mount here whilst we were busy */\n\t\treturn 0;\n\tcase 0:\n\t\tpath_put(path);\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dget(mnt->mnt_root);\n\t\treturn 0;\n\tdefault:\n\t\treturn err;\n\t}\n\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "vul_func_with_fix": "static int follow_automount(struct path *path, struct nameidata *nd,\n\t\t\t    bool *need_mntput)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!path->dentry->d_op || !path->dentry->d_op->d_automount)\n\t\treturn -EREMOTE;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(nd->flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t\t   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    path->dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tnd->total_link_count++;\n\tif (nd->total_link_count >= 40)\n\t\treturn -ELOOP;\n\n\tmnt = path->dentry->d_op->d_automount(path);\n\tif (IS_ERR(mnt)) {\n\t\t/*\n\t\t * The filesystem is allowed to return -EISDIR here to indicate\n\t\t * it doesn't want to automount.  For instance, autofs would do\n\t\t * this so that its userspace daemon can mount on this dentry.\n\t\t *\n\t\t * However, we can only permit this if it's a terminal point in\n\t\t * the path being looked up; if it wasn't then the remainder of\n\t\t * the path is inaccessible and we should say so.\n\t\t */\n\t\tif (PTR_ERR(mnt) == -EISDIR && (nd->flags & LOOKUP_PARENT))\n\t\t\treturn -EREMOTE;\n\t\treturn PTR_ERR(mnt);\n\t}\n\n\tif (!mnt) /* mount collision */\n\t\treturn 0;\n\n\tif (!*need_mntput) {\n\t\t/* lock_mount() may release path->mnt on error */\n\t\tmntget(path->mnt);\n\t\t*need_mntput = true;\n\t}\n\terr = finish_automount(mnt, path);\n\n\tswitch (err) {\n\tcase -EBUSY:\n\t\t/* Someone else made a mount here whilst we were busy */\n\t\treturn 0;\n\tcase 0:\n\t\tpath_put(path);\n\t\tpath->mnt = mnt;\n\t\tpath->dentry = dget(mnt->mnt_root);\n\t\treturn 0;\n\tdefault:\n\t\treturn err;\n\t}\n\n}\n",
        "linevul": 0.00020866510749328882,
        "sysevr": 0.17451803386211395,
        "devign": 1.4716168409053893e-27
    },
    {
        "code": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n {\n \tstruct hstate *h = hstate_inode(inode);\n \tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n \n \tspin_lock(&inode->i_lock);\n \tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n \tspin_unlock(&inode->i_lock);\n \n\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n \thugetlb_acct_memory(h, -(chg - freed));\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029",
        "vul_func_with_fix": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n {\n \tstruct hstate *h = hstate_inode(inode);\n \tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n//fix_flaw_line_below:\n//\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \tspin_lock(&inode->i_lock);\n \tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n \tspin_unlock(&inode->i_lock);\n \n//flaw_line_below:\n\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n//fix_flaw_line_below:\n//\thugepage_subpool_put_pages(spool, (chg - freed));\n \thugetlb_acct_memory(h, -(chg - freed));\n }\n",
        "linevul": 0.9995831847190857,
        "sysevr": 0.18863697350025177,
        "devign": 0.993513286113739
    },
    {
        "code": "static void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->type_data.link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0",
        "vul_func_with_fix": "static void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->type_data.link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n",
        "linevul": 0.00019143587269354612,
        "sysevr": 0.13010340929031372,
        "devign": 3.61578877949853e-09
    },
    {
        "code": "SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t/*\n\t * Obtain the first socket and check if the underlying protocol\n\t * supports the socketpair call.\n\t */\n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (err < 0)\n\t\tgoto out_release_1;\n\n\terr = sock1->ops->socketpair(sock1, sock2);\n\tif (err < 0)\n\t\tgoto out_release_both;\n\n\tfd1 = sock_alloc_file(sock1, &newfile1, flags);\n\tif (unlikely(fd1 < 0)) {\n\t\terr = fd1;\n\t\tgoto out_release_both;\n\t}\n\n\tfd2 = sock_alloc_file(sock2, &newfile2, flags);\n\tif (unlikely(fd2 < 0)) {\n\t\terr = fd2;\n\t\tfput(newfile1);\n\t\tput_unused_fd(fd1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\t/* fd1 and fd2 may be already another descriptors.\n\t * Not kernel problem.\n\t */\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (!err)\n\t\terr = put_user(fd2, &usockvec[1]);\n\tif (!err)\n\t\treturn 0;\n\n\tsys_close(fd2);\n\tsys_close(fd1);\n\treturn err;\n\nout_release_both:\n\tsock_release(sock2);\nout_release_1:\n\tsock_release(sock1);\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "vul_func_with_fix": "SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t/*\n\t * Obtain the first socket and check if the underlying protocol\n\t * supports the socketpair call.\n\t */\n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (err < 0)\n\t\tgoto out_release_1;\n\n\terr = sock1->ops->socketpair(sock1, sock2);\n\tif (err < 0)\n\t\tgoto out_release_both;\n\n\tfd1 = sock_alloc_file(sock1, &newfile1, flags);\n\tif (unlikely(fd1 < 0)) {\n\t\terr = fd1;\n\t\tgoto out_release_both;\n\t}\n\n\tfd2 = sock_alloc_file(sock2, &newfile2, flags);\n\tif (unlikely(fd2 < 0)) {\n\t\terr = fd2;\n\t\tfput(newfile1);\n\t\tput_unused_fd(fd1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\t/* fd1 and fd2 may be already another descriptors.\n\t * Not kernel problem.\n\t */\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (!err)\n\t\terr = put_user(fd2, &usockvec[1]);\n\tif (!err)\n\t\treturn 0;\n\n\tsys_close(fd2);\n\tsys_close(fd1);\n\treturn err;\n\nout_release_both:\n\tsock_release(sock2);\nout_release_1:\n\tsock_release(sock1);\nout:\n\treturn err;\n}\n",
        "linevul": 6.457003473769873e-05,
        "sysevr": 0.2488761991262436,
        "devign": 0.6333134174346924
    },
    {
        "code": "static void set_data_ptr_seg(struct mlx5_wqe_data_seg *dseg, struct ib_sge *sg)\n{\n\tdseg->byte_count = cpu_to_be32(sg->length);\n\tdseg->lkey       = cpu_to_be32(sg->lkey);\n\tdseg->addr       = cpu_to_be64(sg->addr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00",
        "vul_func_with_fix": "static void set_data_ptr_seg(struct mlx5_wqe_data_seg *dseg, struct ib_sge *sg)\n{\n\tdseg->byte_count = cpu_to_be32(sg->length);\n\tdseg->lkey       = cpu_to_be32(sg->lkey);\n\tdseg->addr       = cpu_to_be64(sg->addr);\n}\n",
        "linevul": 0.00027054030215367675,
        "sysevr": 0.12936396896839142,
        "devign": 0.24446289241313934
    },
    {
        "code": " static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\t/* Fill in the dest address from the route entry passed with the skb\n\t * and the source address from the transport.\n\t */\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n \n \tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n \n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n \n \tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n \t\tskb->local_df = 1;\n \n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7",
        "vul_func_with_fix": " static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n {\n \tstruct sock *sk = skb->sk;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n//flaw_line_below:\n\tstruct flowi6 fl6;\n//flaw_line_below:\n\n//flaw_line_below:\n\tmemset(&fl6, 0, sizeof(fl6));\n//flaw_line_below:\n\n//flaw_line_below:\n\tfl6.flowi6_proto = sk->sk_protocol;\n//flaw_line_below:\n\n//flaw_line_below:\n\t/* Fill in the dest address from the route entry passed with the skb\n//flaw_line_below:\n\t * and the source address from the transport.\n//flaw_line_below:\n\t */\n//flaw_line_below:\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n//flaw_line_below:\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n//flaw_line_below:\n\n//flaw_line_below:\n\tfl6.flowlabel = np->flow_label;\n//flaw_line_below:\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n//flaw_line_below:\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n//flaw_line_below:\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n//flaw_line_below:\n\telse\n//flaw_line_below:\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (np->opt && np->opt->srcrt) {\n//flaw_line_below:\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n//flaw_line_below:\n\t\tfl6.daddr = *rt0->addr;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n \n \tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n//flaw_line_below:\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n//fix_flaw_line_below:\n//\t\t skb->len, &fl6->saddr, &fl6->daddr);\n \n//flaw_line_below:\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n//fix_flaw_line_below:\n//\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n \n \tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n \t\tskb->local_df = 1;\n \n//flaw_line_below:\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n//fix_flaw_line_below:\n//\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n }\n",
        "linevul": 0.9993425011634827,
        "sysevr": 0.20199140906333923,
        "devign": 2.124112885582008e-09
    },
    {
        "code": "static inline void list_add_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_rq->on_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tint cpu = cpu_of(rq);\n\t\t/*\n\t\t * Ensure we either appear before our parent (if already\n\t\t * enqueued) or force our parent to appear after us when it is\n\t\t * enqueued. The fact that we always enqueue bottom-up\n\t\t * reduces this to two cases and a special case for the root\n\t\t * cfs_rq. Furthermore, it also means that we will always reset\n\t\t * tmp_alone_branch either when the branch is connected\n\t\t * to a tree or when we reach the beg of the tree\n\t\t */\n\t\tif (cfs_rq->tg->parent &&\n\t\t    cfs_rq->tg->parent->cfs_rq[cpu]->on_list) {\n\t\t\t/*\n\t\t\t * If parent is already on the list, we add the child\n\t\t\t * just before. Thanks to circular linked property of\n\t\t\t * the list, this means to put the child at the tail\n\t\t\t * of the list that starts by parent.\n\t\t\t */\n\t\t\tlist_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t\t&(cfs_rq->tg->parent->cfs_rq[cpu]->leaf_cfs_rq_list));\n\t\t\t/*\n\t\t\t * The branch is now connected to its tree so we can\n\t\t\t * reset tmp_alone_branch to the beginning of the\n\t\t\t * list.\n\t\t\t */\n\t\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t} else if (!cfs_rq->tg->parent) {\n\t\t\t/*\n\t\t\t * cfs rq without parent should be put\n\t\t\t * at the tail of the list.\n\t\t\t */\n\t\t\tlist_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t\t&rq->leaf_cfs_rq_list);\n\t\t\t/*\n\t\t\t * We have reach the beg of a tree so we can reset\n\t\t\t * tmp_alone_branch to the beginning of the list.\n\t\t\t */\n\t\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The parent has not already been added so we want to\n\t\t\t * make sure that it will be put after us.\n\t\t\t * tmp_alone_branch points to the beg of the branch\n\t\t\t * where we will add parent.\n\t\t\t */\n\t\t\tlist_add_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t\trq->tmp_alone_branch);\n\t\t\t/*\n\t\t\t * update tmp_alone_branch to points to the new beg\n\t\t\t * of the branch\n\t\t\t */\n\t\t\trq->tmp_alone_branch = &cfs_rq->leaf_cfs_rq_list;\n\t\t}\n\n\t\tcfs_rq->on_list = 1;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static inline void list_add_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_rq->on_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tint cpu = cpu_of(rq);\n\t\t/*\n\t\t * Ensure we either appear before our parent (if already\n\t\t * enqueued) or force our parent to appear after us when it is\n\t\t * enqueued. The fact that we always enqueue bottom-up\n\t\t * reduces this to two cases and a special case for the root\n\t\t * cfs_rq. Furthermore, it also means that we will always reset\n\t\t * tmp_alone_branch either when the branch is connected\n\t\t * to a tree or when we reach the beg of the tree\n\t\t */\n\t\tif (cfs_rq->tg->parent &&\n\t\t    cfs_rq->tg->parent->cfs_rq[cpu]->on_list) {\n\t\t\t/*\n\t\t\t * If parent is already on the list, we add the child\n\t\t\t * just before. Thanks to circular linked property of\n\t\t\t * the list, this means to put the child at the tail\n\t\t\t * of the list that starts by parent.\n\t\t\t */\n\t\t\tlist_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t\t&(cfs_rq->tg->parent->cfs_rq[cpu]->leaf_cfs_rq_list));\n\t\t\t/*\n\t\t\t * The branch is now connected to its tree so we can\n\t\t\t * reset tmp_alone_branch to the beginning of the\n\t\t\t * list.\n\t\t\t */\n\t\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t} else if (!cfs_rq->tg->parent) {\n\t\t\t/*\n\t\t\t * cfs rq without parent should be put\n\t\t\t * at the tail of the list.\n\t\t\t */\n\t\t\tlist_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t\t&rq->leaf_cfs_rq_list);\n\t\t\t/*\n\t\t\t * We have reach the beg of a tree so we can reset\n\t\t\t * tmp_alone_branch to the beginning of the list.\n\t\t\t */\n\t\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The parent has not already been added so we want to\n\t\t\t * make sure that it will be put after us.\n\t\t\t * tmp_alone_branch points to the beg of the branch\n\t\t\t * where we will add parent.\n\t\t\t */\n\t\t\tlist_add_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t\trq->tmp_alone_branch);\n\t\t\t/*\n\t\t\t * update tmp_alone_branch to points to the new beg\n\t\t\t * of the branch\n\t\t\t */\n\t\t\trq->tmp_alone_branch = &cfs_rq->leaf_cfs_rq_list;\n\t\t}\n\n\t\tcfs_rq->on_list = 1;\n\t}\n}\n",
        "linevul": 7.088854181347415e-05,
        "sysevr": 0.2225196659564972,
        "devign": 7.432762231474044e-06
    },
    {
        "code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n {\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601",
        "vul_func_with_fix": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n//fix_flaw_line_below:\n//static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n {\n//flaw_line_below:\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n//fix_flaw_line_below:\n//\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n }\n",
        "linevul": 0.00012251734733581543,
        "sysevr": 0.12741325795650482,
        "devign": 0.9982640147209167
    },
    {
        "code": "bool tcp_alloc_md5sig_pool(void)\n{\n\tif (unlikely(!tcp_md5sig_pool_populated)) {\n\t\tmutex_lock(&tcp_md5sig_mutex);\n\n\t\tif (!tcp_md5sig_pool_populated)\n\t\t\t__tcp_alloc_md5sig_pool();\n\n\t\tmutex_unlock(&tcp_md5sig_mutex);\n\t}\n\treturn tcp_md5sig_pool_populated;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/499350a5a6e7512d9ed369ed63a4244b6536f4f8",
        "vul_func_with_fix": "bool tcp_alloc_md5sig_pool(void)\n{\n\tif (unlikely(!tcp_md5sig_pool_populated)) {\n\t\tmutex_lock(&tcp_md5sig_mutex);\n\n\t\tif (!tcp_md5sig_pool_populated)\n\t\t\t__tcp_alloc_md5sig_pool();\n\n\t\tmutex_unlock(&tcp_md5sig_mutex);\n\t}\n\treturn tcp_md5sig_pool_populated;\n}\n",
        "linevul": 6.490635860245675e-05,
        "sysevr": 0.14949926733970642,
        "devign": 1.2650605185626773e-07
    },
    {
        "code": "static int nfs41_test_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs41_test_stateid(server, stateid),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "vul_func_with_fix": "static int nfs41_test_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs41_test_stateid(server, stateid),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "linevul": 5.1376468036323786e-05,
        "sysevr": 0.12609493732452393,
        "devign": 4.8098641514116025e-08
    },
    {
        "code": "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = current->audit_context;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c",
        "vul_func_with_fix": "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = current->audit_context;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\treturn 0;\n}\n",
        "linevul": 6.237073830561712e-05,
        "sysevr": 0.22273683547973633,
        "devign": 3.0084905260435123e-19
    },
    {
        "code": "struct vfsmount *mnt_clone_internal(struct path *path)\n{\n\tstruct mount *p;\n\tp = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\tp->mnt.mnt_flags |= MNT_INTERNAL;\n\treturn &p->mnt;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "struct vfsmount *mnt_clone_internal(struct path *path)\n{\n\tstruct mount *p;\n\tp = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\tp->mnt.mnt_flags |= MNT_INTERNAL;\n\treturn &p->mnt;\n}\n",
        "linevul": 6.259602378122509e-05,
        "sysevr": 0.13972944021224976,
        "devign": 3.009449192804695e-15
    },
    {
        "code": "static int perf_event_read_group(struct perf_event *event,\n \t\t\t\t   u64 read_format, char __user *buf)\n {\n \tstruct perf_event *leader = event->group_leader, *sub;\n\tint n = 0, size = 0, ret = -EFAULT;\n \tstruct perf_event_context *ctx = leader->ctx;\n\tu64 values[5];\n \tu64 count, enabled, running;\n \n\tmutex_lock(&ctx->mutex);\n \tcount = perf_event_read_value(leader, &enabled, &running);\n \n \tvalues[n++] = 1 + leader->nr_siblings;\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tvalues[n++] = enabled;\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tvalues[n++] = running;\n\tvalues[n++] = count;\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(leader);\n\n \tsize = n * sizeof(u64);\n \n \tif (copy_to_user(buf, values, size))\n\t\tgoto unlock;\n \n \tret = size;\n \n\tlist_for_each_entry(sub, &leader->sibling_list, group_entry) {\n\t\tn = 0;\n\n\t\tvalues[n++] = perf_event_read_value(sub, &enabled, &running);\n\t\tif (read_format & PERF_FORMAT_ID)\n\t\t\tvalues[n++] = primary_event_id(sub);\n\n \t\tsize = n * sizeof(u64);\n \n \t\tif (copy_to_user(buf + ret, values, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n \t\t}\n \n \t\tret += size;\n \t}\nunlock:\n\tmutex_unlock(&ctx->mutex);\n \n \treturn ret;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
        "vul_func_with_fix": "static int perf_event_read_group(struct perf_event *event,\n \t\t\t\t   u64 read_format, char __user *buf)\n {\n \tstruct perf_event *leader = event->group_leader, *sub;\n//flaw_line_below:\n\tint n = 0, size = 0, ret = -EFAULT;\n \tstruct perf_event_context *ctx = leader->ctx;\n//flaw_line_below:\n\tu64 values[5];\n//fix_flaw_line_below:\n//\tint n = 0, size = 0, ret;\n \tu64 count, enabled, running;\n//fix_flaw_line_below:\n//\tu64 values[5];\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tlockdep_assert_held(&ctx->mutex);\n \n//flaw_line_below:\n\tmutex_lock(&ctx->mutex);\n \tcount = perf_event_read_value(leader, &enabled, &running);\n \n \tvalues[n++] = 1 + leader->nr_siblings;\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)\n\t\tvalues[n++] = enabled;\n\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)\n\t\tvalues[n++] = running;\n\tvalues[n++] = count;\n\tif (read_format & PERF_FORMAT_ID)\n\t\tvalues[n++] = primary_event_id(leader);\n\n \tsize = n * sizeof(u64);\n \n \tif (copy_to_user(buf, values, size))\n//flaw_line_below:\n\t\tgoto unlock;\n//fix_flaw_line_below:\n//\t\treturn -EFAULT;\n \n \tret = size;\n \n\tlist_for_each_entry(sub, &leader->sibling_list, group_entry) {\n\t\tn = 0;\n\n\t\tvalues[n++] = perf_event_read_value(sub, &enabled, &running);\n\t\tif (read_format & PERF_FORMAT_ID)\n\t\t\tvalues[n++] = primary_event_id(sub);\n\n \t\tsize = n * sizeof(u64);\n \n \t\tif (copy_to_user(buf + ret, values, size)) {\n//flaw_line_below:\n\t\t\tret = -EFAULT;\n//flaw_line_below:\n\t\t\tgoto unlock;\n//fix_flaw_line_below:\n//\t\t\treturn -EFAULT;\n \t\t}\n \n \t\tret += size;\n \t}\n//flaw_line_below:\nunlock:\n//flaw_line_below:\n\tmutex_unlock(&ctx->mutex);\n \n \treturn ret;\n }\n",
        "linevul": 0.9995949864387512,
        "sysevr": 0.15594619512557983,
        "devign": 0.504452645778656
    },
    {
        "code": "struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
        "vul_func_with_fix": "struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n",
        "linevul": 5.790841896669008e-05,
        "sysevr": 0.129441499710083,
        "devign": 0.00011218252620892599
    },
    {
        "code": "static int vhost_scsi_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_scsi *vs;\n\tstruct vhost_virtqueue **vqs;\n\tint r = -ENOMEM, i;\n\n\tvs = kzalloc(sizeof(*vs), GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!vs) {\n\t\tvs = vzalloc(sizeof(*vs));\n\t\tif (!vs)\n\t\t\tgoto err_vs;\n\t}\n\n\tvqs = kmalloc(VHOST_SCSI_MAX_VQ * sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs)\n\t\tgoto err_vqs;\n\n\tvhost_work_init(&vs->vs_completion_work, vhost_scsi_complete_cmd_work);\n\tvhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);\n\n\tvs->vs_events_nr = 0;\n\tvs->vs_events_missed = false;\n\n\tvqs[VHOST_SCSI_VQ_CTL] = &vs->vqs[VHOST_SCSI_VQ_CTL].vq;\n\tvqs[VHOST_SCSI_VQ_EVT] = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tvs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;\n\tvs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;\n\tfor (i = VHOST_SCSI_VQ_IO; i < VHOST_SCSI_MAX_VQ; i++) {\n\t\tvqs[i] = &vs->vqs[i].vq;\n\t\tvs->vqs[i].vq.handle_kick = vhost_scsi_handle_kick;\n\t}\n\tvhost_dev_init(&vs->dev, vqs, VHOST_SCSI_MAX_VQ);\n\n\tvhost_scsi_init_inflight(vs, NULL);\n\n\tf->private_data = vs;\n\treturn 0;\n\nerr_vqs:\n\tkvfree(vs);\nerr_vs:\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c",
        "vul_func_with_fix": "static int vhost_scsi_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_scsi *vs;\n\tstruct vhost_virtqueue **vqs;\n\tint r = -ENOMEM, i;\n\n\tvs = kzalloc(sizeof(*vs), GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!vs) {\n\t\tvs = vzalloc(sizeof(*vs));\n\t\tif (!vs)\n\t\t\tgoto err_vs;\n\t}\n\n\tvqs = kmalloc(VHOST_SCSI_MAX_VQ * sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs)\n\t\tgoto err_vqs;\n\n\tvhost_work_init(&vs->vs_completion_work, vhost_scsi_complete_cmd_work);\n\tvhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);\n\n\tvs->vs_events_nr = 0;\n\tvs->vs_events_missed = false;\n\n\tvqs[VHOST_SCSI_VQ_CTL] = &vs->vqs[VHOST_SCSI_VQ_CTL].vq;\n\tvqs[VHOST_SCSI_VQ_EVT] = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tvs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;\n\tvs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;\n\tfor (i = VHOST_SCSI_VQ_IO; i < VHOST_SCSI_MAX_VQ; i++) {\n\t\tvqs[i] = &vs->vqs[i].vq;\n\t\tvs->vqs[i].vq.handle_kick = vhost_scsi_handle_kick;\n\t}\n\tvhost_dev_init(&vs->dev, vqs, VHOST_SCSI_MAX_VQ);\n\n\tvhost_scsi_init_inflight(vs, NULL);\n\n\tf->private_data = vs;\n\treturn 0;\n\nerr_vqs:\n\tkvfree(vs);\nerr_vs:\n\treturn r;\n}\n",
        "linevul": 0.00011636966519290581,
        "sysevr": 0.1631345897912979,
        "devign": 1.5859978203025472e-27
    },
    {
        "code": "long keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "long keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n",
        "linevul": 0.00023879678337834775,
        "sysevr": 0.22711977362632751,
        "devign": 5.5608875176005454e-18
    },
    {
        "code": "static struct net_device *ip6mr_reg_vif(struct net *net, struct mr6_table *mrt)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\tif (mrt->id == RT6_TABLE_DFLT)\n\t\tsprintf(name, \"pim6reg\");\n\telse\n\t\tsprintf(name, \"pim6reg%u\", mrt->id);\n\n\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, reg_vif_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (register_netdevice(dev)) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tif (dev_open(dev))\n\t\tgoto failure;\n\n\tdev_hold(dev);\n\treturn dev;\n\nfailure:\n\tunregister_netdevice(dev);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/99253eb750fda6a644d5188fb26c43bad8d5a745",
        "vul_func_with_fix": "static struct net_device *ip6mr_reg_vif(struct net *net, struct mr6_table *mrt)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\tif (mrt->id == RT6_TABLE_DFLT)\n\t\tsprintf(name, \"pim6reg\");\n\telse\n\t\tsprintf(name, \"pim6reg%u\", mrt->id);\n\n\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, reg_vif_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (register_netdevice(dev)) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tif (dev_open(dev))\n\t\tgoto failure;\n\n\tdev_hold(dev);\n\treturn dev;\n\nfailure:\n\tunregister_netdevice(dev);\n\treturn NULL;\n}\n",
        "linevul": 4.8492380301468074e-05,
        "sysevr": 0.12127551436424255,
        "devign": 3.611985991325716e-19
    },
    {
        "code": "__nvme_fc_parse_u64(substring_t *sstr, u64 *val)\n{\n\tu64 token64;\n\n\tif (match_u64(sstr, &token64))\n\t\treturn -EINVAL;\n\t*val = token64;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0c319d3a144d4b8f1ea2047fd614d2149b68f889",
        "vul_func_with_fix": "__nvme_fc_parse_u64(substring_t *sstr, u64 *val)\n{\n\tu64 token64;\n\n\tif (match_u64(sstr, &token64))\n\t\treturn -EINVAL;\n\t*val = token64;\n\n\treturn 0;\n}\n",
        "linevul": 5.6276821851497516e-05,
        "sysevr": 0.16220781207084656,
        "devign": 1.7384300576850364e-07
    },
    {
        "code": "static int bond_ioctl_change_active(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *old_active = NULL;\n\tstruct slave *new_active = NULL;\n\tint res = 0;\n\n\tif (!USES_PRIMARY(bond->params.mode))\n\t\treturn -EINVAL;\n\n\t/* Verify that master_dev is indeed the master of slave_dev */\n\tif (!(slave_dev->flags & IFF_SLAVE) || (slave_dev->master != bond_dev))\n\t\treturn -EINVAL;\n\n\tread_lock(&bond->lock);\n\n\tread_lock(&bond->curr_slave_lock);\n\told_active = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\tnew_active = bond_get_slave_by_dev(bond, slave_dev);\n\n\t/*\n\t * Changing to the current active: do nothing; return success.\n\t */\n\tif (new_active && (new_active == old_active)) {\n\t\tread_unlock(&bond->lock);\n\t\treturn 0;\n\t}\n\n\tif ((new_active) &&\n\t    (old_active) &&\n\t    (new_active->link == BOND_LINK_UP) &&\n\t    IS_UP(new_active->dev)) {\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_change_active_slave(bond, new_active);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t} else\n\t\tres = -EINVAL;\n\n\tread_unlock(&bond->lock);\n\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static int bond_ioctl_change_active(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *old_active = NULL;\n\tstruct slave *new_active = NULL;\n\tint res = 0;\n\n\tif (!USES_PRIMARY(bond->params.mode))\n\t\treturn -EINVAL;\n\n\t/* Verify that master_dev is indeed the master of slave_dev */\n\tif (!(slave_dev->flags & IFF_SLAVE) || (slave_dev->master != bond_dev))\n\t\treturn -EINVAL;\n\n\tread_lock(&bond->lock);\n\n\tread_lock(&bond->curr_slave_lock);\n\told_active = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\tnew_active = bond_get_slave_by_dev(bond, slave_dev);\n\n\t/*\n\t * Changing to the current active: do nothing; return success.\n\t */\n\tif (new_active && (new_active == old_active)) {\n\t\tread_unlock(&bond->lock);\n\t\treturn 0;\n\t}\n\n\tif ((new_active) &&\n\t    (old_active) &&\n\t    (new_active->link == BOND_LINK_UP) &&\n\t    IS_UP(new_active->dev)) {\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_change_active_slave(bond, new_active);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t} else\n\t\tres = -EINVAL;\n\n\tread_unlock(&bond->lock);\n\n\treturn res;\n}\n",
        "linevul": 4.7171892219921574e-05,
        "sysevr": 0.12454427778720856,
        "devign": 7.16256863597664e-07
    },
    {
        "code": "SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, int, mode,\n\t\tunsigned, dev)\n{\n\tint error;\n\tchar *tmp;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\tif (S_ISDIR(mode))\n\t\treturn -EPERM;\n\n\terror = user_path_parent(dfd, filename, &nd, &tmp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = lookup_create(&nd, 0);\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (!IS_POSIXACL(nd.path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = may_mknod(mode);\n\tif (error)\n\t\tgoto out_dput;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_mknod(&nd.path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out_drop_write;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(tmp);\n\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "vul_func_with_fix": "SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, int, mode,\n\t\tunsigned, dev)\n{\n\tint error;\n\tchar *tmp;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\tif (S_ISDIR(mode))\n\t\treturn -EPERM;\n\n\terror = user_path_parent(dfd, filename, &nd, &tmp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = lookup_create(&nd, 0);\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (!IS_POSIXACL(nd.path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = may_mknod(mode);\n\tif (error)\n\t\tgoto out_dput;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_mknod(&nd.path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out_drop_write;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(tmp);\n\n\treturn error;\n}\n",
        "linevul": 6.05388377152849e-05,
        "sysevr": 0.16555358469486237,
        "devign": 0.630953848361969
    },
    {
        "code": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6",
        "vul_func_with_fix": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}\n",
        "linevul": 7.86206146585755e-05,
        "sysevr": 0.12728570401668549,
        "devign": 0.4219176173210144
    },
    {
        "code": "static int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_handled(vcpu)) {\n\t\tnested_vmx_vmexit(vcpu, exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\t\treturn 1;\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked &&\n\t    !(is_guest_mode(vcpu) && nested_cpu_has_virtual_nmis(\n\t\t\t\t\tget_vmcs12(vcpu))))) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = exit_reason;\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_handled(vcpu)) {\n\t\tnested_vmx_vmexit(vcpu, exit_reason,\n\t\t\t\t  vmcs_read32(VM_EXIT_INTR_INFO),\n\t\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\t\treturn 1;\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 2;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked &&\n\t    !(is_guest_mode(vcpu) && nested_cpu_has_virtual_nmis(\n\t\t\t\t\tget_vmcs12(vcpu))))) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = exit_reason;\n\t}\n\treturn 0;\n}\n",
        "linevul": 5.3078118071425706e-05,
        "sysevr": 0.16604147851467133,
        "devign": 1.7418379022124397e-12
    },
    {
        "code": "static int loop_prepare_queue(struct loop_device *lo)\n{\n\tkthread_init_worker(&lo->worker);\n\tlo->worker_task = kthread_run(loop_kthread_worker_fn,\n\t\t\t&lo->worker, \"loop%d\", lo->lo_number);\n\tif (IS_ERR(lo->worker_task))\n\t\treturn -ENOMEM;\n\tset_user_nice(lo->worker_task, MIN_NICE);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
        "vul_func_with_fix": "static int loop_prepare_queue(struct loop_device *lo)\n{\n\tkthread_init_worker(&lo->worker);\n\tlo->worker_task = kthread_run(loop_kthread_worker_fn,\n\t\t\t&lo->worker, \"loop%d\", lo->lo_number);\n\tif (IS_ERR(lo->worker_task))\n\t\treturn -ENOMEM;\n\tset_user_nice(lo->worker_task, MIN_NICE);\n\treturn 0;\n}\n",
        "linevul": 8.168741624103859e-05,
        "sysevr": 0.12911780178546906,
        "devign": 2.8890756453847644e-10
    },
    {
        "code": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\tif (!pud_present(*pud))\n\t\treturn NULL;\n\tif (pud_huge(*pud))\n\t\treturn (pte_t *)pud;\n\tpmd = pmd_offset(pud, addr);\n\treturn (pte_t *) pmd;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5af10dfd0afc559bb4b0f7e3e8227a1578333995",
        "vul_func_with_fix": "pte_t *huge_pte_offset(struct mm_struct *mm,\n\t\t       unsigned long addr, unsigned long sz)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset(mm, addr);\n\tif (!pgd_present(*pgd))\n\t\treturn NULL;\n\tp4d = p4d_offset(pgd, addr);\n\tif (!p4d_present(*p4d))\n\t\treturn NULL;\n\tpud = pud_offset(p4d, addr);\n\tif (!pud_present(*pud))\n\t\treturn NULL;\n\tif (pud_huge(*pud))\n\t\treturn (pte_t *)pud;\n\tpmd = pmd_offset(pud, addr);\n\treturn (pte_t *) pmd;\n}\n",
        "linevul": 4.8970385250868276e-05,
        "sysevr": 0.17428185045719147,
        "devign": 1.6434986704894072e-09
    },
    {
        "code": "static void kvmppc_complete_mmio_load(struct kvm_vcpu *vcpu,\n                                      struct kvm_run *run)\n{\n\tu64 uninitialized_var(gpr);\n\n\tif (run->mmio.len > sizeof(gpr)) {\n\t\tprintk(KERN_ERR \"bad MMIO length: %d\\n\", run->mmio.len);\n\t\treturn;\n\t}\n\n\tif (!vcpu->arch.mmio_host_swabbed) {\n\t\tswitch (run->mmio.len) {\n\t\tcase 8: gpr = *(u64 *)run->mmio.data; break;\n\t\tcase 4: gpr = *(u32 *)run->mmio.data; break;\n\t\tcase 2: gpr = *(u16 *)run->mmio.data; break;\n\t\tcase 1: gpr = *(u8 *)run->mmio.data; break;\n\t\t}\n\t} else {\n\t\tswitch (run->mmio.len) {\n\t\tcase 8: gpr = swab64(*(u64 *)run->mmio.data); break;\n\t\tcase 4: gpr = swab32(*(u32 *)run->mmio.data); break;\n\t\tcase 2: gpr = swab16(*(u16 *)run->mmio.data); break;\n\t\tcase 1: gpr = *(u8 *)run->mmio.data; break;\n\t\t}\n\t}\n\n\t/* conversion between single and double precision */\n\tif ((vcpu->arch.mmio_sp64_extend) && (run->mmio.len == 4))\n\t\tgpr = sp_to_dp(gpr);\n\n\tif (vcpu->arch.mmio_sign_extend) {\n\t\tswitch (run->mmio.len) {\n#ifdef CONFIG_PPC64\n\t\tcase 4:\n\t\t\tgpr = (s64)(s32)gpr;\n\t\t\tbreak;\n#endif\n\t\tcase 2:\n\t\t\tgpr = (s64)(s16)gpr;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgpr = (s64)(s8)gpr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (vcpu->arch.io_gpr & KVM_MMIO_REG_EXT_MASK) {\n\tcase KVM_MMIO_REG_GPR:\n\t\tkvmppc_set_gpr(vcpu, vcpu->arch.io_gpr, gpr);\n\t\tbreak;\n\tcase KVM_MMIO_REG_FPR:\n\t\tVCPU_FPR(vcpu, vcpu->arch.io_gpr & KVM_MMIO_REG_MASK) = gpr;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S\n\tcase KVM_MMIO_REG_QPR:\n\t\tvcpu->arch.qpr[vcpu->arch.io_gpr & KVM_MMIO_REG_MASK] = gpr;\n\t\tbreak;\n\tcase KVM_MMIO_REG_FQPR:\n\t\tVCPU_FPR(vcpu, vcpu->arch.io_gpr & KVM_MMIO_REG_MASK) = gpr;\n\t\tvcpu->arch.qpr[vcpu->arch.io_gpr & KVM_MMIO_REG_MASK] = gpr;\n\t\tbreak;\n#endif\n#ifdef CONFIG_VSX\n\tcase KVM_MMIO_REG_VSX:\n\t\tif (vcpu->arch.mmio_vsx_copy_type == KVMPPC_VSX_COPY_DWORD)\n\t\t\tkvmppc_set_vsr_dword(vcpu, gpr);\n\t\telse if (vcpu->arch.mmio_vsx_copy_type == KVMPPC_VSX_COPY_WORD)\n\t\t\tkvmppc_set_vsr_word(vcpu, gpr);\n\t\telse if (vcpu->arch.mmio_vsx_copy_type ==\n\t\t\t\tKVMPPC_VSX_COPY_DWORD_LOAD_DUMP)\n\t\t\tkvmppc_set_vsr_dword_dump(vcpu, gpr);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0",
        "vul_func_with_fix": "static void kvmppc_complete_mmio_load(struct kvm_vcpu *vcpu,\n                                      struct kvm_run *run)\n{\n\tu64 uninitialized_var(gpr);\n\n\tif (run->mmio.len > sizeof(gpr)) {\n\t\tprintk(KERN_ERR \"bad MMIO length: %d\\n\", run->mmio.len);\n\t\treturn;\n\t}\n\n\tif (!vcpu->arch.mmio_host_swabbed) {\n\t\tswitch (run->mmio.len) {\n\t\tcase 8: gpr = *(u64 *)run->mmio.data; break;\n\t\tcase 4: gpr = *(u32 *)run->mmio.data; break;\n\t\tcase 2: gpr = *(u16 *)run->mmio.data; break;\n\t\tcase 1: gpr = *(u8 *)run->mmio.data; break;\n\t\t}\n\t} else {\n\t\tswitch (run->mmio.len) {\n\t\tcase 8: gpr = swab64(*(u64 *)run->mmio.data); break;\n\t\tcase 4: gpr = swab32(*(u32 *)run->mmio.data); break;\n\t\tcase 2: gpr = swab16(*(u16 *)run->mmio.data); break;\n\t\tcase 1: gpr = *(u8 *)run->mmio.data; break;\n\t\t}\n\t}\n\n\t/* conversion between single and double precision */\n\tif ((vcpu->arch.mmio_sp64_extend) && (run->mmio.len == 4))\n\t\tgpr = sp_to_dp(gpr);\n\n\tif (vcpu->arch.mmio_sign_extend) {\n\t\tswitch (run->mmio.len) {\n#ifdef CONFIG_PPC64\n\t\tcase 4:\n\t\t\tgpr = (s64)(s32)gpr;\n\t\t\tbreak;\n#endif\n\t\tcase 2:\n\t\t\tgpr = (s64)(s16)gpr;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgpr = (s64)(s8)gpr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (vcpu->arch.io_gpr & KVM_MMIO_REG_EXT_MASK) {\n\tcase KVM_MMIO_REG_GPR:\n\t\tkvmppc_set_gpr(vcpu, vcpu->arch.io_gpr, gpr);\n\t\tbreak;\n\tcase KVM_MMIO_REG_FPR:\n\t\tVCPU_FPR(vcpu, vcpu->arch.io_gpr & KVM_MMIO_REG_MASK) = gpr;\n\t\tbreak;\n#ifdef CONFIG_PPC_BOOK3S\n\tcase KVM_MMIO_REG_QPR:\n\t\tvcpu->arch.qpr[vcpu->arch.io_gpr & KVM_MMIO_REG_MASK] = gpr;\n\t\tbreak;\n\tcase KVM_MMIO_REG_FQPR:\n\t\tVCPU_FPR(vcpu, vcpu->arch.io_gpr & KVM_MMIO_REG_MASK) = gpr;\n\t\tvcpu->arch.qpr[vcpu->arch.io_gpr & KVM_MMIO_REG_MASK] = gpr;\n\t\tbreak;\n#endif\n#ifdef CONFIG_VSX\n\tcase KVM_MMIO_REG_VSX:\n\t\tif (vcpu->arch.mmio_vsx_copy_type == KVMPPC_VSX_COPY_DWORD)\n\t\t\tkvmppc_set_vsr_dword(vcpu, gpr);\n\t\telse if (vcpu->arch.mmio_vsx_copy_type == KVMPPC_VSX_COPY_WORD)\n\t\t\tkvmppc_set_vsr_word(vcpu, gpr);\n\t\telse if (vcpu->arch.mmio_vsx_copy_type ==\n\t\t\t\tKVMPPC_VSX_COPY_DWORD_LOAD_DUMP)\n\t\t\tkvmppc_set_vsr_dword_dump(vcpu, gpr);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n}\n",
        "linevul": 5.33517959411256e-05,
        "sysevr": 0.17011894285678864,
        "devign": 7.140386021132061e-30
    },
    {
        "code": "static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)\n{\n\treg->id = 0;\n\treg->var_off = tnum_const(imm);\n\treg->smin_value = (s64)imm;\n\treg->smax_value = (s64)imm;\n\treg->umin_value = imm;\n\treg->umax_value = imm;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
        "vul_func_with_fix": "static void __mark_reg_known(struct bpf_reg_state *reg, u64 imm)\n{\n\treg->id = 0;\n\treg->var_off = tnum_const(imm);\n\treg->smin_value = (s64)imm;\n\treg->smax_value = (s64)imm;\n\treg->umin_value = imm;\n\treg->umax_value = imm;\n}\n",
        "linevul": 5.1431132305879146e-05,
        "sysevr": 0.1538214087486267,
        "devign": 0.002511253347620368
    },
    {
        "code": "static void account_shadowed(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tslot = gfn_to_memslot(kvm, gfn);\n\tfor (i = PT_DIRECTORY_LEVEL;\n\t     i < PT_PAGE_TABLE_LEVEL + KVM_NR_PAGE_SIZES; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->write_count += 1;\n\t}\n\tkvm->arch.indirect_shadow_pages++;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static void account_shadowed(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tslot = gfn_to_memslot(kvm, gfn);\n\tfor (i = PT_DIRECTORY_LEVEL;\n\t     i < PT_PAGE_TABLE_LEVEL + KVM_NR_PAGE_SIZES; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->write_count += 1;\n\t}\n\tkvm->arch.indirect_shadow_pages++;\n}\n",
        "linevul": 4.734201866085641e-05,
        "sysevr": 0.1265108585357666,
        "devign": 0.019789284095168114
    },
    {
        "code": "long do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * Do some preliminary argument and permissions checking before we\n\t * actually start allocating stuff\n\t */\n\tif (clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) {\n\t\tif (clone_flags & (CLONE_THREAD|CLONE_PARENT))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if ((clone_flags & CSIGNAL) != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(clone_flags, stack_start, stack_size,\n\t\t\t child_tidptr, NULL, trace);\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tnr = task_pid_vnr(p);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t\tget_task_struct(p);\n\t\t}\n\n\t\twake_up_new_task(p);\n\n\t\t/* forking complete and child started to run, tell ptracer */\n\t\tif (unlikely(trace))\n\t\t\tptrace_event(trace, nr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\t\tptrace_event(PTRACE_EVENT_VFORK_DONE, nr);\n\t\t}\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e66eded8309ebf679d3d3c1f5820d1f2ca332c71",
        "vul_func_with_fix": "long do_fork(unsigned long clone_flags,\n\t      unsigned long stack_start,\n\t      unsigned long stack_size,\n\t      int __user *parent_tidptr,\n\t      int __user *child_tidptr)\n{\n\tstruct task_struct *p;\n\tint trace = 0;\n\tlong nr;\n\n\t/*\n\t * Do some preliminary argument and permissions checking before we\n\t * actually start allocating stuff\n\t */\n\tif (clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) {\n\t\tif (clone_flags & (CLONE_THREAD|CLONE_PARENT))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if ((clone_flags & CSIGNAL) != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(clone_flags, stack_start, stack_size,\n\t\t\t child_tidptr, NULL, trace);\n\t/*\n\t * Do this prior waking up the new thread - the thread pointer\n\t * might get invalid after that point, if the thread exits quickly.\n\t */\n\tif (!IS_ERR(p)) {\n\t\tstruct completion vfork;\n\n\t\ttrace_sched_process_fork(current, p);\n\n\t\tnr = task_pid_vnr(p);\n\n\t\tif (clone_flags & CLONE_PARENT_SETTID)\n\t\t\tput_user(nr, parent_tidptr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tp->vfork_done = &vfork;\n\t\t\tinit_completion(&vfork);\n\t\t\tget_task_struct(p);\n\t\t}\n\n\t\twake_up_new_task(p);\n\n\t\t/* forking complete and child started to run, tell ptracer */\n\t\tif (unlikely(trace))\n\t\t\tptrace_event(trace, nr);\n\n\t\tif (clone_flags & CLONE_VFORK) {\n\t\t\tif (!wait_for_vfork_done(p, &vfork))\n\t\t\t\tptrace_event(PTRACE_EVENT_VFORK_DONE, nr);\n\t\t}\n\t} else {\n\t\tnr = PTR_ERR(p);\n\t}\n\treturn nr;\n}\n",
        "linevul": 0.00028526785899885,
        "sysevr": 0.32661738991737366,
        "devign": 0.6891716122627258
    },
    {
        "code": "void mark_page_dirty_in_slot(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\t     gfn_t gfn)\n{\n\tif (memslot && memslot->dirty_bitmap) {\n\t\tunsigned long rel_gfn = gfn - memslot->base_gfn;\n\n\t\t/* TODO: introduce set_bit_le() and use it */\n\t\ttest_and_set_bit_le(rel_gfn, memslot->dirty_bitmap);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8",
        "vul_func_with_fix": "void mark_page_dirty_in_slot(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\t     gfn_t gfn)\n{\n\tif (memslot && memslot->dirty_bitmap) {\n\t\tunsigned long rel_gfn = gfn - memslot->base_gfn;\n\n\t\t/* TODO: introduce set_bit_le() and use it */\n\t\ttest_and_set_bit_le(rel_gfn, memslot->dirty_bitmap);\n\t}\n}\n",
        "linevul": 4.785867713508196e-05,
        "sysevr": 0.1660863310098648,
        "devign": 5.012398105463944e-07
    },
    {
        "code": "static void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = arg;\n\tstruct ieee80211_hw *hw = data->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\thwsim_check_magic(vif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tskb = ieee80211_beacon_get(hw, vif);\n\tif (skb == NULL)\n\t\treturn;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(vif, NULL, skb,\n\t\t\t\t       info->control.rates,\n\t\t\t\t       ARRAY_SIZE(info->control.rates));\n\n\ttxrate = ieee80211_get_tx_rate(hw, info);\n\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t/* fake header transmission time */\n\tdata->abs_bcn_ts = mac80211_hwsim_get_tsf_raw();\n\tmgmt->u.beacon.timestamp = cpu_to_le64(data->abs_bcn_ts +\n\t\t\t\t\t       data->tsf_offset +\n\t\t\t\t\t       24 * 8 * 10 / txrate->bitrate);\n\n\tmac80211_hwsim_tx_frame(hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\n\tif (vif->csa_active && ieee80211_csa_is_complete(vif))\n\t\tieee80211_csa_finish(vif);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "vul_func_with_fix": "static void mac80211_hwsim_beacon_tx(void *arg, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct mac80211_hwsim_data *data = arg;\n\tstruct ieee80211_hw *hw = data->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\thwsim_check_magic(vif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT &&\n\t    vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tskb = ieee80211_beacon_get(hw, vif);\n\tif (skb == NULL)\n\t\treturn;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(vif, NULL, skb,\n\t\t\t\t       info->control.rates,\n\t\t\t\t       ARRAY_SIZE(info->control.rates));\n\n\ttxrate = ieee80211_get_tx_rate(hw, info);\n\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t/* fake header transmission time */\n\tdata->abs_bcn_ts = mac80211_hwsim_get_tsf_raw();\n\tmgmt->u.beacon.timestamp = cpu_to_le64(data->abs_bcn_ts +\n\t\t\t\t\t       data->tsf_offset +\n\t\t\t\t\t       24 * 8 * 10 / txrate->bitrate);\n\n\tmac80211_hwsim_tx_frame(hw, skb,\n\t\t\t\trcu_dereference(vif->chanctx_conf)->def.chan);\n\n\tif (vif->csa_active && ieee80211_csa_is_complete(vif))\n\t\tieee80211_csa_finish(vif);\n}\n",
        "linevul": 7.995263149496168e-05,
        "sysevr": 0.1360642910003662,
        "devign": 2.80362585665177e-24
    },
    {
        "code": "void oz_hcd_data_ind(void *hport, u8 endpoint, const u8 *data, int data_len)\n{\n\tstruct oz_port *port = (struct oz_port *)hport;\n\tstruct oz_endpoint *ep;\n\tstruct oz_hcd *ozhcd = port->ozhcd;\n\n\tspin_lock_bh(&ozhcd->hcd_lock);\n\tep = port->in_ep[endpoint & USB_ENDPOINT_NUMBER_MASK];\n\tif (ep == NULL)\n\t\tgoto done;\n\tswitch (ep->attrib & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_INT:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (!list_empty(&ep->urb_list)) {\n\t\t\tstruct oz_urb_link *urbl =\n\t\t\t\tlist_first_entry(&ep->urb_list,\n\t\t\t\t\tstruct oz_urb_link, link);\n\t\t\tstruct urb *urb;\n\t\t\tint copy_len;\n\n\t\t\tlist_del_init(&urbl->link);\n\t\t\tspin_unlock_bh(&ozhcd->hcd_lock);\n\t\t\turb = urbl->urb;\n\t\t\toz_free_urb_link(urbl);\n\t\t\tif (data_len <= urb->transfer_buffer_length)\n\t\t\t\tcopy_len = data_len;\n\t\t\telse\n\t\t\t\tcopy_len = urb->transfer_buffer_length;\n\t\t\tmemcpy(urb->transfer_buffer, data, copy_len);\n\t\t\turb->actual_length = copy_len;\n\t\t\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n\t\t\treturn;\n\t\t}\n\t\toz_dbg(ON, \"buffering frame as URB is not available\\n\");\n\t\toz_hcd_buffer_data(ep, data, data_len);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\toz_hcd_buffer_data(ep, data, data_len);\n\t\tbreak;\n\t}\ndone:\n\tspin_unlock_bh(&ozhcd->hcd_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c",
        "vul_func_with_fix": "void oz_hcd_data_ind(void *hport, u8 endpoint, const u8 *data, int data_len)\n{\n\tstruct oz_port *port = (struct oz_port *)hport;\n\tstruct oz_endpoint *ep;\n\tstruct oz_hcd *ozhcd = port->ozhcd;\n\n\tspin_lock_bh(&ozhcd->hcd_lock);\n\tep = port->in_ep[endpoint & USB_ENDPOINT_NUMBER_MASK];\n\tif (ep == NULL)\n\t\tgoto done;\n\tswitch (ep->attrib & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_INT:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (!list_empty(&ep->urb_list)) {\n\t\t\tstruct oz_urb_link *urbl =\n\t\t\t\tlist_first_entry(&ep->urb_list,\n\t\t\t\t\tstruct oz_urb_link, link);\n\t\t\tstruct urb *urb;\n\t\t\tint copy_len;\n\n\t\t\tlist_del_init(&urbl->link);\n\t\t\tspin_unlock_bh(&ozhcd->hcd_lock);\n\t\t\turb = urbl->urb;\n\t\t\toz_free_urb_link(urbl);\n\t\t\tif (data_len <= urb->transfer_buffer_length)\n\t\t\t\tcopy_len = data_len;\n\t\t\telse\n\t\t\t\tcopy_len = urb->transfer_buffer_length;\n\t\t\tmemcpy(urb->transfer_buffer, data, copy_len);\n\t\t\turb->actual_length = copy_len;\n\t\t\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n\t\t\treturn;\n\t\t}\n\t\toz_dbg(ON, \"buffering frame as URB is not available\\n\");\n\t\toz_hcd_buffer_data(ep, data, data_len);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\toz_hcd_buffer_data(ep, data, data_len);\n\t\tbreak;\n\t}\ndone:\n\tspin_unlock_bh(&ozhcd->hcd_lock);\n}\n",
        "linevul": 0.00013537031190935522,
        "sysevr": 0.19209061563014984,
        "devign": 2.338357270672848e-16
    },
    {
        "code": "smb2_new_read_req(void **buf, unsigned int *total_len,\n\t\t  struct cifs_io_parms *io_parms, unsigned int remaining_bytes,\n\t\t  int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, (void **) &req,\n\t\t\t\t total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->sync_hdr;\n\tshdr->ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* next 8-byte aligned request */\n\t\t\t*total_len = DIV_ROUND_UP(*total_len, 8) * 8;\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else /* END_OF_CHAIN */\n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\tshdr->SessionId = 0xFFFFFFFF;\n\t\t\tshdr->TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb",
        "vul_func_with_fix": "smb2_new_read_req(void **buf, unsigned int *total_len,\n\t\t  struct cifs_io_parms *io_parms, unsigned int remaining_bytes,\n\t\t  int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, (void **) &req,\n\t\t\t\t total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->sync_hdr;\n\tshdr->ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* next 8-byte aligned request */\n\t\t\t*total_len = DIV_ROUND_UP(*total_len, 8) * 8;\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else /* END_OF_CHAIN */\n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\tshdr->SessionId = 0xFFFFFFFF;\n\t\t\tshdr->TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n",
        "linevul": 6.541777838720009e-05,
        "sysevr": 0.2012474536895752,
        "devign": 3.6085916149904435e-30
    },
    {
        "code": "static void btrfs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tu64 page_start = page_offset(page);\n\tu64 page_end = page_start + PAGE_CACHE_SIZE - 1;\n\tint inode_evicting = inode->i_state & I_FREEING;\n\n\t/*\n\t * we have the page locked, so new writeback can't start,\n\t * and the dirty bit won't be cleared while we are here.\n\t *\n\t * Wait for IO on this page so that we can safely clear\n\t * the PagePrivate2 bit and do ordered accounting\n\t */\n\twait_on_page_writeback(page);\n\n\ttree = &BTRFS_I(inode)->io_tree;\n\tif (offset) {\n\t\tbtrfs_releasepage(page, GFP_NOFS);\n\t\treturn;\n\t}\n\n\tif (!inode_evicting)\n\t\tlock_extent_bits(tree, page_start, page_end, 0, &cached_state);\n\tordered = btrfs_lookup_ordered_extent(inode, page_start);\n\tif (ordered) {\n\t\t/*\n\t\t * IO on this page will never be started, so we need\n\t\t * to account for any ordered extents now\n\t\t */\n\t\tif (!inode_evicting)\n\t\t\tclear_extent_bit(tree, page_start, page_end,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t\t EXTENT_LOCKED | EXTENT_DO_ACCOUNTING |\n\t\t\t\t\t EXTENT_DEFRAG, 1, 0, &cached_state,\n\t\t\t\t\t GFP_NOFS);\n\t\t/*\n\t\t * whoever cleared the private bit is responsible\n\t\t * for the finish_ordered_io\n\t\t */\n\t\tif (TestClearPagePrivate2(page)) {\n\t\t\tstruct btrfs_ordered_inode_tree *tree;\n\t\t\tu64 new_len;\n\n\t\t\ttree = &BTRFS_I(inode)->ordered_tree;\n\n\t\t\tspin_lock_irq(&tree->lock);\n\t\t\tset_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags);\n\t\t\tnew_len = page_start - ordered->file_offset;\n\t\t\tif (new_len < ordered->truncated_len)\n\t\t\t\tordered->truncated_len = new_len;\n\t\t\tspin_unlock_irq(&tree->lock);\n\n\t\t\tif (btrfs_dec_test_ordered_pending(inode, &ordered,\n\t\t\t\t\t\t\t   page_start,\n\t\t\t\t\t\t\t   PAGE_CACHE_SIZE, 1))\n\t\t\t\tbtrfs_finish_ordered_io(ordered);\n\t\t}\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (!inode_evicting) {\n\t\t\tcached_state = NULL;\n\t\t\tlock_extent_bits(tree, page_start, page_end, 0,\n\t\t\t\t\t &cached_state);\n\t\t}\n\t}\n\n\tif (!inode_evicting) {\n\t\tclear_extent_bit(tree, page_start, page_end,\n\t\t\t\t EXTENT_LOCKED | EXTENT_DIRTY |\n\t\t\t\t EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING |\n\t\t\t\t EXTENT_DEFRAG, 1, 1,\n\t\t\t\t &cached_state, GFP_NOFS);\n\n\t\t__btrfs_releasepage(page, GFP_NOFS);\n\t}\n\n\tClearPageChecked(page);\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tpage_cache_release(page);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7",
        "vul_func_with_fix": "static void btrfs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tu64 page_start = page_offset(page);\n\tu64 page_end = page_start + PAGE_CACHE_SIZE - 1;\n\tint inode_evicting = inode->i_state & I_FREEING;\n\n\t/*\n\t * we have the page locked, so new writeback can't start,\n\t * and the dirty bit won't be cleared while we are here.\n\t *\n\t * Wait for IO on this page so that we can safely clear\n\t * the PagePrivate2 bit and do ordered accounting\n\t */\n\twait_on_page_writeback(page);\n\n\ttree = &BTRFS_I(inode)->io_tree;\n\tif (offset) {\n\t\tbtrfs_releasepage(page, GFP_NOFS);\n\t\treturn;\n\t}\n\n\tif (!inode_evicting)\n\t\tlock_extent_bits(tree, page_start, page_end, 0, &cached_state);\n\tordered = btrfs_lookup_ordered_extent(inode, page_start);\n\tif (ordered) {\n\t\t/*\n\t\t * IO on this page will never be started, so we need\n\t\t * to account for any ordered extents now\n\t\t */\n\t\tif (!inode_evicting)\n\t\t\tclear_extent_bit(tree, page_start, page_end,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t\t EXTENT_LOCKED | EXTENT_DO_ACCOUNTING |\n\t\t\t\t\t EXTENT_DEFRAG, 1, 0, &cached_state,\n\t\t\t\t\t GFP_NOFS);\n\t\t/*\n\t\t * whoever cleared the private bit is responsible\n\t\t * for the finish_ordered_io\n\t\t */\n\t\tif (TestClearPagePrivate2(page)) {\n\t\t\tstruct btrfs_ordered_inode_tree *tree;\n\t\t\tu64 new_len;\n\n\t\t\ttree = &BTRFS_I(inode)->ordered_tree;\n\n\t\t\tspin_lock_irq(&tree->lock);\n\t\t\tset_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags);\n\t\t\tnew_len = page_start - ordered->file_offset;\n\t\t\tif (new_len < ordered->truncated_len)\n\t\t\t\tordered->truncated_len = new_len;\n\t\t\tspin_unlock_irq(&tree->lock);\n\n\t\t\tif (btrfs_dec_test_ordered_pending(inode, &ordered,\n\t\t\t\t\t\t\t   page_start,\n\t\t\t\t\t\t\t   PAGE_CACHE_SIZE, 1))\n\t\t\t\tbtrfs_finish_ordered_io(ordered);\n\t\t}\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (!inode_evicting) {\n\t\t\tcached_state = NULL;\n\t\t\tlock_extent_bits(tree, page_start, page_end, 0,\n\t\t\t\t\t &cached_state);\n\t\t}\n\t}\n\n\tif (!inode_evicting) {\n\t\tclear_extent_bit(tree, page_start, page_end,\n\t\t\t\t EXTENT_LOCKED | EXTENT_DIRTY |\n\t\t\t\t EXTENT_DELALLOC | EXTENT_DO_ACCOUNTING |\n\t\t\t\t EXTENT_DEFRAG, 1, 1,\n\t\t\t\t &cached_state, GFP_NOFS);\n\n\t\t__btrfs_releasepage(page, GFP_NOFS);\n\t}\n\n\tClearPageChecked(page);\n\tif (PagePrivate(page)) {\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tpage_cache_release(page);\n\t}\n}\n",
        "linevul": 0.0002982531732413918,
        "sysevr": 0.1468033641576767,
        "devign": 3.1748575256268598e-21
    },
    {
        "code": "static enum task_disposition sas_scsi_find_task(struct sas_task *task)\n{\n\tunsigned long flags;\n\tint i, res;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(task->dev->port->ha->core.shost->transportt);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tSAS_DPRINTK(\"%s: aborting task 0x%p\\n\", __func__, task);\n\t\tres = si->dft->lldd_abort_task(task);\n\n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\t\tSAS_DPRINTK(\"%s: task 0x%p is done\\n\", __func__,\n\t\t\t\t    task);\n\t\t\treturn TASK_IS_DONE;\n\t\t}\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\tif (res == TMF_RESP_FUNC_COMPLETE) {\n\t\t\tSAS_DPRINTK(\"%s: task 0x%p is aborted\\n\",\n\t\t\t\t    __func__, task);\n\t\t\treturn TASK_IS_ABORTED;\n\t\t} else if (si->dft->lldd_query_task) {\n\t\t\tSAS_DPRINTK(\"%s: querying task 0x%p\\n\",\n\t\t\t\t    __func__, task);\n\t\t\tres = si->dft->lldd_query_task(task);\n\t\t\tswitch (res) {\n\t\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t\t\tSAS_DPRINTK(\"%s: task 0x%p at LU\\n\",\n\t\t\t\t\t    __func__, task);\n\t\t\t\treturn TASK_IS_AT_LU;\n\t\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\t\tSAS_DPRINTK(\"%s: task 0x%p not at LU\\n\",\n\t\t\t\t\t    __func__, task);\n\t\t\t\treturn TASK_IS_NOT_AT_LU;\n\t\t\tcase TMF_RESP_FUNC_FAILED:\n                                SAS_DPRINTK(\"%s: task 0x%p failed to abort\\n\",\n                                                __func__, task);\n                                return TASK_ABORT_FAILED;\n                        }\n\n\t\t}\n\t}\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39",
        "vul_func_with_fix": "static enum task_disposition sas_scsi_find_task(struct sas_task *task)\n{\n\tunsigned long flags;\n\tint i, res;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(task->dev->port->ha->core.shost->transportt);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tSAS_DPRINTK(\"%s: aborting task 0x%p\\n\", __func__, task);\n\t\tres = si->dft->lldd_abort_task(task);\n\n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\t\tSAS_DPRINTK(\"%s: task 0x%p is done\\n\", __func__,\n\t\t\t\t    task);\n\t\t\treturn TASK_IS_DONE;\n\t\t}\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\tif (res == TMF_RESP_FUNC_COMPLETE) {\n\t\t\tSAS_DPRINTK(\"%s: task 0x%p is aborted\\n\",\n\t\t\t\t    __func__, task);\n\t\t\treturn TASK_IS_ABORTED;\n\t\t} else if (si->dft->lldd_query_task) {\n\t\t\tSAS_DPRINTK(\"%s: querying task 0x%p\\n\",\n\t\t\t\t    __func__, task);\n\t\t\tres = si->dft->lldd_query_task(task);\n\t\t\tswitch (res) {\n\t\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t\t\tSAS_DPRINTK(\"%s: task 0x%p at LU\\n\",\n\t\t\t\t\t    __func__, task);\n\t\t\t\treturn TASK_IS_AT_LU;\n\t\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\t\tSAS_DPRINTK(\"%s: task 0x%p not at LU\\n\",\n\t\t\t\t\t    __func__, task);\n\t\t\t\treturn TASK_IS_NOT_AT_LU;\n\t\t\tcase TMF_RESP_FUNC_FAILED:\n                                SAS_DPRINTK(\"%s: task 0x%p failed to abort\\n\",\n                                                __func__, task);\n                                return TASK_ABORT_FAILED;\n                        }\n\n\t\t}\n\t}\n\treturn res;\n}\n",
        "linevul": 8.763460937188938e-05,
        "sysevr": 0.1395798772573471,
        "devign": 1.0853803878705097e-18
    },
    {
        "code": "megasas_issue_blocked_cmd(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd, int timeout)\n{\n\tint ret = 0;\n\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d DCMD Timed out\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS);\n\n\treturn (cmd->cmd_status_drv == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "vul_func_with_fix": "megasas_issue_blocked_cmd(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd, int timeout)\n{\n\tint ret = 0;\n\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d DCMD Timed out\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS);\n\n\treturn (cmd->cmd_status_drv == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n}\n",
        "linevul": 5.1022339903283864e-05,
        "sysevr": 0.17046433687210083,
        "devign": 2.471478143453674e-21
    },
    {
        "code": "static int area_io(struct pstore *ps, int rw)\n{\n\tint r;\n\tchunk_t chunk;\n\n\tchunk = area_location(ps, ps->current_area);\n\n\tr = chunk_io(ps, ps->area, chunk, rw, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e9c6a182649f4259db704ae15a91ac820e63b0ca",
        "vul_func_with_fix": "static int area_io(struct pstore *ps, int rw)\n{\n\tint r;\n\tchunk_t chunk;\n\n\tchunk = area_location(ps, ps->current_area);\n\n\tr = chunk_io(ps, ps->area, chunk, rw, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n",
        "linevul": 5.658527879859321e-05,
        "sysevr": 0.1309605836868286,
        "devign": 5.686677364489973e-20
    },
    {
        "code": "static void lzo_exit(struct crypto_tfm *tfm)\n{\n\tstruct lzo_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tkvfree(ctx->lzo_comp_mem);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static void lzo_exit(struct crypto_tfm *tfm)\n{\n\tstruct lzo_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tkvfree(ctx->lzo_comp_mem);\n}\n",
        "linevul": 4.792617619386874e-05,
        "sysevr": 0.1276843398809433,
        "devign": 7.777066102221397e-09
    },
    {
        "code": "SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&address);\n\t\tif (err >= 0) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = sock->ops->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c",
        "vul_func_with_fix": "SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&address);\n\t\tif (err >= 0) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = sock->ops->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n",
        "linevul": 0.00011675735004246235,
        "sysevr": 0.16118405759334564,
        "devign": 0.4516651928424835
    },
    {
        "code": "bool kvm_is_mmio_pfn(pfn_t pfn)\n{\n\tif (pfn_valid(pfn)) {\n\t\tint reserved;\n\t\tstruct page *tail = pfn_to_page(pfn);\n\t\tstruct page *head = compound_trans_head(tail);\n\t\treserved = PageReserved(head);\n\t\tif (head != tail) {\n\t\t\t/*\n\t\t\t * \"head\" is not a dangling pointer\n\t\t\t * (compound_trans_head takes care of that)\n\t\t\t * but the hugepage may have been splitted\n\t\t\t * from under us (and we may not hold a\n\t\t\t * reference count on the head page so it can\n\t\t\t * be reused before we run PageReferenced), so\n\t\t\t * we've to check PageTail before returning\n\t\t\t * what we just read.\n\t\t\t */\n\t\t\tsmp_rmb();\n\t\t\tif (PageTail(tail))\n\t\t\t\treturn reserved;\n\t\t}\n\t\treturn PageReserved(tail);\n\t}\n\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12d6e7538e2d418c08f082b1b44ffa5fb7270ed8",
        "vul_func_with_fix": "bool kvm_is_mmio_pfn(pfn_t pfn)\n{\n\tif (pfn_valid(pfn)) {\n\t\tint reserved;\n\t\tstruct page *tail = pfn_to_page(pfn);\n\t\tstruct page *head = compound_trans_head(tail);\n\t\treserved = PageReserved(head);\n\t\tif (head != tail) {\n\t\t\t/*\n\t\t\t * \"head\" is not a dangling pointer\n\t\t\t * (compound_trans_head takes care of that)\n\t\t\t * but the hugepage may have been splitted\n\t\t\t * from under us (and we may not hold a\n\t\t\t * reference count on the head page so it can\n\t\t\t * be reused before we run PageReferenced), so\n\t\t\t * we've to check PageTail before returning\n\t\t\t * what we just read.\n\t\t\t */\n\t\t\tsmp_rmb();\n\t\t\tif (PageTail(tail))\n\t\t\t\treturn reserved;\n\t\t}\n\t\treturn PageReserved(tail);\n\t}\n\n\treturn true;\n}\n",
        "linevul": 8.709276153240353e-05,
        "sysevr": 0.16221784055233002,
        "devign": 0.0032036451157182455
    },
    {
        "code": "static void intel_pmu_disable_bts(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tunsigned long debugctlmsr;\n\n\tif (!cpuc->ds)\n\t\treturn;\n\n\tdebugctlmsr = get_debugctlmsr();\n\n\tdebugctlmsr &=\n\t\t~(DEBUGCTLMSR_TR | DEBUGCTLMSR_BTS | DEBUGCTLMSR_BTINT |\n\t\t  DEBUGCTLMSR_BTS_OFF_OS | DEBUGCTLMSR_BTS_OFF_USR);\n\n\tupdate_debugctlmsr(debugctlmsr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void intel_pmu_disable_bts(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tunsigned long debugctlmsr;\n\n\tif (!cpuc->ds)\n\t\treturn;\n\n\tdebugctlmsr = get_debugctlmsr();\n\n\tdebugctlmsr &=\n\t\t~(DEBUGCTLMSR_TR | DEBUGCTLMSR_BTS | DEBUGCTLMSR_BTINT |\n\t\t  DEBUGCTLMSR_BTS_OFF_OS | DEBUGCTLMSR_BTS_OFF_USR);\n\n\tupdate_debugctlmsr(debugctlmsr);\n}\n",
        "linevul": 4.6352590288734064e-05,
        "sysevr": 0.1296815276145935,
        "devign": 5.549497967822885e-14
    },
    {
        "code": "static void reparent_to_kthreadd(void)\n{\n\twrite_lock_irq(&tasklist_lock);\n\n\tptrace_unlink(current);\n\t/* Reparent to init */\n\tcurrent->real_parent = current->parent = kthreadd_task;\n\tlist_move_tail(&current->sibling, &current->real_parent->children);\n\n\t/* Set the exit signal to SIGCHLD so we signal init on exit */\n\tcurrent->exit_signal = SIGCHLD;\n\n\tif (task_nice(current) < 0)\n\t\tset_user_nice(current, 0);\n\t/* cpus_allowed? */\n\t/* rt_priority? */\n\t/* signals? */\n\tmemcpy(current->signal->rlim, init_task.signal->rlim,\n\t       sizeof(current->signal->rlim));\n\n\tatomic_inc(&init_cred.usage);\n\tcommit_creds(&init_cred);\n\twrite_unlock_irq(&tasklist_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3",
        "vul_func_with_fix": "static void reparent_to_kthreadd(void)\n{\n\twrite_lock_irq(&tasklist_lock);\n\n\tptrace_unlink(current);\n\t/* Reparent to init */\n\tcurrent->real_parent = current->parent = kthreadd_task;\n\tlist_move_tail(&current->sibling, &current->real_parent->children);\n\n\t/* Set the exit signal to SIGCHLD so we signal init on exit */\n\tcurrent->exit_signal = SIGCHLD;\n\n\tif (task_nice(current) < 0)\n\t\tset_user_nice(current, 0);\n\t/* cpus_allowed? */\n\t/* rt_priority? */\n\t/* signals? */\n\tmemcpy(current->signal->rlim, init_task.signal->rlim,\n\t       sizeof(current->signal->rlim));\n\n\tatomic_inc(&init_cred.usage);\n\tcommit_creds(&init_cred);\n\twrite_unlock_irq(&tasklist_lock);\n}\n",
        "linevul": 4.655433076550253e-05,
        "sysevr": 0.12872980535030365,
        "devign": 1.5029370109553852e-11
    },
    {
        "code": "COMPAT_SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n#ifdef __BIG_ENDIAN\n\tsigset_t newset;\n\tcompat_sigset_t newset32;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset32, unewset, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tsigset_from_compat(&newset, &newset32);\n\treturn sigsuspend(&newset);\n#else\n\t/* on little-endian bitmaps don't care about granularity */\n\treturn sys_rt_sigsuspend((sigset_t __user *)unewset, sigsetsize);\n#endif\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9e146d8eb3b9ecae5086d373b50fa0c1f3e7f0f",
        "vul_func_with_fix": "COMPAT_SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n#ifdef __BIG_ENDIAN\n\tsigset_t newset;\n\tcompat_sigset_t newset32;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset32, unewset, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tsigset_from_compat(&newset, &newset32);\n\treturn sigsuspend(&newset);\n#else\n\t/* on little-endian bitmaps don't care about granularity */\n\treturn sys_rt_sigsuspend((sigset_t __user *)unewset, sigsetsize);\n#endif\n}\n",
        "linevul": 4.625288784154691e-05,
        "sysevr": 0.15892785787582397,
        "devign": 0.6728697419166565
    },
    {
        "code": "static int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long a;\n#endif\n\tint i;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tvmx->hv_deadline_tsc = -1;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tvmx_secondary_exec_control(vmx));\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\n\tvm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tASSERT(vmx->pml_pg);\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388",
        "vul_func_with_fix": "static int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned long a;\n#endif\n\tint i;\n\n\t/* I/O */\n\tvmcs_write64(IO_BITMAP_A, __pa(vmx_io_bitmap_a));\n\tvmcs_write64(IO_BITMAP_B, __pa(vmx_io_bitmap_b));\n\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx_msr_bitmap_legacy));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tvmx->hv_deadline_tsc = -1;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\tvmx_secondary_exec_control(vmx));\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (ple_gap) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_FS_BASE, a);\n\tvmcs_writel(HOST_FS_BASE, a); /* 22.2.4 */\n\trdmsrl(MSR_GS_BASE, a);\n\tvmcs_writel(HOST_GS_BASE, a); /* 22.2.4 */\n#else\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n#endif\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t++vmx->nmsrs;\n\t}\n\n\n\tvm_exit_controls_init(vmx, vmcs_config.vmexit_ctrl);\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_init(vmx, vmcs_config.vmentry_ctrl);\n\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tASSERT(vmx->pml_pg);\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 0.00030398491071537137,
        "sysevr": 0.1345248967409134,
        "devign": 2.6286264049416063e-22
    },
    {
        "code": " update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n {\n\tstruct ring_buffer *buf;\n \tif (tr->stop_count)\n \t\treturn;\n \n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n \n \tarch_spin_lock(&tr->max_lock);\n \n\tbuf = tr->trace_buffer.buffer;\n\ttr->trace_buffer.buffer = tr->max_buffer.buffer;\n\ttr->max_buffer.buffer = buf;\n \n \t__update_max_tr(tr, tsk, cpu);\n \tarch_spin_unlock(&tr->max_lock);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": " update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n {\n//flaw_line_below:\n\tstruct ring_buffer *buf;\n//flaw_line_below:\n\n \tif (tr->stop_count)\n \t\treturn;\n \n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n \n \tarch_spin_lock(&tr->max_lock);\n \n//flaw_line_below:\n\tbuf = tr->trace_buffer.buffer;\n//flaw_line_below:\n\ttr->trace_buffer.buffer = tr->max_buffer.buffer;\n//flaw_line_below:\n\ttr->max_buffer.buffer = buf;\n//fix_flaw_line_below:\n//\tswap(tr->trace_buffer.buffer, tr->max_buffer.buffer);\n \n \t__update_max_tr(tr, tsk, cpu);\n \tarch_spin_unlock(&tr->max_lock);\n}\n",
        "linevul": 0.9996768236160278,
        "sysevr": 0.16619683802127838,
        "devign": 0.9730913639068604
    },
    {
        "code": "static inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed",
        "vul_func_with_fix": "static inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n",
        "linevul": 6.831841892562807e-05,
        "sysevr": 0.12656079232692719,
        "devign": 0.020540470257401466
    },
    {
        "code": "static void kiocb_batch_free(struct kiocb_batch *batch)\n {\n \tstruct kiocb *req, *n;\n \n \tlist_for_each_entry_safe(req, n, &batch->head, ki_batch) {\n \t\tlist_del(&req->ki_batch);\n \t\tkmem_cache_free(kiocb_cachep, req);\n \t}\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428",
        "vul_func_with_fix": "static void kiocb_batch_free(struct kiocb_batch *batch)\n//fix_flaw_line_below:\n//static void kiocb_batch_free(struct kioctx *ctx, struct kiocb_batch *batch)\n {\n \tstruct kiocb *req, *n;\n \n//fix_flaw_line_below:\n//\tif (list_empty(&batch->head))\n//fix_flaw_line_below:\n//\t\treturn;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tspin_lock_irq(&ctx->ctx_lock);\n \tlist_for_each_entry_safe(req, n, &batch->head, ki_batch) {\n \t\tlist_del(&req->ki_batch);\n//fix_flaw_line_below:\n//\t\tlist_del(&req->ki_list);\n \t\tkmem_cache_free(kiocb_cachep, req);\n//fix_flaw_line_below:\n//\t\tctx->reqs_active--;\n \t}\n//fix_flaw_line_below:\n//\tspin_unlock_irq(&ctx->ctx_lock);\n }\n",
        "linevul": 0.9995928406715393,
        "sysevr": 0.12651807069778442,
        "devign": 0.958268404006958
    },
    {
        "code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9",
        "vul_func_with_fix": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "linevul": 7.805384666426107e-05,
        "sysevr": 0.1544094681739807,
        "devign": 4.981556391941547e-32
    },
    {
        "code": "__wsum skb_checksum(const struct sk_buff *skb, int offset,\n\t\t    int len, __wsum csum)\n{\n\tconst struct skb_checksum_ops ops = {\n\t\t.update  = csum_partial_ext,\n\t\t.combine = csum_block_add_ext,\n\t};\n\n\treturn __skb_checksum(skb, offset, len, csum, &ops);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "vul_func_with_fix": "__wsum skb_checksum(const struct sk_buff *skb, int offset,\n\t\t    int len, __wsum csum)\n{\n\tconst struct skb_checksum_ops ops = {\n\t\t.update  = csum_partial_ext,\n\t\t.combine = csum_block_add_ext,\n\t};\n\n\treturn __skb_checksum(skb, offset, len, csum, &ops);\n}\n",
        "linevul": 6.331034819595516e-05,
        "sysevr": 0.17688938975334167,
        "devign": 4.954683581817609e-13
    },
    {
        "code": "static int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcred->security = cxt;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865",
        "vul_func_with_fix": "static int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcred->security = cxt;\n\treturn 0;\n}\n",
        "linevul": 5.5932800023583695e-05,
        "sysevr": 0.12688149511814117,
        "devign": 8.530858758604154e-05
    },
    {
        "code": "call_bind_status(struct rpc_task *task)\n{\n\tint status = -EIO;\n\n\tif (task->tk_status >= 0) {\n\t\tdprint_status(task);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_connect;\n\t\treturn;\n\t}\n\n\tswitch (task->tk_status) {\n\tcase -ENOMEM:\n\t\tdprintk(\"RPC: %5u rpcbind out of memory\\n\", task->tk_pid);\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EACCES:\n\t\tdprintk(\"RPC: %5u remote rpcbind: RPC program/version \"\n\t\t\t\t\"unavailable\\n\", task->tk_pid);\n\t\t/* fail immediately if this is an RPC ping */\n\t\tif (task->tk_msg.rpc_proc->p_proc == 0) {\n \t\t\tstatus = -EOPNOTSUPP;\n \t\t\tbreak;\n \t\t}\n \t\trpc_delay(task, 3*HZ);\n \t\tgoto retry_timeout;\n \tcase -ETIMEDOUT:\n\t\tdprintk(\"RPC: %5u rpcbind request timed out\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tgoto retry_timeout;\n\tcase -EPFNOSUPPORT:\n\t\t/* server doesn't support any rpcbind version we know of */\n\t\tdprintk(\"RPC: %5u unrecognized remote rpcbind service\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tbreak;\n\tcase -EPROTONOSUPPORT:\n\t\tdprintk(\"RPC: %5u remote rpcbind version unavailable, retrying\\n\",\n\t\t\t\ttask->tk_pid);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_bind;\n\t\treturn;\n\tcase -ECONNREFUSED:\t\t/* connection problems */\n\tcase -ECONNRESET:\n\tcase -ENOTCONN:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPIPE:\n\t\tdprintk(\"RPC: %5u remote rpcbind unreachable: %d\\n\",\n\t\t\t\ttask->tk_pid, task->tk_status);\n\t\tif (!RPC_IS_SOFTCONN(task)) {\n\t\t\trpc_delay(task, 5*HZ);\n\t\t\tgoto retry_timeout;\n\t\t}\n\t\tstatus = task->tk_status;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC: %5u unrecognized rpcbind error (%d)\\n\",\n\t\t\t\ttask->tk_pid, -task->tk_status);\n\t}\n\n\trpc_exit(task, status);\n\treturn;\n\nretry_timeout:\n\ttask->tk_action = call_timeout;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f",
        "vul_func_with_fix": "call_bind_status(struct rpc_task *task)\n{\n\tint status = -EIO;\n\n\tif (task->tk_status >= 0) {\n\t\tdprint_status(task);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_connect;\n\t\treturn;\n\t}\n\n\tswitch (task->tk_status) {\n\tcase -ENOMEM:\n\t\tdprintk(\"RPC: %5u rpcbind out of memory\\n\", task->tk_pid);\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EACCES:\n\t\tdprintk(\"RPC: %5u remote rpcbind: RPC program/version \"\n\t\t\t\t\"unavailable\\n\", task->tk_pid);\n\t\t/* fail immediately if this is an RPC ping */\n\t\tif (task->tk_msg.rpc_proc->p_proc == 0) {\n \t\t\tstatus = -EOPNOTSUPP;\n \t\t\tbreak;\n \t\t}\n//fix_flaw_line_below:\n//\t\tif (task->tk_rebind_retry == 0)\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\t\ttask->tk_rebind_retry--;\n \t\trpc_delay(task, 3*HZ);\n \t\tgoto retry_timeout;\n \tcase -ETIMEDOUT:\n\t\tdprintk(\"RPC: %5u rpcbind request timed out\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tgoto retry_timeout;\n\tcase -EPFNOSUPPORT:\n\t\t/* server doesn't support any rpcbind version we know of */\n\t\tdprintk(\"RPC: %5u unrecognized remote rpcbind service\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tbreak;\n\tcase -EPROTONOSUPPORT:\n\t\tdprintk(\"RPC: %5u remote rpcbind version unavailable, retrying\\n\",\n\t\t\t\ttask->tk_pid);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_bind;\n\t\treturn;\n\tcase -ECONNREFUSED:\t\t/* connection problems */\n\tcase -ECONNRESET:\n\tcase -ENOTCONN:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPIPE:\n\t\tdprintk(\"RPC: %5u remote rpcbind unreachable: %d\\n\",\n\t\t\t\ttask->tk_pid, task->tk_status);\n\t\tif (!RPC_IS_SOFTCONN(task)) {\n\t\t\trpc_delay(task, 5*HZ);\n\t\t\tgoto retry_timeout;\n\t\t}\n\t\tstatus = task->tk_status;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC: %5u unrecognized rpcbind error (%d)\\n\",\n\t\t\t\ttask->tk_pid, -task->tk_status);\n\t}\n\n\trpc_exit(task, status);\n\treturn;\n\nretry_timeout:\n\ttask->tk_action = call_timeout;\n}\n",
        "linevul": 0.9977933168411255,
        "sysevr": 0.1837291419506073,
        "devign": 0.9862172603607178
    },
    {
        "code": "void vfio_pci_intx_unmask(struct vfio_pci_device *vdev)\n{\n\tif (vfio_pci_intx_unmask_handler(vdev, NULL) > 0)\n\t\tvfio_send_intx_eventfd(vdev, NULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a",
        "vul_func_with_fix": "void vfio_pci_intx_unmask(struct vfio_pci_device *vdev)\n{\n\tif (vfio_pci_intx_unmask_handler(vdev, NULL) > 0)\n\t\tvfio_send_intx_eventfd(vdev, NULL);\n}\n",
        "linevul": 5.025080463383347e-05,
        "sysevr": 0.1615706980228424,
        "devign": 0.007256354670971632
    },
    {
        "code": "static int __net_init ndisc_net_init(struct net *net)\n{\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\n\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\tif (err < 0) {\n\t\tND_PRINTK(0, err,\n\t\t\t  \"NDISC: Failed to initialize the control socket (err %d)\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tnet->ipv6.ndisc_sk = sk;\n\n\tnp = inet6_sk(sk);\n\tnp->hop_limit = 255;\n\t/* Do not loopback ndisc messages */\n\tnp->mc_loop = 0;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fd99094de2b83d1d4c8457f2c83483b2828e75a",
        "vul_func_with_fix": "static int __net_init ndisc_net_init(struct net *net)\n{\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\n\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\tif (err < 0) {\n\t\tND_PRINTK(0, err,\n\t\t\t  \"NDISC: Failed to initialize the control socket (err %d)\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tnet->ipv6.ndisc_sk = sk;\n\n\tnp = inet6_sk(sk);\n\tnp->hop_limit = 255;\n\t/* Do not loopback ndisc messages */\n\tnp->mc_loop = 0;\n\n\treturn 0;\n}\n",
        "linevul": 4.536454434855841e-05,
        "sysevr": 0.13709339499473572,
        "devign": 0.624527096748352
    },
    {
        "code": "SYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\n\terr = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1",
        "vul_func_with_fix": "SYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\n\terr = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}\n",
        "linevul": 4.9961010518018156e-05,
        "sysevr": 0.15664486587047577,
        "devign": 0.49502286314964294
    },
    {
        "code": "int nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tif (local == NULL)\n\t\treturn 0;\n\n\treturn kref_put(&local->ref, local_release);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5",
        "vul_func_with_fix": "int nfc_llcp_local_put(struct nfc_llcp_local *local)\n{\n\tif (local == NULL)\n\t\treturn 0;\n\n\treturn kref_put(&local->ref, local_release);\n}\n",
        "linevul": 5.2573555876733735e-05,
        "sysevr": 0.15199072659015656,
        "devign": 0.07580473273992538
    },
    {
        "code": "void hns_ppe_reset_common(struct dsaf_device *dsaf_dev, u8 ppe_common_index)\n{\n\tu32 i;\n\tint ret;\n\tstruct ppe_common_cb *ppe_common;\n\n\tppe_common = dsaf_dev->ppe_common[ppe_common_index];\n\tret = hns_ppe_common_init_hw(ppe_common);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < ppe_common->ppe_num; i++) {\n\t\t/* We only need to initiate ppe when the port exists */\n\t\tif (dsaf_dev->mac_cb[i])\n\t\t\thns_ppe_init_hw(&ppe_common->ppe_cb[i]);\n\t}\n\n\tret = hns_rcb_common_init_hw(dsaf_dev->rcb_common[ppe_common_index]);\n\tif (ret)\n\t\treturn;\n\n\thns_rcb_common_init_commit_hw(dsaf_dev->rcb_common[ppe_common_index]);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c",
        "vul_func_with_fix": "void hns_ppe_reset_common(struct dsaf_device *dsaf_dev, u8 ppe_common_index)\n{\n\tu32 i;\n\tint ret;\n\tstruct ppe_common_cb *ppe_common;\n\n\tppe_common = dsaf_dev->ppe_common[ppe_common_index];\n\tret = hns_ppe_common_init_hw(ppe_common);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < ppe_common->ppe_num; i++) {\n\t\t/* We only need to initiate ppe when the port exists */\n\t\tif (dsaf_dev->mac_cb[i])\n\t\t\thns_ppe_init_hw(&ppe_common->ppe_cb[i]);\n\t}\n\n\tret = hns_rcb_common_init_hw(dsaf_dev->rcb_common[ppe_common_index]);\n\tif (ret)\n\t\treturn;\n\n\thns_rcb_common_init_commit_hw(dsaf_dev->rcb_common[ppe_common_index]);\n}\n",
        "linevul": 5.057049565948546e-05,
        "sysevr": 0.16657617688179016,
        "devign": 3.448835463973365e-16
    },
    {
        "code": "static void crypto_rfc4309_free(struct crypto_instance *inst)\n{\n\tcrypto_drop_spawn(crypto_instance_ctx(inst));\n\tkfree(inst);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "static void crypto_rfc4309_free(struct crypto_instance *inst)\n{\n\tcrypto_drop_spawn(crypto_instance_ctx(inst));\n\tkfree(inst);\n}\n",
        "linevul": 0.0004523874376900494,
        "sysevr": 0.12830252945423126,
        "devign": 0.0008271986152976751
    },
    {
        "code": "static int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op);\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif (ctxt->d & BitOp)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccLo:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccHi:\n\t\tif (ctxt->d & ByteOp) {\n\t\t\top->type = OP_NONE;\n\t\t\tbreak;\n\t\t}\n\t\top->type = OP_REG;\n\t\top->bytes = ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RDI);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = reg_read(ctxt, VCPU_REGS_RCX) & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpImm64:\n\t\trc = decode_imm(ctxt, op, ctxt->op_bytes, true);\n\t\tbreak;\n\tcase OpMem8:\n\t\tctxt->memop.bytes = 1;\n\t\tif (ctxt->memop.type == OP_REG) {\n\t\t\tctxt->memop.addr.reg = decode_register(ctxt,\n\t\t\t\t\tctxt->modrm_rm, true);\n\t\t\tfetch_register_operand(&ctxt->memop);\n\t\t}\n\t\tgoto mem_common;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RSI);\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpXLat:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\taddress_mask(ctxt,\n\t\t\t\treg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff));\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3747379accba8e95d70cec0eae0582c8c182050",
        "vul_func_with_fix": "static int decode_operand(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t\t  unsigned d)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (d) {\n\tcase OpReg:\n\t\tdecode_register_operand(ctxt, op);\n\t\tbreak;\n\tcase OpImmUByte:\n\t\trc = decode_imm(ctxt, op, 1, false);\n\t\tbreak;\n\tcase OpMem:\n\t\tctxt->memop.bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\tmem_common:\n\t\t*op = ctxt->memop;\n\t\tctxt->memopp = op;\n\t\tif (ctxt->d & BitOp)\n\t\t\tfetch_bit_operand(ctxt);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpMem64:\n\t\tctxt->memop.bytes = (ctxt->op_bytes == 8) ? 16 : 8;\n\t\tgoto mem_common;\n\tcase OpAcc:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccLo:\n\t\top->type = OP_REG;\n\t\top->bytes = (ctxt->d & ByteOp) ? 2 : ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpAccHi:\n\t\tif (ctxt->d & ByteOp) {\n\t\t\top->type = OP_NONE;\n\t\t\tbreak;\n\t\t}\n\t\top->type = OP_REG;\n\t\top->bytes = ctxt->op_bytes;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\top->orig_val = op->val;\n\t\tbreak;\n\tcase OpDI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RDI);\n\t\top->addr.mem.seg = VCPU_SREG_ES;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpDX:\n\t\top->type = OP_REG;\n\t\top->bytes = 2;\n\t\top->addr.reg = reg_rmw(ctxt, VCPU_REGS_RDX);\n\t\tfetch_register_operand(op);\n\t\tbreak;\n\tcase OpCL:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = reg_read(ctxt, VCPU_REGS_RCX) & 0xff;\n\t\tbreak;\n\tcase OpImmByte:\n\t\trc = decode_imm(ctxt, op, 1, true);\n\t\tbreak;\n\tcase OpOne:\n\t\top->type = OP_IMM;\n\t\top->bytes = 1;\n\t\top->val = 1;\n\t\tbreak;\n\tcase OpImm:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), true);\n\t\tbreak;\n\tcase OpImm64:\n\t\trc = decode_imm(ctxt, op, ctxt->op_bytes, true);\n\t\tbreak;\n\tcase OpMem8:\n\t\tctxt->memop.bytes = 1;\n\t\tif (ctxt->memop.type == OP_REG) {\n\t\t\tctxt->memop.addr.reg = decode_register(ctxt,\n\t\t\t\t\tctxt->modrm_rm, true);\n\t\t\tfetch_register_operand(&ctxt->memop);\n\t\t}\n\t\tgoto mem_common;\n\tcase OpMem16:\n\t\tctxt->memop.bytes = 2;\n\t\tgoto mem_common;\n\tcase OpMem32:\n\t\tctxt->memop.bytes = 4;\n\t\tgoto mem_common;\n\tcase OpImmU16:\n\t\trc = decode_imm(ctxt, op, 2, false);\n\t\tbreak;\n\tcase OpImmU:\n\t\trc = decode_imm(ctxt, op, imm_size(ctxt), false);\n\t\tbreak;\n\tcase OpSI:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\tregister_address(ctxt, VCPU_REGS_RSI);\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\top->count = 1;\n\t\tbreak;\n\tcase OpXLat:\n\t\top->type = OP_MEM;\n\t\top->bytes = (ctxt->d & ByteOp) ? 1 : ctxt->op_bytes;\n\t\top->addr.mem.ea =\n\t\t\taddress_mask(ctxt,\n\t\t\t\treg_read(ctxt, VCPU_REGS_RBX) +\n\t\t\t\t(reg_read(ctxt, VCPU_REGS_RAX) & 0xff));\n\t\top->addr.mem.seg = ctxt->seg_override;\n\t\top->val = 0;\n\t\tbreak;\n\tcase OpImmFAddr:\n\t\top->type = OP_IMM;\n\t\top->addr.mem.ea = ctxt->_eip;\n\t\top->bytes = ctxt->op_bytes + 2;\n\t\tinsn_fetch_arr(op->valptr, op->bytes, ctxt);\n\t\tbreak;\n\tcase OpMemFAddr:\n\t\tctxt->memop.bytes = ctxt->op_bytes + 2;\n\t\tgoto mem_common;\n\tcase OpES:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_ES;\n\t\tbreak;\n\tcase OpCS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_CS;\n\t\tbreak;\n\tcase OpSS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_SS;\n\t\tbreak;\n\tcase OpDS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_DS;\n\t\tbreak;\n\tcase OpFS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_FS;\n\t\tbreak;\n\tcase OpGS:\n\t\top->type = OP_IMM;\n\t\top->val = VCPU_SREG_GS;\n\t\tbreak;\n\tcase OpImplicit:\n\t\t/* Special instructions do their own operand decoding. */\n\tdefault:\n\t\top->type = OP_NONE; /* Disable writeback. */\n\t\tbreak;\n\t}\n\ndone:\n\treturn rc;\n}\n",
        "linevul": 6.812364154029638e-05,
        "sysevr": 0.192876398563385,
        "devign": 0.0
    },
    {
        "code": "static void __kprobes do_kernel_fault(struct pt_regs *regs, int si_code,\n\t\t\t\t      int fault_code, unsigned int insn,\n\t\t\t\t      unsigned long address)\n{\n\tunsigned char asi = ASI_P;\n \n\tif ((!insn) && (regs->tstate & TSTATE_PRIV))\n\t\tgoto cannot_handle;\n\n\t/* If user insn could be read (thus insn is zero), that\n\t * is fine.  We will just gun down the process with a signal\n\t * in that case.\n\t */\n\n\tif (!(fault_code & (FAULT_CODE_WRITE|FAULT_CODE_ITLB)) &&\n\t    (insn & 0xc0800000) == 0xc0800000) {\n\t\tif (insn & 0x2000)\n\t\t\tasi = (regs->tstate >> 24);\n\t\telse\n\t\t\tasi = (insn >> 5);\n\t\tif ((asi & 0xf2) == 0x82) {\n\t\t\tif (insn & 0x1000000) {\n\t\t\t\thandle_ldf_stq(insn, regs);\n\t\t\t} else {\n\t\t\t\t/* This was a non-faulting load. Just clear the\n\t\t\t\t * destination register(s) and continue with the next\n\t\t\t\t * instruction. -jj\n\t\t\t\t */\n\t\t\t\thandle_ld_nf(insn, regs);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\t/* Is this in ex_table? */\n\tif (regs->tstate & TSTATE_PRIV) {\n\t\tconst struct exception_table_entry *entry;\n\n\t\tentry = search_exception_tables(regs->tpc);\n\t\tif (entry) {\n\t\t\tregs->tpc = entry->fixup;\n\t\t\tregs->tnpc = regs->tpc + 4;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* The si_code was set to make clear whether\n\t\t * this was a SEGV_MAPERR or SEGV_ACCERR fault.\n\t\t */\n\t\tdo_fault_siginfo(si_code, SIGSEGV, regs, insn, fault_code);\n\t\treturn;\n\t}\n\ncannot_handle:\n\tunhandled_fault (address, current, regs);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void __kprobes do_kernel_fault(struct pt_regs *regs, int si_code,\n\t\t\t\t      int fault_code, unsigned int insn,\n\t\t\t\t      unsigned long address)\n{\n\tunsigned char asi = ASI_P;\n \n\tif ((!insn) && (regs->tstate & TSTATE_PRIV))\n\t\tgoto cannot_handle;\n\n\t/* If user insn could be read (thus insn is zero), that\n\t * is fine.  We will just gun down the process with a signal\n\t * in that case.\n\t */\n\n\tif (!(fault_code & (FAULT_CODE_WRITE|FAULT_CODE_ITLB)) &&\n\t    (insn & 0xc0800000) == 0xc0800000) {\n\t\tif (insn & 0x2000)\n\t\t\tasi = (regs->tstate >> 24);\n\t\telse\n\t\t\tasi = (insn >> 5);\n\t\tif ((asi & 0xf2) == 0x82) {\n\t\t\tif (insn & 0x1000000) {\n\t\t\t\thandle_ldf_stq(insn, regs);\n\t\t\t} else {\n\t\t\t\t/* This was a non-faulting load. Just clear the\n\t\t\t\t * destination register(s) and continue with the next\n\t\t\t\t * instruction. -jj\n\t\t\t\t */\n\t\t\t\thandle_ld_nf(insn, regs);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\t/* Is this in ex_table? */\n\tif (regs->tstate & TSTATE_PRIV) {\n\t\tconst struct exception_table_entry *entry;\n\n\t\tentry = search_exception_tables(regs->tpc);\n\t\tif (entry) {\n\t\t\tregs->tpc = entry->fixup;\n\t\t\tregs->tnpc = regs->tpc + 4;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t/* The si_code was set to make clear whether\n\t\t * this was a SEGV_MAPERR or SEGV_ACCERR fault.\n\t\t */\n\t\tdo_fault_siginfo(si_code, SIGSEGV, regs, insn, fault_code);\n\t\treturn;\n\t}\n\ncannot_handle:\n\tunhandled_fault (address, current, regs);\n}\n",
        "linevul": 0.0011616898700594902,
        "sysevr": 0.23146918416023254,
        "devign": 0.5940964221954346
    },
    {
        "code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\t/* skip ones added by this propagate_mnt() */\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t/* skip if mountpoint isn't covered by it */\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t/* beginning of peer group among the slaves? */\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\t/* Notice when we are propagating across user namespaces */\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n\treturn 0;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\t/* skip ones added by this propagate_mnt() */\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t/* skip if mountpoint isn't covered by it */\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t/* beginning of peer group among the slaves? */\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\t/* Notice when we are propagating across user namespaces */\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n \t\tread_sequnlock_excl(&mount_lock);\n \t}\n \thlist_add_head(&child->mnt_hash, list);\n//flaw_line_below:\n\treturn 0;\n//fix_flaw_line_below:\n//\treturn count_mounts(m->mnt_ns, child);\n }\n",
        "linevul": 0.00013410992687568069,
        "sysevr": 0.1387265920639038,
        "devign": 0.0
    },
    {
        "code": "struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, 0, NULL);\n\n\tif (!cookie_timestamp_decode(&tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack.v64\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\n\t/*\n\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n \t\tmemset(&fl6, 0, sizeof(fl6));\n \t\tfl6.flowi6_proto = IPPROTO_TCP;\n \t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n \t\tfl6.saddr = ireq->ir_v6_loc_addr;\n \t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n \t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;\n\t}\n\n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, dst);\nout:\n\treturn ret;\nout_free:\n\treqsk_free(req);\n\treturn NULL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "vul_func_with_fix": "struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, 0, NULL);\n\n\tif (!cookie_timestamp_decode(&tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack.v64\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\n\t/*\n\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n \t\tmemset(&fl6, 0, sizeof(fl6));\n \t\tfl6.flowi6_proto = IPPROTO_TCP;\n \t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n//flaw_line_below:\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n//fix_flaw_line_below:\n//\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n \t\tfl6.saddr = ireq->ir_v6_loc_addr;\n \t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n \t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;\n\t}\n\n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, dst);\nout:\n\treturn ret;\nout_free:\n\treqsk_free(req);\n\treturn NULL;\n}\n",
        "linevul": 0.000299187027849257,
        "sysevr": 0.2183029055595398,
        "devign": 0.9999880790710449
    },
    {
        "code": "static int enqueue_to_backlog(struct sk_buff *skb, int cpu,\n\t\t\t      unsigned int *qtail)\n{\n\tstruct softnet_data *sd;\n\tunsigned long flags;\n\tunsigned int qlen;\n\n\tsd = &per_cpu(softnet_data, cpu);\n\n\tlocal_irq_save(flags);\n\n\trps_lock(sd);\n\tif (!netif_running(skb->dev))\n\t\tgoto drop;\n\tqlen = skb_queue_len(&sd->input_pkt_queue);\n\tif (qlen <= netdev_max_backlog && !skb_flow_limit(skb, qlen)) {\n\t\tif (qlen) {\nenqueue:\n\t\t\t__skb_queue_tail(&sd->input_pkt_queue, skb);\n\t\t\tinput_queue_tail_incr_save(sd, qtail);\n\t\t\trps_unlock(sd);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn NET_RX_SUCCESS;\n\t\t}\n\n\t\t/* Schedule NAPI for backlog device\n\t\t * We can use non atomic operation since we own the queue lock\n\t\t */\n\t\tif (!__test_and_set_bit(NAPI_STATE_SCHED, &sd->backlog.state)) {\n\t\t\tif (!rps_ipi_queued(sd))\n\t\t\t\t____napi_schedule(sd, &sd->backlog);\n\t\t}\n\t\tgoto enqueue;\n\t}\n\ndrop:\n\tsd->dropped++;\n\trps_unlock(sd);\n\n\tlocal_irq_restore(flags);\n\n\tatomic_long_inc(&skb->dev->rx_dropped);\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
        "vul_func_with_fix": "static int enqueue_to_backlog(struct sk_buff *skb, int cpu,\n\t\t\t      unsigned int *qtail)\n{\n\tstruct softnet_data *sd;\n\tunsigned long flags;\n\tunsigned int qlen;\n\n\tsd = &per_cpu(softnet_data, cpu);\n\n\tlocal_irq_save(flags);\n\n\trps_lock(sd);\n\tif (!netif_running(skb->dev))\n\t\tgoto drop;\n\tqlen = skb_queue_len(&sd->input_pkt_queue);\n\tif (qlen <= netdev_max_backlog && !skb_flow_limit(skb, qlen)) {\n\t\tif (qlen) {\nenqueue:\n\t\t\t__skb_queue_tail(&sd->input_pkt_queue, skb);\n\t\t\tinput_queue_tail_incr_save(sd, qtail);\n\t\t\trps_unlock(sd);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn NET_RX_SUCCESS;\n\t\t}\n\n\t\t/* Schedule NAPI for backlog device\n\t\t * We can use non atomic operation since we own the queue lock\n\t\t */\n\t\tif (!__test_and_set_bit(NAPI_STATE_SCHED, &sd->backlog.state)) {\n\t\t\tif (!rps_ipi_queued(sd))\n\t\t\t\t____napi_schedule(sd, &sd->backlog);\n\t\t}\n\t\tgoto enqueue;\n\t}\n\ndrop:\n\tsd->dropped++;\n\trps_unlock(sd);\n\n\tlocal_irq_restore(flags);\n\n\tatomic_long_inc(&skb->dev->rx_dropped);\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n",
        "linevul": 6.0918566305190325e-05,
        "sysevr": 0.12696129083633423,
        "devign": 3.4089656496056937e-32
    },
    {
        "code": "static int vhost_net_release(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = f->private_data;\n\tstruct socket *tx_sock;\n\tstruct socket *rx_sock;\n\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\tvhost_dev_stop(&n->dev);\n\tvhost_dev_cleanup(&n->dev, false);\n\tvhost_net_vq_reset(n);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\t/* Make sure no callbacks are outstanding */\n\tsynchronize_rcu_bh();\n\t/* We do an extra flush before freeing memory,\n\t * since jobs can re-queue themselves. */\n\tvhost_net_flush(n);\n\tkfree(n->dev.vqs);\n\tkfree(n);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0",
        "vul_func_with_fix": "static int vhost_net_release(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = f->private_data;\n\tstruct socket *tx_sock;\n\tstruct socket *rx_sock;\n\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\tvhost_dev_stop(&n->dev);\n\tvhost_dev_cleanup(&n->dev, false);\n\tvhost_net_vq_reset(n);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\t/* Make sure no callbacks are outstanding */\n\tsynchronize_rcu_bh();\n\t/* We do an extra flush before freeing memory,\n\t * since jobs can re-queue themselves. */\n\tvhost_net_flush(n);\n\tkfree(n->dev.vqs);\n\tkfree(n);\n\treturn 0;\n}\n",
        "linevul": 8.540064300177619e-05,
        "sysevr": 0.12827834486961365,
        "devign": 8.722564416530076e-06
    },
    {
        "code": "int nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_secinfo(dir, name, flavors),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "int nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_secinfo(dir, name, flavors),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "linevul": 8.005806739674881e-05,
        "sysevr": 0.16050513088703156,
        "devign": 1.2816297356721407e-08
    },
    {
        "code": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n \t\t\t     unsigned char __user *data, int optlen)\n {\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n \t\tkfree(opt);\n \t\treturn -EFAULT;\n \t}\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n//fix_flaw_line_below:\n//int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,\n \t\t\t     unsigned char __user *data, int optlen)\n {\n//flaw_line_below:\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n//fix_flaw_line_below:\n//\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n//flaw_line_below:\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n//fix_flaw_line_below:\n//\tif (optlen && copy_from_user(opt->opt.__data, data, optlen)) {\n \t\tkfree(opt);\n \t\treturn -EFAULT;\n \t}\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n",
        "linevul": 0.9996656179428101,
        "sysevr": 0.14621993899345398,
        "devign": 0.515441358089447
    },
    {
        "code": "void __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU,\n\t\t\tsighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tvm_area_cachep = kmem_cache_create(\"vm_area_struct\",\n\t\t\tsizeof(struct vm_area_struct), 0,\n\t\t\tSLAB_PANIC, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7",
        "vul_func_with_fix": "void __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU,\n\t\t\tsighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\tvm_area_cachep = kmem_cache_create(\"vm_area_struct\",\n\t\t\tsizeof(struct vm_area_struct), 0,\n\t\t\tSLAB_PANIC, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n",
        "linevul": 0.0002217423461843282,
        "sysevr": 0.16072212159633636,
        "devign": 0.5977188944816589
    },
    {
        "code": "static int pid_smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_smaps_op);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce",
        "vul_func_with_fix": "static int pid_smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_smaps_op);\n}\n",
        "linevul": 0.00021543567709159106,
        "sysevr": 0.12712623178958893,
        "devign": 0.00021468722843565047
    },
    {
        "code": "static int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,\n\t\t\t\t      int out_ports, int in_ports)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(umidi->card, \"USB MIDI\",\n\t\t\t      umidi->next_midi_device++,\n\t\t\t      out_ports, in_ports, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, umidi->card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->ops = &snd_usbmidi_ops;\n\trmidi->private_data = umidi;\n\trmidi->private_free = snd_usbmidi_rawmidi_free;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_usbmidi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_usbmidi_input_ops);\n\n\tumidi->rmidi = rmidi;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/07d86ca93db7e5cdf4743564d98292042ec21af7",
        "vul_func_with_fix": "static int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,\n\t\t\t\t      int out_ports, int in_ports)\n{\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\n\terr = snd_rawmidi_new(umidi->card, \"USB MIDI\",\n\t\t\t      umidi->next_midi_device++,\n\t\t\t      out_ports, in_ports, &rmidi);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(rmidi->name, umidi->card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->ops = &snd_usbmidi_ops;\n\trmidi->private_data = umidi;\n\trmidi->private_free = snd_usbmidi_rawmidi_free;\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t    &snd_usbmidi_output_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t    &snd_usbmidi_input_ops);\n\n\tumidi->rmidi = rmidi;\n\treturn 0;\n}\n",
        "linevul": 6.609222327824682e-05,
        "sysevr": 0.13702864944934845,
        "devign": 1.890859600243034e-15
    },
    {
        "code": "asmlinkage void sys_exit_group(int error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7",
        "vul_func_with_fix": "asmlinkage void sys_exit_group(int error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n}\n",
        "linevul": 5.226493158261292e-05,
        "sysevr": 0.1693897843360901,
        "devign": 4.550086941890186e-06
    },
    {
        "code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\n\tkernel_fpu_begin();\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tclmul_ghash_mul(dst, &ctx->shash);\n\t}\n\n\tclmul_ghash_update(dst, src, srclen, &ctx->shash);\n\tkernel_fpu_end();\n\n\tif (srclen & 0xf) {\n\t\tsrc += srclen - (srclen & 0xf);\n\t\tsrclen &= 0xf;\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\n\tkernel_fpu_begin();\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tclmul_ghash_mul(dst, &ctx->shash);\n\t}\n\n\tclmul_ghash_update(dst, src, srclen, &ctx->shash);\n\tkernel_fpu_end();\n\n\tif (srclen & 0xf) {\n\t\tsrc += srclen - (srclen & 0xf);\n\t\tsrclen &= 0xf;\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 6.602929352084175e-05,
        "sysevr": 0.13823997974395752,
        "devign": 1.0572017436830117e-12
    },
    {
        "code": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n \t\t\t\tstruct uid_gid_map *new_map)\n {\n \t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n \n \t/* Allow the specified ids if we have the appropriate capability\n \t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n \t */\n\tif (ns_capable(ns->parent, cap_setid))\n \t\treturn true;\n \n \treturn false;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6708075f104c3c9b04b23336bb0366ca30c3931b",
        "vul_func_with_fix": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n//fix_flaw_line_below:\n//static bool new_idmap_permitted(const struct file *file, \n//fix_flaw_line_below:\n//\t\t\t\tstruct user_namespace *ns, int cap_setid,\n \t\t\t\tstruct uid_gid_map *new_map)\n {\n \t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n \n \t/* Allow the specified ids if we have the appropriate capability\n \t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n//fix_flaw_line_below:\n//\t * And the opener of the id file also had the approprpiate capability.\n \t */\n//flaw_line_below:\n\tif (ns_capable(ns->parent, cap_setid))\n//fix_flaw_line_below:\n//\tif (ns_capable(ns->parent, cap_setid) &&\n//fix_flaw_line_below:\n//\t    file_ns_capable(file, ns->parent, cap_setid))\n \t\treturn true;\n \n \treturn false;\n}\n",
        "linevul": 0.9805282950401306,
        "sysevr": 0.13719813525676727,
        "devign": 5.75479412146043e-17
    },
    {
        "code": "static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)\n{\n\t__u32 tmp[OUTPUT_POOL_WORDS];\n\n\tif (r->pull && r->entropy_count < nbytes * 8 &&\n\t    r->entropy_count < r->poolinfo->POOLBITS) {\n\t\t/* If we're limited, always leave two wakeup worth's BITS */\n\t\tint rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;\n\t\tint bytes = nbytes;\n\n\t\t/* pull at least as many as BYTES as wakeup BITS */\n\t\tbytes = max_t(int, bytes, random_read_wakeup_thresh / 8);\n\t\t/* but never more than the buffer size */\n\t\tbytes = min_t(int, bytes, sizeof(tmp));\n\n\t\tDEBUG_ENT(\"going to reseed %s with %d bits \"\n\t\t\t  \"(%d of %d requested)\\n\",\n\t\t\t  r->name, bytes * 8, nbytes * 8, r->entropy_count);\n\n\t\tbytes = extract_entropy(r->pull, tmp, bytes,\n\t\t\t\t\trandom_read_wakeup_thresh / 8, rsvd);\n\t\tmix_pool_bytes(r, tmp, bytes);\n\t\tcredit_entropy_bits(r, bytes*8);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
        "vul_func_with_fix": "static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)\n{\n\t__u32 tmp[OUTPUT_POOL_WORDS];\n\n\tif (r->pull && r->entropy_count < nbytes * 8 &&\n\t    r->entropy_count < r->poolinfo->POOLBITS) {\n\t\t/* If we're limited, always leave two wakeup worth's BITS */\n\t\tint rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;\n\t\tint bytes = nbytes;\n\n\t\t/* pull at least as many as BYTES as wakeup BITS */\n\t\tbytes = max_t(int, bytes, random_read_wakeup_thresh / 8);\n\t\t/* but never more than the buffer size */\n\t\tbytes = min_t(int, bytes, sizeof(tmp));\n\n\t\tDEBUG_ENT(\"going to reseed %s with %d bits \"\n\t\t\t  \"(%d of %d requested)\\n\",\n\t\t\t  r->name, bytes * 8, nbytes * 8, r->entropy_count);\n\n\t\tbytes = extract_entropy(r->pull, tmp, bytes,\n\t\t\t\t\trandom_read_wakeup_thresh / 8, rsvd);\n\t\tmix_pool_bytes(r, tmp, bytes);\n\t\tcredit_entropy_bits(r, bytes*8);\n\t}\n}\n",
        "linevul": 0.00010325984476367012,
        "sysevr": 0.15055684745311737,
        "devign": 0.5232899188995361
    },
    {
        "code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n \t\tret = PTR_ERR(keyring);\n \t\tgoto error2;\n \t} else if (keyring == new->session_keyring) {\n \t\tret = 0;\n \t\tgoto error2;\n \t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/23567fd052a9abb6d67fe8e7a9ccdd9800a540f2",
        "vul_func_with_fix": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n \t\tret = PTR_ERR(keyring);\n \t\tgoto error2;\n \t} else if (keyring == new->session_keyring) {\n//fix_flaw_line_below:\n//\t\tkey_put(keyring);\n \t\tret = 0;\n \t\tgoto error2;\n \t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n",
        "linevul": 7.282870501512662e-05,
        "sysevr": 0.23608539998531342,
        "devign": 0.9987412095069885
    },
    {
        "code": "static int find_overflow_devnum(void)\n{\n\tint ret;\n\n\tif (!overflow_maj) {\n\t\tret = alloc_chrdev_region(&overflow_maj, 0, IB_UCM_MAX_DEVICES,\n\t\t\t\t\t  \"infiniband_cm\");\n\t\tif (ret) {\n\t\t\tpr_err(\"ucm: couldn't register dynamic device number\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = find_first_zero_bit(overflow_map, IB_UCM_MAX_DEVICES);\n\tif (ret >= IB_UCM_MAX_DEVICES)\n\t\treturn -1;\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static int find_overflow_devnum(void)\n{\n\tint ret;\n\n\tif (!overflow_maj) {\n\t\tret = alloc_chrdev_region(&overflow_maj, 0, IB_UCM_MAX_DEVICES,\n\t\t\t\t\t  \"infiniband_cm\");\n\t\tif (ret) {\n\t\t\tpr_err(\"ucm: couldn't register dynamic device number\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = find_first_zero_bit(overflow_map, IB_UCM_MAX_DEVICES);\n\tif (ret >= IB_UCM_MAX_DEVICES)\n\t\treturn -1;\n\n\treturn ret;\n}\n",
        "linevul": 4.8646066716173664e-05,
        "sysevr": 0.1268947571516037,
        "devign": 9.567695384061787e-15
    },
    {
        "code": "static void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tif (nfs4_setup_sequence(data->seq_server, data->seq_args,\n\t\t\t\tdata->seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "vul_func_with_fix": "static void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tif (nfs4_setup_sequence(data->seq_server, data->seq_args,\n\t\t\t\tdata->seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n",
        "linevul": 4.9912388931261376e-05,
        "sysevr": 0.12462933361530304,
        "devign": 3.8061730850413866e-11
    },
    {
        "code": "int crypto_register_instance(struct crypto_template *tmpl,\n\t\t\t     struct crypto_instance *inst)\n{\n\tstruct crypto_larval *larval;\n\tint err;\n\n\terr = crypto_check_alg(&inst->alg);\n\tif (err)\n\t\tgoto err;\n\n\tinst->alg.cra_module = tmpl->module;\n\tinst->alg.cra_flags |= CRYPTO_ALG_INSTANCE;\n\n\tdown_write(&crypto_alg_sem);\n\n\tlarval = __crypto_register_alg(&inst->alg);\n\tif (IS_ERR(larval))\n\t\tgoto unlock;\n\n\thlist_add_head(&inst->list, &tmpl->instances);\n\tinst->tmpl = tmpl;\n\nunlock:\n\tup_write(&crypto_alg_sem);\n\n\terr = PTR_ERR(larval);\n\tif (IS_ERR(larval))\n\t\tgoto err;\n\n\tcrypto_wait_for_test(larval);\n\terr = 0;\n\nerr:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "int crypto_register_instance(struct crypto_template *tmpl,\n\t\t\t     struct crypto_instance *inst)\n{\n\tstruct crypto_larval *larval;\n\tint err;\n\n\terr = crypto_check_alg(&inst->alg);\n\tif (err)\n\t\tgoto err;\n\n\tinst->alg.cra_module = tmpl->module;\n\tinst->alg.cra_flags |= CRYPTO_ALG_INSTANCE;\n\n\tdown_write(&crypto_alg_sem);\n\n\tlarval = __crypto_register_alg(&inst->alg);\n\tif (IS_ERR(larval))\n\t\tgoto unlock;\n\n\thlist_add_head(&inst->list, &tmpl->instances);\n\tinst->tmpl = tmpl;\n\nunlock:\n\tup_write(&crypto_alg_sem);\n\n\terr = PTR_ERR(larval);\n\tif (IS_ERR(larval))\n\t\tgoto err;\n\n\tcrypto_wait_for_test(larval);\n\terr = 0;\n\nerr:\n\treturn err;\n}\n",
        "linevul": 6.54328687232919e-05,
        "sysevr": 0.1848418116569519,
        "devign": 0.0002909334434662014
    },
    {
        "code": "handle_t *ext4_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\thandle_t  *handle;\n\n\ttrace_ext4_journal_start(sb, nblocks, _RET_IP_);\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\thandle = ext4_journal_current_handle();\n\n\t/*\n\t * If a handle has been started, it should be allowed to\n\t * finish, otherwise deadlock could happen between freeze\n\t * and others(e.g. truncate) due to the restart of the\n\t * journal handle if the filesystem is forzen and active\n\t * handles are not stopped.\n\t */\n\tif (!handle)\n\t\tvfs_check_frozen(sb, SB_FREEZE_TRANS);\n\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\treturn jbd2_journal_start(journal, nblocks);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b",
        "vul_func_with_fix": "handle_t *ext4_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\thandle_t  *handle;\n\n\ttrace_ext4_journal_start(sb, nblocks, _RET_IP_);\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\thandle = ext4_journal_current_handle();\n\n\t/*\n\t * If a handle has been started, it should be allowed to\n\t * finish, otherwise deadlock could happen between freeze\n\t * and others(e.g. truncate) due to the restart of the\n\t * journal handle if the filesystem is forzen and active\n\t * handles are not stopped.\n\t */\n\tif (!handle)\n\t\tvfs_check_frozen(sb, SB_FREEZE_TRANS);\n\n\tif (!journal)\n\t\treturn ext4_get_nojournal();\n\t/*\n\t * Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly.\n\t */\n\tif (is_journal_aborted(journal)) {\n\t\text4_abort(sb, \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\treturn jbd2_journal_start(journal, nblocks);\n}\n",
        "linevul": 7.07473955117166e-05,
        "sysevr": 0.19198982417583466,
        "devign": 2.9054300298980706e-08
    },
    {
        "code": "__trace_array_vprintk(struct ring_buffer *buffer,\n\t\t      unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct trace_event_call *call = &event_print;\n\tstruct ring_buffer_event *event;\n\tint len = 0, size, pc;\n\tstruct print_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn 0;\n\n\t/* Don't pollute graph traces with trace_vprintk internals */\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out_nobuffer;\n\t}\n\n\tlen = vscnprintf(tbuffer, TRACE_BUF_SIZE, fmt, args);\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + len + 1;\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_PRINT, size,\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, tbuffer, len + 1);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(&global_trace, buffer, flags, 6, pc, NULL);\n\t}\n\nout:\n\tput_trace_buf();\n\nout_nobuffer:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "__trace_array_vprintk(struct ring_buffer *buffer,\n\t\t      unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct trace_event_call *call = &event_print;\n\tstruct ring_buffer_event *event;\n\tint len = 0, size, pc;\n\tstruct print_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn 0;\n\n\t/* Don't pollute graph traces with trace_vprintk internals */\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out_nobuffer;\n\t}\n\n\tlen = vscnprintf(tbuffer, TRACE_BUF_SIZE, fmt, args);\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + len + 1;\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_PRINT, size,\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, tbuffer, len + 1);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(&global_trace, buffer, flags, 6, pc, NULL);\n\t}\n\nout:\n\tput_trace_buf();\n\nout_nobuffer:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\n",
        "linevul": 0.00013969787687528878,
        "sysevr": 0.1979161500930786,
        "devign": 5.74072651508819e-29
    },
    {
        "code": "static void perf_event_init_userpage(struct perf_event *event)\n{\n\tstruct perf_event_mmap_page *userpg;\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\tuserpg = rb->user_page;\n\n\t/* Allow new userspace to detect that bit 0 is deprecated */\n\tuserpg->cap_bit0_is_deprecated = 1;\n\tuserpg->size = offsetof(struct perf_event_mmap_page, __reserved);\n\tuserpg->data_offset = PAGE_SIZE;\n\tuserpg->data_size = perf_data_size(rb);\n\nunlock:\n\trcu_read_unlock();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "vul_func_with_fix": "static void perf_event_init_userpage(struct perf_event *event)\n{\n\tstruct perf_event_mmap_page *userpg;\n\tstruct ring_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (!rb)\n\t\tgoto unlock;\n\n\tuserpg = rb->user_page;\n\n\t/* Allow new userspace to detect that bit 0 is deprecated */\n\tuserpg->cap_bit0_is_deprecated = 1;\n\tuserpg->size = offsetof(struct perf_event_mmap_page, __reserved);\n\tuserpg->data_offset = PAGE_SIZE;\n\tuserpg->data_size = perf_data_size(rb);\n\nunlock:\n\trcu_read_unlock();\n}\n",
        "linevul": 5.080948176328093e-05,
        "sysevr": 0.13118287920951843,
        "devign": 2.5071234631468542e-05
    },
    {
        "code": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n \tstruct rdma_ucm_cmd_hdr hdr;\n \tssize_t ret;\n \n \tif (len < sizeof(hdr))\n \t\treturn -EINVAL;\n \n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n \tstruct rdma_ucm_cmd_hdr hdr;\n \tssize_t ret;\n \n//fix_flaw_line_below:\n//\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n//fix_flaw_line_below:\n//\t\treturn -EACCES;\n//fix_flaw_line_below:\n//\n \tif (len < sizeof(hdr))\n \t\treturn -EINVAL;\n \n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}\n",
        "linevul": 0.9996429681777954,
        "sysevr": 0.14085575938224792,
        "devign": 0.590266764163971
    },
    {
        "code": "SMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)\n{\n\tint type;\n\n\ttype = smb2_select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase Kerberos:\n\t\tsess_data->func = SMB2_auth_kerberos;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e",
        "vul_func_with_fix": "SMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)\n{\n\tint type;\n\n\ttype = smb2_select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase Kerberos:\n\t\tsess_data->func = SMB2_auth_kerberos;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 4.782062751473859e-05,
        "sysevr": 0.16632050275802612,
        "devign": 2.452671621355762e-09
    },
    {
        "code": "__u32 cookie_init_timestamp(struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq;\n\tu32 ts, ts_now = tcp_time_stamp;\n\tu32 options = 0;\n\n\tireq = inet_rsk(req);\n\n\toptions = ireq->wscale_ok ? ireq->snd_wscale : 0xf;\n\toptions |= ireq->sack_ok << 4;\n\toptions |= ireq->ecn_ok << 5;\n\n\tts = ts_now & ~TSMASK;\n\tts |= options;\n\tif (ts > ts_now) {\n\t\tts >>= TSBITS;\n\t\tts--;\n\t\tts <<= TSBITS;\n\t\tts |= options;\n\t}\n\treturn ts;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "__u32 cookie_init_timestamp(struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq;\n\tu32 ts, ts_now = tcp_time_stamp;\n\tu32 options = 0;\n\n\tireq = inet_rsk(req);\n\n\toptions = ireq->wscale_ok ? ireq->snd_wscale : 0xf;\n\toptions |= ireq->sack_ok << 4;\n\toptions |= ireq->ecn_ok << 5;\n\n\tts = ts_now & ~TSMASK;\n\tts |= options;\n\tif (ts > ts_now) {\n\t\tts >>= TSBITS;\n\t\tts--;\n\t\tts <<= TSBITS;\n\t\tts |= options;\n\t}\n\treturn ts;\n}\n",
        "linevul": 0.0003536357544362545,
        "sysevr": 0.1852726936340332,
        "devign": 6.062944742611653e-13
    },
    {
        "code": "cpu_to_phys_group(int cpu, const struct cpumask *cpu_map,\n\t\t  struct sched_group **sg, struct cpumask *mask)\n{\n\tint group;\n#ifdef CONFIG_SCHED_BOOK\n\tcpumask_and(mask, cpu_book_mask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#elif defined(CONFIG_SCHED_MC)\n\tcpumask_and(mask, cpu_coregroup_mask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#elif defined(CONFIG_SCHED_SMT)\n\tcpumask_and(mask, topology_thread_cpumask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#else\n\tgroup = cpu;\n#endif\n\tif (sg)\n\t\t*sg = &per_cpu(sched_group_phys, group).sg;\n\treturn group;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": "cpu_to_phys_group(int cpu, const struct cpumask *cpu_map,\n\t\t  struct sched_group **sg, struct cpumask *mask)\n{\n\tint group;\n#ifdef CONFIG_SCHED_BOOK\n\tcpumask_and(mask, cpu_book_mask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#elif defined(CONFIG_SCHED_MC)\n\tcpumask_and(mask, cpu_coregroup_mask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#elif defined(CONFIG_SCHED_SMT)\n\tcpumask_and(mask, topology_thread_cpumask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#else\n\tgroup = cpu;\n#endif\n\tif (sg)\n\t\t*sg = &per_cpu(sched_group_phys, group).sg;\n\treturn group;\n}\n",
        "linevul": 4.9619717174209654e-05,
        "sysevr": 0.19003696739673615,
        "devign": 0.0012741212267428637
    },
    {
        "code": "void rds_ib_send_add_credits(struct rds_connection *conn, unsigned int credits)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\tif (credits == 0)\n\t\treturn;\n\n\trdsdebug(\"rds_ib_send_add_credits(%u): current=%u%s\\n\",\n\t\t\tcredits,\n\t\t\tIB_GET_SEND_CREDITS(atomic_read(&ic->i_credits)),\n\t\t\ttest_bit(RDS_LL_SEND_FULL, &conn->c_flags) ? \", ll_send_full\" : \"\");\n\n\tatomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);\n\tif (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\n\n\tWARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);\n\n\trds_ib_stats_inc(s_ib_rx_credit_updates);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f",
        "vul_func_with_fix": "void rds_ib_send_add_credits(struct rds_connection *conn, unsigned int credits)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\tif (credits == 0)\n\t\treturn;\n\n\trdsdebug(\"rds_ib_send_add_credits(%u): current=%u%s\\n\",\n\t\t\tcredits,\n\t\t\tIB_GET_SEND_CREDITS(atomic_read(&ic->i_credits)),\n\t\t\ttest_bit(RDS_LL_SEND_FULL, &conn->c_flags) ? \", ll_send_full\" : \"\");\n\n\tatomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);\n\tif (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\n\n\tWARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);\n\n\trds_ib_stats_inc(s_ib_rx_credit_updates);\n}\n",
        "linevul": 5.00091518915724e-05,
        "sysevr": 0.16607806086540222,
        "devign": 1.3437033885566052e-05
    },
    {
        "code": "static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq, fatal);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52",
        "vul_func_with_fix": "static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq, fatal);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n",
        "linevul": 0.001703880145214498,
        "sysevr": 0.18008339405059814,
        "devign": 2.0315694242059572e-23
    },
    {
        "code": "int vcc_create(struct net *net, struct socket *sock, int protocol, int family)\n{\n\tstruct sock *sk;\n\tstruct atm_vcc *vcc;\n\n\tsock->sk = NULL;\n\tif (sock->type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\tsk = sk_alloc(net, family, GFP_KERNEL, &vcc_proto);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_state_change = vcc_def_wakeup;\n\tsk->sk_write_space = vcc_write_space;\n\n\tvcc = atm_sk(sk);\n\tvcc->dev = NULL;\n\tmemset(&vcc->local, 0, sizeof(struct sockaddr_atmsvc));\n\tmemset(&vcc->remote, 0, sizeof(struct sockaddr_atmsvc));\n\tvcc->qos.txtp.max_sdu = 1 << 16; /* for meta VCs */\n\tatomic_set(&sk->sk_wmem_alloc, 1);\n\tatomic_set(&sk->sk_rmem_alloc, 0);\n\tvcc->push = NULL;\n\tvcc->pop = NULL;\n\tvcc->push_oam = NULL;\n\tvcc->vpi = vcc->vci = 0; /* no VCI/VPI yet */\n\tvcc->atm_options = vcc->aal_options = 0;\n\tsk->sk_destruct = vcc_sock_destruct;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e862f1a9b7df4e8196ebec45ac62295138aa3fc2",
        "vul_func_with_fix": "int vcc_create(struct net *net, struct socket *sock, int protocol, int family)\n{\n\tstruct sock *sk;\n\tstruct atm_vcc *vcc;\n\n\tsock->sk = NULL;\n\tif (sock->type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\tsk = sk_alloc(net, family, GFP_KERNEL, &vcc_proto);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_state_change = vcc_def_wakeup;\n\tsk->sk_write_space = vcc_write_space;\n\n\tvcc = atm_sk(sk);\n\tvcc->dev = NULL;\n\tmemset(&vcc->local, 0, sizeof(struct sockaddr_atmsvc));\n\tmemset(&vcc->remote, 0, sizeof(struct sockaddr_atmsvc));\n\tvcc->qos.txtp.max_sdu = 1 << 16; /* for meta VCs */\n\tatomic_set(&sk->sk_wmem_alloc, 1);\n\tatomic_set(&sk->sk_rmem_alloc, 0);\n\tvcc->push = NULL;\n\tvcc->pop = NULL;\n\tvcc->push_oam = NULL;\n\tvcc->vpi = vcc->vci = 0; /* no VCI/VPI yet */\n\tvcc->atm_options = vcc->aal_options = 0;\n\tsk->sk_destruct = vcc_sock_destruct;\n\treturn 0;\n}\n",
        "linevul": 0.853339672088623,
        "sysevr": 0.18306340277194977,
        "devign": 7.840275831299141e-35
    },
    {
        "code": "static int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\n\tif (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\n\t/* According to the Intel VMX instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\t/* Trap single context invalidation invept calls */\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\n\tif (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\ttypes = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\n\t/* According to the Intel VMX instruction reference, the memory\n\t * operand is read even if it isn't needed (e.g., for type==global)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\t/* Trap single context invalidation invept calls */\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n",
        "linevul": 0.0001169851457234472,
        "sysevr": 0.16788268089294434,
        "devign": 1.2095884305375127e-24
    },
    {
        "code": "static int mem_cgroup_usage_register_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 threshold, usage;\n\tint i, size, ret;\n\n\tret = res_counter_memparse_write_strategy(args, &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold < usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static int mem_cgroup_usage_register_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd, const char *args)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 threshold, usage;\n\tint i, size, ret;\n\n\tret = res_counter_memparse_write_strategy(args, &threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&memcg->thresholds_lock);\n\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\n\t/* Check if a threshold crossed before adding a new one */\n\tif (thresholds->primary)\n\t\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\n\tsize = thresholds->primary ? thresholds->primary->size + 1 : 1;\n\n\t/* Allocate memory for new array of thresholds */\n\tnew = kmalloc(sizeof(*new) + size * sizeof(struct mem_cgroup_threshold),\n\t\t\tGFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tnew->size = size;\n\n\t/* Copy thresholds (if any) to new array */\n\tif (thresholds->primary) {\n\t\tmemcpy(new->entries, thresholds->primary->entries, (size - 1) *\n\t\t\t\tsizeof(struct mem_cgroup_threshold));\n\t}\n\n\t/* Add new threshold */\n\tnew->entries[size - 1].eventfd = eventfd;\n\tnew->entries[size - 1].threshold = threshold;\n\n\t/* Sort thresholds. Registering of new threshold isn't time-critical */\n\tsort(new->entries, size, sizeof(struct mem_cgroup_threshold),\n\t\t\tcompare_thresholds, NULL);\n\n\t/* Find current threshold */\n\tnew->current_threshold = -1;\n\tfor (i = 0; i < size; i++) {\n\t\tif (new->entries[i].threshold < usage) {\n\t\t\t/*\n\t\t\t * new->current_threshold will not be used until\n\t\t\t * rcu_assign_pointer(), so it's safe to increment\n\t\t\t * it here.\n\t\t\t */\n\t\t\t++new->current_threshold;\n\t\t}\n\t}\n\n\t/* Free old spare buffer and save old primary buffer as spare */\n\tkfree(thresholds->spare);\n\tthresholds->spare = thresholds->primary;\n\n\trcu_assign_pointer(thresholds->primary, new);\n\n\t/* To be sure that nobody uses thresholds */\n\tsynchronize_rcu();\n\nunlock:\n\tmutex_unlock(&memcg->thresholds_lock);\n\n\treturn ret;\n}\n",
        "linevul": 9.291351307183504e-05,
        "sysevr": 0.15092729032039642,
        "devign": 8.151374714104875e-11
    },
    {
        "code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n \n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887",
        "vul_func_with_fix": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n//fix_flaw_line_below:\n//\thdr->sadb_msg_reserved = 0;\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n \n}\n",
        "linevul": 0.9991766810417175,
        "sysevr": 0.16546420753002167,
        "devign": 0.9892549514770508
    },
    {
        "code": "static u32 rio_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->link_status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75",
        "vul_func_with_fix": "static u32 rio_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->link_status;\n}\n",
        "linevul": 5.609245636151172e-05,
        "sysevr": 0.1291850060224533,
        "devign": 6.527442906190117e-07
    },
    {
        "code": "static int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\n{\n\tconst char *p = (char *) hdr;\n\tint len = skb->len;\n\n\tlen -= sizeof(*hdr);\n\tp += sizeof(*hdr);\n\twhile (len > 0) {\n\t\tconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\n\t\tuint16_t ext_type;\n\t\tint ext_len;\n\n\t\text_len  = ehdr->sadb_ext_len;\n\t\text_len *= sizeof(uint64_t);\n\t\text_type = ehdr->sadb_ext_type;\n\t\tif (ext_len < sizeof(uint64_t) ||\n\t\t    ext_len > len ||\n\t\t    ext_type == SADB_EXT_RESERVED)\n\t\t\treturn -EINVAL;\n\n\t\tif (ext_type <= SADB_EXT_MAX) {\n\t\t\tint min = (int) sadb_ext_min_len[ext_type];\n\t\t\tif (ext_len < min)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_hdrs[ext_type-1] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_type == SADB_EXT_ADDRESS_SRC ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_DST ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_PROXY ||\n\t\t\t    ext_type == SADB_X_EXT_NAT_T_OA) {\n\t\t\t\tif (verify_address_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ext_type == SADB_X_EXT_SEC_CTX) {\n\t\t\t\tif (verify_sec_ctx_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\text_hdrs[ext_type-1] = (void *) p;\n\t\t}\n\t\tp   += ext_len;\n\t\tlen -= ext_len;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/85dfb745ee40232876663ae206cba35f24ab2a40",
        "vul_func_with_fix": "static int parse_exthdrs(struct sk_buff *skb, const struct sadb_msg *hdr, void **ext_hdrs)\n{\n\tconst char *p = (char *) hdr;\n\tint len = skb->len;\n\n\tlen -= sizeof(*hdr);\n\tp += sizeof(*hdr);\n\twhile (len > 0) {\n\t\tconst struct sadb_ext *ehdr = (const struct sadb_ext *) p;\n\t\tuint16_t ext_type;\n\t\tint ext_len;\n\n\t\text_len  = ehdr->sadb_ext_len;\n\t\text_len *= sizeof(uint64_t);\n\t\text_type = ehdr->sadb_ext_type;\n\t\tif (ext_len < sizeof(uint64_t) ||\n\t\t    ext_len > len ||\n\t\t    ext_type == SADB_EXT_RESERVED)\n\t\t\treturn -EINVAL;\n\n\t\tif (ext_type <= SADB_EXT_MAX) {\n\t\t\tint min = (int) sadb_ext_min_len[ext_type];\n\t\t\tif (ext_len < min)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_hdrs[ext_type-1] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (ext_type == SADB_EXT_ADDRESS_SRC ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_DST ||\n\t\t\t    ext_type == SADB_EXT_ADDRESS_PROXY ||\n\t\t\t    ext_type == SADB_X_EXT_NAT_T_OA) {\n\t\t\t\tif (verify_address_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ext_type == SADB_X_EXT_SEC_CTX) {\n\t\t\t\tif (verify_sec_ctx_len(p))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\text_hdrs[ext_type-1] = (void *) p;\n\t\t}\n\t\tp   += ext_len;\n\t\tlen -= ext_len;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 6.332719203783199e-05,
        "sysevr": 0.14114835858345032,
        "devign": 0.8723334670066833
    },
    {
        "code": "static int handle_halt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_halt(vcpu);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed",
        "vul_func_with_fix": "static int handle_halt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_halt(vcpu);\n}\n",
        "linevul": 4.9038058932637796e-05,
        "sysevr": 0.1285083144903183,
        "devign": 3.76786379874261e-10
    },
    {
        "code": "static inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
        "vul_func_with_fix": "static inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}\n",
        "linevul": 0.0001703458692645654,
        "sysevr": 0.11786282062530518,
        "devign": 1.4238460410709308e-10
    },
    {
        "code": "static ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
        "vul_func_with_fix": "static ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}\n",
        "linevul": 0.03539670631289482,
        "sysevr": 0.17023669183254242,
        "devign": 1.4887138025042009e-27
    },
    {
        "code": "static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tstruct mempolicy *pol;\n\n\tdown_write(&oldmm->mmap_sem);\n\tflush_cache_dup_mm(oldmm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\tmm->locked_vm = 0;\n\tmm->mmap = NULL;\n\tmm->mmap_cache = NULL;\n\tmm->free_area_cache = oldmm->mmap_base;\n\tmm->cached_hole_size = ~0UL;\n\tmm->map_count = 0;\n\tcpumask_clear(mm_cpumask(mm));\n\tmm->mm_rb = RB_ROOT;\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tlong pages = vma_pages(mpnt);\n\t\t\tmm->total_vm -= pages;\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n\t\t\t\t\t\t\t\t-pages);\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n\t\t\tif (security_vm_enough_memory(len))\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tpol = mpol_dup(vma_policy(mpnt));\n\t\tretval = PTR_ERR(pol);\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail_nomem_policy;\n\t\tvma_set_policy(tmp, pol);\n\t\ttmp->vm_flags &= ~VM_LOCKED;\n\t\ttmp->vm_mm = mm;\n\t\ttmp->vm_next = NULL;\n\t\tanon_vma_link(tmp);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\t\t\tspin_lock(&mapping->i_mmap_lock);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping->i_mmap_writable++;\n\t\t\ttmp->vm_truncate_count = mpnt->vm_truncate_count;\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_prio_tree_add(tmp, mpnt);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\tspin_unlock(&mapping->i_mmap_lock);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\treturn retval;\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3",
        "vul_func_with_fix": "static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp, **pprev;\n\tstruct rb_node **rb_link, *rb_parent;\n\tint retval;\n\tunsigned long charge;\n\tstruct mempolicy *pol;\n\n\tdown_write(&oldmm->mmap_sem);\n\tflush_cache_dup_mm(oldmm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tdown_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n\tmm->locked_vm = 0;\n\tmm->mmap = NULL;\n\tmm->mmap_cache = NULL;\n\tmm->free_area_cache = oldmm->mmap_base;\n\tmm->cached_hole_size = ~0UL;\n\tmm->map_count = 0;\n\tcpumask_clear(mm_cpumask(mm));\n\tmm->mm_rb = RB_ROOT;\n\trb_link = &mm->mm_rb.rb_node;\n\trb_parent = NULL;\n\tpprev = &mm->mmap;\n\tretval = ksm_fork(mm, oldmm);\n\tif (retval)\n\t\tgoto out;\n\n\tfor (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n\t\tstruct file *file;\n\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tlong pages = vma_pages(mpnt);\n\t\t\tmm->total_vm -= pages;\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n\t\t\t\t\t\t\t\t-pages);\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned int len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n\t\t\tif (security_vm_enough_memory(len))\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\t\ttmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\t*tmp = *mpnt;\n\t\tpol = mpol_dup(vma_policy(mpnt));\n\t\tretval = PTR_ERR(pol);\n\t\tif (IS_ERR(pol))\n\t\t\tgoto fail_nomem_policy;\n\t\tvma_set_policy(tmp, pol);\n\t\ttmp->vm_flags &= ~VM_LOCKED;\n\t\ttmp->vm_mm = mm;\n\t\ttmp->vm_next = NULL;\n\t\tanon_vma_link(tmp);\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct inode *inode = file->f_path.dentry->d_inode;\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\tif (tmp->vm_flags & VM_DENYWRITE)\n\t\t\t\tatomic_dec(&inode->i_writecount);\n\t\t\tspin_lock(&mapping->i_mmap_lock);\n\t\t\tif (tmp->vm_flags & VM_SHARED)\n\t\t\t\tmapping->i_mmap_writable++;\n\t\t\ttmp->vm_truncate_count = mpnt->vm_truncate_count;\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_prio_tree_add(tmp, mpnt);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\tspin_unlock(&mapping->i_mmap_lock);\n\t\t}\n\n\t\t/*\n\t\t * Clear hugetlb-related page reserves for children. This only\n\t\t * affects MAP_PRIVATE mappings. Faults generated by the child\n\t\t * are not guaranteed to succeed, even if read-only\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\treset_vma_resv_huge_pages(tmp);\n\n\t\t/*\n\t\t * Link in the new vma and copy the page table entries.\n\t\t */\n\t\t*pprev = tmp;\n\t\tpprev = &tmp->vm_next;\n\n\t\t__vma_link_rb(mm, tmp, rb_link, rb_parent);\n\t\trb_link = &tmp->vm_rb.rb_right;\n\t\trb_parent = &tmp->vm_rb;\n\n\t\tmm->map_count++;\n\t\tretval = copy_page_range(mm, oldmm, mpnt);\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\t/* a new mm has just been created */\n\tarch_dup_mmap(oldmm, mm);\n\tretval = 0;\nout:\n\tup_write(&mm->mmap_sem);\n\tflush_tlb_mm(oldmm);\n\tup_write(&oldmm->mmap_sem);\n\treturn retval;\nfail_nomem_policy:\n\tkmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto out;\n}\n",
        "linevul": 0.00016295565001200885,
        "sysevr": 0.19731765985488892,
        "devign": 6.671114571086278e-34
    },
    {
        "code": " static int whiteheat_attach(struct usb_serial *serial)\n {\n \tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\t/*\n\t * When the module is reloaded the firmware is still there and\n\t * the endpoints are still in the usb core unchanged. This is the\n\t * unlinking bug in disguise. Same for the call below.\n\t */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\t/* See the comment on the usb_clear_halt() above */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\n\treturn 0;\n\nno_firmware:\n\t/* Firmware likely not running */\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\n\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cbb4be652d374f64661137756b8f357a1827d6a4",
        "vul_func_with_fix": " static int whiteheat_attach(struct usb_serial *serial)\n {\n \tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\t/*\n\t * When the module is reloaded the firmware is still there and\n\t * the endpoints are still in the usb core unchanged. This is the\n\t * unlinking bug in disguise. Same for the call below.\n\t */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\t/* See the comment on the usb_clear_halt() above */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\n\treturn 0;\n\nno_firmware:\n\t/* Firmware likely not running */\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\n\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\n",
        "linevul": 0.0023022086825221777,
        "sysevr": 0.18266430497169495,
        "devign": 1.291131328882995e-17
    },
    {
        "code": "COMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tcompat_sigset_t mask;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= copy_from_user(&mask, &act->sa_mask, sizeof(mask));\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&new_ka.sa.sa_mask, &mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tsigset_to_compat(&mask, &old_ka.sa.sa_mask);\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= copy_to_user(&oact->sa_mask, &mask, sizeof(mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4ea77014af0d6205b05503d1c7aac6eace11d473",
        "vul_func_with_fix": "COMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tcompat_sigset_t mask;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= copy_from_user(&mask, &act->sa_mask, sizeof(mask));\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&new_ka.sa.sa_mask, &mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tsigset_to_compat(&mask, &old_ka.sa.sa_mask);\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= copy_to_user(&oact->sa_mask, &mask, sizeof(mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}\n",
        "linevul": 5.211929601500742e-05,
        "sysevr": 0.16085508465766907,
        "devign": 0.6714069247245789
    },
    {
        "code": "brcmf_cfg80211_update_proto_addr_mode(struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tifp = vif->ifp;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_ADHOC) ||\n\t    (wdev->iftype == NL80211_IFTYPE_AP) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_GO))\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_DIRECT);\n\telse\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_INDIRECT);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ded89912156b1a47d940a0c954c43afbabd0c42c",
        "vul_func_with_fix": "brcmf_cfg80211_update_proto_addr_mode(struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tifp = vif->ifp;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_ADHOC) ||\n\t    (wdev->iftype == NL80211_IFTYPE_AP) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_GO))\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_DIRECT);\n\telse\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_INDIRECT);\n}\n",
        "linevul": 5.1668030209839344e-05,
        "sysevr": 0.16219265758991241,
        "devign": 4.966031023238269e-19
    },
    {
        "code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret);\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
        "vul_func_with_fix": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n//flaw_line_below:\n\t\t\t\t__be16 sport, __be16 dport)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tu64 seq;\n//flaw_line_below:\n\t__u32 hash[4];\n//flaw_line_below:\n\tstruct keydata *keyptr = get_keyptr();\n//flaw_line_below:\n\n//flaw_line_below:\n\thash[0] = (__force u32)saddr;\n//flaw_line_below:\n\thash[1] = (__force u32)daddr;\n//flaw_line_below:\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n//flaw_line_below:\n\thash[3] = keyptr->secret[11];\n//flaw_line_below:\n\n//flaw_line_below:\n\tseq = half_md4_transform(hash, keyptr->secret);\n//flaw_line_below:\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n//flaw_line_below:\n\n//flaw_line_below:\n\tseq += ktime_to_ns(ktime_get_real());\n//flaw_line_below:\n\tseq &= (1ull << 48) - 1;\n//flaw_line_below:\n\n//flaw_line_below:\n\treturn seq;\n//flaw_line_below:\n}\n",
        "linevul": 0.0010590199381113052,
        "sysevr": 0.26438072323799133,
        "devign": 2.688219091773192e-10
    },
    {
        "code": "static inline int cm_convert_to_ms(int iba_time)\n{\n\t/* approximate conversion to ms from 4.096us x 2^iba_time */\n\treturn 1 << max(iba_time - 8, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867",
        "vul_func_with_fix": "static inline int cm_convert_to_ms(int iba_time)\n{\n\t/* approximate conversion to ms from 4.096us x 2^iba_time */\n\treturn 1 << max(iba_time - 8, 0);\n}\n",
        "linevul": 5.8638273912947625e-05,
        "sysevr": 0.12326058745384216,
        "devign": 1.218134343616839e-06
    },
    {
        "code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n \tstruct rpc_cred *cred;\n \tstruct nfs4_state *state;\n \tstruct dentry *res;\n \n \tif (nd->flags & LOOKUP_CREATE) {\n \t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n \tparent = dentry->d_parent;\n \t/* Protect against concurrent sillydeletes */\n \tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n \tput_rpccred(cred);\n \tif (IS_ERR(state)) {\n \t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n \t\tpath.dentry = res;\n \tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n \tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n \treturn res;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n \tstruct rpc_cred *cred;\n \tstruct nfs4_state *state;\n \tstruct dentry *res;\n//fix_flaw_line_below:\n//\tfmode_t fmode = nd->intent.open.flags & (FMODE_READ | FMODE_WRITE | FMODE_EXEC);\n \n \tif (nd->flags & LOOKUP_CREATE) {\n \t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n \tparent = dentry->d_parent;\n \t/* Protect against concurrent sillydeletes */\n \tnfs_block_sillyrename(parent);\n//flaw_line_below:\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n//fix_flaw_line_below:\n//\tstate = nfs4_do_open(dir, &path, fmode, nd->intent.open.flags, &attr, cred);\n \tput_rpccred(cred);\n \tif (IS_ERR(state)) {\n \t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n \t\tpath.dentry = res;\n \tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n \tnfs_unblock_sillyrename(parent);\n//flaw_line_below:\n\tnfs4_intent_set_file(nd, &path, state);\n//fix_flaw_line_below:\n//\tnfs4_intent_set_file(nd, &path, state, fmode);\n \treturn res;\n }\n",
        "linevul": 0.9995409250259399,
        "sysevr": 0.15883904695510864,
        "devign": 1.8983266347749606e-10
    },
    {
        "code": "static void mcryptd_hash_update(struct crypto_async_request *req_async, int err)\n{\n\tstruct ahash_request *req = ahash_request_cast(req_async);\n\tstruct mcryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\n\n\tif (unlikely(err == -EINPROGRESS))\n\t\tgoto out;\n\n\trctx->out = req->result;\n\terr = ahash_mcryptd_update(&rctx->areq);\n\tif (err) {\n\t\treq->base.complete = rctx->complete;\n\t\tgoto out;\n\t}\n\n\treturn;\nout:\n\tlocal_bh_disable();\n\trctx->complete(&req->base, err);\n\tlocal_bh_enable();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/48a992727d82cb7db076fa15d372178743b1f4cd",
        "vul_func_with_fix": "static void mcryptd_hash_update(struct crypto_async_request *req_async, int err)\n{\n\tstruct ahash_request *req = ahash_request_cast(req_async);\n\tstruct mcryptd_hash_request_ctx *rctx = ahash_request_ctx(req);\n\n\tif (unlikely(err == -EINPROGRESS))\n\t\tgoto out;\n\n\trctx->out = req->result;\n\terr = ahash_mcryptd_update(&rctx->areq);\n\tif (err) {\n\t\treq->base.complete = rctx->complete;\n\t\tgoto out;\n\t}\n\n\treturn;\nout:\n\tlocal_bh_disable();\n\trctx->complete(&req->base, err);\n\tlocal_bh_enable();\n}\n",
        "linevul": 6.616303289774805e-05,
        "sysevr": 0.13643309473991394,
        "devign": 0.024787265807390213
    },
    {
        "code": "static int dev_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs;\n\n\tsegs = skb_gso_segment(skb, features);\n\n\t/* Verifying header integrity only. */\n\tif (!segs)\n\t\treturn 0;\n\n\tif (IS_ERR(segs))\n\t\treturn PTR_ERR(segs);\n\n\tskb->next = segs;\n\tDEV_GSO_CB(skb)->destructor = skb->destructor;\n\tskb->destructor = dev_gso_skb_destructor;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "static int dev_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs;\n\n\tsegs = skb_gso_segment(skb, features);\n\n\t/* Verifying header integrity only. */\n\tif (!segs)\n\t\treturn 0;\n\n\tif (IS_ERR(segs))\n\t\treturn PTR_ERR(segs);\n\n\tskb->next = segs;\n\tDEV_GSO_CB(skb)->destructor = skb->destructor;\n\tskb->destructor = dev_gso_skb_destructor;\n\n\treturn 0;\n}\n",
        "linevul": 4.6803386794636026e-05,
        "sysevr": 0.12998594343662262,
        "devign": 1.8988318662907327e-38
    },
    {
        "code": "static inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4291086b1f081b869c6d79e5b7441633dc3ace00",
        "vul_func_with_fix": "static inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n",
        "linevul": 0.00011302843631710857,
        "sysevr": 0.1265251189470291,
        "devign": 0.04415808618068695
    },
    {
        "code": "static void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char cval, fcr = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tcval = 0x00;\n\t\t\tbreak;\n\t\tcase CS6:\n\t\t\tcval = 0x01;\n\t\t\tbreak;\n\t\tcase CS7:\n\t\t\tcval = 0x02;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase CS8:\n\t\t\tcval = 0x03;\n\t\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= 0x04;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\n#ifdef CMSPAR\n\tif (termios->c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n#endif\n\n\tbaud = sb_uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\n\tquot = multi_get_divisor(port, baud);\n\n\tif (mtpt->capabilities & UART_USE_FIFO) {\n\n\t\t\tfcr = fcr_arr[mtpt->port.line];\n\t}\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tsb_uart_update_timeout(port, termios->c_cflag, baud);\n\n\tmtpt->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tmtpt->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tmtpt->port.read_status_mask |= UART_LSR_BI;\n\n\tmtpt->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_BI;\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tmtpt->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_DR;\n\n\tmtpt->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&mtpt->port, termios->c_cflag))\n\t\tmtpt->ier |= UART_IER_MSI;\n\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n\n\tif (mtpt->capabilities & UART_STARTECH) {\n\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\tserial_outp(mtpt, UART_EFR,\n\t\t\t\ttermios->c_cflag & CRTSCTS ? UART_EFR_CTS :0);\n\t}\n\n\tserial_outp(mtpt, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */\n\n\tserial_outp(mtpt, UART_DLL, quot & 0xff);     /* LS of divisor */\n\tserial_outp(mtpt, UART_DLM, quot >> 8);       /* MS of divisor */\n\n\tserial_outp(mtpt, UART_LCR, cval);        /* reset DLAB */\n\tmtpt->lcr = cval;                 /* Save LCR */\n\n\tif (fcr & UART_FCR_ENABLE_FIFO) {\n\t\t/* emulated UARTs (Lucent Venus 167x) need two steps */\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t}\n\n\tserial_outp(mtpt, UART_FCR, fcr);     /* set fcr */\n\n\n\tif ((mtpt->port.type == PORT_16C105X)\n\t\t|| (mtpt->port.type == PORT_16C105XA))\n\t{\n\t\tif(deep[mtpt->port.line]!=0)\n\t\t\tset_deep_fifo(port, ENABLE);\n\n\t\tif (mtpt->interface != RS232)\n\t\t\tset_auto_rts(port,mtpt->interface);\n\n\t}\n\telse\n\t{\n\t\tif (mtpt->interface >= RS485NE)\n\t\t{\n\t\t\tuart_clear_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t}\n\t}\n\n\tif(mtpt->device->device_id == PCI_DEVICE_ID_MP4M)\n\t{\n\t\tSendATCommand(mtpt);\n\t\tprintk(\"SendATCommand\\n\");\n\t}\t\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
        "vul_func_with_fix": "static void multi_set_termios(struct sb_uart_port *port, struct MP_TERMIOS *termios, struct MP_TERMIOS *old)\n{\n\tstruct mp_port *mtpt = (struct mp_port *)port;\n\tunsigned char cval, fcr = 0;\n\tunsigned long flags;\n\tunsigned int baud, quot;\n\n\tswitch (termios->c_cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tcval = 0x00;\n\t\t\tbreak;\n\t\tcase CS6:\n\t\t\tcval = 0x01;\n\t\t\tbreak;\n\t\tcase CS7:\n\t\t\tcval = 0x02;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase CS8:\n\t\t\tcval = 0x03;\n\t\t\tbreak;\n\t}\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= 0x04;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\n#ifdef CMSPAR\n\tif (termios->c_cflag & CMSPAR)\n\t\tcval |= UART_LCR_SPAR;\n#endif\n\n\tbaud = sb_uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\n\tquot = multi_get_divisor(port, baud);\n\n\tif (mtpt->capabilities & UART_USE_FIFO) {\n\t\t//if (baud < 2400)\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\n\t\t//else\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;\n\n\t\t//\tfcr = UART_FCR_ENABLE_FIFO | 0x90;\n\t\t\tfcr = fcr_arr[mtpt->port.line];\n\t}\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tsb_uart_update_timeout(port, termios->c_cflag, baud);\n\n\tmtpt->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tmtpt->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tmtpt->port.read_status_mask |= UART_LSR_BI;\n\n\tmtpt->port.ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_BI;\n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tmtpt->port.ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tmtpt->port.ignore_status_mask |= UART_LSR_DR;\n\n\tmtpt->ier &= ~UART_IER_MSI;\n\tif (UART_ENABLE_MS(&mtpt->port, termios->c_cflag))\n\t\tmtpt->ier |= UART_IER_MSI;\n\n\tserial_out(mtpt, UART_IER, mtpt->ier);\n\n\tif (mtpt->capabilities & UART_STARTECH) {\n\t\tserial_outp(mtpt, UART_LCR, 0xBF);\n\t\tserial_outp(mtpt, UART_EFR,\n\t\t\t\ttermios->c_cflag & CRTSCTS ? UART_EFR_CTS :0);\n\t}\n\n\tserial_outp(mtpt, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */\n\n\tserial_outp(mtpt, UART_DLL, quot & 0xff);     /* LS of divisor */\n\tserial_outp(mtpt, UART_DLM, quot >> 8);       /* MS of divisor */\n\n\tserial_outp(mtpt, UART_LCR, cval);        /* reset DLAB */\n\tmtpt->lcr = cval;                 /* Save LCR */\n\n\tif (fcr & UART_FCR_ENABLE_FIFO) {\n\t\t/* emulated UARTs (Lucent Venus 167x) need two steps */\n\t\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\t}\n\n\tserial_outp(mtpt, UART_FCR, fcr);     /* set fcr */\n\n\n\tif ((mtpt->port.type == PORT_16C105X)\n\t\t|| (mtpt->port.type == PORT_16C105XA))\n\t{\n\t\tif(deep[mtpt->port.line]!=0)\n\t\t\tset_deep_fifo(port, ENABLE);\n\n\t\tif (mtpt->interface != RS232)\n\t\t\tset_auto_rts(port,mtpt->interface);\n\n\t}\n\telse\n\t{\n\t\tif (mtpt->interface >= RS485NE)\n\t\t{\n\t\t\tuart_clear_mctrl(&mtpt->port, TIOCM_RTS);\n\t\t}\n\t}\n\n\tif(mtpt->device->device_id == PCI_DEVICE_ID_MP4M)\n\t{\n\t\tSendATCommand(mtpt);\n\t\tprintk(\"SendATCommand\\n\");\n\t}\t\n\tmulti_set_mctrl(&mtpt->port, mtpt->port.mctrl);\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n}\n",
        "linevul": 0.000723260804079473,
        "sysevr": 0.2667039632797241,
        "devign": 1.0599620323755501e-19
    },
    {
        "code": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n \t\tgoto out_free;\n \tstate = nfs4_opendata_to_nfs4_state(data);\n \tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\n out_free:\n \tnfs4_opendata_put(data);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n \t\tgoto out_free;\n \tstate = nfs4_opendata_to_nfs4_state(data);\n \tif (!IS_ERR(state))\n//flaw_line_below:\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\n//fix_flaw_line_below:\n//\t\tnfs4_close_state(&data->path, state, data->o_arg.fmode);\n out_free:\n \tnfs4_opendata_put(data);\n }\n",
        "linevul": 0.9994774460792542,
        "sysevr": 0.13109970092773438,
        "devign": 0.9999269247055054
    },
    {
        "code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\"SMB3 session key generation failed\\n\");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n \treturn rc;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb",
        "vul_func_with_fix": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n//flaw_line_below:\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n//fix_flaw_line_below:\n//\tif (ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n//flaw_line_below:\n\t\tkfree(ses->auth_key.response);\n//flaw_line_below:\n\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\"SMB3 session key generation failed\\n\");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n//flaw_line_below:\n\t\t\tgoto keygen_exit;\n//fix_flaw_line_below:\n//\t\t\treturn rc;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\n//flaw_line_below:\n\n//flaw_line_below:\nkeygen_exit:\n//flaw_line_below:\n\tif (!ses->server->sign) {\n//flaw_line_below:\n\t\tkfree(ses->auth_key.response);\n//flaw_line_below:\n\t\tses->auth_key.response = NULL;\n//flaw_line_below:\n\t}\n \treturn rc;\n }\n",
        "linevul": 0.9992939233779907,
        "sysevr": 0.21489685773849487,
        "devign": 0.9883313775062561
    },
    {
        "code": "static int __init ipx_init(void)\n{\n\tint rc = proto_register(&ipx_proto, 1);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ipx_family_ops);\n\n\tpEII_datalink = make_EII_client();\n\tif (pEII_datalink)\n\t\tdev_add_pack(&ipx_dix_packet_type);\n\telse\n\t\tprintk(ipx_EII_err_msg);\n\n\tp8023_datalink = make_8023_client();\n\tif (p8023_datalink)\n\t\tdev_add_pack(&ipx_8023_packet_type);\n\telse\n\t\tprintk(ipx_8023_err_msg);\n\n\tp8022_datalink = register_8022_client(ipx_8022_type, ipx_rcv);\n\tif (!p8022_datalink)\n\t\tprintk(ipx_llc_err_msg);\n\n\tpSNAP_datalink = register_snap_client(ipx_snap_id, ipx_rcv);\n\tif (!pSNAP_datalink)\n\t\tprintk(ipx_snap_err_msg);\n\n\tregister_netdevice_notifier(&ipx_dev_notifier);\n\tipx_register_sysctl();\n\tipx_proc_init();\nout:\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int __init ipx_init(void)\n{\n\tint rc = proto_register(&ipx_proto, 1);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ipx_family_ops);\n\n\tpEII_datalink = make_EII_client();\n\tif (pEII_datalink)\n\t\tdev_add_pack(&ipx_dix_packet_type);\n\telse\n\t\tprintk(ipx_EII_err_msg);\n\n\tp8023_datalink = make_8023_client();\n\tif (p8023_datalink)\n\t\tdev_add_pack(&ipx_8023_packet_type);\n\telse\n\t\tprintk(ipx_8023_err_msg);\n\n\tp8022_datalink = register_8022_client(ipx_8022_type, ipx_rcv);\n\tif (!p8022_datalink)\n\t\tprintk(ipx_llc_err_msg);\n\n\tpSNAP_datalink = register_snap_client(ipx_snap_id, ipx_rcv);\n\tif (!pSNAP_datalink)\n\t\tprintk(ipx_snap_err_msg);\n\n\tregister_netdevice_notifier(&ipx_dev_notifier);\n\tipx_register_sysctl();\n\tipx_proc_init();\nout:\n\treturn rc;\n}\n",
        "linevul": 0.0006403178558684886,
        "sysevr": 0.13881565630435944,
        "devign": 0.5798287391662598
    },
    {
        "code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n \n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e4f3aa2e1e67bb48dfbaaf1cad59013d5a5bc276",
        "vul_func_with_fix": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n//flaw_line_below:\n\t\tif ((int)arg >= cdi->capacity)\n//fix_flaw_line_below:\n//\t\tif (arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n \n\t/*\n\t * ->select_disc is a hook to allow a driver-specific way of\n\t * seleting disc.  However, since there is no equivalent hook for\n\t * cdrom_slot_status this may not actually be useful...\n\t */\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}\n",
        "linevul": 0.9995030164718628,
        "sysevr": 0.13047607243061066,
        "devign": 0.9941200613975525
    },
    {
        "code": "bool napi_schedule_prep(struct napi_struct *n)\n{\n\tunsigned long val, new;\n\n\tdo {\n\t\tval = READ_ONCE(n->state);\n\t\tif (unlikely(val & NAPIF_STATE_DISABLE))\n\t\t\treturn false;\n\t\tnew = val | NAPIF_STATE_SCHED;\n\n\t\t/* Sets STATE_MISSED bit if STATE_SCHED was already set\n\t\t * This was suggested by Alexander Duyck, as compiler\n\t\t * emits better code than :\n\t\t * if (val & NAPIF_STATE_SCHED)\n\t\t *     new |= NAPIF_STATE_MISSED;\n\t\t */\n\t\tnew |= (val & NAPIF_STATE_SCHED) / NAPIF_STATE_SCHED *\n\t\t\t\t\t\t   NAPIF_STATE_MISSED;\n\t} while (cmpxchg(&n->state, val, new) != val);\n\n\treturn !(val & NAPIF_STATE_SCHED);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d",
        "vul_func_with_fix": "bool napi_schedule_prep(struct napi_struct *n)\n{\n\tunsigned long val, new;\n\n\tdo {\n\t\tval = READ_ONCE(n->state);\n\t\tif (unlikely(val & NAPIF_STATE_DISABLE))\n\t\t\treturn false;\n\t\tnew = val | NAPIF_STATE_SCHED;\n\n\t\t/* Sets STATE_MISSED bit if STATE_SCHED was already set\n\t\t * This was suggested by Alexander Duyck, as compiler\n\t\t * emits better code than :\n\t\t * if (val & NAPIF_STATE_SCHED)\n\t\t *     new |= NAPIF_STATE_MISSED;\n\t\t */\n\t\tnew |= (val & NAPIF_STATE_SCHED) / NAPIF_STATE_SCHED *\n\t\t\t\t\t\t   NAPIF_STATE_MISSED;\n\t} while (cmpxchg(&n->state, val, new) != val);\n\n\treturn !(val & NAPIF_STATE_SCHED);\n}\n",
        "linevul": 6.635492172790691e-05,
        "sysevr": 0.1497415155172348,
        "devign": 0.0
    },
    {
        "code": "static void propagate_entity_cfs_rq(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq;\n\n\t/* Start to propagate at parent */\n\tse = se->parent;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tbreak;\n\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static void propagate_entity_cfs_rq(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq;\n\n\t/* Start to propagate at parent */\n\tse = se->parent;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tbreak;\n\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t}\n}\n",
        "linevul": 4.805830758414231e-05,
        "sysevr": 0.11861418932676315,
        "devign": 0.003939272370189428
    },
    {
        "code": "bool __is_local_mountpoint(struct dentry *dentry)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool is_covered = false;\n\n\tif (!d_mountpoint(dentry))\n\t\tgoto out;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tis_covered = (mnt->mnt_mountpoint == dentry);\n\t\tif (is_covered)\n\t\t\tbreak;\n\t}\n\tup_read(&namespace_sem);\nout:\n\treturn is_covered;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "bool __is_local_mountpoint(struct dentry *dentry)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool is_covered = false;\n\n\tif (!d_mountpoint(dentry))\n\t\tgoto out;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tis_covered = (mnt->mnt_mountpoint == dentry);\n\t\tif (is_covered)\n\t\t\tbreak;\n\t}\n\tup_read(&namespace_sem);\nout:\n\treturn is_covered;\n}\n",
        "linevul": 0.00011799951607827097,
        "sysevr": 0.1404927372932434,
        "devign": 3.609426177522594e-18
    },
    {
        "code": "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,\n\t\t struct sockaddr __user *addr,  int addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14",
        "vul_func_with_fix": "int __sys_sendto(int fd, void __user *buff, size_t len, unsigned int flags,\n\t\t struct sockaddr __user *addr,  int addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\terr = import_single_range(WRITE, buff, len, &iov, &msg.msg_iter);\n\tif (unlikely(err))\n\t\treturn err;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, &address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n",
        "linevul": 0.00015937807620503008,
        "sysevr": 0.21451233327388763,
        "devign": 0.542367696762085
    },
    {
        "code": "static int ucma_set_option_id(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret = 0;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_ID_TOS:\n\t\tif (optlen != sizeof(u8)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trdma_set_service_type(ctx->cm_id, *((u8 *) optval));\n\t\tbreak;\n\tcase RDMA_OPTION_ID_REUSEADDR:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_reuseaddr(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tcase RDMA_OPTION_ID_AFONLY:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_afonly(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static int ucma_set_option_id(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret = 0;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_ID_TOS:\n\t\tif (optlen != sizeof(u8)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trdma_set_service_type(ctx->cm_id, *((u8 *) optval));\n\t\tbreak;\n\tcase RDMA_OPTION_ID_REUSEADDR:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_reuseaddr(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tcase RDMA_OPTION_ID_AFONLY:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_afonly(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 5.837726712343283e-05,
        "sysevr": 0.12963780760765076,
        "devign": 0.7628793120384216
    },
    {
        "code": "static int do_setxattr(struct btrfs_trans_handle *trans,\n \t\t       struct inode *inode, const char *name,\n \t\t       const void *value, size_t size, int flags)\n {\n\tstruct btrfs_dir_item *di;\n \tstruct btrfs_root *root = BTRFS_I(inode)->root;\n \tstruct btrfs_path *path;\n \tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root))\n\t\treturn -ENOSPC;\n\n \tpath = btrfs_alloc_path();\n \tif (!path)\n \t\treturn -ENOMEM;\n \n \tif (flags & XATTR_REPLACE) {\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode), name,\n\t\t\t\t\tname_len, -1);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t} else if (!di) {\n \t\t\tret = -ENODATA;\n \t\t\tgoto out;\n \t\t}\n\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tif (ret)\n\t\t\tgoto out;\n \t\tbtrfs_release_path(path);\n \n \t\t/*\n\t\t * remove the attribute\n \t\t */\n\t\tif (!value)\n\t\t\tgoto out;\n\t} else {\n\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, 0);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n \t\t\tgoto out;\n \t\t}\n\t\tif (!di && !value)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n \t}\n \nagain:\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n\t\t\t\t      name, name_len, value, size);\n\t/*\n\t * If we're setting an xattr to a new value but the new value is say\n\t * exactly BTRFS_MAX_XATTR_SIZE, we could end up with EOVERFLOW getting\n\t * back from split_leaf.  This is because it thinks we'll be extending\n\t * the existing item size, but we're asking for enough space to add the\n\t * item itself.  So if we get EOVERFLOW just set ret to EEXIST and let\n\t * the rest of the function figure it out.\n\t */\n\tif (ret == -EOVERFLOW)\n \t\tret = -EEXIST;\n \n\tif (ret == -EEXIST) {\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto out;\n \t\t/*\n\t\t * We can't use the path we already have since we won't have the\n\t\t * proper locking for a delete, so release the path and\n\t\t * re-lookup to delete the thing.\n \t\t */\n\t\tbtrfs_release_path(path);\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n\t\t\t\t\tname, name_len, -1);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t} else if (!di) {\n\t\t\t/* Shouldn't happen but just in case... */\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n \t\t}\n \n\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\t\tif (ret)\n\t\t\tgoto out;\n \n \t\t/*\n\t\t * We have a value to set, so go back and try to insert it now.\n \t\t */\n\t\tif (value) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n \t}\n out:\n \tbtrfs_free_path(path);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339",
        "vul_func_with_fix": "static int do_setxattr(struct btrfs_trans_handle *trans,\n \t\t       struct inode *inode, const char *name,\n \t\t       const void *value, size_t size, int flags)\n {\n//flaw_line_below:\n\tstruct btrfs_dir_item *di;\n//fix_flaw_line_below:\n//\tstruct btrfs_dir_item *di = NULL;\n \tstruct btrfs_root *root = BTRFS_I(inode)->root;\n \tstruct btrfs_path *path;\n \tsize_t name_len = strlen(name);\n\tint ret = 0;\n\n\tif (name_len + size > BTRFS_MAX_XATTR_SIZE(root))\n\t\treturn -ENOSPC;\n\n \tpath = btrfs_alloc_path();\n \tif (!path)\n \t\treturn -ENOMEM;\n//fix_flaw_line_below:\n//\tpath->skip_release_on_error = 1;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (!value) {\n//fix_flaw_line_below:\n//\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n//fix_flaw_line_below:\n//\t\t\t\t\tname, name_len, -1);\n//fix_flaw_line_below:\n//\t\tif (!di && (flags & XATTR_REPLACE))\n//fix_flaw_line_below:\n//\t\t\tret = -ENODATA;\n//fix_flaw_line_below:\n//\t\telse if (di)\n//fix_flaw_line_below:\n//\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n \n//fix_flaw_line_below:\n//\t/*\n//fix_flaw_line_below:\n//\t * For a replace we can't just do the insert blindly.\n//fix_flaw_line_below:\n//\t * Do a lookup first (read-only btrfs_search_slot), and return if xattr\n//fix_flaw_line_below:\n//\t * doesn't exist. If it exists, fall down below to the insert/replace\n//fix_flaw_line_below:\n//\t * path - we can't race with a concurrent xattr delete, because the VFS\n//fix_flaw_line_below:\n//\t * locks the inode's i_mutex before calling setxattr or removexattr.\n//fix_flaw_line_below:\n//\t */\n \tif (flags & XATTR_REPLACE) {\n//flaw_line_below:\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode), name,\n//flaw_line_below:\n\t\t\t\t\tname_len, -1);\n//flaw_line_below:\n\t\tif (IS_ERR(di)) {\n//flaw_line_below:\n\t\t\tret = PTR_ERR(di);\n//flaw_line_below:\n\t\t\tgoto out;\n//flaw_line_below:\n\t\t} else if (!di) {\n//fix_flaw_line_below:\n//\t\tASSERT(mutex_is_locked(&inode->i_mutex));\n//fix_flaw_line_below:\n//\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n//fix_flaw_line_below:\n//\t\t\t\t\tname, name_len, 0);\n//fix_flaw_line_below:\n//\t\tif (!di) {\n \t\t\tret = -ENODATA;\n \t\t\tgoto out;\n \t\t}\n//flaw_line_below:\n\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n//flaw_line_below:\n\t\tif (ret)\n//flaw_line_below:\n\t\t\tgoto out;\n \t\tbtrfs_release_path(path);\n//fix_flaw_line_below:\n//\t\tdi = NULL;\n//fix_flaw_line_below:\n//\t}\n \n//fix_flaw_line_below:\n//\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n//fix_flaw_line_below:\n//\t\t\t\t      name, name_len, value, size);\n//fix_flaw_line_below:\n//\tif (ret == -EOVERFLOW) {\n \t\t/*\n//flaw_line_below:\n\t\t * remove the attribute\n//fix_flaw_line_below:\n//\t\t * We have an existing item in a leaf, split_leaf couldn't\n//fix_flaw_line_below:\n//\t\t * expand it. That item might have or not a dir_item that\n//fix_flaw_line_below:\n//\t\t * matches our target xattr, so lets check.\n \t\t */\n//flaw_line_below:\n\t\tif (!value)\n//flaw_line_below:\n\t\t\tgoto out;\n//flaw_line_below:\n\t} else {\n//flaw_line_below:\n\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n//flaw_line_below:\n\t\t\t\t\tname, name_len, 0);\n//flaw_line_below:\n\t\tif (IS_ERR(di)) {\n//flaw_line_below:\n\t\t\tret = PTR_ERR(di);\n//fix_flaw_line_below:\n//\t\tret = 0;\n//fix_flaw_line_below:\n//\t\tbtrfs_assert_tree_locked(path->nodes[0]);\n//fix_flaw_line_below:\n//\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n//fix_flaw_line_below:\n//\t\tif (!di && !(flags & XATTR_REPLACE)) {\n//fix_flaw_line_below:\n//\t\t\tret = -ENOSPC;\n \t\t\tgoto out;\n \t\t}\n//flaw_line_below:\n\t\tif (!di && !value)\n//flaw_line_below:\n\t\t\tgoto out;\n//flaw_line_below:\n\t\tbtrfs_release_path(path);\n//fix_flaw_line_below:\n//\t} else if (ret == -EEXIST) {\n//fix_flaw_line_below:\n//\t\tret = 0;\n//fix_flaw_line_below:\n//\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n//fix_flaw_line_below:\n//\t\tASSERT(di); /* logic error */\n//fix_flaw_line_below:\n//\t} else if (ret) {\n//fix_flaw_line_below:\n//\t\tgoto out;\n \t}\n \n//flaw_line_below:\nagain:\n//flaw_line_below:\n\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n//flaw_line_below:\n\t\t\t\t      name, name_len, value, size);\n//flaw_line_below:\n\t/*\n//flaw_line_below:\n\t * If we're setting an xattr to a new value but the new value is say\n//flaw_line_below:\n\t * exactly BTRFS_MAX_XATTR_SIZE, we could end up with EOVERFLOW getting\n//flaw_line_below:\n\t * back from split_leaf.  This is because it thinks we'll be extending\n//flaw_line_below:\n\t * the existing item size, but we're asking for enough space to add the\n//flaw_line_below:\n\t * item itself.  So if we get EOVERFLOW just set ret to EEXIST and let\n//flaw_line_below:\n\t * the rest of the function figure it out.\n//flaw_line_below:\n\t */\n//flaw_line_below:\n\tif (ret == -EOVERFLOW)\n//fix_flaw_line_below:\n//\tif (di && (flags & XATTR_CREATE)) {\n \t\tret = -EEXIST;\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n \n//flaw_line_below:\n\tif (ret == -EEXIST) {\n//flaw_line_below:\n\t\tif (flags & XATTR_CREATE)\n//flaw_line_below:\n\t\t\tgoto out;\n//fix_flaw_line_below:\n//\tif (di) {\n \t\t/*\n//flaw_line_below:\n\t\t * We can't use the path we already have since we won't have the\n//flaw_line_below:\n\t\t * proper locking for a delete, so release the path and\n//flaw_line_below:\n\t\t * re-lookup to delete the thing.\n//fix_flaw_line_below:\n//\t\t * We're doing a replace, and it must be atomic, that is, at\n//fix_flaw_line_below:\n//\t\t * any point in time we have either the old or the new xattr\n//fix_flaw_line_below:\n//\t\t * value in the tree. We don't want readers (getxattr and\n//fix_flaw_line_below:\n//\t\t * listxattrs) to miss a value, this is specially important\n//fix_flaw_line_below:\n//\t\t * for ACLs.\n \t\t */\n//flaw_line_below:\n\t\tbtrfs_release_path(path);\n//flaw_line_below:\n\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n//flaw_line_below:\n\t\t\t\t\tname, name_len, -1);\n//flaw_line_below:\n\t\tif (IS_ERR(di)) {\n//flaw_line_below:\n\t\t\tret = PTR_ERR(di);\n//flaw_line_below:\n\t\t\tgoto out;\n//flaw_line_below:\n\t\t} else if (!di) {\n//flaw_line_below:\n\t\t\t/* Shouldn't happen but just in case... */\n//flaw_line_below:\n\t\t\tbtrfs_release_path(path);\n//flaw_line_below:\n\t\t\tgoto again;\n//fix_flaw_line_below:\n//\t\tconst int slot = path->slots[0];\n//fix_flaw_line_below:\n//\t\tstruct extent_buffer *leaf = path->nodes[0];\n//fix_flaw_line_below:\n//\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n//fix_flaw_line_below:\n//\t\tconst u32 item_size = btrfs_item_size_nr(leaf, slot);\n//fix_flaw_line_below:\n//\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n//fix_flaw_line_below:\n//\t\tstruct btrfs_item *item;\n//fix_flaw_line_below:\n//\t\tunsigned long data_ptr;\n//fix_flaw_line_below:\n//\t\tchar *ptr;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (size > old_data_len) {\n//fix_flaw_line_below:\n//\t\t\tif (btrfs_leaf_free_space(root, leaf) <\n//fix_flaw_line_below:\n//\t\t\t    (size - old_data_len)) {\n//fix_flaw_line_below:\n//\t\t\t\tret = -ENOSPC;\n//fix_flaw_line_below:\n//\t\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t\t}\n \t\t}\n \n//flaw_line_below:\n\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n//flaw_line_below:\n\t\tif (ret)\n//flaw_line_below:\n\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n//fix_flaw_line_below:\n//\t\t\t/* No other xattrs packed in the same leaf item. */\n//fix_flaw_line_below:\n//\t\t\tif (size > old_data_len)\n//fix_flaw_line_below:\n//\t\t\t\tbtrfs_extend_item(root, path,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t  size - old_data_len);\n//fix_flaw_line_below:\n//\t\t\telse if (size < old_data_len)\n//fix_flaw_line_below:\n//\t\t\t\tbtrfs_truncate_item(root, path, data_size, 1);\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\t/* There are other xattrs packed in the same item. */\n//fix_flaw_line_below:\n//\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n//fix_flaw_line_below:\n//\t\t\tif (ret)\n//fix_flaw_line_below:\n//\t\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t\tbtrfs_extend_item(root, path, data_size);\n//fix_flaw_line_below:\n//\t\t}\n \n//fix_flaw_line_below:\n//\t\titem = btrfs_item_nr(slot);\n//fix_flaw_line_below:\n//\t\tptr = btrfs_item_ptr(leaf, slot, char);\n//fix_flaw_line_below:\n//\t\tptr += btrfs_item_size(leaf, item) - data_size;\n//fix_flaw_line_below:\n//\t\tdi = (struct btrfs_dir_item *)ptr;\n//fix_flaw_line_below:\n//\t\tbtrfs_set_dir_data_len(leaf, di, size);\n//fix_flaw_line_below:\n//\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n//fix_flaw_line_below:\n//\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n//fix_flaw_line_below:\n//\t\tbtrfs_mark_buffer_dirty(leaf);\n//fix_flaw_line_below:\n//\t} else {\n \t\t/*\n//flaw_line_below:\n\t\t * We have a value to set, so go back and try to insert it now.\n//fix_flaw_line_below:\n//\t\t * Insert, and we had space for the xattr, so path->slots[0] is\n//fix_flaw_line_below:\n//\t\t * where our xattr dir_item is and btrfs_insert_xattr_item()\n//fix_flaw_line_below:\n//\t\t * filled it.\n \t\t */\n//flaw_line_below:\n\t\tif (value) {\n//flaw_line_below:\n\t\t\tbtrfs_release_path(path);\n//flaw_line_below:\n\t\t\tgoto again;\n//flaw_line_below:\n\t\t}\n \t}\n out:\n \tbtrfs_free_path(path);\n\treturn ret;\n}\n",
        "linevul": 0.9995102882385254,
        "sysevr": 0.17621798813343048,
        "devign": 0.9999642372131348
    },
    {
        "code": "bool legitimize_mnt(struct vfsmount *bastard, unsigned seq)\n{\n\tstruct mount *mnt;\n\tif (read_seqretry(&mount_lock, seq))\n\t\treturn false;\n\tif (bastard == NULL)\n\t\treturn true;\n\tmnt = real_mount(bastard);\n\tmnt_add_count(mnt, 1);\n\tif (likely(!read_seqretry(&mount_lock, seq)))\n\t\treturn true;\n\tif (bastard->mnt_flags & MNT_SYNC_UMOUNT) {\n\t\tmnt_add_count(mnt, -1);\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\tmntput(bastard);\n\trcu_read_lock();\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705",
        "vul_func_with_fix": "bool legitimize_mnt(struct vfsmount *bastard, unsigned seq)\n{\n\tstruct mount *mnt;\n\tif (read_seqretry(&mount_lock, seq))\n\t\treturn false;\n\tif (bastard == NULL)\n\t\treturn true;\n\tmnt = real_mount(bastard);\n\tmnt_add_count(mnt, 1);\n\tif (likely(!read_seqretry(&mount_lock, seq)))\n\t\treturn true;\n\tif (bastard->mnt_flags & MNT_SYNC_UMOUNT) {\n\t\tmnt_add_count(mnt, -1);\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\tmntput(bastard);\n\trcu_read_lock();\n\treturn false;\n}\n",
        "linevul": 8.76866834005341e-05,
        "sysevr": 0.1406521052122116,
        "devign": 0.26337501406669617
    },
    {
        "code": "static void ext4_put_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i, err;\n\n\text4_unregister_li_request(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\tdestroy_workqueue(sbi->rsv_conversion_wq);\n\n\tif (sbi->s_journal) {\n\t\terr = jbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t\tif (err < 0)\n\t\t\text4_abort(sb, \"Couldn't clean up the journal\");\n\t}\n\n\text4_unregister_sysfs(sb);\n\text4_es_unregister_shrinker(sbi);\n\tdel_timer_sync(&sbi->s_err_report);\n \text4_release_system_zone(sb);\n \text4_mb_release(sb);\n \text4_ext_release(sb);\n\text4_xattr_put_super(sb);\n \n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\text4_clear_feature_journal_needs_recovery(sb);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\n\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tsync_blockdev(sb->s_bdev);\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text4_blkdev_remove(sbi);\n\t}\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\n\tsb->s_fs_info = NULL;\n\t/*\n\t * Now that we are completely done shutting down the\n\t * superblock, we need to actually destroy the kobject.\n\t */\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
        "vul_func_with_fix": "static void ext4_put_super(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint i, err;\n\n\text4_unregister_li_request(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\tflush_workqueue(sbi->rsv_conversion_wq);\n\tdestroy_workqueue(sbi->rsv_conversion_wq);\n\n\tif (sbi->s_journal) {\n\t\terr = jbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t\tif (err < 0)\n\t\t\text4_abort(sb, \"Couldn't clean up the journal\");\n\t}\n\n\text4_unregister_sysfs(sb);\n\text4_es_unregister_shrinker(sbi);\n\tdel_timer_sync(&sbi->s_err_report);\n \text4_release_system_zone(sb);\n \text4_mb_release(sb);\n \text4_ext_release(sb);\n//flaw_line_below:\n\text4_xattr_put_super(sb);\n \n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\text4_clear_feature_journal_needs_recovery(sb);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n\tfor (i = 0; i < sbi->s_gdb_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\n\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n\tbrelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\n\t/* Debugging code just in case the in-memory inode orphan list\n\t * isn't empty.  The on-disk one can be non-empty if we've\n\t * detected an error and taken the fs readonly, but the\n\t * in-memory list had better be clean by this point. */\n\tif (!list_empty(&sbi->s_orphan))\n\t\tdump_orphan_list(sb, sbi);\n\tJ_ASSERT(list_empty(&sbi->s_orphan));\n\n\tsync_blockdev(sb->s_bdev);\n\tinvalidate_bdev(sb->s_bdev);\n\tif (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n\t\t/*\n\t\t * Invalidate the journal device's buffers.  We don't want them\n\t\t * floating about in memory - the physical journal device may\n\t\t * hotswapped, and it breaks the `ro-after' testing code.\n\t\t */\n\t\tsync_blockdev(sbi->journal_bdev);\n\t\tinvalidate_bdev(sbi->journal_bdev);\n\t\text4_blkdev_remove(sbi);\n\t}\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\n\tsb->s_fs_info = NULL;\n\t/*\n\t * Now that we are completely done shutting down the\n\t * superblock, we need to actually destroy the kobject.\n\t */\n\tkobject_put(&sbi->s_kobj);\n\twait_for_completion(&sbi->s_kobj_unregister);\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n",
        "linevul": 9.947471698978916e-05,
        "sysevr": 0.15462571382522583,
        "devign": 0.9953678846359253
    },
    {
        "code": "megasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Don't signal app if it is just an aborted previously registered aen\n\t */\n\tif ((!cmd->abort_aen) && (instance->unload == 0)) {\n\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\tmegasas_poll_wait_aen = 1;\n\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\twake_up(&megasas_poll_wait);\n\t\tkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\n\t}\n\telse\n\t\tcmd->abort_aen = 0;\n\n\tinstance->aen_cmd = NULL;\n\n\tmegasas_return_cmd(instance, cmd);\n\n\tif ((instance->unload == 0) &&\n\t\t((instance->issuepend_done == 1))) {\n\t\tstruct megasas_aen_event *ev;\n\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (!ev) {\n\t\t\tdev_err(&instance->pdev->dev, \"megasas_service_aen: out of memory\\n\");\n\t\t} else {\n\t\t\tev->instance = instance;\n\t\t\tinstance->ev = ev;\n\t\t\tINIT_DELAYED_WORK(&ev->hotplug_work,\n\t\t\t\t\t  megasas_aen_polling);\n\t\t\tschedule_delayed_work(&ev->hotplug_work, 0);\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "vul_func_with_fix": "megasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Don't signal app if it is just an aborted previously registered aen\n\t */\n\tif ((!cmd->abort_aen) && (instance->unload == 0)) {\n\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\tmegasas_poll_wait_aen = 1;\n\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\twake_up(&megasas_poll_wait);\n\t\tkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\n\t}\n\telse\n\t\tcmd->abort_aen = 0;\n\n\tinstance->aen_cmd = NULL;\n\n\tmegasas_return_cmd(instance, cmd);\n\n\tif ((instance->unload == 0) &&\n\t\t((instance->issuepend_done == 1))) {\n\t\tstruct megasas_aen_event *ev;\n\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (!ev) {\n\t\t\tdev_err(&instance->pdev->dev, \"megasas_service_aen: out of memory\\n\");\n\t\t} else {\n\t\t\tev->instance = instance;\n\t\t\tinstance->ev = ev;\n\t\t\tINIT_DELAYED_WORK(&ev->hotplug_work,\n\t\t\t\t\t  megasas_aen_polling);\n\t\t\tschedule_delayed_work(&ev->hotplug_work, 0);\n\t\t}\n\t}\n}\n",
        "linevul": 8.86419802554883e-05,
        "sysevr": 0.1767861396074295,
        "devign": 2.8737295348224772e-30
    },
    {
        "code": "static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n \n  __error:\n \tif (chip) {\n \t\tif (!chip->num_interfaces)\n \t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n \t}\n \tmutex_unlock(&register_mutex);\n \treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b",
        "vul_func_with_fix": "static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n \n  __error:\n \tif (chip) {\n//fix_flaw_line_below:\n//\t\t/* chip->active is inside the chip->card object,\n//fix_flaw_line_below:\n//\t\t * decrement before memory is possibly returned.\n//fix_flaw_line_below:\n//\t\t */\n//fix_flaw_line_below:\n//\t\tatomic_dec(&chip->active);\n \t\tif (!chip->num_interfaces)\n \t\t\tsnd_card_free(chip->card);\n//flaw_line_below:\n\t\tatomic_dec(&chip->active);\n \t}\n \tmutex_unlock(&register_mutex);\n \treturn err;\n}\n",
        "linevul": 0.001270281383767724,
        "sysevr": 0.17795521020889282,
        "devign": 3.4830281020470366e-11
    },
    {
        "code": "int btrfs_orphan_del(struct btrfs_trans_handle *trans, struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint delete_item = 0;\n\tint release_rsv = 0;\n\tint ret = 0;\n\n\tspin_lock(&root->orphan_lock);\n\tif (test_and_clear_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\tdelete_item = 1;\n\n\tif (test_and_clear_bit(BTRFS_INODE_ORPHAN_META_RESERVED,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\trelease_rsv = 1;\n\tspin_unlock(&root->orphan_lock);\n\n\tif (trans && delete_item) {\n\t\tret = btrfs_del_orphan_item(trans, root, btrfs_ino(inode));\n\t\tBUG_ON(ret); /* -ENOMEM or corruption (JDM: Recheck) */\n\t}\n\n\tif (release_rsv) {\n\t\tbtrfs_orphan_release_metadata(inode);\n\t\tatomic_dec(&root->orphan_inodes);\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "vul_func_with_fix": "int btrfs_orphan_del(struct btrfs_trans_handle *trans, struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint delete_item = 0;\n\tint release_rsv = 0;\n\tint ret = 0;\n\n\tspin_lock(&root->orphan_lock);\n\tif (test_and_clear_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\tdelete_item = 1;\n\n\tif (test_and_clear_bit(BTRFS_INODE_ORPHAN_META_RESERVED,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\trelease_rsv = 1;\n\tspin_unlock(&root->orphan_lock);\n\n\tif (trans && delete_item) {\n\t\tret = btrfs_del_orphan_item(trans, root, btrfs_ino(inode));\n\t\tBUG_ON(ret); /* -ENOMEM or corruption (JDM: Recheck) */\n\t}\n\n\tif (release_rsv) {\n\t\tbtrfs_orphan_release_metadata(inode);\n\t\tatomic_dec(&root->orphan_inodes);\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 5.5514385167043656e-05,
        "sysevr": 0.1743638664484024,
        "devign": 1.0492563887964934e-05
    },
    {
        "code": "static void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_lock_state *lsp = data->lsp;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tdata->rpc_status = task->tk_status;\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(NFS_SERVER(d_inode(data->ctx->dentry)),\n\t\t\t\tdata->timestamp);\n\t\tif (data->arg.new_lock) {\n\t\t\tdata->fl.fl_flags &= ~(FL_SLEEP | FL_ACCESS);\n\t\t\tif (do_vfs_lock(lsp->ls_state->inode, &data->fl) < 0) {\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tnfs_confirm_seqid(&lsp->ls_seqid, 0);\n\t\t\tnfs4_stateid_copy(&lsp->ls_stateid, &data->res.stateid);\n\t\t\tset_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t} else if (!nfs4_update_lock_stateid(lsp, &data->res.stateid))\n\t\t\trpc_restart_call_prepare(task);\n\t\tbreak;\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OLD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tif (!nfs4_stateid_match(&data->arg.open_stateid,\n\t\t\t\t\t\t&lsp->ls_state->open_stateid))\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t} else if (!nfs4_stateid_match(&data->arg.lock_stateid,\n\t\t\t\t\t\t&lsp->ls_stateid))\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_lock_state *lsp = data->lsp;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tdata->rpc_status = task->tk_status;\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(NFS_SERVER(d_inode(data->ctx->dentry)),\n\t\t\t\tdata->timestamp);\n\t\tif (data->arg.new_lock) {\n\t\t\tdata->fl.fl_flags &= ~(FL_SLEEP | FL_ACCESS);\n\t\t\tif (do_vfs_lock(lsp->ls_state->inode, &data->fl) < 0) {\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tnfs_confirm_seqid(&lsp->ls_seqid, 0);\n\t\t\tnfs4_stateid_copy(&lsp->ls_stateid, &data->res.stateid);\n\t\t\tset_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t} else if (!nfs4_update_lock_stateid(lsp, &data->res.stateid))\n\t\t\trpc_restart_call_prepare(task);\n\t\tbreak;\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OLD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tif (!nfs4_stateid_match(&data->arg.open_stateid,\n\t\t\t\t\t\t&lsp->ls_state->open_stateid))\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t} else if (!nfs4_stateid_match(&data->arg.lock_stateid,\n\t\t\t\t\t\t&lsp->ls_stateid))\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}\n",
        "linevul": 6.546407530549914e-05,
        "sysevr": 0.11856629699468613,
        "devign": 3.751567820930927e-23
    },
    {
        "code": "int udpv6_offload_exit(void)\n{\n\treturn inet6_del_offload(&udpv6_offload, IPPROTO_UDP);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1",
        "vul_func_with_fix": "int udpv6_offload_exit(void)\n{\n\treturn inet6_del_offload(&udpv6_offload, IPPROTO_UDP);\n}\n",
        "linevul": 5.13471313752234e-05,
        "sysevr": 0.15222232043743134,
        "devign": 6.18416262643251e-10
    },
    {
        "code": "static void rawv6_close(struct sock *sk, long timeout)\n{\n\tif (inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\tip6_ra_control(sk, -1);\n\tip6mr_sk_done(sk);\n\tsk_common_release(sk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69",
        "vul_func_with_fix": "static void rawv6_close(struct sock *sk, long timeout)\n{\n\tif (inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\tip6_ra_control(sk, -1);\n\tip6mr_sk_done(sk);\n\tsk_common_release(sk);\n}\n",
        "linevul": 0.00010097268386743963,
        "sysevr": 0.12693573534488678,
        "devign": 2.6141260605072603e-05
    },
    {
        "code": "struct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file, err);\n\tif (!sock)\n\t\tfput(file);\n\treturn sock;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "vul_func_with_fix": "struct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file, err);\n\tif (!sock)\n\t\tfput(file);\n\treturn sock;\n}\n",
        "linevul": 9.409958875039592e-05,
        "sysevr": 0.14332807064056396,
        "devign": 0.0003040118608623743
    },
    {
        "code": "static int fuse_writepages_fill(struct page *page,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tbool is_writeback;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fc, get_fuse_inode(inode));\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Being under writeback is unlikely but possible.  For example direct\n\t * read to an mmaped fuse file will set the page dirty twice; once when\n\t * the pages are faulted with get_user_pages(), and then after the read\n\t * completed.\n\t */\n\tis_writeback = fuse_page_is_writeback(inode, page->index);\n\n\tif (req && req->num_pages &&\n\t    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||\n\t     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->req = NULL;\n\t}\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The page must not be redirtied until the writeout is completed\n\t * (i.e. userspace has sent a reply to the write request).  Otherwise\n\t * there could be more than one temporary page instance for each real\n\t * page.\n\t *\n\t * This is ensured by holding the page lock in page_mkwrite() while\n\t * checking fuse_page_is_writeback().  We already hold the page lock\n\t * since clear_page_dirty_for_io() and keep it held until we add the\n\t * request to the fi->writepages list and increment req->num_pages.\n\t * After this fuse_page_is_writeback() will indicate that the page is\n\t * under writeback, so we can release the page lock.\n\t */\n\tif (data->req == NULL) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\terr = -ENOMEM;\n\t\treq = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);\n\t\tif (!req) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfuse_write_fill(req, data->ff, page_offset(page), 0);\n\t\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\treq->misc.write.next = NULL;\n\t\treq->in.argpages = 1;\n\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\t\treq->num_pages = 0;\n\t\treq->end = fuse_writepage_end;\n\t\treq->inode = inode;\n\n\t\tspin_lock(&fc->lock);\n\t\tlist_add(&req->writepages_entry, &fi->writepages);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdata->req = req;\n\t}\n\tset_page_writeback(page);\n\n\tcopy_highpage(tmp_page, page);\n\treq->pages[req->num_pages] = tmp_page;\n\treq->page_descs[req->num_pages].offset = 0;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (is_writeback && fuse_writepage_in_flight(req, page)) {\n\t\tend_page_writeback(page);\n\t\tdata->req = NULL;\n\t\tgoto out_unlock;\n\t}\n\tdata->orig_pages[req->num_pages] = page;\n\n\t/*\n\t * Protected by fc->lock against concurrent access by\n\t * fuse_page_is_writeback().\n\t */\n\tspin_lock(&fc->lock);\n\treq->num_pages++;\n\tspin_unlock(&fc->lock);\n\nout_unlock:\n\tunlock_page(page);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876",
        "vul_func_with_fix": "static int fuse_writepages_fill(struct page *page,\n\t\tstruct writeback_control *wbc, void *_data)\n{\n\tstruct fuse_fill_wb_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct page *tmp_page;\n\tbool is_writeback;\n\tint err;\n\n\tif (!data->ff) {\n\t\terr = -EIO;\n\t\tdata->ff = fuse_write_file_get(fc, get_fuse_inode(inode));\n\t\tif (!data->ff)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Being under writeback is unlikely but possible.  For example direct\n\t * read to an mmaped fuse file will set the page dirty twice; once when\n\t * the pages are faulted with get_user_pages(), and then after the read\n\t * completed.\n\t */\n\tis_writeback = fuse_page_is_writeback(inode, page->index);\n\n\tif (req && req->num_pages &&\n\t    (is_writeback || req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_write ||\n\t     data->orig_pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_writepages_send(data);\n\t\tdata->req = NULL;\n\t}\n\terr = -ENOMEM;\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto out_unlock;\n\n\t/*\n\t * The page must not be redirtied until the writeout is completed\n\t * (i.e. userspace has sent a reply to the write request).  Otherwise\n\t * there could be more than one temporary page instance for each real\n\t * page.\n\t *\n\t * This is ensured by holding the page lock in page_mkwrite() while\n\t * checking fuse_page_is_writeback().  We already hold the page lock\n\t * since clear_page_dirty_for_io() and keep it held until we add the\n\t * request to the fi->writepages list and increment req->num_pages.\n\t * After this fuse_page_is_writeback() will indicate that the page is\n\t * under writeback, so we can release the page lock.\n\t */\n\tif (data->req == NULL) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\terr = -ENOMEM;\n\t\treq = fuse_request_alloc_nofs(FUSE_MAX_PAGES_PER_REQ);\n\t\tif (!req) {\n\t\t\t__free_page(tmp_page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfuse_write_fill(req, data->ff, page_offset(page), 0);\n\t\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\t\treq->misc.write.next = NULL;\n\t\treq->in.argpages = 1;\n\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\t\treq->num_pages = 0;\n\t\treq->end = fuse_writepage_end;\n\t\treq->inode = inode;\n\n\t\tspin_lock(&fc->lock);\n\t\tlist_add(&req->writepages_entry, &fi->writepages);\n\t\tspin_unlock(&fc->lock);\n\n\t\tdata->req = req;\n\t}\n\tset_page_writeback(page);\n\n\tcopy_highpage(tmp_page, page);\n\treq->pages[req->num_pages] = tmp_page;\n\treq->page_descs[req->num_pages].offset = 0;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\n\tinc_wb_stat(&inode_to_bdi(inode)->wb, WB_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\n\terr = 0;\n\tif (is_writeback && fuse_writepage_in_flight(req, page)) {\n\t\tend_page_writeback(page);\n\t\tdata->req = NULL;\n\t\tgoto out_unlock;\n\t}\n\tdata->orig_pages[req->num_pages] = page;\n\n\t/*\n\t * Protected by fc->lock against concurrent access by\n\t * fuse_page_is_writeback().\n\t */\n\tspin_lock(&fc->lock);\n\treq->num_pages++;\n\tspin_unlock(&fc->lock);\n\nout_unlock:\n\tunlock_page(page);\n\n\treturn err;\n}\n",
        "linevul": 0.0007539414800703526,
        "sysevr": 0.20946873724460602,
        "devign": 5.709640659573578e-13
    },
    {
        "code": "static int __svc_rpcb_register4(struct net *net, const u32 program,\n\t\t\t\tconst u32 version,\n\t\t\t\tconst unsigned short protocol,\n\t\t\t\tconst unsigned short port)\n{\n\tconst struct sockaddr_in sin = {\n\t\t.sin_family\t\t= AF_INET,\n\t\t.sin_addr.s_addr\t= htonl(INADDR_ANY),\n\t\t.sin_port\t\t= htons(port),\n\t};\n\tconst char *netid;\n\tint error;\n\n\tswitch (protocol) {\n\tcase IPPROTO_UDP:\n\t\tnetid = RPCBIND_NETID_UDP;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tnetid = RPCBIND_NETID_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\terror = rpcb_v4_register(net, program, version,\n\t\t\t\t\t(const struct sockaddr *)&sin, netid);\n\n\t/*\n\t * User space didn't support rpcbind v4, so retry this\n\t * registration request with the legacy rpcbind v2 protocol.\n\t */\n\tif (error == -EPROTONOSUPPORT)\n\t\terror = rpcb_register(net, program, version, protocol, port);\n\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static int __svc_rpcb_register4(struct net *net, const u32 program,\n\t\t\t\tconst u32 version,\n\t\t\t\tconst unsigned short protocol,\n\t\t\t\tconst unsigned short port)\n{\n\tconst struct sockaddr_in sin = {\n\t\t.sin_family\t\t= AF_INET,\n\t\t.sin_addr.s_addr\t= htonl(INADDR_ANY),\n\t\t.sin_port\t\t= htons(port),\n\t};\n\tconst char *netid;\n\tint error;\n\n\tswitch (protocol) {\n\tcase IPPROTO_UDP:\n\t\tnetid = RPCBIND_NETID_UDP;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tnetid = RPCBIND_NETID_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\terror = rpcb_v4_register(net, program, version,\n\t\t\t\t\t(const struct sockaddr *)&sin, netid);\n\n\t/*\n\t * User space didn't support rpcbind v4, so retry this\n\t * registration request with the legacy rpcbind v2 protocol.\n\t */\n\tif (error == -EPROTONOSUPPORT)\n\t\terror = rpcb_register(net, program, version, protocol, port);\n\n\treturn error;\n}\n",
        "linevul": 0.00011349361011525616,
        "sysevr": 0.13455073535442352,
        "devign": 8.903607711374045e-19
    },
    {
        "code": "static int nfs4_xdr_dec_lockt(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      struct nfs_lockt_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lockt(xdr, res);\nout:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int nfs4_xdr_dec_lockt(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      struct nfs_lockt_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lockt(xdr, res);\nout:\n\treturn status;\n}\n",
        "linevul": 5.450215030577965e-05,
        "sysevr": 0.1365310698747635,
        "devign": 0.0002125362807419151
    },
    {
        "code": "static void cm_format_lap(struct cm_lap_msg *lap_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  struct ib_sa_path_rec *alternate_path,\n\t\t\t  const void *private_data,\n\t\t\t  u8 private_data_len)\n{\n\tcm_format_mad_hdr(&lap_msg->hdr, CM_LAP_ATTR_ID,\n\t\t\t  cm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_LAP));\n\tlap_msg->local_comm_id = cm_id_priv->id.local_id;\n\tlap_msg->remote_comm_id = cm_id_priv->id.remote_id;\n\tcm_lap_set_remote_qpn(lap_msg, cm_id_priv->remote_qpn);\n\t/* todo: need remote CM response timeout */\n\tcm_lap_set_remote_resp_timeout(lap_msg, 0x1F);\n\tlap_msg->alt_local_lid = alternate_path->slid;\n\tlap_msg->alt_remote_lid = alternate_path->dlid;\n\tlap_msg->alt_local_gid = alternate_path->sgid;\n\tlap_msg->alt_remote_gid = alternate_path->dgid;\n\tcm_lap_set_flow_label(lap_msg, alternate_path->flow_label);\n\tcm_lap_set_traffic_class(lap_msg, alternate_path->traffic_class);\n\tlap_msg->alt_hop_limit = alternate_path->hop_limit;\n\tcm_lap_set_packet_rate(lap_msg, alternate_path->rate);\n\tcm_lap_set_sl(lap_msg, alternate_path->sl);\n\tcm_lap_set_subnet_local(lap_msg, 1); /* local only... */\n\tcm_lap_set_local_ack_timeout(lap_msg,\n\t\tcm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\n\t\t\t       alternate_path->packet_life_time));\n\n\tif (private_data && private_data_len)\n\t\tmemcpy(lap_msg->private_data, private_data, private_data_len);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867",
        "vul_func_with_fix": "static void cm_format_lap(struct cm_lap_msg *lap_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  struct ib_sa_path_rec *alternate_path,\n\t\t\t  const void *private_data,\n\t\t\t  u8 private_data_len)\n{\n\tcm_format_mad_hdr(&lap_msg->hdr, CM_LAP_ATTR_ID,\n\t\t\t  cm_form_tid(cm_id_priv, CM_MSG_SEQUENCE_LAP));\n\tlap_msg->local_comm_id = cm_id_priv->id.local_id;\n\tlap_msg->remote_comm_id = cm_id_priv->id.remote_id;\n\tcm_lap_set_remote_qpn(lap_msg, cm_id_priv->remote_qpn);\n\t/* todo: need remote CM response timeout */\n\tcm_lap_set_remote_resp_timeout(lap_msg, 0x1F);\n\tlap_msg->alt_local_lid = alternate_path->slid;\n\tlap_msg->alt_remote_lid = alternate_path->dlid;\n\tlap_msg->alt_local_gid = alternate_path->sgid;\n\tlap_msg->alt_remote_gid = alternate_path->dgid;\n\tcm_lap_set_flow_label(lap_msg, alternate_path->flow_label);\n\tcm_lap_set_traffic_class(lap_msg, alternate_path->traffic_class);\n\tlap_msg->alt_hop_limit = alternate_path->hop_limit;\n\tcm_lap_set_packet_rate(lap_msg, alternate_path->rate);\n\tcm_lap_set_sl(lap_msg, alternate_path->sl);\n\tcm_lap_set_subnet_local(lap_msg, 1); /* local only... */\n\tcm_lap_set_local_ack_timeout(lap_msg,\n\t\tcm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\n\t\t\t       alternate_path->packet_life_time));\n\n\tif (private_data && private_data_len)\n\t\tmemcpy(lap_msg->private_data, private_data, private_data_len);\n}\n",
        "linevul": 7.111041486496106e-05,
        "sysevr": 0.1605205088853836,
        "devign": 0.8367565274238586
    },
    {
        "code": "void blk_mq_insert_request(struct request *rq, bool at_head, bool run_queue,\n\t\tbool async)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx = rq->mq_ctx, *current_ctx;\n\n\tcurrent_ctx = blk_mq_get_ctx(q);\n\tif (!cpu_online(ctx->cpu))\n\t\trq->mq_ctx = ctx = current_ctx;\n\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\n\tspin_lock(&ctx->lock);\n\t__blk_mq_insert_request(hctx, rq, at_head);\n\tspin_unlock(&ctx->lock);\n\n\tif (run_queue)\n\t\tblk_mq_run_hw_queue(hctx, async);\n\n\tblk_mq_put_ctx(current_ctx);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9",
        "vul_func_with_fix": "void blk_mq_insert_request(struct request *rq, bool at_head, bool run_queue,\n\t\tbool async)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx = rq->mq_ctx, *current_ctx;\n\n\tcurrent_ctx = blk_mq_get_ctx(q);\n\tif (!cpu_online(ctx->cpu))\n\t\trq->mq_ctx = ctx = current_ctx;\n\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\n\tspin_lock(&ctx->lock);\n\t__blk_mq_insert_request(hctx, rq, at_head);\n\tspin_unlock(&ctx->lock);\n\n\tif (run_queue)\n\t\tblk_mq_run_hw_queue(hctx, async);\n\n\tblk_mq_put_ctx(current_ctx);\n}\n",
        "linevul": 5.2975919970776886e-05,
        "sysevr": 0.17836421728134155,
        "devign": 2.1518446026980035e-18
    },
    {
        "code": "static noinline int add_pending_csums(struct btrfs_trans_handle *trans,\n\t\t\t     struct inode *inode, u64 file_offset,\n\t\t\t     struct list_head *list)\n{\n\tstruct btrfs_ordered_sum *sum;\n\n\tlist_for_each_entry(sum, list, list) {\n\t\tbtrfs_csum_file_blocks(trans,\n\t\t       BTRFS_I(inode)->root->fs_info->csum_root, sum);\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "vul_func_with_fix": "static noinline int add_pending_csums(struct btrfs_trans_handle *trans,\n\t\t\t     struct inode *inode, u64 file_offset,\n\t\t\t     struct list_head *list)\n{\n\tstruct btrfs_ordered_sum *sum;\n\n\tlist_for_each_entry(sum, list, list) {\n\t\tbtrfs_csum_file_blocks(trans,\n\t\t       BTRFS_I(inode)->root->fs_info->csum_root, sum);\n\t}\n\treturn 0;\n}\n",
        "linevul": 5.565177707467228e-05,
        "sysevr": 0.13179466128349304,
        "devign": 0.5581978559494019
    },
    {
        "code": "static int ioperm_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tif (!target->thread.io_bitmap_ptr)\n\t\treturn -ENXIO;\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   target->thread.io_bitmap_ptr,\n\t\t\t\t   0, IO_BITMAP_BYTES);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int ioperm_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tif (!target->thread.io_bitmap_ptr)\n\t\treturn -ENXIO;\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   target->thread.io_bitmap_ptr,\n\t\t\t\t   0, IO_BITMAP_BYTES);\n}\n",
        "linevul": 6.156037125037983e-05,
        "sysevr": 0.15385554730892181,
        "devign": 0.4824189841747284
    },
    {
        "code": "static int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm *p = &t->parms;\n\n\tNLA_PUT_U32(skb, IFLA_GRE_LINK, p->link);\n\tNLA_PUT_BE16(skb, IFLA_GRE_IFLAGS, p->i_flags);\n\tNLA_PUT_BE16(skb, IFLA_GRE_OFLAGS, p->o_flags);\n\tNLA_PUT_BE32(skb, IFLA_GRE_IKEY, p->i_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_OKEY, p->o_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_LOCAL, p->iph.saddr);\n\tNLA_PUT_BE32(skb, IFLA_GRE_REMOTE, p->iph.daddr);\n\tNLA_PUT_U8(skb, IFLA_GRE_TTL, p->iph.ttl);\n\tNLA_PUT_U8(skb, IFLA_GRE_TOS, p->iph.tos);\n\tNLA_PUT_U8(skb, IFLA_GRE_PMTUDISC, !!(p->iph.frag_off & htons(IP_DF)));\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2892f02712e9516d72841d5c019ed6916329794",
        "vul_func_with_fix": "static int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm *p = &t->parms;\n\n\tNLA_PUT_U32(skb, IFLA_GRE_LINK, p->link);\n\tNLA_PUT_BE16(skb, IFLA_GRE_IFLAGS, p->i_flags);\n\tNLA_PUT_BE16(skb, IFLA_GRE_OFLAGS, p->o_flags);\n\tNLA_PUT_BE32(skb, IFLA_GRE_IKEY, p->i_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_OKEY, p->o_key);\n\tNLA_PUT_BE32(skb, IFLA_GRE_LOCAL, p->iph.saddr);\n\tNLA_PUT_BE32(skb, IFLA_GRE_REMOTE, p->iph.daddr);\n\tNLA_PUT_U8(skb, IFLA_GRE_TTL, p->iph.ttl);\n\tNLA_PUT_U8(skb, IFLA_GRE_TOS, p->iph.tos);\n\tNLA_PUT_U8(skb, IFLA_GRE_PMTUDISC, !!(p->iph.frag_off & htons(IP_DF)));\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
        "linevul": 5.072688509244472e-05,
        "sysevr": 0.11791753023862839,
        "devign": 0.6723647713661194
    },
    {
        "code": " static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n\t\tsize_t *acl_len)\n {\n\t__be32 *savep;\n \tuint32_t attrlen,\n \t\t bitmap[3] = {0};\n \tstruct kvec *iov = req->rq_rcv_buf.head;\n \tint status;\n \n\t*acl_len = 0;\n \tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n \t\tsize_t hdrlen;\n \t\tu32 recvd;\n \n \t\t/* We ignore &savep and don't do consistency checks on\n \t\t * the attr length.  Let userspace figure it out.... */\n \t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n \t\trecvd = req->rq_rcv_buf.len - hdrlen;\n \t\tif (attrlen > recvd) {\n\t\t\tdprintk(\"NFS: server cheating in getattr\"\n\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n \t\t\t\t\tattrlen, recvd);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\txdr_read_pages(xdr, attrlen);\n\t\t*acl_len = attrlen;\n \t} else\n \t\tstatus = -EOPNOTSUPP;\n \nout:\n\treturn status;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": " static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n//flaw_line_below:\n\t\tsize_t *acl_len)\n//fix_flaw_line_below:\n//\t\t\t struct nfs_getaclres *res)\n {\n//flaw_line_below:\n\t__be32 *savep;\n//fix_flaw_line_below:\n//\t__be32 *savep, *bm_p;\n \tuint32_t attrlen,\n \t\t bitmap[3] = {0};\n \tstruct kvec *iov = req->rq_rcv_buf.head;\n \tint status;\n \n//flaw_line_below:\n\t*acl_len = 0;\n//fix_flaw_line_below:\n//\tres->acl_len = 0;\n \tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n \t\tgoto out;\n//fix_flaw_line_below:\n//\tbm_p = xdr->p;\n \tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto out;\n\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACL)) {\n \t\tsize_t hdrlen;\n \t\tu32 recvd;\n \n//fix_flaw_line_below:\n//\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n//fix_flaw_line_below:\n//\t\t * are stored with the acl data to handle the problem of\n//fix_flaw_line_below:\n//\t\t * variable length bitmaps.*/\n//fix_flaw_line_below:\n//\t\txdr->p = bm_p;\n//fix_flaw_line_below:\n//\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;\n//fix_flaw_line_below:\n//\t\tres->acl_data_offset <<= 2;\n//fix_flaw_line_below:\n//\n \t\t/* We ignore &savep and don't do consistency checks on\n \t\t * the attr length.  Let userspace figure it out.... */\n \t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n//fix_flaw_line_below:\n//\t\tattrlen += res->acl_data_offset;\n \t\trecvd = req->rq_rcv_buf.len - hdrlen;\n \t\tif (attrlen > recvd) {\n//flaw_line_below:\n\t\t\tdprintk(\"NFS: server cheating in getattr\"\n//flaw_line_below:\n\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n//fix_flaw_line_below:\n//\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {\n//fix_flaw_line_below:\n//\t\t\t\t/* getxattr interface called with a NULL buf */\n//fix_flaw_line_below:\n//\t\t\t\tres->acl_len = attrlen;\n//fix_flaw_line_below:\n//\t\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t\t}\n//fix_flaw_line_below:\n//\t\t\tdprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",\n \t\t\t\t\tattrlen, recvd);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\txdr_read_pages(xdr, attrlen);\n//flaw_line_below:\n\t\t*acl_len = attrlen;\n//fix_flaw_line_below:\n//\t\tres->acl_len = attrlen;\n \t} else\n \t\tstatus = -EOPNOTSUPP;\n \nout:\n\treturn status;\n}\n",
        "linevul": 0.9994572997093201,
        "sysevr": 0.15459568798542023,
        "devign": 4.4444286118050513e-07
    },
    {
        "code": "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd",
        "vul_func_with_fix": "static u32 map_id_range_down(struct uid_gid_map *map, u32 id, u32 count)\n{\n\tstruct uid_gid_extent *extent;\n\tunsigned extents = map->nr_extents;\n\tsmp_rmb();\n\n\tif (extents <= UID_GID_MAP_MAX_BASE_EXTENTS)\n\t\textent = map_id_range_down_base(extents, map, id, count);\n\telse\n\t\textent = map_id_range_down_max(extents, map, id, count);\n\n\t/* Map the id or note failure */\n\tif (extent)\n\t\tid = (id - extent->first) + extent->lower_first;\n\telse\n\t\tid = (u32) -1;\n\n\treturn id;\n}\n",
        "linevul": 5.9486421378096566e-05,
        "sysevr": 0.14267142117023468,
        "devign": 1.2148847025768555e-14
    },
    {
        "code": "static void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c9b92530a723ac5ef8e352885a1862b18f31b2f5",
        "vul_func_with_fix": "static void ext4_update_dx_flag(struct inode *inode)\n{\n\tif (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX))\n\t\text4_clear_inode_flag(inode, EXT4_INODE_INDEX);\n}\n",
        "linevul": 0.00010445031512062997,
        "sysevr": 0.12674139440059662,
        "devign": 0.00016150189912877977
    },
    {
        "code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n \t\tstruct nfsd4_layoutget *lgp)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n \t__be32 *p;\n \n \tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n \t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n \t*p++ = cpu_to_be32(lgp->lg_layout_type);\n \n \tnfserr = ops->encode_layoutget(xdr, lgp);\n out:\n \tkfree(lgp->lg_content);\n\treturn nfserr;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n \t\tstruct nfsd4_layoutget *lgp)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n//flaw_line_below:\n\tconst struct nfsd4_layout_ops *ops =\n//flaw_line_below:\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n//fix_flaw_line_below:\n//\tconst struct nfsd4_layout_ops *ops;\n \t__be32 *p;\n \n \tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n \t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n \t*p++ = cpu_to_be32(lgp->lg_layout_type);\n \n//fix_flaw_line_below:\n//\tops = nfsd4_layout_ops[lgp->lg_layout_type];\n \tnfserr = ops->encode_layoutget(xdr, lgp);\n out:\n \tkfree(lgp->lg_content);\n\treturn nfserr;\n}\n",
        "linevul": 0.9996168613433838,
        "sysevr": 0.1915571242570877,
        "devign": 0.9684310555458069
    },
    {
        "code": "static int vmci_transport_notify_recv_post_dequeue(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tssize_t copied,\n\tbool data_read,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_post_dequeue(\n\t\t\t&vsk->sk, target, copied, data_read,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/680d04e0ba7e926233e3b9cee59125ce181f66ba",
        "vul_func_with_fix": "static int vmci_transport_notify_recv_post_dequeue(\n\tstruct vsock_sock *vsk,\n\tsize_t target,\n\tssize_t copied,\n\tbool data_read,\n\tstruct vsock_transport_recv_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->recv_post_dequeue(\n\t\t\t&vsk->sk, target, copied, data_read,\n\t\t\t(struct vmci_transport_recv_notify_data *)data);\n}\n",
        "linevul": 6.634385499637574e-05,
        "sysevr": 0.13369587063789368,
        "devign": 1.9588145125024048e-13
    },
    {
        "code": "static struct atalk_iface *atalk_find_interface(__be16 net, int node)\n{\n\tstruct atalk_iface *iface;\n\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif ((node == ATADDR_BCAST ||\n\t\t     node == ATADDR_ANYNODE ||\n\t\t     iface->address.s_node == node) &&\n\t\t    iface->address.s_net == net &&\n\t\t    !(iface->status & ATIF_PROBE))\n\t\t\tbreak;\n\n\t\t/* XXXX.0 -- net.0 returns the iface associated with net */\n\t\tif (node == ATADDR_ANYNODE && net != ATADDR_ANYNET &&\n\t\t    ntohs(iface->nets.nr_firstnet) <= ntohs(net) &&\n\t\t    ntohs(net) <= ntohs(iface->nets.nr_lastnet))\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn iface;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static struct atalk_iface *atalk_find_interface(__be16 net, int node)\n{\n\tstruct atalk_iface *iface;\n\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif ((node == ATADDR_BCAST ||\n\t\t     node == ATADDR_ANYNODE ||\n\t\t     iface->address.s_node == node) &&\n\t\t    iface->address.s_net == net &&\n\t\t    !(iface->status & ATIF_PROBE))\n\t\t\tbreak;\n\n\t\t/* XXXX.0 -- net.0 returns the iface associated with net */\n\t\tif (node == ATADDR_ANYNODE && net != ATADDR_ANYNET &&\n\t\t    ntohs(iface->nets.nr_firstnet) <= ntohs(net) &&\n\t\t    ntohs(net) <= ntohs(iface->nets.nr_lastnet))\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn iface;\n}\n",
        "linevul": 4.750391963170841e-05,
        "sysevr": 0.1185452863574028,
        "devign": 4.013177762929371e-23
    },
    {
        "code": "static int __init usbip_core_init(void)\n{\n\tpr_info(DRIVER_DESC \" v\" USBIP_VERSION \"\\n\");\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb",
        "vul_func_with_fix": "static int __init usbip_core_init(void)\n{\n\tpr_info(DRIVER_DESC \" v\" USBIP_VERSION \"\\n\");\n\treturn 0;\n}\n",
        "linevul": 9.136374137597159e-05,
        "sysevr": 0.12574872374534607,
        "devign": 0.4808011054992676
    },
    {
        "code": "struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)\n{\n\tskb_release_all(dst);\n\treturn __skb_clone(dst, src);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "vul_func_with_fix": "struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)\n{\n\tskb_release_all(dst);\n\treturn __skb_clone(dst, src);\n}\n",
        "linevul": 5.360162685974501e-05,
        "sysevr": 0.1443091332912445,
        "devign": 0.00442511448636651
    },
    {
        "code": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running + !se->on_rq);\n\n\tfor_each_sched_entity(se) {\n\t\tstruct load_weight *load;\n\t\tstruct load_weight lw;\n\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tload = &cfs_rq->load;\n\n\t\tif (unlikely(!se->on_rq)) {\n\t\t\tlw = cfs_rq->load;\n\n\t\t\tupdate_load_add(&lw, se->load.weight);\n\t\t\tload = &lw;\n\t\t}\n\t\tslice = __calc_delta(slice, se->load.weight, load);\n\t}\n\treturn slice;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running + !se->on_rq);\n\n\tfor_each_sched_entity(se) {\n\t\tstruct load_weight *load;\n\t\tstruct load_weight lw;\n\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tload = &cfs_rq->load;\n\n\t\tif (unlikely(!se->on_rq)) {\n\t\t\tlw = cfs_rq->load;\n\n\t\t\tupdate_load_add(&lw, se->load.weight);\n\t\t\tload = &lw;\n\t\t}\n\t\tslice = __calc_delta(slice, se->load.weight, load);\n\t}\n\treturn slice;\n}\n",
        "linevul": 5.248228626442142e-05,
        "sysevr": 0.15149694681167603,
        "devign": 9.493072639088496e-08
    },
    {
        "code": "static void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "vul_func_with_fix": "static void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n",
        "linevul": 0.00011525813170010224,
        "sysevr": 0.15355202555656433,
        "devign": 6.262186047455967e-16
    },
    {
        "code": "static struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}\n",
        "linevul": 0.00014526364975608885,
        "sysevr": 0.14341069757938385,
        "devign": 0.0
    },
    {
        "code": "void dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "void dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}\n",
        "linevul": 0.0002005363057833165,
        "sysevr": 0.15586501359939575,
        "devign": 3.5910575050699875e-14
    },
    {
        "code": "int do_xdp_generic(struct bpf_prog *xdp_prog, struct sk_buff *skb)\n{\n\tif (xdp_prog) {\n\t\tu32 act = netif_receive_generic_xdp(skb, xdp_prog);\n\t\tint err;\n\n\t\tif (act != XDP_PASS) {\n\t\t\tswitch (act) {\n\t\t\tcase XDP_REDIRECT:\n\t\t\t\terr = xdp_do_generic_redirect(skb->dev, skb,\n\t\t\t\t\t\t\t      xdp_prog);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_redir;\n\t\t\t/* fallthru to submit skb */\n\t\t\tcase XDP_TX:\n\t\t\t\tgeneric_xdp_tx(skb, xdp_prog);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn XDP_DROP;\n\t\t}\n\t}\n\treturn XDP_PASS;\nout_redir:\n\tkfree_skb(skb);\n\treturn XDP_DROP;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d",
        "vul_func_with_fix": "int do_xdp_generic(struct bpf_prog *xdp_prog, struct sk_buff *skb)\n{\n\tif (xdp_prog) {\n\t\tu32 act = netif_receive_generic_xdp(skb, xdp_prog);\n\t\tint err;\n\n\t\tif (act != XDP_PASS) {\n\t\t\tswitch (act) {\n\t\t\tcase XDP_REDIRECT:\n\t\t\t\terr = xdp_do_generic_redirect(skb->dev, skb,\n\t\t\t\t\t\t\t      xdp_prog);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_redir;\n\t\t\t/* fallthru to submit skb */\n\t\t\tcase XDP_TX:\n\t\t\t\tgeneric_xdp_tx(skb, xdp_prog);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn XDP_DROP;\n\t\t}\n\t}\n\treturn XDP_PASS;\nout_redir:\n\tkfree_skb(skb);\n\treturn XDP_DROP;\n}\n",
        "linevul": 4.900355634163134e-05,
        "sysevr": 0.15230871737003326,
        "devign": 1.455131950933719e-06
    },
    {
        "code": " static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n \n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/681fef8380eb818c0b845fca5d2ab1dcbab114ee",
        "vul_func_with_fix": " static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n//flaw_line_below:\n\tstruct usbdevfs_connectinfo ci = {\n//flaw_line_below:\n\t\t.devnum = ps->dev->devnum,\n//flaw_line_below:\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n//flaw_line_below:\n\t};\n//fix_flaw_line_below:\n//\tstruct usbdevfs_connectinfo ci;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tmemset(&ci, 0, sizeof(ci));\n//fix_flaw_line_below:\n//\tci.devnum = ps->dev->devnum;\n//fix_flaw_line_below:\n//\tci.slow = ps->dev->speed == USB_SPEED_LOW;\n \n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "linevul": 0.9995655417442322,
        "sysevr": 0.12812131643295288,
        "devign": 0.655854344367981
    },
    {
        "code": "xfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/eb178619f930fa2ba2348de332a1ff1c66a31424",
        "vul_func_with_fix": "xfs_buf_is_vmapped(\n\tstruct xfs_buf\t*bp)\n{\n\t/*\n\t * Return true if the buffer is vmapped.\n\t *\n\t * b_addr is null if the buffer is not mapped, but the code is clever\n\t * enough to know it doesn't have to map a single page, so the check has\n\t * to be both for b_addr and bp->b_page_count > 1.\n\t */\n\treturn bp->b_addr && bp->b_page_count > 1;\n}\n",
        "linevul": 8.561941649531946e-05,
        "sysevr": 0.17907042801380157,
        "devign": 0.18541792035102844
    },
    {
        "code": "static void fm10k_tx_map(struct fm10k_ring *tx_ring,\n\t\t\t struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tstruct skb_frag_struct *frag;\n\tunsigned char *data;\n\tdma_addr_t dma;\n\tunsigned int data_len, size;\n\tu32 tx_flags = first->tx_flags;\n\tu16 i = tx_ring->next_to_use;\n\tu8 flags = fm10k_tx_desc_flags(skb, tx_flags);\n\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\n\t/* add HW VLAN tag */\n\tif (skb_vlan_tag_present(skb))\n\t\ttx_desc->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\telse\n\t\ttx_desc->vlan = 0;\n\n\tsize = skb_headlen(skb);\n\tdata = skb->data;\n\n\tdma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\n\n\tdata_len = skb->data_len;\n\ttx_buffer = first;\n\n\tfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\n\t\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\t\tgoto dma_error;\n\n\t\t/* record length, and DMA address */\n\t\tdma_unmap_len_set(tx_buffer, len, size);\n\t\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\n\t\twhile (unlikely(size > FM10K_MAX_DATA_PER_TXD)) {\n\t\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++, dma,\n\t\t\t\t\t       FM10K_MAX_DATA_PER_TXD, flags)) {\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tdma += FM10K_MAX_DATA_PER_TXD;\n\t\t\tsize -= FM10K_MAX_DATA_PER_TXD;\n\t\t}\n\n\t\tif (likely(!data_len))\n\t\t\tbreak;\n\n\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++,\n\t\t\t\t       dma, size, flags)) {\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\ti = 0;\n\t\t}\n\n\t\tsize = skb_frag_size(frag);\n\t\tdata_len -= size;\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t}\n\n\t/* write last descriptor with LAST bit set */\n\tflags |= FM10K_TXD_FLAG_LAST;\n\n\tif (fm10k_tx_desc_push(tx_ring, tx_desc, i++, dma, size, flags))\n\t\ti = 0;\n\n\t/* record bytecount for BQL */\n\tnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\n\n\t/* record SW timestamp if HW timestamp is not available */\n\tskb_tx_timestamp(first->skb);\n\n\t/* Force memory writes to complete before letting h/w know there\n\t * are new descriptors to fetch.  (Only applicable for weak-ordered\n\t * memory model archs, such as IA-64).\n\t *\n\t * We also need this memory barrier to make certain all of the\n\t * status bits have been updated before next_to_watch is written.\n\t */\n\twmb();\n\n\t/* set next_to_watch value indicating a packet is present */\n\tfirst->next_to_watch = tx_desc;\n\n\ttx_ring->next_to_use = i;\n\n\t/* Make sure there is space in the ring for the next send. */\n\tfm10k_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\t/* notify HW of packet */\n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !skb->xmit_more) {\n\t\twritel(i, tx_ring->tail);\n\n\t\t/* we need this if more than one processor can write to our tail\n\t\t * at a time, it synchronizes IO on IA64/Altix systems\n\t\t */\n\t\tmmiowb();\n\t}\n\n\treturn;\ndma_error:\n\tdev_err(tx_ring->dev, \"TX DMA map failed\\n\");\n\n\t/* clear dma mappings for failed tx_buffer map */\n\tfor (;;) {\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t\tfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\n\t\tif (tx_buffer == first)\n\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\ti = tx_ring->count;\n\t\ti--;\n\t}\n\n\ttx_ring->next_to_use = i;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f",
        "vul_func_with_fix": "static void fm10k_tx_map(struct fm10k_ring *tx_ring,\n\t\t\t struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tstruct skb_frag_struct *frag;\n\tunsigned char *data;\n\tdma_addr_t dma;\n\tunsigned int data_len, size;\n\tu32 tx_flags = first->tx_flags;\n\tu16 i = tx_ring->next_to_use;\n\tu8 flags = fm10k_tx_desc_flags(skb, tx_flags);\n\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\n\t/* add HW VLAN tag */\n\tif (skb_vlan_tag_present(skb))\n\t\ttx_desc->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\telse\n\t\ttx_desc->vlan = 0;\n\n\tsize = skb_headlen(skb);\n\tdata = skb->data;\n\n\tdma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\n\n\tdata_len = skb->data_len;\n\ttx_buffer = first;\n\n\tfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\n\t\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\t\tgoto dma_error;\n\n\t\t/* record length, and DMA address */\n\t\tdma_unmap_len_set(tx_buffer, len, size);\n\t\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\n\t\twhile (unlikely(size > FM10K_MAX_DATA_PER_TXD)) {\n\t\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++, dma,\n\t\t\t\t\t       FM10K_MAX_DATA_PER_TXD, flags)) {\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tdma += FM10K_MAX_DATA_PER_TXD;\n\t\t\tsize -= FM10K_MAX_DATA_PER_TXD;\n\t\t}\n\n\t\tif (likely(!data_len))\n\t\t\tbreak;\n\n\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++,\n\t\t\t\t       dma, size, flags)) {\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\ti = 0;\n\t\t}\n\n\t\tsize = skb_frag_size(frag);\n\t\tdata_len -= size;\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t}\n\n\t/* write last descriptor with LAST bit set */\n\tflags |= FM10K_TXD_FLAG_LAST;\n\n\tif (fm10k_tx_desc_push(tx_ring, tx_desc, i++, dma, size, flags))\n\t\ti = 0;\n\n\t/* record bytecount for BQL */\n\tnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\n\n\t/* record SW timestamp if HW timestamp is not available */\n\tskb_tx_timestamp(first->skb);\n\n\t/* Force memory writes to complete before letting h/w know there\n\t * are new descriptors to fetch.  (Only applicable for weak-ordered\n\t * memory model archs, such as IA-64).\n\t *\n\t * We also need this memory barrier to make certain all of the\n\t * status bits have been updated before next_to_watch is written.\n\t */\n\twmb();\n\n\t/* set next_to_watch value indicating a packet is present */\n\tfirst->next_to_watch = tx_desc;\n\n\ttx_ring->next_to_use = i;\n\n\t/* Make sure there is space in the ring for the next send. */\n\tfm10k_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\t/* notify HW of packet */\n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !skb->xmit_more) {\n\t\twritel(i, tx_ring->tail);\n\n\t\t/* we need this if more than one processor can write to our tail\n\t\t * at a time, it synchronizes IO on IA64/Altix systems\n\t\t */\n\t\tmmiowb();\n\t}\n\n\treturn;\ndma_error:\n\tdev_err(tx_ring->dev, \"TX DMA map failed\\n\");\n\n\t/* clear dma mappings for failed tx_buffer map */\n\tfor (;;) {\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t\tfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\n\t\tif (tx_buffer == first)\n\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\ti = tx_ring->count;\n\t\ti--;\n\t}\n\n\ttx_ring->next_to_use = i;\n}\n",
        "linevul": 0.00026216634432785213,
        "sysevr": 0.18556195497512817,
        "devign": 4.338750936490072e-15
    },
    {
        "code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\n\t/* Free the existing undo structures for this semaphore set.  */\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\n\t/* Wake up all pending processes and let them fail with EIDRM. */\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n \n \t/* Remove the semaphore set from the IDR */\n \tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n \n \twake_up_sem_queue_do(&tasks);\n \tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\n\t/* Free the existing undo structures for this semaphore set.  */\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\n\t/* Wake up all pending processes and let them fail with EIDRM. */\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n \n \t/* Remove the semaphore set from the IDR */\n \tsem_rmid(ns, sma);\n//flaw_line_below:\n\tsem_unlock(sma);\n//fix_flaw_line_below:\n//\tsem_unlock(sma, -1);\n \n \twake_up_sem_queue_do(&tasks);\n \tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}\n",
        "linevul": 0.00013094060705043375,
        "sysevr": 0.13717781007289886,
        "devign": 0.971637487411499
    },
    {
        "code": "static int ext4_ext_search_left(struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\text4_lblk_t *logical, ext4_fsblk_t *phys)\n{\n\tstruct ext4_extent_idx *ix;\n\tstruct ext4_extent *ex;\n\tint depth, ee_len;\n\n\tif (unlikely(path == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path == NULL *logical %d!\", *logical);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tdepth = path->p_depth;\n\t*phys = 0;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn 0;\n\n\t/* usually extent in the path covers blocks smaller\n\t * then *logical, but it can be that extent is the\n\t * first one in the file */\n\n\tex = path[depth].p_ext;\n\tee_len = ext4_ext_get_actual_len(ex);\n\tif (*logical < le32_to_cpu(ex->ee_block)) {\n\t\tif (unlikely(EXT_FIRST_EXTENT(path[depth].p_hdr) != ex)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"EXT_FIRST_EXTENT != ex *logical %d ee_block %d!\",\n\t\t\t\t\t *logical, le32_to_cpu(ex->ee_block));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\twhile (--depth >= 0) {\n\t\t\tix = path[depth].p_idx;\n\t\t\tif (unlikely(ix != EXT_FIRST_INDEX(path[depth].p_hdr))) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t  \"ix (%d) != EXT_FIRST_INDEX (%d) (depth %d)!\",\n\t\t\t\t  ix != NULL ? le32_to_cpu(ix->ei_block) : 0,\n\t\t\t\t  EXT_FIRST_INDEX(path[depth].p_hdr) != NULL ?\n\t\tle32_to_cpu(EXT_FIRST_INDEX(path[depth].p_hdr)->ei_block) : 0,\n\t\t\t\t  depth);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (unlikely(*logical < (le32_to_cpu(ex->ee_block) + ee_len))) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"logical %d < ee_block %d + ee_len %d!\",\n\t\t\t\t *logical, le32_to_cpu(ex->ee_block), ee_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t*logical = le32_to_cpu(ex->ee_block) + ee_len - 1;\n\t*phys = ext4_ext_pblock(ex) + ee_len - 1;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static int ext4_ext_search_left(struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\text4_lblk_t *logical, ext4_fsblk_t *phys)\n{\n\tstruct ext4_extent_idx *ix;\n\tstruct ext4_extent *ex;\n\tint depth, ee_len;\n\n\tif (unlikely(path == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path == NULL *logical %d!\", *logical);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tdepth = path->p_depth;\n\t*phys = 0;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn 0;\n\n\t/* usually extent in the path covers blocks smaller\n\t * then *logical, but it can be that extent is the\n\t * first one in the file */\n\n\tex = path[depth].p_ext;\n\tee_len = ext4_ext_get_actual_len(ex);\n\tif (*logical < le32_to_cpu(ex->ee_block)) {\n\t\tif (unlikely(EXT_FIRST_EXTENT(path[depth].p_hdr) != ex)) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"EXT_FIRST_EXTENT != ex *logical %d ee_block %d!\",\n\t\t\t\t\t *logical, le32_to_cpu(ex->ee_block));\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\twhile (--depth >= 0) {\n\t\t\tix = path[depth].p_idx;\n\t\t\tif (unlikely(ix != EXT_FIRST_INDEX(path[depth].p_hdr))) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t  \"ix (%d) != EXT_FIRST_INDEX (%d) (depth %d)!\",\n\t\t\t\t  ix != NULL ? le32_to_cpu(ix->ei_block) : 0,\n\t\t\t\t  EXT_FIRST_INDEX(path[depth].p_hdr) != NULL ?\n\t\tle32_to_cpu(EXT_FIRST_INDEX(path[depth].p_hdr)->ei_block) : 0,\n\t\t\t\t  depth);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (unlikely(*logical < (le32_to_cpu(ex->ee_block) + ee_len))) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"logical %d < ee_block %d + ee_len %d!\",\n\t\t\t\t *logical, le32_to_cpu(ex->ee_block), ee_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t*logical = le32_to_cpu(ex->ee_block) + ee_len - 1;\n\t*phys = ext4_ext_pblock(ex) + ee_len - 1;\n\treturn 0;\n}\n",
        "linevul": 6.258719076868147e-05,
        "sysevr": 0.25921356678009033,
        "devign": 0.80855792760849
    },
    {
        "code": "static inline int get_numa_group(struct numa_group *grp)\n{\n\treturn atomic_inc_not_zero(&grp->refcount);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static inline int get_numa_group(struct numa_group *grp)\n{\n\treturn atomic_inc_not_zero(&grp->refcount);\n}\n",
        "linevul": 5.4936455853749067e-05,
        "sysevr": 0.1273602843284607,
        "devign": 2.5127465050900355e-06
    },
    {
        "code": "static int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\n\tif (!rt) {\n\t\tpol->xfrm_nr = 0;\n\t} else {\n\t\tstruct xfrm_user_tmpl *utmpl = nla_data(rt);\n\t\tint nr = nla_len(rt) / sizeof(*utmpl);\n\t\tint err;\n\n\t\terr = validate_tmpl(nr, utmpl, pol->family);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_templates(pol, utmpl, nr);\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\n\tif (!rt) {\n\t\tpol->xfrm_nr = 0;\n\t} else {\n\t\tstruct xfrm_user_tmpl *utmpl = nla_data(rt);\n\t\tint nr = nla_len(rt) / sizeof(*utmpl);\n\t\tint err;\n\n\t\terr = validate_tmpl(nr, utmpl, pol->family);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_templates(pol, utmpl, nr);\n\t}\n\treturn 0;\n}\n",
        "linevul": 5.614388282992877e-05,
        "sysevr": 0.13073290884494781,
        "devign": 0.0355767197906971
    },
    {
        "code": "int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,\n\t\t\t const struct nlmsghdr *nlh,\n\t\t\t struct netlink_dump_control *control)\n{\n\tstruct netlink_callback *cb;\n\tstruct sock *sk;\n\tstruct netlink_sock *nlk;\n\tint ret;\n\n\t/* Memory mapped dump requests need to be copied to avoid looping\n\t * on the pending state in netlink_mmap_sendmsg() while the CB hold\n\t * a reference to the skb.\n\t */\n\tif (netlink_skb_is_mmaped(skb)) {\n\t\tskb = skb_copy(skb, GFP_KERNEL);\n\t\tif (skb == NULL)\n\t\t\treturn -ENOBUFS;\n\t} else\n\t\tatomic_inc(&skb->users);\n\n\tsk = netlink_lookup(sock_net(ssk), ssk->sk_protocol, NETLINK_CB(skb).portid);\n\tif (sk == NULL) {\n\t\tret = -ECONNREFUSED;\n\t\tgoto error_free;\n\t}\n\n\tnlk = nlk_sk(sk);\n\tmutex_lock(nlk->cb_mutex);\n\t/* A dump is in progress... */\n\tif (nlk->cb_running) {\n\t\tret = -EBUSY;\n\t\tgoto error_unlock;\n\t}\n\t/* add reference of module which cb->dump belongs to */\n\tif (!try_module_get(control->module)) {\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto error_unlock;\n\t}\n\n\tcb = &nlk->cb;\n\tmemset(cb, 0, sizeof(*cb));\n\tcb->dump = control->dump;\n\tcb->done = control->done;\n\tcb->nlh = nlh;\n\tcb->data = control->data;\n\tcb->module = control->module;\n\tcb->min_dump_alloc = control->min_dump_alloc;\n\tcb->skb = skb;\n\n\tnlk->cb_running = true;\n\n\tmutex_unlock(nlk->cb_mutex);\n\n\tret = netlink_dump(sk);\n\tsock_put(sk);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/* We successfully started a dump, by returning -EINTR we\n\t * signal not to send ACK even if it was requested.\n\t */\n\treturn -EINTR;\n\nerror_unlock:\n\tsock_put(sk);\n\tmutex_unlock(nlk->cb_mutex);\nerror_free:\n\tkfree_skb(skb);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,\n\t\t\t const struct nlmsghdr *nlh,\n\t\t\t struct netlink_dump_control *control)\n{\n\tstruct netlink_callback *cb;\n\tstruct sock *sk;\n\tstruct netlink_sock *nlk;\n\tint ret;\n\n\t/* Memory mapped dump requests need to be copied to avoid looping\n\t * on the pending state in netlink_mmap_sendmsg() while the CB hold\n\t * a reference to the skb.\n\t */\n\tif (netlink_skb_is_mmaped(skb)) {\n\t\tskb = skb_copy(skb, GFP_KERNEL);\n\t\tif (skb == NULL)\n\t\t\treturn -ENOBUFS;\n\t} else\n\t\tatomic_inc(&skb->users);\n\n\tsk = netlink_lookup(sock_net(ssk), ssk->sk_protocol, NETLINK_CB(skb).portid);\n\tif (sk == NULL) {\n\t\tret = -ECONNREFUSED;\n\t\tgoto error_free;\n\t}\n\n\tnlk = nlk_sk(sk);\n\tmutex_lock(nlk->cb_mutex);\n\t/* A dump is in progress... */\n\tif (nlk->cb_running) {\n\t\tret = -EBUSY;\n\t\tgoto error_unlock;\n\t}\n\t/* add reference of module which cb->dump belongs to */\n\tif (!try_module_get(control->module)) {\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto error_unlock;\n\t}\n\n\tcb = &nlk->cb;\n\tmemset(cb, 0, sizeof(*cb));\n\tcb->dump = control->dump;\n\tcb->done = control->done;\n\tcb->nlh = nlh;\n\tcb->data = control->data;\n\tcb->module = control->module;\n\tcb->min_dump_alloc = control->min_dump_alloc;\n\tcb->skb = skb;\n\n\tnlk->cb_running = true;\n\n\tmutex_unlock(nlk->cb_mutex);\n\n\tret = netlink_dump(sk);\n\tsock_put(sk);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/* We successfully started a dump, by returning -EINTR we\n\t * signal not to send ACK even if it was requested.\n\t */\n\treturn -EINTR;\n\nerror_unlock:\n\tsock_put(sk);\n\tmutex_unlock(nlk->cb_mutex);\nerror_free:\n\tkfree_skb(skb);\n\treturn ret;\n}\n",
        "linevul": 8.741243073018268e-05,
        "sysevr": 0.22461864352226257,
        "devign": 5.303966886621956e-34
    },
    {
        "code": "pegasus_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_ethtool_sset(&pegasus->mii, ecmd);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace",
        "vul_func_with_fix": "pegasus_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_ethtool_sset(&pegasus->mii, ecmd);\n}\n",
        "linevul": 4.746529521071352e-05,
        "sysevr": 0.14119373261928558,
        "devign": 5.203771051895791e-15
    },
    {
        "code": "static inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f",
        "vul_func_with_fix": "static inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n",
        "linevul": 7.255018863361329e-05,
        "sysevr": 0.1372433751821518,
        "devign": 0.5068068504333496
    },
    {
        "code": "static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,\n\t\t\t   bool *writable, kvm_pfn_t *pfn)\n{\n\tstruct page *page[1];\n\tint npages = 0;\n\n\tmight_sleep();\n\n\tif (writable)\n\t\t*writable = write_fault;\n\n\tif (async) {\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tnpages = get_user_page_nowait(addr, write_fault, page);\n\t\tup_read(&current->mm->mmap_sem);\n\t} else {\n\t\tunsigned int flags = FOLL_TOUCH | FOLL_HWPOISON;\n\n\t\tif (write_fault)\n\t\t\tflags |= FOLL_WRITE;\n\n\t\tnpages = __get_user_pages_unlocked(current, current->mm, addr, 1,\n\t\t\t\t\t\t   page, flags);\n\t}\n\tif (npages != 1)\n\t\treturn npages;\n\n\t/* map read fault as writable if possible */\n\tif (unlikely(!write_fault) && writable) {\n\t\tstruct page *wpage[1];\n\n\t\tnpages = __get_user_pages_fast(addr, 1, 1, wpage);\n\t\tif (npages == 1) {\n\t\t\t*writable = true;\n\t\t\tput_page(page[0]);\n\t\t\tpage[0] = wpage[0];\n\t\t}\n\n\t\tnpages = 1;\n\t}\n\t*pfn = page_to_pfn(page[0]);\n\treturn npages;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "vul_func_with_fix": "static int hva_to_pfn_slow(unsigned long addr, bool *async, bool write_fault,\n\t\t\t   bool *writable, kvm_pfn_t *pfn)\n{\n\tstruct page *page[1];\n\tint npages = 0;\n\n\tmight_sleep();\n\n\tif (writable)\n\t\t*writable = write_fault;\n\n\tif (async) {\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tnpages = get_user_page_nowait(addr, write_fault, page);\n\t\tup_read(&current->mm->mmap_sem);\n\t} else {\n\t\tunsigned int flags = FOLL_TOUCH | FOLL_HWPOISON;\n\n\t\tif (write_fault)\n\t\t\tflags |= FOLL_WRITE;\n\n\t\tnpages = __get_user_pages_unlocked(current, current->mm, addr, 1,\n\t\t\t\t\t\t   page, flags);\n\t}\n\tif (npages != 1)\n\t\treturn npages;\n\n\t/* map read fault as writable if possible */\n\tif (unlikely(!write_fault) && writable) {\n\t\tstruct page *wpage[1];\n\n\t\tnpages = __get_user_pages_fast(addr, 1, 1, wpage);\n\t\tif (npages == 1) {\n\t\t\t*writable = true;\n\t\t\tput_page(page[0]);\n\t\t\tpage[0] = wpage[0];\n\t\t}\n\n\t\tnpages = 1;\n\t}\n\t*pfn = page_to_pfn(page[0]);\n\treturn npages;\n}\n",
        "linevul": 5.508943286258727e-05,
        "sysevr": 0.11823511123657227,
        "devign": 3.653887456028193e-30
    },
    {
        "code": "static int ipgre_newlink(struct net *src_net, struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct nlattr *data[])\n{\n\tstruct ip_tunnel *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint mtu;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\tipgre_netlink_parms(data, &nt->parms);\n\n\tif (ipgre_tunnel_find(net, &nt->parms, dev->type))\n\t\treturn -EEXIST;\n\n\tif (dev->type == ARPHRD_ETHER && !tb[IFLA_ADDRESS])\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tmtu = ipgre_tunnel_bind_dev(dev);\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = mtu;\n\n\t/* Can use a lockless transmit, unless we generate output sequences */\n\tif (!(nt->parms.o_flags & GRE_SEQ))\n\t\tdev->features |= NETIF_F_LLTX;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tipgre_tunnel_link(ign, nt);\n\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "static int ipgre_newlink(struct net *src_net, struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct nlattr *data[])\n{\n\tstruct ip_tunnel *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint mtu;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\tipgre_netlink_parms(data, &nt->parms);\n\n\tif (ipgre_tunnel_find(net, &nt->parms, dev->type))\n\t\treturn -EEXIST;\n\n\tif (dev->type == ARPHRD_ETHER && !tb[IFLA_ADDRESS])\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tmtu = ipgre_tunnel_bind_dev(dev);\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = mtu;\n\n\t/* Can use a lockless transmit, unless we generate output sequences */\n\tif (!(nt->parms.o_flags & GRE_SEQ))\n\t\tdev->features |= NETIF_F_LLTX;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tipgre_tunnel_link(ign, nt);\n\nout:\n\treturn err;\n}\n",
        "linevul": 0.0035465441178530455,
        "sysevr": 0.14191986620426178,
        "devign": 1.3356364223668324e-26
    },
    {
        "code": "static int _nfs4_free_stateid(struct nfs_server *server, struct nfs4_state *state)\n{\n\tint status;\n\tstruct nfs41_free_stateid_args args = {\n\t\t.stateid = &state->stateid,\n\t};\n\tstruct nfs41_free_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\targs.seq_args.sa_session = res.seq_res.sr_session = NULL;\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg, &args.seq_args, &res.seq_res, 0, 1);\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int _nfs4_free_stateid(struct nfs_server *server, struct nfs4_state *state)\n{\n\tint status;\n\tstruct nfs41_free_stateid_args args = {\n\t\t.stateid = &state->stateid,\n\t};\n\tstruct nfs41_free_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\targs.seq_args.sa_session = res.seq_res.sr_session = NULL;\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg, &args.seq_args, &res.seq_res, 0, 1);\n\treturn status;\n}\n",
        "linevul": 4.935167089570314e-05,
        "sysevr": 0.17593692243099213,
        "devign": 1.4447325862001623e-29
    },
    {
        "code": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "vul_func_with_fix": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n \tstruct crypto_report_aead raead;\n \tstruct aead_alg *aead = &alg->cra_aead;\n \n//flaw_line_below:\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n//flaw_line_below:\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n//flaw_line_below:\n\t\t aead->geniv ?: \"<built-in>\");\n//fix_flaw_line_below:\n//\tstrncpy(raead.type, \"aead\", sizeof(raead.type));\n//fix_flaw_line_below:\n//\tstrncpy(raead.geniv, aead->geniv ?: \"<built-in>\", sizeof(raead.geniv));\n \n \traead.blocksize = alg->cra_blocksize;\n \traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
        "linevul": 0.999256432056427,
        "sysevr": 0.12895911931991577,
        "devign": 0.9984866380691528
    },
    {
        "code": "static int edge_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tdev_dbg(&port->dev, \"%s - TIOCGSERIAL\\n\", __func__);\n\t\treturn get_serial_info(edge_port,\n\t\t\t\t(struct serial_struct __user *) arg);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e",
        "vul_func_with_fix": "static int edge_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tdev_dbg(&port->dev, \"%s - TIOCGSERIAL\\n\", __func__);\n\t\treturn get_serial_info(edge_port,\n\t\t\t\t(struct serial_struct __user *) arg);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n",
        "linevul": 4.977606295142323e-05,
        "sysevr": 0.126164048910141,
        "devign": 0.00015807300223968923
    },
    {
        "code": "static int airo_get_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\tvwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;\n\t/* If more than one rate, set auto */\n\treadConfigRid(local, 1);\n\tvwrq->fixed = (local->config.rates[1] == 0);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static int airo_get_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\tvwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;\n\t/* If more than one rate, set auto */\n\treadConfigRid(local, 1);\n\tvwrq->fixed = (local->config.rates[1] == 0);\n\n\treturn 0;\n}\n",
        "linevul": 4.6284440031740814e-05,
        "sysevr": 0.11747339367866516,
        "devign": 4.4827429799849244e-14
    },
    {
        "code": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r;\n\tstruct path path;\n\n\tif (!(flag & CL_COPY_ALL) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tif (!(flag & CL_COPY_ALL) && IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tpath.mnt = &q->mnt;\n\t\t\tpath.dentry = p->mnt_mountpoint;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tbr_write_lock(&vfsmount_lock);\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tattach_mnt(q, &path);\n\t\t\tbr_write_unlock(&vfsmount_lock);\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tLIST_HEAD(umount_list);\n\t\tbr_write_lock(&vfsmount_lock);\n\t\tumount_tree(res, 0, &umount_list);\n\t\tbr_write_unlock(&vfsmount_lock);\n\t\trelease_mounts(&umount_list);\n\t}\n\treturn q;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9",
        "vul_func_with_fix": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r;\n\tstruct path path;\n\n\tif (!(flag & CL_COPY_ALL) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tif (!(flag & CL_COPY_ALL) && IS_MNT_UNBINDABLE(s)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tpath.mnt = &q->mnt;\n\t\t\tpath.dentry = p->mnt_mountpoint;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tbr_write_lock(&vfsmount_lock);\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tattach_mnt(q, &path);\n\t\t\tbr_write_unlock(&vfsmount_lock);\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tLIST_HEAD(umount_list);\n\t\tbr_write_lock(&vfsmount_lock);\n\t\tumount_tree(res, 0, &umount_list);\n\t\tbr_write_unlock(&vfsmount_lock);\n\t\trelease_mounts(&umount_list);\n\t}\n\treturn q;\n}\n",
        "linevul": 8.448123116977513e-05,
        "sysevr": 0.15986765921115875,
        "devign": 0.0
    },
    {
        "code": " static inline void sem_putref(struct sem_array *sma)\n {\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": " static inline void sem_putref(struct sem_array *sma)\n {\n//flaw_line_below:\n\tipc_lock_by_ptr(&sma->sem_perm);\n//flaw_line_below:\n\tipc_rcu_putref(sma);\n//flaw_line_below:\n\tipc_unlock(&(sma)->sem_perm);\n//fix_flaw_line_below:\n//\tsem_lock_and_putref(sma);\n//fix_flaw_line_below:\n//\tsem_unlock(sma, -1);\n }\n",
        "linevul": 0.9438799023628235,
        "sysevr": 0.1255325973033905,
        "devign": 0.9879686832427979
    },
    {
        "code": "int do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8b01fc86b9f425899f8a3a8fc1c47d73c2c20543",
        "vul_func_with_fix": "int do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}\n",
        "linevul": 4.916992111247964e-05,
        "sysevr": 0.1713533252477646,
        "devign": 0.6058743000030518
    },
    {
        "code": "static int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea",
        "vul_func_with_fix": "static int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 5.171869997866452e-05,
        "sysevr": 0.12296915054321289,
        "devign": 0.0010434117866680026
    },
    {
        "code": "static int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long tmptaint = get_taint();\n\tint err;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &tmptaint;\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (write) {\n\t\t/*\n\t\t * Poor man's atomic or. Not worth adding a primitive\n\t\t * to everyone's atomic.h for this\n\t\t */\n\t\tint i;\n\t\tfor (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {\n\t\t\tif ((tmptaint >> i) & 1)\n\t\t\t\tadd_taint(i, LOCKDEP_STILL_OK);\n\t\t}\n\t}\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "static int proc_taint(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tunsigned long tmptaint = get_taint();\n\tint err;\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &tmptaint;\n\terr = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (write) {\n\t\t/*\n\t\t * Poor man's atomic or. Not worth adding a primitive\n\t\t * to everyone's atomic.h for this\n\t\t */\n\t\tint i;\n\t\tfor (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {\n\t\t\tif ((tmptaint >> i) & 1)\n\t\t\t\tadd_taint(i, LOCKDEP_STILL_OK);\n\t\t}\n\t}\n\n\treturn err;\n}\n",
        "linevul": 5.096855238662101e-05,
        "sysevr": 0.1312519758939743,
        "devign": 0.6254057288169861
    },
    {
        "code": "nl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct nlattr *keys)\n{\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\tresult->defmgmt = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 4)\n\t\t\tgoto error;\n\t\tif (parse.def) {\n\t\t\tif (def)\n\t\t\t\tgoto error;\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
        "vul_func_with_fix": "nl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct nlattr *keys)\n{\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\tresult->defmgmt = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 4)\n\t\t\tgoto error;\n\t\tif (parse.def) {\n\t\t\tif (def)\n\t\t\t\tgoto error;\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n",
        "linevul": 7.131624442990869e-05,
        "sysevr": 0.20120136439800262,
        "devign": 1.6761821151987238e-13
    },
    {
        "code": "\t\t\t\t__releases(kernel_lock)\n\t\t\t\t__acquires(kernel_lock)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -EINVAL;\n\tint blocksize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tsbi->s_sectors_written_start = part_stat_read(sb->s_bdev->bd_part,\n\t\t\t\t\t\t      sectors[1]);\n\n\tunlock_kernel();\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS) {\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, \"bsdgroups\",\n\t\t\t\"2.6.38\");\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\t}\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (def_mount_opts & EXT4_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (def_mount_opts & EXT4_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tset_opt(sbi->s_mount_opt, DELALLOC);\n\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#blocks per group too big: %lu\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\tif ((ext4_blocks_count(es) >\n\t     (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) ||\n\t    (ext4_blocks_count(es) >\n\t     (pgoff_t)(~0ULL) >> (PAGE_CACHE_SHIFT - sb->s_blocksize_bits))) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tret = -EFBIG;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n                ext4_msg(sb, KERN_WARNING, \"bad geometry: first data\"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n#endif\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_max_writeback_mb_bump = 128;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\tsb->s_op = &ext4_sops;\n\telse\n\t\tsb->s_op = &ext4_nojournal_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n \t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n \t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n \t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount4;\n \t} else {\n \t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n \t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n \t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n \t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n \t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount4;\n \t}\n \n \tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n \t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n \t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n \t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount4;\n \t\t}\n \tdefault:\n \t\tbreak;\n \t}\n \tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n \n no_journal:\n \tif (test_opt(sb, NOBH)) {\n \t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n \t\t\text4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"\n \t\t\t\t\"its supported only with writeback mode\");\n \t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n \t\t}\n \t}\n \tEXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");\n \tif (!EXT4_SB(sb)->dio_unwritten_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tiput(root);\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\tif (test_opt(sb, DELALLOC) &&\n\t    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring delalloc option - \"\n \t\t\t \"requested data journaling mode\");\n \t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n \t}\n \n \terr = ext4_setup_system_zone(sb);\n \tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\\n\", err);\n\t\tgoto failed_mount4;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initalize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount4;\n\t}\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err) {\n\t\text4_mb_release(sb);\n\t\text4_ext_release(sb);\n\t\tgoto failed_mount4;\n\t};\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s\", descr);\n\n\tlock_kernel();\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tdestroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);\nfailed_mount_wq:\n\text4_release_system_zone(sb);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tif (sbi->s_flex_groups) {\n\t\tif (is_vmalloc_addr(sbi->s_flex_groups))\n\t\t\tvfree(sbi->s_flex_groups);\n\t\telse\n\t\t\tkfree(sbi->s_flex_groups);\n\t}\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\tlock_kernel();\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
        "vul_func_with_fix": "\t\t\t\t__releases(kernel_lock)\n\t\t\t\t__acquires(kernel_lock)\n{\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -EINVAL;\n\tint blocksize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\treturn -ENOMEM;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tsbi->s_sectors_written_start = part_stat_read(sb->s_bdev->bd_part,\n\t\t\t\t\t\t      sectors[1]);\n\n\tunlock_kernel();\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS) {\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, \"bsdgroups\",\n\t\t\t\"2.6.38\");\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\t}\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (def_mount_opts & EXT4_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (def_mount_opts & EXT4_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tset_opt(sbi->s_mount_opt, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tset_opt(sbi->s_mount_opt, DELALLOC);\n\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#blocks per group too big: %lu\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\tif ((ext4_blocks_count(es) >\n\t     (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) ||\n\t    (ext4_blocks_count(es) >\n\t     (pgoff_t)(~0ULL) >> (PAGE_CACHE_SHIFT - sb->s_blocksize_bits))) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tret = -EFBIG;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n                ext4_msg(sb, KERN_WARNING, \"bad geometry: first data\"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n#endif\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_max_writeback_mb_bump = 128;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\tsb->s_op = &ext4_sops;\n\telse\n\t\tsb->s_op = &ext4_nojournal_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n \t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n \t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n \t\t       \"suppressed and not mounted read-only\");\n//flaw_line_below:\n\t\tgoto failed_mount4;\n//fix_flaw_line_below:\n//\t\tgoto failed_mount_wq;\n \t} else {\n \t\tclear_opt(sbi->s_mount_opt, DATA_FLAGS);\n \t\tset_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n \t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n \t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n \t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n//flaw_line_below:\n\t\tgoto failed_mount4;\n//fix_flaw_line_below:\n//\t\tgoto failed_mount_wq;\n \t}\n \n \tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sbi->s_mount_opt, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sbi->s_mount_opt, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n \t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n \t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n \t\t\t       \"requested data journaling mode\");\n//flaw_line_below:\n\t\t\tgoto failed_mount4;\n//fix_flaw_line_below:\n//\t\t\tgoto failed_mount_wq;\n \t\t}\n \tdefault:\n \t\tbreak;\n \t}\n \tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n \n no_journal:\n//flaw_line_below:\n\n \tif (test_opt(sb, NOBH)) {\n \t\tif (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {\n \t\t\text4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"\n \t\t\t\t\"its supported only with writeback mode\");\n \t\t\tclear_opt(sbi->s_mount_opt, NOBH);\n \t\t}\n//fix_flaw_line_below:\n//\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n//fix_flaw_line_below:\n//\t\t\text4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"\n//fix_flaw_line_below:\n//\t\t\t\t\"not supported with nobh mode\");\n//fix_flaw_line_below:\n//\t\t\tgoto failed_mount_wq;\n//fix_flaw_line_below:\n//\t\t}\n \t}\n \tEXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");\n \tif (!EXT4_SB(sb)->dio_unwritten_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tiput(root);\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\tif (test_opt(sb, DELALLOC) &&\n\t    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring delalloc option - \"\n \t\t\t \"requested data journaling mode\");\n \t\tclear_opt(sbi->s_mount_opt, DELALLOC);\n \t}\n//fix_flaw_line_below:\n//\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n//fix_flaw_line_below:\n//\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n//fix_flaw_line_below:\n//\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n//fix_flaw_line_below:\n//\t\t\t\t\"option - requested data journaling mode\");\n//fix_flaw_line_below:\n//\t\t\tclear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tif (sb->s_blocksize < PAGE_SIZE) {\n//fix_flaw_line_below:\n//\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n//fix_flaw_line_below:\n//\t\t\t\t\"option - block size is too small\");\n//fix_flaw_line_below:\n//\t\t\tclear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t}\n \n \terr = ext4_setup_system_zone(sb);\n \tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\\n\", err);\n\t\tgoto failed_mount4;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initalize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount4;\n\t}\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err) {\n\t\text4_mb_release(sb);\n\t\text4_ext_release(sb);\n\t\tgoto failed_mount4;\n\t};\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s\", descr);\n\n\tlock_kernel();\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tdestroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);\nfailed_mount_wq:\n\text4_release_system_zone(sb);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tif (sbi->s_flex_groups) {\n\t\tif (is_vmalloc_addr(sbi->s_flex_groups))\n\t\t\tvfree(sbi->s_flex_groups);\n\t\telse\n\t\t\tkfree(sbi->s_flex_groups);\n\t}\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n\tlock_kernel();\n\treturn ret;\n}\n",
        "linevul": 0.000951988622546196,
        "sysevr": 0.5246708989143372,
        "devign": 0.6273706555366516
    },
    {
        "code": "static void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\n{\n\tn_tty_receive_char_inline(tty, c);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4291086b1f081b869c6d79e5b7441633dc3ace00",
        "vul_func_with_fix": "static void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\n{\n\tn_tty_receive_char_inline(tty, c);\n}\n",
        "linevul": 5.5077034630812705e-05,
        "sysevr": 0.12353134155273438,
        "devign": 1.2859263653908215e-09
    },
    {
        "code": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n \t\t\tresult = kctl->put(kctl, control);\n \t\t}\n \t\tif (result > 0) {\n \t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n \t\t\treturn 0;\n \t\t}\n \t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "vul_func_with_fix": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n \t\t\tresult = kctl->put(kctl, control);\n \t\t}\n \t\tif (result > 0) {\n//fix_flaw_line_below:\n//\t\t\tstruct snd_ctl_elem_id id = control->id;\n \t\t\tup_read(&card->controls_rwsem);\n//flaw_line_below:\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n//flaw_line_below:\n\t\t\t\t       &control->id);\n//fix_flaw_line_below:\n//\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);\n \t\t\treturn 0;\n \t\t}\n \t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n",
        "linevul": 0.00028332986403256655,
        "sysevr": 0.1373966932296753,
        "devign": 6.555218899715323e-28
    },
    {
        "code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\n\tunix_remove_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\n\twake_up_interruptible_all(&u->peer_wait);\n\n\tskpair = unix_peer(sk);\n\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n \t\t\tskpair->sk_state_change(skpair);\n \t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n \t\t}\n \t\tsock_put(skpair); /* It may now die */\n \t\tunix_peer(sk) = NULL;\n \t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock->err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c",
        "vul_func_with_fix": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\n\tunix_remove_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\n\twake_up_interruptible_all(&u->peer_wait);\n\n\tskpair = unix_peer(sk);\n\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n \t\t\tskpair->sk_state_change(skpair);\n \t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n \t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n \t\tsock_put(skpair); /* It may now die */\n \t\tunix_peer(sk) = NULL;\n \t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock->err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}\n",
        "linevul": 0.00014366136747412384,
        "sysevr": 0.18062104284763336,
        "devign": 0.0
    },
    {
        "code": "static void armv7pmu_start(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pmu_lock, flags);\n\t/* Enable all counters */\n\tarmv7_pmnc_write(armv7_pmnc_read() | ARMV7_PMNC_E);\n\traw_spin_unlock_irqrestore(&pmu_lock, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void armv7pmu_start(void)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pmu_lock, flags);\n\t/* Enable all counters */\n\tarmv7_pmnc_write(armv7_pmnc_read() | ARMV7_PMNC_E);\n\traw_spin_unlock_irqrestore(&pmu_lock, flags);\n}\n",
        "linevul": 5.0227143219672143e-05,
        "sysevr": 0.1267952024936676,
        "devign": 1.1618561147896944e-11
    },
    {
        "code": "SMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18f39e7be0121317550d03e267e3ebd4dbfbb3ce",
        "vul_func_with_fix": "SMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}\n",
        "linevul": 4.7511435695923865e-05,
        "sysevr": 0.16990189254283905,
        "devign": 4.599151892659137e-10
    },
    {
        "code": "static void __usb_queue_reset_device(struct work_struct *ws)\n{\n\tint rc;\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, reset_ws);\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\n\trc = usb_lock_device_for_reset(udev, iface);\n\tif (rc >= 0) {\n\t\tusb_reset_device(udev);\n\t\tusb_unlock_device(udev);\n\t}\n\tusb_put_intf(iface);\t/* Undo _get_ in usb_queue_reset_device() */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2e1c42391ff2556387b3cb6308b24f6f65619feb",
        "vul_func_with_fix": "static void __usb_queue_reset_device(struct work_struct *ws)\n{\n\tint rc;\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, reset_ws);\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\n\trc = usb_lock_device_for_reset(udev, iface);\n\tif (rc >= 0) {\n\t\tusb_reset_device(udev);\n\t\tusb_unlock_device(udev);\n\t}\n\tusb_put_intf(iface);\t/* Undo _get_ in usb_queue_reset_device() */\n}\n",
        "linevul": 7.713536615483463e-05,
        "sysevr": 0.12508821487426758,
        "devign": 2.2618553430220345e-06
    },
    {
        "code": "static inline int x86_pmu_addr_offset(int index)\n{\n\tint offset;\n\n\t/* offset = X86_FEATURE_PERFCTR_CORE ? index << 1 : index */\n\talternative_io(ASM_NOP2,\n\t\t       \"shll $1, %%eax\",\n\t\t       X86_FEATURE_PERFCTR_CORE,\n\t\t       \"=a\" (offset),\n\t\t       \"a\"  (index));\n\n\treturn offset;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline int x86_pmu_addr_offset(int index)\n{\n\tint offset;\n\n\t/* offset = X86_FEATURE_PERFCTR_CORE ? index << 1 : index */\n\talternative_io(ASM_NOP2,\n\t\t       \"shll $1, %%eax\",\n\t\t       X86_FEATURE_PERFCTR_CORE,\n\t\t       \"=a\" (offset),\n\t\t       \"a\"  (index));\n\n\treturn offset;\n}\n",
        "linevul": 4.8654696001904085e-05,
        "sysevr": 0.1268453747034073,
        "devign": 2.0935571498625904e-08
    },
    {
        "code": "nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_setclientid *setclid)\n{\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf && client_has_state(conf)) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\t\trpc_ntop((struct sockaddr *) &conf->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\t\tdprintk(\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\", addr_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier)) {\n\t\t/* case 1: probable callback update */\n\t\tcopy_clid(new, conf);\n\t\tgen_confirm(new, nn);\n\t} else /* case 4 (new client) or cases 2, 3 (client reboot): */\n\t\tgen_clid(new, nn);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_setclientid *setclid)\n{\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf && client_has_state(conf)) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\t\trpc_ntop((struct sockaddr *) &conf->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\t\tdprintk(\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\", addr_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier)) {\n\t\t/* case 1: probable callback update */\n\t\tcopy_clid(new, conf);\n\t\tgen_confirm(new, nn);\n\t} else /* case 4 (new client) or cases 2, 3 (client reboot): */\n\t\tgen_clid(new, nn);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}\n",
        "linevul": 0.00021626918169204146,
        "sysevr": 0.20473302900791168,
        "devign": 1.3687984598819264e-17
    },
    {
        "code": "static int filename_lookup(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tint retval = path_lookupat(dfd, name->name, flags | LOOKUP_RCU, nd);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(dfd, name->name, flags, nd);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(dfd, name->name,\n\t\t\t\t\t\tflags | LOOKUP_REVAL, nd);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "static int filename_lookup(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tint retval = path_lookupat(dfd, name->name, flags | LOOKUP_RCU, nd);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(dfd, name->name, flags, nd);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(dfd, name->name,\n\t\t\t\t\t\tflags | LOOKUP_REVAL, nd);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, nd->path.dentry, flags & LOOKUP_PARENT);\n\treturn retval;\n}\n",
        "linevul": 7.584543345728889e-05,
        "sysevr": 0.14253009855747223,
        "devign": 6.134705373903038e-13
    },
    {
        "code": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}\n",
        "linevul": 6.710830348310992e-05,
        "sysevr": 0.12512829899787903,
        "devign": 7.2322291089221835e-06
    },
    {
        "code": "inet_csk_find_open_port(struct sock *sk, struct inet_bind_bucket **tb_ret, int *port_ret)\n{\n\tstruct inet_hashinfo *hinfo = sk->sk_prot->h.hashinfo;\n\tint port = 0;\n\tstruct inet_bind_hashbucket *head;\n\tstruct net *net = sock_net(sk);\n\tint i, low, high, attempt_half;\n\tstruct inet_bind_bucket *tb;\n\tu32 remaining, offset;\n\n\tattempt_half = (sk->sk_reuse == SK_CAN_REUSE) ? 1 : 0;\nother_half_scan:\n\tinet_get_local_port_range(net, &low, &high);\n\thigh++; /* [32768, 60999] -> [32768, 61000[ */\n\tif (high - low < 4)\n\t\tattempt_half = 0;\n\tif (attempt_half) {\n\t\tint half = low + (((high - low) >> 2) << 1);\n\n\t\tif (attempt_half == 1)\n\t\t\thigh = half;\n\t\telse\n\t\t\tlow = half;\n\t}\n\tremaining = high - low;\n\tif (likely(remaining > 1))\n\t\tremaining &= ~1U;\n\n\toffset = prandom_u32() % remaining;\n\t/* __inet_hash_connect() favors ports having @low parity\n\t * We do the opposite to not pollute connect() users.\n\t */\n\toffset |= 1U;\n\nother_parity_scan:\n\tport = low + offset;\n\tfor (i = 0; i < remaining; i += 2, port += 2) {\n\t\tif (unlikely(port >= high))\n\t\t\tport -= remaining;\n\t\tif (inet_is_local_reserved_port(net, port))\n\t\t\tcontinue;\n\t\thead = &hinfo->bhash[inet_bhashfn(net, port,\n\t\t\t\t\t\t  hinfo->bhash_size)];\n\t\tspin_lock_bh(&head->lock);\n\t\tinet_bind_bucket_for_each(tb, &head->chain)\n\t\t\tif (net_eq(ib_net(tb), net) && tb->port == port) {\n\t\t\t\tif (!inet_csk_bind_conflict(sk, tb, false, false))\n\t\t\t\t\tgoto success;\n\t\t\t\tgoto next_port;\n\t\t\t}\n\t\ttb = NULL;\n\t\tgoto success;\nnext_port:\n\t\tspin_unlock_bh(&head->lock);\n\t\tcond_resched();\n\t}\n\n\toffset--;\n\tif (!(offset & 1))\n\t\tgoto other_parity_scan;\n\n\tif (attempt_half == 1) {\n\t\t/* OK we now try the upper half of the range */\n\t\tattempt_half = 2;\n\t\tgoto other_half_scan;\n\t}\n\treturn NULL;\nsuccess:\n\t*port_ret = port;\n\t*tb_ret = tb;\n\treturn head;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a",
        "vul_func_with_fix": "inet_csk_find_open_port(struct sock *sk, struct inet_bind_bucket **tb_ret, int *port_ret)\n{\n\tstruct inet_hashinfo *hinfo = sk->sk_prot->h.hashinfo;\n\tint port = 0;\n\tstruct inet_bind_hashbucket *head;\n\tstruct net *net = sock_net(sk);\n\tint i, low, high, attempt_half;\n\tstruct inet_bind_bucket *tb;\n\tu32 remaining, offset;\n\n\tattempt_half = (sk->sk_reuse == SK_CAN_REUSE) ? 1 : 0;\nother_half_scan:\n\tinet_get_local_port_range(net, &low, &high);\n\thigh++; /* [32768, 60999] -> [32768, 61000[ */\n\tif (high - low < 4)\n\t\tattempt_half = 0;\n\tif (attempt_half) {\n\t\tint half = low + (((high - low) >> 2) << 1);\n\n\t\tif (attempt_half == 1)\n\t\t\thigh = half;\n\t\telse\n\t\t\tlow = half;\n\t}\n\tremaining = high - low;\n\tif (likely(remaining > 1))\n\t\tremaining &= ~1U;\n\n\toffset = prandom_u32() % remaining;\n\t/* __inet_hash_connect() favors ports having @low parity\n\t * We do the opposite to not pollute connect() users.\n\t */\n\toffset |= 1U;\n\nother_parity_scan:\n\tport = low + offset;\n\tfor (i = 0; i < remaining; i += 2, port += 2) {\n\t\tif (unlikely(port >= high))\n\t\t\tport -= remaining;\n\t\tif (inet_is_local_reserved_port(net, port))\n\t\t\tcontinue;\n\t\thead = &hinfo->bhash[inet_bhashfn(net, port,\n\t\t\t\t\t\t  hinfo->bhash_size)];\n\t\tspin_lock_bh(&head->lock);\n\t\tinet_bind_bucket_for_each(tb, &head->chain)\n\t\t\tif (net_eq(ib_net(tb), net) && tb->port == port) {\n\t\t\t\tif (!inet_csk_bind_conflict(sk, tb, false, false))\n\t\t\t\t\tgoto success;\n\t\t\t\tgoto next_port;\n\t\t\t}\n\t\ttb = NULL;\n\t\tgoto success;\nnext_port:\n\t\tspin_unlock_bh(&head->lock);\n\t\tcond_resched();\n\t}\n\n\toffset--;\n\tif (!(offset & 1))\n\t\tgoto other_parity_scan;\n\n\tif (attempt_half == 1) {\n\t\t/* OK we now try the upper half of the range */\n\t\tattempt_half = 2;\n\t\tgoto other_half_scan;\n\t}\n\treturn NULL;\nsuccess:\n\t*port_ret = port;\n\t*tb_ret = tb;\n\treturn head;\n}\n",
        "linevul": 0.00010954598110402003,
        "sysevr": 0.193495973944664,
        "devign": 7.96212818985526e-36
    },
    {
        "code": "static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n\tif (addr_len)\n\t\t*addr_len=sizeof(*sin6);\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tif (skb_csum_unnecessary(skb)) {\n\t\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\t} else if (msg->msg_flags&MSG_TRUNC) {\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb, 0, msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Copy the address. */\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n \t\tsin6->sin6_flowinfo = 0;\n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n \t}\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tskb_kill_datagram(sk, skb, flags);\n\n\t/* Error for blocking case is chosen to masquerade\n\t   as some normal condition.\n\t */\n\terr = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;\n\tgoto out;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69",
        "vul_func_with_fix": "static int rawv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n//flaw_line_below:\n\tif (addr_len)\n//flaw_line_below:\n\t\t*addr_len=sizeof(*sin6);\n//flaw_line_below:\n\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ipv6_recv_error(sk, msg, len);\n \n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tif (skb_csum_unnecessary(skb)) {\n\t\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\t} else if (msg->msg_flags&MSG_TRUNC) {\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb, 0, msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Copy the address. */\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n \t\tsin6->sin6_flowinfo = 0;\n \t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n \t\t\t\t\t\t\t  IP6CB(skb)->iif);\n//fix_flaw_line_below:\n//\t\t*addr_len = sizeof(*sin6);\n \t}\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tskb_kill_datagram(sk, skb, flags);\n\n\t/* Error for blocking case is chosen to masquerade\n\t   as some normal condition.\n\t */\n\terr = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;\n\tgoto out;\n}\n",
        "linevul": 0.9993452429771423,
        "sysevr": 0.19325615465641022,
        "devign": 7.344966575305103e-29
    },
    {
        "code": "struct sock *inet_csk_complete_hashdance(struct sock *sk, struct sock *child,\n\t\t\t\t\t struct request_sock *req, bool own_req)\n{\n\tif (own_req) {\n\t\tinet_csk_reqsk_queue_drop(sk, req);\n\t\treqsk_queue_removed(&inet_csk(sk)->icsk_accept_queue, req);\n\t\tif (inet_csk_reqsk_queue_add(sk, req, child))\n\t\t\treturn child;\n\t}\n\t/* Too bad, another child took ownership of the request, undo. */\n\tbh_unlock_sock(child);\n\tsock_put(child);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a",
        "vul_func_with_fix": "struct sock *inet_csk_complete_hashdance(struct sock *sk, struct sock *child,\n\t\t\t\t\t struct request_sock *req, bool own_req)\n{\n\tif (own_req) {\n\t\tinet_csk_reqsk_queue_drop(sk, req);\n\t\treqsk_queue_removed(&inet_csk(sk)->icsk_accept_queue, req);\n\t\tif (inet_csk_reqsk_queue_add(sk, req, child))\n\t\t\treturn child;\n\t}\n\t/* Too bad, another child took ownership of the request, undo. */\n\tbh_unlock_sock(child);\n\tsock_put(child);\n\treturn NULL;\n}\n",
        "linevul": 5.069042890681885e-05,
        "sysevr": 0.14682139456272125,
        "devign": 4.295269516582309e-14
    },
    {
        "code": "static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n \t\tret = -EINVAL;\n \t\tif (!vma_can_userfault(cur))\n \t\t\tgoto out_unlock;\n \t\t/*\n \t\t * If this vma contains ending address, and huge pages\n \t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n \t\tBUG_ON(!vma_can_userfault(vma));\n \t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n \t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n \n \t\t/*\n \t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1",
        "vul_func_with_fix": "static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tbool basic_ioctls;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tbasic_ioctls = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n \t\tret = -EINVAL;\n \t\tif (!vma_can_userfault(cur))\n \t\t\tgoto out_unlock;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/*\n//fix_flaw_line_below:\n//\t\t * UFFDIO_COPY will fill file holes even without\n//fix_flaw_line_below:\n//\t\t * PROT_WRITE. This check enforces that if this is a\n//fix_flaw_line_below:\n//\t\t * MAP_SHARED, the process has write permission to the backing\n//fix_flaw_line_below:\n//\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n//fix_flaw_line_below:\n//\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n//fix_flaw_line_below:\n//\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n//fix_flaw_line_below:\n//\t\t */\n//fix_flaw_line_below:\n//\t\tret = -EPERM;\n//fix_flaw_line_below:\n//\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n//fix_flaw_line_below:\n//\t\t\tgoto out_unlock;\n//fix_flaw_line_below:\n//\n \t\t/*\n \t\t * If this vma contains ending address, and huge pages\n \t\t * check alignment.\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur) && end <= cur->vm_end &&\n\t\t    end > cur->vm_start) {\n\t\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(cur);\n\n\t\t\tret = -EINVAL;\n\n\t\t\tif (end & (vma_hpagesize - 1))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Note vmas containing huge pages\n\t\t */\n\t\tif (is_vm_hugetlb_page(cur))\n\t\t\tbasic_ioctls = true;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n \t\tBUG_ON(!vma_can_userfault(vma));\n \t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n \t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n//fix_flaw_line_below:\n//\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n \n \t\t/*\n \t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC :\n\t\t\t     UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}\n",
        "linevul": 0.888713538646698,
        "sysevr": 0.22134144604206085,
        "devign": 0.9999974966049194
    },
    {
        "code": "static long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tif (key->type_data.x[0])\n\t\treturn key->type_data.x[0];\n\n\treturn user_read(key, buffer, buflen);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tif (key->type_data.x[0])\n\t\treturn key->type_data.x[0];\n\n\treturn user_read(key, buffer, buflen);\n}\n",
        "linevul": 0.0003566869127098471,
        "sysevr": 0.1399042010307312,
        "devign": 0.3170989155769348
    },
    {
        "code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n \tstruct scsi_device *SDev;\n \tstruct scsi_sense_hdr sshdr;\n \tint result, err = 0, retries = 0;\n \n \tSDev = cd->device;\n \n       retry:\n \tif (!scsi_block_when_processing_errors(SDev)) {\n \t\terr = -ENODEV;\n \t\tgoto out;\n \t}\n \n \tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n \t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n \n \t/* Minimal error checking.  Ignore cases we know about, and report the rest. */\n \tif (driver_byte(result) != 0) {\n \t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t/* This happens if there is no disc in drive */\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\t/* sense: Logical unit is in process of becoming ready */\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\t/* sleep 2 sec and try again */\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\t/* 20 secs are enough? */\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\t/* sense: Invalid command operation code */\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\t/* Wake up a process waiting for device */\n      out:\n\tcgc->stat = err;\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe",
        "vul_func_with_fix": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n \tstruct scsi_device *SDev;\n \tstruct scsi_sense_hdr sshdr;\n \tint result, err = 0, retries = 0;\n//fix_flaw_line_below:\n//\tunsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;\n \n \tSDev = cd->device;\n \n//fix_flaw_line_below:\n//\tif (cgc->sense)\n//fix_flaw_line_below:\n//\t\tsenseptr = sense_buffer;\n//fix_flaw_line_below:\n//\n       retry:\n \tif (!scsi_block_when_processing_errors(SDev)) {\n \t\terr = -ENODEV;\n \t\tgoto out;\n \t}\n \n \tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n//flaw_line_below:\n\t\t\t      cgc->buffer, cgc->buflen,\n//flaw_line_below:\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n//fix_flaw_line_below:\n//\t\t\t      cgc->buffer, cgc->buflen, senseptr, &sshdr,\n \t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n \n//fix_flaw_line_below:\n//\tif (cgc->sense)\n//fix_flaw_line_below:\n//\t\tmemcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));\n//fix_flaw_line_below:\n//\n \t/* Minimal error checking.  Ignore cases we know about, and report the rest. */\n \tif (driver_byte(result) != 0) {\n \t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t/* This happens if there is no disc in drive */\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\t/* sense: Logical unit is in process of becoming ready */\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\t/* sleep 2 sec and try again */\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\t/* 20 secs are enough? */\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\t/* sense: Invalid command operation code */\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\n\t/* Wake up a process waiting for device */\n      out:\n\tcgc->stat = err;\n\treturn err;\n}\n",
        "linevul": 0.9991394281387329,
        "sysevr": 0.18377412855625153,
        "devign": 0.9999501705169678
    },
    {
        "code": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n \n \tBT_DBG(\"\");\n \n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n \n\t/* session struct allocated as private part of net_device */\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdown_write(&bnep_session_sem);\n\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\ts = netdev_priv(dev);\n\n\t/* This is rx header therefore addresses are swapped.\n\t * ie. eh.h_dest is our local address. */\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\t/* Set default mc filter */\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\t/* Set default protocol filter */\n\tbnep_set_default_proto_filter(s);\n#endif\n\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\n\t__bnep_link_session(s);\n\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\t/* Session thread start failed, gotta cleanup. */\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\n\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/71bb99a02b32b4cc4265118e85f6035ca72923f0",
        "vul_func_with_fix": "int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n{\n\tstruct net_device *dev;\n\tstruct bnep_session *s, *ss;\n\tu8 dst[ETH_ALEN], src[ETH_ALEN];\n\tint err;\n \n \tBT_DBG(\"\");\n \n//fix_flaw_line_below:\n//\tif (!l2cap_is_socket(sock))\n//fix_flaw_line_below:\n//\t\treturn -EBADFD;\n//fix_flaw_line_below:\n//\n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n \n\t/* session struct allocated as private part of net_device */\n\tdev = alloc_netdev(sizeof(struct bnep_session),\n\t\t\t   (*req->device) ? req->device : \"bnep%d\",\n\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t   bnep_net_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdown_write(&bnep_session_sem);\n\n\tss = __bnep_get_session(dst);\n\tif (ss && ss->state == BT_CONNECTED) {\n\t\terr = -EEXIST;\n\t\tgoto failed;\n\t}\n\n\ts = netdev_priv(dev);\n\n\t/* This is rx header therefore addresses are swapped.\n\t * ie. eh.h_dest is our local address. */\n\tmemcpy(s->eh.h_dest,   &src, ETH_ALEN);\n\tmemcpy(s->eh.h_source, &dst, ETH_ALEN);\n\tmemcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);\n\n\ts->dev   = dev;\n\ts->sock  = sock;\n\ts->role  = req->role;\n\ts->state = BT_CONNECTED;\n\n\ts->msg.msg_flags = MSG_NOSIGNAL;\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\t/* Set default mc filter */\n\tset_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\t/* Set default protocol filter */\n\tbnep_set_default_proto_filter(s);\n#endif\n\n\tSET_NETDEV_DEV(dev, bnep_get_device(s));\n\tSET_NETDEV_DEVTYPE(dev, &bnep_type);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto failed;\n\n\t__bnep_link_session(s);\n\n\t__module_get(THIS_MODULE);\n\ts->task = kthread_run(bnep_session, s, \"kbnepd %s\", dev->name);\n\tif (IS_ERR(s->task)) {\n\t\t/* Session thread start failed, gotta cleanup. */\n\t\tmodule_put(THIS_MODULE);\n\t\tunregister_netdev(dev);\n\t\t__bnep_unlink_session(s);\n\t\terr = PTR_ERR(s->task);\n\t\tgoto failed;\n\t}\n\n\tup_write(&bnep_session_sem);\n\tstrcpy(req->device, dev->name);\n\treturn 0;\n\nfailed:\n\tup_write(&bnep_session_sem);\n\tfree_netdev(dev);\n\treturn err;\n}\n",
        "linevul": 0.9996522665023804,
        "sysevr": 0.17986880242824554,
        "devign": 0.9997438788414001
    },
    {
        "code": "static void migrate_nr_uninterruptible(struct rq *rq_src)\n{\n\tstruct rq *rq_dest = cpu_rq(cpumask_any(cpu_active_mask));\n\n\trq_dest->nr_uninterruptible += rq_src->nr_uninterruptible;\n\trq_src->nr_uninterruptible = 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void migrate_nr_uninterruptible(struct rq *rq_src)\n{\n\tstruct rq *rq_dest = cpu_rq(cpumask_any(cpu_active_mask));\n\n\trq_dest->nr_uninterruptible += rq_src->nr_uninterruptible;\n\trq_src->nr_uninterruptible = 0;\n}\n",
        "linevul": 5.543492443393916e-05,
        "sysevr": 0.12428902089595795,
        "devign": 2.2800726640070934e-07
    },
    {
        "code": "static int debugfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\tdebugfs_apply_options(sb);\n\nfail:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
        "vul_func_with_fix": "static int debugfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\tdebugfs_apply_options(sb);\n\nfail:\n\treturn err;\n}\n",
        "linevul": 0.00014434338663704693,
        "sysevr": 0.12701690196990967,
        "devign": 1.8231649368541692e-31
    },
    {
        "code": " queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704",
        "vul_func_with_fix": " queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n//flaw_line_below:\n\tdrop_futex_key_refs(&q->key);\n }\n",
        "linevul": 0.9925876259803772,
        "sysevr": 0.1571546494960785,
        "devign": 0.9963562488555908
    },
    {
        "code": "SYSCALL_DEFINE0(munlockall)\n{\n\tint ret;\n\n\tdown_write(&current->mm->mmap_sem);\n\tret = do_mlockall(0);\n\tup_write(&current->mm->mmap_sem);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c",
        "vul_func_with_fix": "SYSCALL_DEFINE0(munlockall)\n{\n\tint ret;\n\n\tdown_write(&current->mm->mmap_sem);\n\tret = do_mlockall(0);\n\tup_write(&current->mm->mmap_sem);\n\treturn ret;\n}\n",
        "linevul": 5.159638385521248e-05,
        "sysevr": 0.15415561199188232,
        "devign": 7.75786546114432e-09
    },
    {
        "code": "static int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)\n{\n\tregister struct sock *sk;\n\tstruct hlist_node *node;\n\tint lm = 0;\n\n\tif (type != SCO_LINK && type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"hdev %s, bdaddr %s\", hdev->name, batostr(bdaddr));\n\n\t/* Find listening sockets */\n\tread_lock(&sco_sk_list.lock);\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||\n\t\t\t\t!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\n\t\t\tlm |= HCI_LM_ACCEPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn lm;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86",
        "vul_func_with_fix": "static int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)\n{\n\tregister struct sock *sk;\n\tstruct hlist_node *node;\n\tint lm = 0;\n\n\tif (type != SCO_LINK && type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"hdev %s, bdaddr %s\", hdev->name, batostr(bdaddr));\n\n\t/* Find listening sockets */\n\tread_lock(&sco_sk_list.lock);\n\tsk_for_each(sk, node, &sco_sk_list.head) {\n\t\tif (sk->sk_state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||\n\t\t\t\t!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {\n\t\t\tlm |= HCI_LM_ACCEPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sco_sk_list.lock);\n\n\treturn lm;\n}\n",
        "linevul": 5.501865962287411e-05,
        "sysevr": 0.12180490046739578,
        "devign": 7.642624123079152e-15
    },
    {
        "code": "alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node, bool hugepage)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zl;\n\tnodemask_t *nmask;\n\nretry_cpuset:\n\tpol = get_vma_policy(vma, addr);\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) && hugepage)) {\n\t\tint hpage_node = node;\n\n\t\t/*\n\t\t * For hugepage allocation and non-interleave policy which\n\t\t * allows the current node (or other explicitly preferred\n\t\t * node) we only try to allocate from the current/preferred\n\t\t * node and don't fall back to other nodes, as the cost of\n\t\t * remote accesses would likely offset THP benefits.\n\t\t *\n\t\t * If the policy is interleave, or does not allow the current\n\t\t * node in its nodemask, we allocate the standard way.\n\t\t */\n\t\tif (pol->mode == MPOL_PREFERRED &&\n\t\t\t\t\t\t!(pol->flags & MPOL_F_LOCAL))\n\t\t\thpage_node = pol->v.preferred_node;\n\n\t\tnmask = policy_nodemask(gfp, pol);\n\t\tif (!nmask || node_isset(hpage_node, *nmask)) {\n\t\t\tmpol_cond_put(pol);\n\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\t\t\tgfp | __GFP_THISNODE, order);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tzl = policy_zonelist(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, zl, nmask);\n\tmpol_cond_put(pol);\nout:\n\tif (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn page;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cf01fb9985e8deb25ccf0ea54d916b8871ae0e62",
        "vul_func_with_fix": "alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node, bool hugepage)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tunsigned int cpuset_mems_cookie;\n\tstruct zonelist *zl;\n\tnodemask_t *nmask;\n\nretry_cpuset:\n\tpol = get_vma_policy(vma, addr);\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) && hugepage)) {\n\t\tint hpage_node = node;\n\n\t\t/*\n\t\t * For hugepage allocation and non-interleave policy which\n\t\t * allows the current node (or other explicitly preferred\n\t\t * node) we only try to allocate from the current/preferred\n\t\t * node and don't fall back to other nodes, as the cost of\n\t\t * remote accesses would likely offset THP benefits.\n\t\t *\n\t\t * If the policy is interleave, or does not allow the current\n\t\t * node in its nodemask, we allocate the standard way.\n\t\t */\n\t\tif (pol->mode == MPOL_PREFERRED &&\n\t\t\t\t\t\t!(pol->flags & MPOL_F_LOCAL))\n\t\t\thpage_node = pol->v.preferred_node;\n\n\t\tnmask = policy_nodemask(gfp, pol);\n\t\tif (!nmask || node_isset(hpage_node, *nmask)) {\n\t\t\tmpol_cond_put(pol);\n\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\t\t\tgfp | __GFP_THISNODE, order);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tzl = policy_zonelist(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, zl, nmask);\n\tmpol_cond_put(pol);\nout:\n\tif (unlikely(!page && read_mems_allowed_retry(cpuset_mems_cookie)))\n\t\tgoto retry_cpuset;\n\treturn page;\n}\n",
        "linevul": 0.0008980878628790379,
        "sysevr": 0.20764604210853577,
        "devign": 1.4529215500457307e-24
    },
    {
        "code": "static int crypto_ctr_crypt_inplace(struct blkcipher_walk *walk,\n\t\t\t\t    struct crypto_cipher *tfm)\n{\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\n\t\t   crypto_cipher_alg(tfm)->cia_encrypt;\n\tunsigned int bsize = crypto_cipher_blocksize(tfm);\n\tunsigned long alignmask = crypto_cipher_alignmask(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *ctrblk = walk->iv;\n\tu8 *src = walk->src.virt.addr;\n\tu8 tmp[bsize + alignmask];\n\tu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\n\n\tdo {\n\t\t/* create keystream */\n\t\tfn(crypto_cipher_tfm(tfm), keystream, ctrblk);\n\t\tcrypto_xor(src, keystream, bsize);\n\n\t\t/* increment counter in counterblock */\n\t\tcrypto_inc(ctrblk, bsize);\n\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "static int crypto_ctr_crypt_inplace(struct blkcipher_walk *walk,\n\t\t\t\t    struct crypto_cipher *tfm)\n{\n\tvoid (*fn)(struct crypto_tfm *, u8 *, const u8 *) =\n\t\t   crypto_cipher_alg(tfm)->cia_encrypt;\n\tunsigned int bsize = crypto_cipher_blocksize(tfm);\n\tunsigned long alignmask = crypto_cipher_alignmask(tfm);\n\tunsigned int nbytes = walk->nbytes;\n\tu8 *ctrblk = walk->iv;\n\tu8 *src = walk->src.virt.addr;\n\tu8 tmp[bsize + alignmask];\n\tu8 *keystream = PTR_ALIGN(tmp + 0, alignmask + 1);\n\n\tdo {\n\t\t/* create keystream */\n\t\tfn(crypto_cipher_tfm(tfm), keystream, ctrblk);\n\t\tcrypto_xor(src, keystream, bsize);\n\n\t\t/* increment counter in counterblock */\n\t\tcrypto_inc(ctrblk, bsize);\n\n\t\tsrc += bsize;\n\t} while ((nbytes -= bsize) >= bsize);\n\n\treturn nbytes;\n}\n",
        "linevul": 7.218959945021197e-05,
        "sysevr": 0.15355484187602997,
        "devign": 0.0021710970904678106
    },
    {
        "code": "static int hci_uart_setup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct hci_rp_read_local_version *ver;\n\tstruct sk_buff *skb;\n\tunsigned int speed;\n\tint err;\n\n\t/* Init speed if any */\n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\thci_uart_set_baudrate(hu, speed);\n\n\t/* Operational speed if any */\n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (hu->proto->set_baudrate && speed) {\n\t\terr = hu->proto->set_baudrate(hu, speed);\n\t\tif (!err)\n\t\t\thci_uart_set_baudrate(hu, speed);\n\t}\n\n\tif (hu->proto->setup)\n\t\treturn hu->proto->setup(hu);\n\n\tif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\n\t\treturn 0;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tBT_ERR(\"%s: Reading local version information failed (%ld)\",\n\t\t       hdev->name, PTR_ERR(skb));\n\t\treturn 0;\n\t}\n\n\tif (skb->len != sizeof(*ver)) {\n\t\tBT_ERR(\"%s: Event length mismatch for version information\",\n\t\t       hdev->name);\n\t\tgoto done;\n\t}\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\n\tswitch (le16_to_cpu(ver->manufacturer)) {\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tcase 2:\n\t\thdev->set_bdaddr = btintel_set_bdaddr;\n\t\tbtintel_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tcase 15:\n\t\thdev->set_bdaddr = btbcm_set_bdaddr;\n\t\tbtbcm_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\tkfree_skb(skb);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a",
        "vul_func_with_fix": "static int hci_uart_setup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct hci_rp_read_local_version *ver;\n\tstruct sk_buff *skb;\n\tunsigned int speed;\n\tint err;\n\n\t/* Init speed if any */\n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\thci_uart_set_baudrate(hu, speed);\n\n\t/* Operational speed if any */\n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (hu->proto->set_baudrate && speed) {\n\t\terr = hu->proto->set_baudrate(hu, speed);\n\t\tif (!err)\n\t\t\thci_uart_set_baudrate(hu, speed);\n\t}\n\n\tif (hu->proto->setup)\n\t\treturn hu->proto->setup(hu);\n\n\tif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\n\t\treturn 0;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tBT_ERR(\"%s: Reading local version information failed (%ld)\",\n\t\t       hdev->name, PTR_ERR(skb));\n\t\treturn 0;\n\t}\n\n\tif (skb->len != sizeof(*ver)) {\n\t\tBT_ERR(\"%s: Event length mismatch for version information\",\n\t\t       hdev->name);\n\t\tgoto done;\n\t}\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\n\tswitch (le16_to_cpu(ver->manufacturer)) {\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tcase 2:\n\t\thdev->set_bdaddr = btintel_set_bdaddr;\n\t\tbtintel_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tcase 15:\n\t\thdev->set_bdaddr = btbcm_set_bdaddr;\n\t\tbtbcm_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\tkfree_skb(skb);\n\treturn 0;\n}\n",
        "linevul": 0.0002824080875143409,
        "sysevr": 0.139478400349617,
        "devign": 0.0
    },
    {
        "code": " static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f778a636713a435d3a922c60b1622a91136560c1",
        "vul_func_with_fix": " static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n {\n//fix_flaw_line_below:\n//\tmemset(p, 0, sizeof(*p));\n \tmemcpy(&p->id, &x->id, sizeof(p->id));\n \tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n \tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n",
        "linevul": 0.9994482398033142,
        "sysevr": 0.1481732279062271,
        "devign": 0.9991577863693237
    },
    {
        "code": "static int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fsinfo,\n\t};\n\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = fsinfo,\n\t};\n\n\treturn rpc_call_sync(server->client, &msg, 0);\n}\n",
        "linevul": 4.986500789527781e-05,
        "sysevr": 0.15976431965827942,
        "devign": 8.314455822611307e-16
    },
    {
        "code": "int fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = fuse_get_dev(file);\n\n\tif (fud) {\n\t\tstruct fuse_conn *fc = fud->fc;\n\t\tstruct fuse_pqueue *fpq = &fud->pq;\n\t\tLIST_HEAD(to_end);\n\t\tunsigned int i;\n\n\t\tspin_lock(&fpq->lock);\n\t\tWARN_ON(!list_empty(&fpq->io));\n\t\tfor (i = 0; i < FUSE_PQ_HASH_SIZE; i++)\n\t\t\tlist_splice_init(&fpq->processing[i], &to_end);\n\t\tspin_unlock(&fpq->lock);\n\n\t\tend_requests(fc, &to_end);\n\n\t\t/* Are we the last open device? */\n\t\tif (atomic_dec_and_test(&fc->dev_count)) {\n\t\t\tWARN_ON(fc->iq.fasync != NULL);\n\t\t\tfuse_abort_conn(fc);\n\t\t}\n\t\tfuse_dev_free(fud);\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "vul_func_with_fix": "int fuse_dev_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = fuse_get_dev(file);\n\n\tif (fud) {\n\t\tstruct fuse_conn *fc = fud->fc;\n\t\tstruct fuse_pqueue *fpq = &fud->pq;\n\t\tLIST_HEAD(to_end);\n\t\tunsigned int i;\n\n\t\tspin_lock(&fpq->lock);\n\t\tWARN_ON(!list_empty(&fpq->io));\n\t\tfor (i = 0; i < FUSE_PQ_HASH_SIZE; i++)\n\t\t\tlist_splice_init(&fpq->processing[i], &to_end);\n\t\tspin_unlock(&fpq->lock);\n\n\t\tend_requests(fc, &to_end);\n\n\t\t/* Are we the last open device? */\n\t\tif (atomic_dec_and_test(&fc->dev_count)) {\n\t\t\tWARN_ON(fc->iq.fasync != NULL);\n\t\t\tfuse_abort_conn(fc);\n\t\t}\n\t\tfuse_dev_free(fud);\n\t}\n\treturn 0;\n}\n",
        "linevul": 0.00011216734128538519,
        "sysevr": 0.16031785309314728,
        "devign": 3.083293895723239e-17
    },
    {
        "code": "static ssize_t slabs_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static ssize_t slabs_show(struct kmem_cache *s, char *buf)\n{\n\treturn show_slab_objects(s, buf, SO_ALL);\n}\n",
        "linevul": 5.364734533941373e-05,
        "sysevr": 0.12412267923355103,
        "devign": 2.0241921561137133e-07
    },
    {
        "code": "static void intr_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\t__u8 *d;\n\tint status = urb->status;\n\tint res;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\n\t\tdev_info(&urb->dev->dev, \"%s: intr status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (d[0] & TSR_ERRORS) {\n\t\tdev->netdev->stats.tx_errors++;\n\t\tif (d[INT_TSR] & (TSR_ECOL | TSR_JBR))\n\t\t\tdev->netdev->stats.tx_aborted_errors++;\n\t\tif (d[INT_TSR] & TSR_LCOL)\n\t\t\tdev->netdev->stats.tx_window_errors++;\n\t\tif (d[INT_TSR] & TSR_LOSS_CRS)\n\t\t\tdev->netdev->stats.tx_carrier_errors++;\n\t}\n\t/* Report link status changes to the network stack */\n\tif ((d[INT_MSR] & MSR_LINK) == 0) {\n\t\tif (netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_off(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK LOST\\n\", __func__);\n\t\t}\n\t} else {\n\t\tif (!netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_on(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK CAME BACK\\n\", __func__);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (res)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"can't resubmit intr, %s-%s/input0, status %d\\n\",\n\t\t\tdev->udev->bus->bus_name, dev->udev->devpath, res);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7926aff5c57b577ab0f43364ff0c59d968f6a414",
        "vul_func_with_fix": "static void intr_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\t__u8 *d;\n\tint status = urb->status;\n\tint res;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tswitch (status) {\n\tcase 0:\t\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\t/* unlink */\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t/* -EPIPE:  should clear the halt */\n\tdefault:\n\t\tdev_info(&urb->dev->dev, \"%s: intr status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (d[0] & TSR_ERRORS) {\n\t\tdev->netdev->stats.tx_errors++;\n\t\tif (d[INT_TSR] & (TSR_ECOL | TSR_JBR))\n\t\t\tdev->netdev->stats.tx_aborted_errors++;\n\t\tif (d[INT_TSR] & TSR_LCOL)\n\t\t\tdev->netdev->stats.tx_window_errors++;\n\t\tif (d[INT_TSR] & TSR_LOSS_CRS)\n\t\t\tdev->netdev->stats.tx_carrier_errors++;\n\t}\n\t/* Report link status changes to the network stack */\n\tif ((d[INT_MSR] & MSR_LINK) == 0) {\n\t\tif (netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_off(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK LOST\\n\", __func__);\n\t\t}\n\t} else {\n\t\tif (!netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_on(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK CAME BACK\\n\", __func__);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (res)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"can't resubmit intr, %s-%s/input0, status %d\\n\",\n\t\t\tdev->udev->bus->bus_name, dev->udev->devpath, res);\n}\n",
        "linevul": 6.871947698527947e-05,
        "sysevr": 0.14381127059459686,
        "devign": 3.822877652376982e-30
    },
    {
        "code": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f0d1bec9d58d4c038d0ac958c9af82be6eb18045",
        "vul_func_with_fix": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}\n",
        "linevul": 0.00019184079428669065,
        "sysevr": 0.1273241490125656,
        "devign": 3.3361398479235483e-16
    },
    {
        "code": "SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,\n\t\tstruct timespec __user *, interval)\n{\n\tstruct task_struct *p;\n\tunsigned int time_slice;\n\tunsigned long flags;\n\tstruct rq *rq;\n\tint retval;\n\tstruct timespec t;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &flags);\n\ttime_slice = p->sched_class->get_rr_interval(rq, p);\n\ttask_rq_unlock(rq, p, &flags);\n\n\trcu_read_unlock();\n\tjiffies_to_timespec(time_slice, &t);\n\tretval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,\n\t\tstruct timespec __user *, interval)\n{\n\tstruct task_struct *p;\n\tunsigned int time_slice;\n\tunsigned long flags;\n\tstruct rq *rq;\n\tint retval;\n\tstruct timespec t;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &flags);\n\ttime_slice = p->sched_class->get_rr_interval(rq, p);\n\ttask_rq_unlock(rq, p, &flags);\n\n\trcu_read_unlock();\n\tjiffies_to_timespec(time_slice, &t);\n\tretval = copy_to_user(interval, &t, sizeof(t)) ? -EFAULT : 0;\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}\n",
        "linevul": 8.091206109384075e-05,
        "sysevr": 0.17083433270454407,
        "devign": 0.58897864818573
    },
    {
        "code": "int kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "int kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_write_guest(vcpu->kvm, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\n",
        "linevul": 0.00013698331895284355,
        "sysevr": 0.15598659217357635,
        "devign": 7.547282342845488e-21
    },
    {
        "code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with pernet_ops_rwsem held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n \n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/355b98553789b646ed97ad801a619ff898471b92",
        "vul_func_with_fix": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with pernet_ops_rwsem held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n \n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n//fix_flaw_line_below:\n//\tget_random_bytes(&net->hash_mix, sizeof(u32));\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}\n",
        "linevul": 0.9995219707489014,
        "sysevr": 0.14025063812732697,
        "devign": 0.6608608365058899
    },
    {
        "code": "xfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n \n \n \t/*\n\t * If we are allocating a new inode, then check what was returned is\n\t * actually a free, empty inode. If we are not allocating an inode,\n\t * the check we didn't find a free inode.\n \t */\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(mp,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tino);\n\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out_destroy;\n\t\t}\n\t} else if (VFS_I(ip)->i_mode == 0) {\n\t\terror = -ENOENT;\n \t\tgoto out_destroy;\n\t}\n \n \t/*\n \t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/afca6c5b2595fc44383919fba740c194b0b76aff",
        "vul_func_with_fix": "xfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\tint\t\t\tiflags;\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\tif (!xfs_inode_verify_forks(ip)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out_destroy;\n\t}\n\n\ttrace_xfs_iget_miss(ip);\n \n \n \t/*\n//flaw_line_below:\n\t * If we are allocating a new inode, then check what was returned is\n//flaw_line_below:\n\t * actually a free, empty inode. If we are not allocating an inode,\n//flaw_line_below:\n\t * the check we didn't find a free inode.\n//fix_flaw_line_below:\n//\t * Check the inode free state is valid. This also detects lookup\n//fix_flaw_line_below:\n//\t * racing with unlinks.\n \t */\n//flaw_line_below:\n\tif (flags & XFS_IGET_CREATE) {\n//flaw_line_below:\n\t\tif (VFS_I(ip)->i_mode != 0) {\n//flaw_line_below:\n\t\t\txfs_warn(mp,\n//flaw_line_below:\n\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n//flaw_line_below:\n\t\t\t\tino);\n//flaw_line_below:\n\t\t\terror = -EFSCORRUPTED;\n//flaw_line_below:\n\t\t\tgoto out_destroy;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t\tif (ip->i_d.di_nblocks != 0) {\n//flaw_line_below:\n\t\t\txfs_warn(mp,\n//flaw_line_below:\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n//flaw_line_below:\n\t\t\t\tino);\n//flaw_line_below:\n\t\t\terror = -EFSCORRUPTED;\n//flaw_line_below:\n\t\t\tgoto out_destroy;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t} else if (VFS_I(ip)->i_mode == 0) {\n//flaw_line_below:\n\t\terror = -ENOENT;\n//fix_flaw_line_below:\n//\terror = xfs_iget_check_free_state(ip, flags);\n//fix_flaw_line_below:\n//\tif (error)\n \t\tgoto out_destroy;\n//flaw_line_below:\n\t}\n \n \t/*\n \t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region. Since we can be called from transaction context, don't\n\t * recurse into the file system.\n\t */\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\terror = -EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\t/*\n\t * These values must be set before inserting the inode into the radix\n\t * tree as the moment it is inserted a concurrent lookup (allowed by the\n\t * RCU locking mechanism) can find it and that lookup must see that this\n\t * is an inode currently under construction (i.e. that XFS_INEW is set).\n\t * The ip->i_flags_lock that protects the XFS_INEW flag forms the\n\t * memory barrier that ensures this detection works correctly at lookup\n\t * time.\n\t */\n\tiflags = XFS_INEW;\n\tif (flags & XFS_IGET_DONTCACHE)\n\t\tiflags |= XFS_IDONTCACHE;\n\tip->i_udquot = NULL;\n\tip->i_gdquot = NULL;\n\tip->i_pdquot = NULL;\n\txfs_iflags_set(ip, iflags);\n\n\t/* insert the new inode */\n\tspin_lock(&pag->pag_ici_lock);\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(mp, xs_ig_dup);\n\t\terror = -EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\tspin_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}\n",
        "linevul": 0.00030771023011766374,
        "sysevr": 0.23514579236507416,
        "devign": 0.9977123737335205
    },
    {
        "code": "int arch_prctl_spec_ctrl_set(struct task_struct *task, unsigned long which,\n\t\t\t     unsigned long ctrl)\n{\n\tswitch (which) {\n\tcase PR_SPEC_STORE_BYPASS:\n\t\treturn ssb_prctl_set(task, ctrl);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fdf82a7856b32d905c39afc85e34364491e46346",
        "vul_func_with_fix": "int arch_prctl_spec_ctrl_set(struct task_struct *task, unsigned long which,\n\t\t\t     unsigned long ctrl)\n{\n\tswitch (which) {\n\tcase PR_SPEC_STORE_BYPASS:\n\t\treturn ssb_prctl_set(task, ctrl);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n",
        "linevul": 5.711451012757607e-05,
        "sysevr": 0.16507644951343536,
        "devign": 2.6561744123632103e-11
    },
    {
        "code": "static void __init enable_swap_cgroup(void)\n{\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static void __init enable_swap_cgroup(void)\n{\n}\n",
        "linevul": 5.257144584902562e-05,
        "sysevr": 0.12549321353435516,
        "devign": 0.07873139530420303
    },
    {
        "code": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n \t\t\t\tjumpstack[stackidx++] = e;\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8",
        "vul_func_with_fix": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n//flaw_line_below:\n\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n//fix_flaw_line_below:\n//\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n//fix_flaw_line_below:\n//\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n//fix_flaw_line_below:\n//\t\t\t\t\tverdict = NF_DROP;\n//fix_flaw_line_below:\n//\t\t\t\t\tbreak;\n//fix_flaw_line_below:\n//\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n//fix_flaw_line_below:\n//\t\t\t}\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n",
        "linevul": 0.0021295116748660803,
        "sysevr": 0.2465960532426834,
        "devign": 0.0008795597241260111
    },
    {
        "code": "static void migrate_tasks(unsigned int dead_cpu)\n{\n\tstruct rq *rq = cpu_rq(dead_cpu);\n\tstruct task_struct *next, *stop = rq->stop;\n\tint dest_cpu;\n\n\t/*\n\t * Fudge the rq selection such that the below task selection loop\n\t * doesn't get stuck on the currently eligible stop task.\n\t *\n\t * We're currently inside stop_machine() and the rq is either stuck\n\t * in the stop_machine_cpu_stop() loop, or we're executing this code,\n\t * either way we should never end up calling schedule() until we're\n\t * done here.\n\t */\n\trq->stop = NULL;\n\n\t/*\n\t * put_prev_task() and pick_next_task() sched\n\t * class method both need to have an up-to-date\n\t * value of rq->clock[_task]\n\t */\n\tupdate_rq_clock(rq);\n\n\tfor ( ; ; ) {\n\t\t/*\n\t\t * There's this thread running, bail when that's the only\n\t\t * remaining thread.\n\t\t */\n\t\tif (rq->nr_running == 1)\n\t\t\tbreak;\n\n\t\tnext = pick_next_task(rq);\n\t\tBUG_ON(!next);\n\t\tnext->sched_class->put_prev_task(rq, next);\n\n\t\t/* Find suitable destination for @next, with force if needed. */\n\t\tdest_cpu = select_fallback_rq(dead_cpu, next);\n\t\traw_spin_unlock(&rq->lock);\n\n\t\t__migrate_task(next, dead_cpu, dest_cpu);\n\n\t\traw_spin_lock(&rq->lock);\n\t}\n\n\trq->stop = stop;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4efbc454ba68def5ef285b26ebfcfdb605b52755",
        "vul_func_with_fix": "static void migrate_tasks(unsigned int dead_cpu)\n{\n\tstruct rq *rq = cpu_rq(dead_cpu);\n\tstruct task_struct *next, *stop = rq->stop;\n\tint dest_cpu;\n\n\t/*\n\t * Fudge the rq selection such that the below task selection loop\n\t * doesn't get stuck on the currently eligible stop task.\n\t *\n\t * We're currently inside stop_machine() and the rq is either stuck\n\t * in the stop_machine_cpu_stop() loop, or we're executing this code,\n\t * either way we should never end up calling schedule() until we're\n\t * done here.\n\t */\n\trq->stop = NULL;\n\n\t/*\n\t * put_prev_task() and pick_next_task() sched\n\t * class method both need to have an up-to-date\n\t * value of rq->clock[_task]\n\t */\n\tupdate_rq_clock(rq);\n\n\tfor ( ; ; ) {\n\t\t/*\n\t\t * There's this thread running, bail when that's the only\n\t\t * remaining thread.\n\t\t */\n\t\tif (rq->nr_running == 1)\n\t\t\tbreak;\n\n\t\tnext = pick_next_task(rq);\n\t\tBUG_ON(!next);\n\t\tnext->sched_class->put_prev_task(rq, next);\n\n\t\t/* Find suitable destination for @next, with force if needed. */\n\t\tdest_cpu = select_fallback_rq(dead_cpu, next);\n\t\traw_spin_unlock(&rq->lock);\n\n\t\t__migrate_task(next, dead_cpu, dest_cpu);\n\n\t\traw_spin_lock(&rq->lock);\n\t}\n\n\trq->stop = stop;\n}\n",
        "linevul": 0.000127265157061629,
        "sysevr": 0.14915449917316437,
        "devign": 2.0115221879661582e-13
    },
    {
        "code": "static int proc_sys_permission(struct inode *inode, int mask)\n{\n\t/*\n\t * sysctl entries that are not writeable,\n\t * are _NOT_ writeable, capabilities or not.\n\t */\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *table;\n\tint error;\n\n\t/* Executable files are not allowed under /proc/sys/ */\n\tif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\n\t\treturn -EACCES;\n\n\thead = grab_header(inode);\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\ttable = PROC_I(inode)->sysctl_entry;\n\tif (!table) /* global root - r-xr-xr-x */\n\t\terror = mask & MAY_WRITE ? -EACCES : 0;\n\telse /* Use the permissions on the sysctl table entry */\n\t\terror = sysctl_perm(head, table, mask & ~MAY_NOT_BLOCK);\n\n\tsysctl_head_finish(head);\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/93362fa47fe98b62e4a34ab408c4a418432e7939",
        "vul_func_with_fix": "static int proc_sys_permission(struct inode *inode, int mask)\n{\n\t/*\n\t * sysctl entries that are not writeable,\n\t * are _NOT_ writeable, capabilities or not.\n\t */\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *table;\n\tint error;\n\n\t/* Executable files are not allowed under /proc/sys/ */\n\tif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\n\t\treturn -EACCES;\n\n\thead = grab_header(inode);\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\ttable = PROC_I(inode)->sysctl_entry;\n\tif (!table) /* global root - r-xr-xr-x */\n\t\terror = mask & MAY_WRITE ? -EACCES : 0;\n\telse /* Use the permissions on the sysctl table entry */\n\t\terror = sysctl_perm(head, table, mask & ~MAY_NOT_BLOCK);\n\n\tsysctl_head_finish(head);\n\treturn error;\n}\n",
        "linevul": 5.986172254779376e-05,
        "sysevr": 0.12436284124851227,
        "devign": 3.3754140975339464e-12
    },
    {
        "code": "SCTP_STATIC int sctp_getsockopt_connectx3(struct sock* sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n\tif (len < sizeof(param))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\treturn -EFAULT;\n\n\terr = __sctp_setsockopt_connectx(sk,\n\t\t\t(struct sockaddr __user *)param.addrs,\n\t\t\tparam.addr_num, &assoc_id);\n\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/726bc6b092da4c093eb74d13c07184b18c1af0f1",
        "vul_func_with_fix": "SCTP_STATIC int sctp_getsockopt_connectx3(struct sock* sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n\tif (len < sizeof(param))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\treturn -EFAULT;\n\n\terr = __sctp_setsockopt_connectx(sk,\n\t\t\t(struct sockaddr __user *)param.addrs,\n\t\t\tparam.addr_num, &assoc_id);\n\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n",
        "linevul": 4.9772213969845325e-05,
        "sysevr": 0.1710575968027115,
        "devign": 0.5499873757362366
    },
    {
        "code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tint scale = cfs_rq->nr_running >= sched_nr_latency;\n\tint next_buddy_marked = 0;\n\n\tif (unlikely(se == pse))\n\t\treturn;\n\n\t/*\n\t * This is possible from callers such as attach_tasks(), in which we\n\t * unconditionally check_prempt_curr() after an enqueue (which may have\n\t * lead to a throttle).  This both saves work and prevents false\n\t * next-buddy nomination below.\n\t */\n\tif (unlikely(throttled_hierarchy(cfs_rq_of(pse))))\n\t\treturn;\n\n\tif (sched_feat(NEXT_BUDDY) && scale && !(wake_flags & WF_FORK)) {\n\t\tset_next_buddy(pse);\n\t\tnext_buddy_marked = 1;\n\t}\n\n\t/*\n\t * We can come here with TIF_NEED_RESCHED already set from new task\n\t * wake up path.\n\t *\n\t * Note: this also catches the edge-case of curr being in a throttled\n\t * group (e.g. via set_curr_task), since update_curr() (in the\n\t * enqueue of curr) will have resulted in resched being set.  This\n\t * prevents us from potentially nominating it as a false LAST_BUDDY\n\t * below.\n\t */\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\t/* Idle tasks are by definition preempted by non-idle tasks. */\n\tif (unlikely(task_has_idle_policy(curr)) &&\n\t    likely(!task_has_idle_policy(p)))\n\t\tgoto preempt;\n\n\t/*\n\t * Batch and idle tasks do not preempt non-idle tasks (their preemption\n\t * is driven by the tick):\n\t */\n\tif (unlikely(p->policy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION))\n\t\treturn;\n\n\tfind_matching_se(&se, &pse);\n\tupdate_curr(cfs_rq_of(se));\n\tBUG_ON(!pse);\n\tif (wakeup_preempt_entity(se, pse) == 1) {\n\t\t/*\n\t\t * Bias pick_next to pick the sched entity that is\n\t\t * triggering this preemption.\n\t\t */\n\t\tif (!next_buddy_marked)\n\t\t\tset_next_buddy(pse);\n\t\tgoto preempt;\n\t}\n\n\treturn;\n\npreempt:\n\tresched_curr(rq);\n\t/*\n\t * Only set the backward buddy when the current task is still\n\t * on the rq. This can happen when a wakeup gets interleaved\n\t * with schedule on the ->pre_schedule() or idle_balance()\n\t * point, either of which can * drop the rq lock.\n\t *\n\t * Also, during early boot the idle thread is in the fair class,\n\t * for obvious reasons its a bad idea to schedule back to it.\n\t */\n\tif (unlikely(!se->on_rq || curr == rq->idle))\n\t\treturn;\n\n\tif (sched_feat(LAST_BUDDY) && scale && entity_is_task(se))\n\t\tset_last_buddy(se);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tint scale = cfs_rq->nr_running >= sched_nr_latency;\n\tint next_buddy_marked = 0;\n\n\tif (unlikely(se == pse))\n\t\treturn;\n\n\t/*\n\t * This is possible from callers such as attach_tasks(), in which we\n\t * unconditionally check_prempt_curr() after an enqueue (which may have\n\t * lead to a throttle).  This both saves work and prevents false\n\t * next-buddy nomination below.\n\t */\n\tif (unlikely(throttled_hierarchy(cfs_rq_of(pse))))\n\t\treturn;\n\n\tif (sched_feat(NEXT_BUDDY) && scale && !(wake_flags & WF_FORK)) {\n\t\tset_next_buddy(pse);\n\t\tnext_buddy_marked = 1;\n\t}\n\n\t/*\n\t * We can come here with TIF_NEED_RESCHED already set from new task\n\t * wake up path.\n\t *\n\t * Note: this also catches the edge-case of curr being in a throttled\n\t * group (e.g. via set_curr_task), since update_curr() (in the\n\t * enqueue of curr) will have resulted in resched being set.  This\n\t * prevents us from potentially nominating it as a false LAST_BUDDY\n\t * below.\n\t */\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\t/* Idle tasks are by definition preempted by non-idle tasks. */\n\tif (unlikely(task_has_idle_policy(curr)) &&\n\t    likely(!task_has_idle_policy(p)))\n\t\tgoto preempt;\n\n\t/*\n\t * Batch and idle tasks do not preempt non-idle tasks (their preemption\n\t * is driven by the tick):\n\t */\n\tif (unlikely(p->policy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION))\n\t\treturn;\n\n\tfind_matching_se(&se, &pse);\n\tupdate_curr(cfs_rq_of(se));\n\tBUG_ON(!pse);\n\tif (wakeup_preempt_entity(se, pse) == 1) {\n\t\t/*\n\t\t * Bias pick_next to pick the sched entity that is\n\t\t * triggering this preemption.\n\t\t */\n\t\tif (!next_buddy_marked)\n\t\t\tset_next_buddy(pse);\n\t\tgoto preempt;\n\t}\n\n\treturn;\n\npreempt:\n\tresched_curr(rq);\n\t/*\n\t * Only set the backward buddy when the current task is still\n\t * on the rq. This can happen when a wakeup gets interleaved\n\t * with schedule on the ->pre_schedule() or idle_balance()\n\t * point, either of which can * drop the rq lock.\n\t *\n\t * Also, during early boot the idle thread is in the fair class,\n\t * for obvious reasons its a bad idea to schedule back to it.\n\t */\n\tif (unlikely(!se->on_rq || curr == rq->idle))\n\t\treturn;\n\n\tif (sched_feat(LAST_BUDDY) && scale && entity_is_task(se))\n\t\tset_last_buddy(se);\n}\n",
        "linevul": 0.00015030548092909157,
        "sysevr": 0.18824847042560577,
        "devign": 1.1863766013059288e-27
    },
    {
        "code": "int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n\t\t\t const struct drm_framebuffer_funcs *funcs)\n{\n\tint ret;\n\n\tret = drm_mode_object_get(dev, &fb->base, DRM_MODE_OBJECT_FB);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tfb->dev = dev;\n\tfb->funcs = funcs;\n\tdev->mode_config.num_fb++;\n\tlist_add(&fb->head, &dev->mode_config.fb_list);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2",
        "vul_func_with_fix": "int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,\n\t\t\t const struct drm_framebuffer_funcs *funcs)\n{\n\tint ret;\n\n\tret = drm_mode_object_get(dev, &fb->base, DRM_MODE_OBJECT_FB);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tfb->dev = dev;\n\tfb->funcs = funcs;\n\tdev->mode_config.num_fb++;\n\tlist_add(&fb->head, &dev->mode_config.fb_list);\n\n\treturn 0;\n}\n",
        "linevul": 4.8586160119157284e-05,
        "sysevr": 0.16346342861652374,
        "devign": 4.4961229406226266e-08
    },
    {
        "code": "static void intel_clovertown_quirks(void)\n{\n\t/*\n\t * PEBS is unreliable due to:\n\t *\n\t *   AJ67  - PEBS may experience CPL leaks\n\t *   AJ68  - PEBS PMI may be delayed by one event\n\t *   AJ69  - GLOBAL_STATUS[62] will only be set when DEBUGCTL[12]\n\t *   AJ106 - FREEZE_LBRS_ON_PMI doesn't work in combination with PEBS\n\t *\n\t * AJ67 could be worked around by restricting the OS/USR flags.\n\t * AJ69 could be worked around by setting PMU_FREEZE_ON_PMI.\n\t *\n\t * AJ106 could possibly be worked around by not allowing LBR\n\t *       usage from PEBS, including the fixup.\n\t * AJ68  could possibly be worked around by always programming\n\t *\t a pebs_event_reset[0] value and coping with the lost events.\n\t *\n\t * But taken together it might just make sense to not enable PEBS on\n\t * these chips.\n\t */\n\tprintk(KERN_WARNING \"PEBS disabled due to CPU errata.\\n\");\n\tx86_pmu.pebs = 0;\n\tx86_pmu.pebs_constraints = NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void intel_clovertown_quirks(void)\n{\n\t/*\n\t * PEBS is unreliable due to:\n\t *\n\t *   AJ67  - PEBS may experience CPL leaks\n\t *   AJ68  - PEBS PMI may be delayed by one event\n\t *   AJ69  - GLOBAL_STATUS[62] will only be set when DEBUGCTL[12]\n\t *   AJ106 - FREEZE_LBRS_ON_PMI doesn't work in combination with PEBS\n\t *\n\t * AJ67 could be worked around by restricting the OS/USR flags.\n\t * AJ69 could be worked around by setting PMU_FREEZE_ON_PMI.\n\t *\n\t * AJ106 could possibly be worked around by not allowing LBR\n\t *       usage from PEBS, including the fixup.\n\t * AJ68  could possibly be worked around by always programming\n\t *\t a pebs_event_reset[0] value and coping with the lost events.\n\t *\n\t * But taken together it might just make sense to not enable PEBS on\n\t * these chips.\n\t */\n\tprintk(KERN_WARNING \"PEBS disabled due to CPU errata.\\n\");\n\tx86_pmu.pebs = 0;\n\tx86_pmu.pebs_constraints = NULL;\n}\n",
        "linevul": 7.318920688703656e-05,
        "sysevr": 0.1609748750925064,
        "devign": 0.0027266922406852245
    },
    {
        "code": "int qeth_mdio_read(struct net_device *dev, int phy_id, int regnum)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc = 0;\n\n\tswitch (regnum) {\n\tcase MII_BMCR: /* Basic mode control register */\n\t\trc = BMCR_FULLDPLX;\n\t\tif ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_OSN) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))\n\t\t\trc |= BMCR_SPEED100;\n\t\tbreak;\n\tcase MII_BMSR: /* Basic mode status register */\n\t\trc = BMSR_ERCAP | BMSR_ANEGCOMPLETE | BMSR_LSTATUS |\n\t\t     BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | BMSR_100FULL |\n\t\t     BMSR_100BASE4;\n\t\tbreak;\n\tcase MII_PHYSID1: /* PHYS ID 1 */\n\t\trc = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 8) |\n\t\t     dev->dev_addr[2];\n\t\trc = (rc >> 5) & 0xFFFF;\n\t\tbreak;\n\tcase MII_PHYSID2: /* PHYS ID 2 */\n\t\trc = (dev->dev_addr[2] << 10) & 0xFFFF;\n\t\tbreak;\n\tcase MII_ADVERTISE: /* Advertisement control reg */\n\t\trc = ADVERTISE_ALL;\n\t\tbreak;\n\tcase MII_LPA: /* Link partner ability reg */\n\t\trc = LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL |\n\t\t     LPA_100BASE4 | LPA_LPACK;\n\t\tbreak;\n\tcase MII_EXPANSION: /* Expansion register */\n\t\tbreak;\n\tcase MII_DCOUNTER: /* disconnect counter */\n\t\tbreak;\n\tcase MII_FCSCOUNTER: /* false carrier counter */\n\t\tbreak;\n\tcase MII_NWAYTEST: /* N-way auto-neg test register */\n\t\tbreak;\n\tcase MII_RERRCOUNTER: /* rx error counter */\n\t\trc = card->stats.rx_errors;\n\t\tbreak;\n\tcase MII_SREVISION: /* silicon revision */\n\t\tbreak;\n\tcase MII_RESV1: /* reserved 1 */\n\t\tbreak;\n\tcase MII_LBRERROR: /* loopback, rx, bypass error */\n\t\tbreak;\n\tcase MII_PHYADDR: /* physical address */\n\t\tbreak;\n\tcase MII_RESV2: /* reserved 2 */\n\t\tbreak;\n\tcase MII_TPISTATUS: /* TPI status for 10mbps */\n\t\tbreak;\n\tcase MII_NCONFIG: /* network interface config */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62",
        "vul_func_with_fix": "int qeth_mdio_read(struct net_device *dev, int phy_id, int regnum)\n{\n\tstruct qeth_card *card = dev->ml_priv;\n\tint rc = 0;\n\n\tswitch (regnum) {\n\tcase MII_BMCR: /* Basic mode control register */\n\t\trc = BMCR_FULLDPLX;\n\t\tif ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_OSN) &&\n\t\t    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))\n\t\t\trc |= BMCR_SPEED100;\n\t\tbreak;\n\tcase MII_BMSR: /* Basic mode status register */\n\t\trc = BMSR_ERCAP | BMSR_ANEGCOMPLETE | BMSR_LSTATUS |\n\t\t     BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | BMSR_100FULL |\n\t\t     BMSR_100BASE4;\n\t\tbreak;\n\tcase MII_PHYSID1: /* PHYS ID 1 */\n\t\trc = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 8) |\n\t\t     dev->dev_addr[2];\n\t\trc = (rc >> 5) & 0xFFFF;\n\t\tbreak;\n\tcase MII_PHYSID2: /* PHYS ID 2 */\n\t\trc = (dev->dev_addr[2] << 10) & 0xFFFF;\n\t\tbreak;\n\tcase MII_ADVERTISE: /* Advertisement control reg */\n\t\trc = ADVERTISE_ALL;\n\t\tbreak;\n\tcase MII_LPA: /* Link partner ability reg */\n\t\trc = LPA_10HALF | LPA_10FULL | LPA_100HALF | LPA_100FULL |\n\t\t     LPA_100BASE4 | LPA_LPACK;\n\t\tbreak;\n\tcase MII_EXPANSION: /* Expansion register */\n\t\tbreak;\n\tcase MII_DCOUNTER: /* disconnect counter */\n\t\tbreak;\n\tcase MII_FCSCOUNTER: /* false carrier counter */\n\t\tbreak;\n\tcase MII_NWAYTEST: /* N-way auto-neg test register */\n\t\tbreak;\n\tcase MII_RERRCOUNTER: /* rx error counter */\n\t\trc = card->stats.rx_errors;\n\t\tbreak;\n\tcase MII_SREVISION: /* silicon revision */\n\t\tbreak;\n\tcase MII_RESV1: /* reserved 1 */\n\t\tbreak;\n\tcase MII_LBRERROR: /* loopback, rx, bypass error */\n\t\tbreak;\n\tcase MII_PHYADDR: /* physical address */\n\t\tbreak;\n\tcase MII_RESV2: /* reserved 2 */\n\t\tbreak;\n\tcase MII_TPISTATUS: /* TPI status for 10mbps */\n\t\tbreak;\n\tcase MII_NCONFIG: /* network interface config */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\n",
        "linevul": 5.8182584325550124e-05,
        "sysevr": 0.19584475457668304,
        "devign": 5.845854399513795e-13
    },
    {
        "code": "megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "vul_func_with_fix": "megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}\n",
        "linevul": 6.93188703735359e-05,
        "sysevr": 0.16028714179992676,
        "devign": 0.1274479776620865
    },
    {
        "code": "static char *usb_devnode(struct device *dev,\n\t\t\t umode_t *mode, kuid_t *uid, kgid_t *gid)\n{\n\tstruct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\treturn kasprintf(GFP_KERNEL, \"bus/usb/%03d/%03d\",\n\t\t\t usb_dev->bus->busnum, usb_dev->devnum);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf",
        "vul_func_with_fix": "static char *usb_devnode(struct device *dev,\n\t\t\t umode_t *mode, kuid_t *uid, kgid_t *gid)\n{\n\tstruct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\treturn kasprintf(GFP_KERNEL, \"bus/usb/%03d/%03d\",\n\t\t\t usb_dev->bus->busnum, usb_dev->devnum);\n}\n",
        "linevul": 6.426987965824082e-05,
        "sysevr": 0.12769819796085358,
        "devign": 6.952755211842021e-12
    },
    {
        "code": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1, KM_USER0);\n\taddr2 = kmap_atomic(page2, KM_USER1);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2, KM_USER1);\n\tkunmap_atomic(addr1, KM_USER0);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2b472611a32a72f4a118c069c2d62a1a3f087afd",
        "vul_func_with_fix": "static int memcmp_pages(struct page *page1, struct page *page2)\n{\n\tchar *addr1, *addr2;\n\tint ret;\n\n\taddr1 = kmap_atomic(page1, KM_USER0);\n\taddr2 = kmap_atomic(page2, KM_USER1);\n\tret = memcmp(addr1, addr2, PAGE_SIZE);\n\tkunmap_atomic(addr2, KM_USER1);\n\tkunmap_atomic(addr1, KM_USER0);\n\treturn ret;\n}\n",
        "linevul": 9.651218715589494e-05,
        "sysevr": 0.11780254542827606,
        "devign": 3.440582304392592e-06
    },
    {
        "code": "static int check_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint cr = ctxt->modrm_reg;\n\tu64 efer = 0;\n\n\tstatic u64 cr_reserved_bits[] = {\n\t\t0xffffffff00000000ULL,\n\t\t0, 0, 0, /* CR3 checked later */\n\t\tCR4_RESERVED_BITS,\n\t\t0, 0, 0,\n\t\tCR8_RESERVED_BITS,\n\t};\n\n\tif (!valid_cr(cr))\n\t\treturn emulate_ud(ctxt);\n\n\tif (new_val & cr_reserved_bits[cr])\n\t\treturn emulate_gp(ctxt, 0);\n\n\tswitch (cr) {\n\tcase 0: {\n\t\tu64 cr4;\n\t\tif (((new_val & X86_CR0_PG) && !(new_val & X86_CR0_PE)) ||\n\t\t    ((new_val & X86_CR0_NW) && !(new_val & X86_CR0_CD)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((new_val & X86_CR0_PG) && (efer & EFER_LME) &&\n\t\t    !(cr4 & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 3: {\n\t\tu64 rsvd = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (efer & EFER_LMA)\n\t\t\trsvd = CR3_L_MODE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_PAE)\n\t\t\trsvd = CR3_PAE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 0) & X86_CR0_PG)\n\t\t\trsvd = CR3_NONPAE_RESERVED_BITS;\n\n\t\tif (new_val & rsvd)\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 4: {\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((efer & EFER_LMA) && !(new_val & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84",
        "vul_func_with_fix": "static int check_cr_write(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 new_val = ctxt->src.val64;\n\tint cr = ctxt->modrm_reg;\n\tu64 efer = 0;\n\n\tstatic u64 cr_reserved_bits[] = {\n\t\t0xffffffff00000000ULL,\n\t\t0, 0, 0, /* CR3 checked later */\n\t\tCR4_RESERVED_BITS,\n\t\t0, 0, 0,\n\t\tCR8_RESERVED_BITS,\n\t};\n\n\tif (!valid_cr(cr))\n\t\treturn emulate_ud(ctxt);\n\n\tif (new_val & cr_reserved_bits[cr])\n\t\treturn emulate_gp(ctxt, 0);\n\n\tswitch (cr) {\n\tcase 0: {\n\t\tu64 cr4;\n\t\tif (((new_val & X86_CR0_PG) && !(new_val & X86_CR0_PE)) ||\n\t\t    ((new_val & X86_CR0_NW) && !(new_val & X86_CR0_CD)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tcr4 = ctxt->ops->get_cr(ctxt, 4);\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((new_val & X86_CR0_PG) && (efer & EFER_LME) &&\n\t\t    !(cr4 & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 3: {\n\t\tu64 rsvd = 0;\n\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\tif (efer & EFER_LMA)\n\t\t\trsvd = CR3_L_MODE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_PAE)\n\t\t\trsvd = CR3_PAE_RESERVED_BITS;\n\t\telse if (ctxt->ops->get_cr(ctxt, 0) & X86_CR0_PG)\n\t\t\trsvd = CR3_NONPAE_RESERVED_BITS;\n\n\t\tif (new_val & rsvd)\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\tcase 4: {\n\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\n\t\tif ((efer & EFER_LMA) && !(new_val & X86_CR4_PAE))\n\t\t\treturn emulate_gp(ctxt, 0);\n\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n",
        "linevul": 4.8887613957049325e-05,
        "sysevr": 0.2004176825284958,
        "devign": 0.0
    },
    {
        "code": "static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n{\n\tunsigned char s[12] = {0,};\n\tint size;\n\n\tif (offset & 1) {\n\t\tmemcpy(&s[1], &ctx->from, 4);\n\t\tmemcpy(&s[7], &ctx->to, 4);\n\t\ts[0] = ~0;\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\ts[4] = ~s[4];\n\t\ts[5] = ~0;\n\t\tsize = 12;\n\t} else {\n\t\tmemcpy(&s[0], &ctx->from, 4);\n\t\tmemcpy(&s[4], &ctx->to, 4);\n\t\ts[0] = ~s[0];\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\tsize = 8;\n\t}\n\t*ctx->check = csum_fold(csum_partial(s, size,\n\t\t\t\t\t     ~csum_unfold(*ctx->check)));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc",
        "vul_func_with_fix": "static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n{\n\tunsigned char s[12] = {0,};\n\tint size;\n\n\tif (offset & 1) {\n\t\tmemcpy(&s[1], &ctx->from, 4);\n\t\tmemcpy(&s[7], &ctx->to, 4);\n\t\ts[0] = ~0;\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\ts[4] = ~s[4];\n\t\ts[5] = ~0;\n\t\tsize = 12;\n\t} else {\n\t\tmemcpy(&s[0], &ctx->from, 4);\n\t\tmemcpy(&s[4], &ctx->to, 4);\n\t\ts[0] = ~s[0];\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\tsize = 8;\n\t}\n\t*ctx->check = csum_fold(csum_partial(s, size,\n\t\t\t\t\t     ~csum_unfold(*ctx->check)));\n}\n",
        "linevul": 5.950066406512633e-05,
        "sysevr": 0.15435440838336945,
        "devign": 0.0
    },
    {
        "code": "void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tdown_write(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new, MPOL_REBIND_ONCE);\n\tup_write(&mm->mmap_sem);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "void mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tdown_write(&mm->mmap_sem);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new, MPOL_REBIND_ONCE);\n\tup_write(&mm->mmap_sem);\n}\n",
        "linevul": 0.00019176908244844526,
        "sysevr": 0.1701250970363617,
        "devign": 2.3058143483467575e-07
    },
    {
        "code": "void hiddev_report_event(struct hid_device *hid, struct hid_report *report)\n{\n\tunsigned type = report->type;\n\tstruct hiddev_usage_ref uref;\n\n\tmemset(&uref, 0, sizeof(uref));\n\turef.report_type =\n\t  (type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :\n\t  ((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :\n\t   ((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE : 0));\n\turef.report_id = report->id;\n\turef.field_index = HID_FIELD_INDEX_NONE;\n\n\thiddev_send_event(hid, &uref);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/93a2001bdfd5376c3dc2158653034c20392d15c5",
        "vul_func_with_fix": "void hiddev_report_event(struct hid_device *hid, struct hid_report *report)\n{\n\tunsigned type = report->type;\n\tstruct hiddev_usage_ref uref;\n\n\tmemset(&uref, 0, sizeof(uref));\n\turef.report_type =\n\t  (type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :\n\t  ((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :\n\t   ((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE : 0));\n\turef.report_id = report->id;\n\turef.field_index = HID_FIELD_INDEX_NONE;\n\n\thiddev_send_event(hid, &uref);\n}\n",
        "linevul": 5.0519400247139856e-05,
        "sysevr": 0.18796084821224213,
        "devign": 0.009520736522972584
    },
    {
        "code": "int nf_ct_frag6_init(void)\n{\n\tnf_frags.hashfn = nf_hashfn;\n\tnf_frags.constructor = ip6_frag_init;\n\tnf_frags.destructor = NULL;\n\tnf_frags.skb_free = nf_skb_free;\n\tnf_frags.qsize = sizeof(struct nf_ct_frag6_queue);\n\tnf_frags.match = ip6_frag_match;\n\tnf_frags.frag_expire = nf_ct_frag6_expire;\n\tnf_frags.secret_interval = 10 * 60 * HZ;\n\tnf_init_frags.timeout = IPV6_FRAG_TIMEOUT;\n\tnf_init_frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnf_init_frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tinet_frags_init_net(&nf_init_frags);\n\tinet_frags_init(&nf_frags);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce",
        "vul_func_with_fix": "int nf_ct_frag6_init(void)\n{\n\tnf_frags.hashfn = nf_hashfn;\n\tnf_frags.constructor = ip6_frag_init;\n\tnf_frags.destructor = NULL;\n\tnf_frags.skb_free = nf_skb_free;\n\tnf_frags.qsize = sizeof(struct nf_ct_frag6_queue);\n\tnf_frags.match = ip6_frag_match;\n\tnf_frags.frag_expire = nf_ct_frag6_expire;\n\tnf_frags.secret_interval = 10 * 60 * HZ;\n\tnf_init_frags.timeout = IPV6_FRAG_TIMEOUT;\n\tnf_init_frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnf_init_frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tinet_frags_init_net(&nf_init_frags);\n\tinet_frags_init(&nf_frags);\n\n\treturn 0;\n}\n",
        "linevul": 8.140792488120496e-05,
        "sysevr": 0.20670552551746368,
        "devign": 5.458833001104795e-15
    },
    {
        "code": "static void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs)\n{\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (re) {\n\t\tstruct xfrm_replay_state_esn *replay_esn;\n\t\treplay_esn = nla_data(re);\n\t\tmemcpy(x->replay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t\tmemcpy(x->preplay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t}\n\n\tif (rp) {\n\t\tstruct xfrm_replay_state *replay;\n\t\treplay = nla_data(rp);\n\t\tmemcpy(&x->replay, replay, sizeof(*replay));\n\t\tmemcpy(&x->preplay, replay, sizeof(*replay));\n\t}\n\n\tif (lt) {\n\t\tstruct xfrm_lifetime_cur *ltime;\n\t\tltime = nla_data(lt);\n\t\tx->curlft.bytes = ltime->bytes;\n\t\tx->curlft.packets = ltime->packets;\n\t\tx->curlft.add_time = ltime->add_time;\n\t\tx->curlft.use_time = ltime->use_time;\n\t}\n\n\tif (et)\n\t\tx->replay_maxage = nla_get_u32(et);\n\n\tif (rt)\n\t\tx->replay_maxdiff = nla_get_u32(rt);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs)\n{\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (re) {\n\t\tstruct xfrm_replay_state_esn *replay_esn;\n\t\treplay_esn = nla_data(re);\n\t\tmemcpy(x->replay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t\tmemcpy(x->preplay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t}\n\n\tif (rp) {\n\t\tstruct xfrm_replay_state *replay;\n\t\treplay = nla_data(rp);\n\t\tmemcpy(&x->replay, replay, sizeof(*replay));\n\t\tmemcpy(&x->preplay, replay, sizeof(*replay));\n\t}\n\n\tif (lt) {\n\t\tstruct xfrm_lifetime_cur *ltime;\n\t\tltime = nla_data(lt);\n\t\tx->curlft.bytes = ltime->bytes;\n\t\tx->curlft.packets = ltime->packets;\n\t\tx->curlft.add_time = ltime->add_time;\n\t\tx->curlft.use_time = ltime->use_time;\n\t}\n\n\tif (et)\n\t\tx->replay_maxage = nla_get_u32(et);\n\n\tif (rt)\n\t\tx->replay_maxdiff = nla_get_u32(rt);\n}\n",
        "linevul": 5.68354589631781e-05,
        "sysevr": 0.16652025282382965,
        "devign": 3.6684046204867195e-19
    },
    {
        "code": "vsock_stream_recvmsg(struct kiocb *kiocb,\n\t\t     struct socket *sock,\n\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tint err;\n\tsize_t target;\n\tssize_t copied;\n\tlong timeout;\n\tstruct vsock_transport_recv_notify_data recv_data;\n\n\tDEFINE_WAIT(wait);\n\n\tsk = sock->sk;\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\n\t\t/* Recvmsg is supposed to return 0 if a peer performs an\n\t\t * orderly shutdown. Differentiate between that case and when a\n\t\t * peer has not connected or a local shutdown occured with the\n\t\t * SOCK_DONE flag.\n\t\t */\n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -ENOTCONN;\n\n\t\tgoto out;\n\t}\n\n\tif (flags & MSG_OOB) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* We don't check peer_shutdown flag here since peer may actually shut\n\t * down, but there can be data in the queue that a local socket can\n\t * receive.\n\t */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* It is valid on Linux to pass in a zero-length receive buffer.  This\n\t * is not an error.  We may as well bail out now.\n\t */\n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* We must not copy less than target bytes into the user's buffer\n\t * before returning successfully, so we wait for the consume queue to\n\t * have that much data to consume before dequeueing.  Note that this\n\t * makes it impossible to handle cases where target is greater than the\n\t * queue size.\n\t */\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tif (target >= transport->stream_rcvhiwat(vsk)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tcopied = 0;\n\n\terr = transport->notify_recv_init(vsk, target, &recv_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\twhile (1) {\n\t\ts64 ready = vsock_stream_has_data(vsk);\n\n\t\tif (ready < 0) {\n\t\t\t/* Invalid queue pair content. XXX This should be\n\t\t\t * changed to a connection reset in a later change.\n\t\t\t */\n\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_wait;\n\t\t} else if (ready > 0) {\n\t\t\tssize_t read;\n\n\t\t\terr = transport->notify_recv_pre_dequeue(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\tread = transport->stream_dequeue(\n\t\t\t\t\tvsk, msg->msg_iov,\n\t\t\t\t\tlen - copied, flags);\n\t\t\tif (read < 0) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopied += read;\n\n\t\t\terr = transport->notify_recv_post_dequeue(\n\t\t\t\t\tvsk, target, read,\n\t\t\t\t\t!(flags & MSG_PEEK), &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_wait;\n\n\t\t\tif (read >= target || flags & MSG_PEEK)\n\t\t\t\tbreak;\n\n\t\t\ttarget -= read;\n\t\t} else {\n\t\t\tif (sk->sk_err != 0 || (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t    || (vsk->peer_shutdown & SEND_SHUTDOWN)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Don't wait for non-blocking sockets. */\n\t\t\tif (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_block(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tlock_sock(sk);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeout);\n\t\t\t\tbreak;\n\t\t\t} else if (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t}\n\t}\n\n\tif (sk->sk_err)\n\t\terr = -sk->sk_err;\n\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\terr = 0;\n\n\tif (copied > 0) {\n\t\t/* We only do these additional bookkeeping/notification steps\n\t\t * if we actually copied something out of the queue pair\n\t\t * instead of just peeking ahead.\n\t\t */\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\t/* If the other side has shutdown for sending and there\n\t\t\t * is nothing more to read, then modify the socket\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (vsk->peer_shutdown & SEND_SHUTDOWN) {\n\t\t\t\tif (vsock_stream_has_data(vsk) <= 0) {\n\t\t\t\t\tsk->sk_state = SS_UNCONNECTED;\n\t\t\t\t\tsock_set_flag(sk, SOCK_DONE);\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = copied;\n\t}\n\nout_wait:\n\tfinish_wait(sk_sleep(sk), &wait);\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "vsock_stream_recvmsg(struct kiocb *kiocb,\n\t\t     struct socket *sock,\n\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tint err;\n\tsize_t target;\n\tssize_t copied;\n\tlong timeout;\n\tstruct vsock_transport_recv_notify_data recv_data;\n\n\tDEFINE_WAIT(wait);\n\n\tsk = sock->sk;\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n//flaw_line_below:\n\tmsg->msg_namelen = 0;\n//flaw_line_below:\n\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\n\t\t/* Recvmsg is supposed to return 0 if a peer performs an\n\t\t * orderly shutdown. Differentiate between that case and when a\n\t\t * peer has not connected or a local shutdown occured with the\n\t\t * SOCK_DONE flag.\n\t\t */\n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -ENOTCONN;\n\n\t\tgoto out;\n\t}\n\n\tif (flags & MSG_OOB) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* We don't check peer_shutdown flag here since peer may actually shut\n\t * down, but there can be data in the queue that a local socket can\n\t * receive.\n\t */\n\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* It is valid on Linux to pass in a zero-length receive buffer.  This\n\t * is not an error.  We may as well bail out now.\n\t */\n\tif (!len) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* We must not copy less than target bytes into the user's buffer\n\t * before returning successfully, so we wait for the consume queue to\n\t * have that much data to consume before dequeueing.  Note that this\n\t * makes it impossible to handle cases where target is greater than the\n\t * queue size.\n\t */\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\tif (target >= transport->stream_rcvhiwat(vsk)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tcopied = 0;\n\n\terr = transport->notify_recv_init(vsk, target, &recv_data);\n\tif (err < 0)\n\t\tgoto out;\n\n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\twhile (1) {\n\t\ts64 ready = vsock_stream_has_data(vsk);\n\n\t\tif (ready < 0) {\n\t\t\t/* Invalid queue pair content. XXX This should be\n\t\t\t * changed to a connection reset in a later change.\n\t\t\t */\n\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_wait;\n\t\t} else if (ready > 0) {\n\t\t\tssize_t read;\n\n\t\t\terr = transport->notify_recv_pre_dequeue(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\tread = transport->stream_dequeue(\n\t\t\t\t\tvsk, msg->msg_iov,\n\t\t\t\t\tlen - copied, flags);\n\t\t\tif (read < 0) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopied += read;\n\n\t\t\terr = transport->notify_recv_post_dequeue(\n\t\t\t\t\tvsk, target, read,\n\t\t\t\t\t!(flags & MSG_PEEK), &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_wait;\n\n\t\t\tif (read >= target || flags & MSG_PEEK)\n\t\t\t\tbreak;\n\n\t\t\ttarget -= read;\n\t\t} else {\n\t\t\tif (sk->sk_err != 0 || (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t    || (vsk->peer_shutdown & SEND_SHUTDOWN)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Don't wait for non-blocking sockets. */\n\t\t\tif (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = transport->notify_recv_pre_block(\n\t\t\t\t\tvsk, target, &recv_data);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tlock_sock(sk);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeout);\n\t\t\t\tbreak;\n\t\t\t} else if (timeout == 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t}\n\t}\n\n\tif (sk->sk_err)\n\t\terr = -sk->sk_err;\n\telse if (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\terr = 0;\n\n\tif (copied > 0) {\n\t\t/* We only do these additional bookkeeping/notification steps\n\t\t * if we actually copied something out of the queue pair\n\t\t * instead of just peeking ahead.\n\t\t */\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\t/* If the other side has shutdown for sending and there\n\t\t\t * is nothing more to read, then modify the socket\n\t\t\t * state.\n\t\t\t */\n\t\t\tif (vsk->peer_shutdown & SEND_SHUTDOWN) {\n\t\t\t\tif (vsock_stream_has_data(vsk) <= 0) {\n\t\t\t\t\tsk->sk_state = SS_UNCONNECTED;\n\t\t\t\t\tsock_set_flag(sk, SOCK_DONE);\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = copied;\n\t}\n\nout_wait:\n\tfinish_wait(sk_sleep(sk), &wait);\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "linevul": 0.9994644522666931,
        "sysevr": 0.28868037462234497,
        "devign": 0.9999970197677612
    },
    {
        "code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \n \t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9824dfae5741275473a23a7ed5756c7b6efacc9d",
        "vul_func_with_fix": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                 case SIOCFINDIPDDPRT:\n \t\t\tspin_lock_bh(&ipddp_route_lock);\n \t\t\trp = __ipddp_find_route(&rcp);\n//flaw_line_below:\n\t\t\tif (rp)\n//flaw_line_below:\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n//fix_flaw_line_below:\n//\t\t\tif (rp) {\n//fix_flaw_line_below:\n//\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n//fix_flaw_line_below:\n//\t\t\t\trcp2.ip    = rp->ip;\n//fix_flaw_line_below:\n//\t\t\t\trcp2.at    = rp->at;\n//fix_flaw_line_below:\n//\t\t\t\trcp2.flags = rp->flags;\n//fix_flaw_line_below:\n//\t\t\t}\n \t\t\tspin_unlock_bh(&ipddp_route_lock);\n \n \t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n",
        "linevul": 0.016714435070753098,
        "sysevr": 0.1213221400976181,
        "devign": 0.9963403940200806
    },
    {
        "code": "void svc_printk(struct svc_rqst *rqstp, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tchar \tbuf[RPC_MAX_ADDRBUFLEN];\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tdprintk(\"svc: %s: %pV\", svc_print_addr(rqstp, buf, sizeof(buf)), &vaf);\n\n\tva_end(args);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "void svc_printk(struct svc_rqst *rqstp, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tchar \tbuf[RPC_MAX_ADDRBUFLEN];\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tdprintk(\"svc: %s: %pV\", svc_print_addr(rqstp, buf, sizeof(buf)), &vaf);\n\n\tva_end(args);\n}\n",
        "linevul": 7.035705493763089e-05,
        "sysevr": 0.16161513328552246,
        "devign": 8.202915551436534e-20
    },
    {
        "code": "static int tx_active(struct edgeport_port *port)\n{\n\tint status;\n\tstruct out_endpoint_desc_block *oedb;\n\t__u8 *lsr;\n\tint bytes_left = 0;\n\n\toedb = kmalloc(sizeof(*oedb), GFP_KERNEL);\n\tif (!oedb) {\n\t\tdev_err(&port->port->dev, \"%s - out of memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tlsr = kmalloc(1, GFP_KERNEL);\t/* Sigh, that's right, just one byte,\n\t\t\t\t\t   as not all platforms can do DMA\n\t\t\t\t\t   from stack */\n\tif (!lsr) {\n\t\tkfree(oedb);\n\t\treturn -ENOMEM;\n\t}\n\t/* Read the DMA Count Registers */\n\tstatus = read_ram(port->port->serial->dev, port->dma_address,\n\t\t\t\t\t\tsizeof(*oedb), (void *)oedb);\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\n\tdev_dbg(&port->port->dev, \"%s - XByteCount    0x%X\\n\", __func__, oedb->XByteCount);\n\n\t/* and the LSR */\n\tstatus = read_ram(port->port->serial->dev,\n\t\t\tport->uart_base + UMPMEM_OFFS_UART_LSR, 1, lsr);\n\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\tdev_dbg(&port->port->dev, \"%s - LSR = 0x%X\\n\", __func__, *lsr);\n\n\t/* If either buffer has data or we are transmitting then return TRUE */\n\tif ((oedb->XByteCount & 0x80) != 0)\n\t\tbytes_left += 64;\n\n\tif ((*lsr & UMP_UART_LSR_TX_MASK) == 0)\n\t\tbytes_left += 1;\n\n\t/* We return Not Active if we get any kind of error */\nexit_is_tx_active:\n\tdev_dbg(&port->port->dev, \"%s - return %d\\n\", __func__, bytes_left);\n\n\tkfree(lsr);\n\tkfree(oedb);\n\treturn bytes_left;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811",
        "vul_func_with_fix": "static int tx_active(struct edgeport_port *port)\n{\n\tint status;\n\tstruct out_endpoint_desc_block *oedb;\n\t__u8 *lsr;\n\tint bytes_left = 0;\n\n\toedb = kmalloc(sizeof(*oedb), GFP_KERNEL);\n\tif (!oedb) {\n\t\tdev_err(&port->port->dev, \"%s - out of memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tlsr = kmalloc(1, GFP_KERNEL);\t/* Sigh, that's right, just one byte,\n\t\t\t\t\t   as not all platforms can do DMA\n\t\t\t\t\t   from stack */\n\tif (!lsr) {\n\t\tkfree(oedb);\n\t\treturn -ENOMEM;\n\t}\n\t/* Read the DMA Count Registers */\n\tstatus = read_ram(port->port->serial->dev, port->dma_address,\n\t\t\t\t\t\tsizeof(*oedb), (void *)oedb);\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\n\tdev_dbg(&port->port->dev, \"%s - XByteCount    0x%X\\n\", __func__, oedb->XByteCount);\n\n\t/* and the LSR */\n\tstatus = read_ram(port->port->serial->dev,\n\t\t\tport->uart_base + UMPMEM_OFFS_UART_LSR, 1, lsr);\n\n\tif (status)\n\t\tgoto exit_is_tx_active;\n\tdev_dbg(&port->port->dev, \"%s - LSR = 0x%X\\n\", __func__, *lsr);\n\n\t/* If either buffer has data or we are transmitting then return TRUE */\n\tif ((oedb->XByteCount & 0x80) != 0)\n\t\tbytes_left += 64;\n\n\tif ((*lsr & UMP_UART_LSR_TX_MASK) == 0)\n\t\tbytes_left += 1;\n\n\t/* We return Not Active if we get any kind of error */\nexit_is_tx_active:\n\tdev_dbg(&port->port->dev, \"%s - return %d\\n\", __func__, bytes_left);\n\n\tkfree(lsr);\n\tkfree(oedb);\n\treturn bytes_left;\n}\n",
        "linevul": 6.009061326039955e-05,
        "sysevr": 0.17877337336540222,
        "devign": 1.011991494161746e-24
    },
    {
        "code": "static void do_unhandled_exception(int trapnr, int signr, char *str, char *fn_name,\n\t\tunsigned long error_code, struct pt_regs *regs, struct task_struct *tsk)\n{\n\tshow_excp_regs(fn_name, trapnr, signr, regs);\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_no = trapnr;\n\n\tif (user_mode(regs))\n\t\tforce_sig(signr, tsk);\n\n\tdie_if_no_fixup(str, regs, error_code);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void do_unhandled_exception(int trapnr, int signr, char *str, char *fn_name,\n\t\tunsigned long error_code, struct pt_regs *regs, struct task_struct *tsk)\n{\n\tshow_excp_regs(fn_name, trapnr, signr, regs);\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_no = trapnr;\n\n\tif (user_mode(regs))\n\t\tforce_sig(signr, tsk);\n\n\tdie_if_no_fixup(str, regs, error_code);\n}\n",
        "linevul": 4.9143811338581145e-05,
        "sysevr": 0.15109293162822723,
        "devign": 1.4267290690886392e-12
    },
    {
        "code": "static int napi_gro_complete(struct sk_buff *skb)\n{\n\tstruct packet_offload *ptype;\n\t__be16 type = skb->protocol;\n\tstruct list_head *head = &offload_base;\n\tint err = -ENOENT;\n\n\tBUILD_BUG_ON(sizeof(struct napi_gro_cb) > sizeof(skb->cb));\n\n\tif (NAPI_GRO_CB(skb)->count == 1) {\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, head, list) {\n\t\tif (ptype->type != type || !ptype->callbacks.gro_complete)\n\t\t\tcontinue;\n\n\t\terr = ptype->callbacks.gro_complete(skb, 0);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (err) {\n\t\tWARN_ON(&ptype->list == head);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\nout:\n\treturn netif_receive_skb_internal(skb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
        "vul_func_with_fix": "static int napi_gro_complete(struct sk_buff *skb)\n{\n\tstruct packet_offload *ptype;\n\t__be16 type = skb->protocol;\n\tstruct list_head *head = &offload_base;\n\tint err = -ENOENT;\n\n\tBUILD_BUG_ON(sizeof(struct napi_gro_cb) > sizeof(skb->cb));\n\n\tif (NAPI_GRO_CB(skb)->count == 1) {\n\t\tskb_shinfo(skb)->gso_size = 0;\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, head, list) {\n\t\tif (ptype->type != type || !ptype->callbacks.gro_complete)\n\t\t\tcontinue;\n\n\t\terr = ptype->callbacks.gro_complete(skb, 0);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (err) {\n\t\tWARN_ON(&ptype->list == head);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\nout:\n\treturn netif_receive_skb_internal(skb);\n}\n",
        "linevul": 6.792177737224847e-05,
        "sysevr": 0.14934797585010529,
        "devign": 3.500955783498086e-16
    },
    {
        "code": "xfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n \t\t\t\t\tsbp->namelen,\n \t\t\t\t\tsbp->valuelen,\n \t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n \t\t\treturn error;\n \t\tif (context->seen_enough)\n \t\t\tbreak;\n \t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f",
        "vul_func_with_fix": "xfs_attr_shortform_list(xfs_attr_list_context_t *context)\n{\n\tattrlist_cursor_kern_t *cursor;\n\txfs_attr_sf_sort_t *sbuf, *sbp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_inode_t *dp;\n\tint sbsize, nsbuf, count, i;\n\tint error;\n\n\tASSERT(context != NULL);\n\tdp = context->dp;\n\tASSERT(dp != NULL);\n\tASSERT(dp->i_afp != NULL);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tASSERT(sf != NULL);\n\tif (!sf->hdr.count)\n\t\treturn 0;\n\tcursor = context->cursor;\n\tASSERT(cursor != NULL);\n\n\ttrace_xfs_attr_list_sf(context);\n\n\t/*\n\t * If the buffer is large enough and the cursor is at the start,\n\t * do not bother with sorting since we will return everything in\n\t * one buffer and another call using the cursor won't need to be\n\t * made.\n\t * Note the generous fudge factor of 16 overhead bytes per entry.\n\t * If bufsize is zero then put_listent must be a search function\n\t * and can just scan through what we have.\n\t */\n\tif (context->bufsize == 0 ||\n\t    (XFS_ISRESET_CURSOR(cursor) &&\n             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\n\t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\t\terror = context->put_listent(context,\n\t\t\t\t\t   sfe->flags,\n\t\t\t\t\t   sfe->nameval,\n\t\t\t\t\t   (int)sfe->namelen,\n\t\t\t\t\t   (int)sfe->valuelen,\n\t\t\t\t\t   &sfe->nameval[sfe->namelen]);\n\n\t\t\t/*\n\t\t\t * Either search callback finished early or\n\t\t\t * didn't fit it all in the buffer after all.\n\t\t\t */\n\t\t\tif (context->seen_enough)\n\t\t\t\tbreak;\n\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\t}\n\t\ttrace_xfs_attr_list_sf_all(context);\n\t\treturn 0;\n\t}\n\n\t/* do no more for a search callback */\n\tif (context->bufsize == 0)\n\t\treturn 0;\n\n\t/*\n\t * It didn't all fit, so we have to sort everything on hashval.\n\t */\n\tsbsize = sf->hdr.count * sizeof(*sbuf);\n\tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\n\n\t/*\n\t * Scan the attribute list for the rest of the entries, storing\n\t * the relevant info from only those that match into a buffer.\n\t */\n\tnsbuf = 0;\n\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\n\t\tif (unlikely(\n\t\t    ((char *)sfe < (char *)sf) ||\n\t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     context->dp->i_mount, sfe);\n\t\t\tkmem_free(sbuf);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tsbp->entno = i;\n\t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\n\t\tsbp->name = sfe->nameval;\n\t\tsbp->namelen = sfe->namelen;\n\t\t/* These are bytes, and both on-disk, don't endian-flip */\n\t\tsbp->valuelen = sfe->valuelen;\n\t\tsbp->flags = sfe->flags;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t\tsbp++;\n\t\tnsbuf++;\n\t}\n\n\t/*\n\t * Sort the entries on hash then entno.\n\t */\n\txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\n\n\t/*\n\t * Re-find our place IN THE SORTED LIST.\n\t */\n\tcount = 0;\n\tcursor->initted = 1;\n\tcursor->blkno = 0;\n\tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\n\t\tif (sbp->hash == cursor->hashval) {\n\t\t\tif (cursor->offset == count) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} else if (sbp->hash > cursor->hashval) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == nsbuf) {\n\t\tkmem_free(sbuf);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop putting entries into the user buffer.\n\t */\n\tfor ( ; i < nsbuf; i++, sbp++) {\n\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n \t\t\t\t\tsbp->namelen,\n \t\t\t\t\tsbp->valuelen,\n \t\t\t\t\t&sbp->name[sbp->namelen]);\n//flaw_line_below:\n\t\tif (error)\n//fix_flaw_line_below:\n//\t\tif (error) {\n//fix_flaw_line_below:\n//\t\t\tkmem_free(sbuf);\n \t\t\treturn error;\n//fix_flaw_line_below:\n//\t\t}\n \t\tif (context->seen_enough)\n \t\t\tbreak;\n \t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}\n",
        "linevul": 0.0017252586549147964,
        "sysevr": 0.24948155879974365,
        "devign": 2.735640047824006e-10
    },
    {
        "code": "brcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_pktcnt_le pktcnt;\n\ts32 err;\n\tu32 rate;\n\tu32 rssi;\n\n\t/* Get the current tx rate */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);\n\tif (err < 0) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RATE error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\n\tsinfo->txrate.legacy = rate * 5;\n\n\tmemset(&scbval, 0, sizeof(scbval));\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,\n\t\t\t\t     sizeof(scbval));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RSSI error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\trssi = le32_to_cpu(scbval.val);\n\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = rssi;\n\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,\n\t\t\t\t     sizeof(pktcnt));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_GET_PKTCNTS error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_RX_DROP_MISC) |\n\t\t\t BIT(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_TX_FAILED);\n\tsinfo->rx_packets = le32_to_cpu(pktcnt.rx_good_pkt);\n\tsinfo->rx_dropped_misc = le32_to_cpu(pktcnt.rx_bad_pkt);\n\tsinfo->tx_packets = le32_to_cpu(pktcnt.tx_good_pkt);\n\tsinfo->tx_failed  = le32_to_cpu(pktcnt.tx_bad_pkt);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ded89912156b1a47d940a0c954c43afbabd0c42c",
        "vul_func_with_fix": "brcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_pktcnt_le pktcnt;\n\ts32 err;\n\tu32 rate;\n\tu32 rssi;\n\n\t/* Get the current tx rate */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);\n\tif (err < 0) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RATE error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\n\tsinfo->txrate.legacy = rate * 5;\n\n\tmemset(&scbval, 0, sizeof(scbval));\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,\n\t\t\t\t     sizeof(scbval));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_RSSI error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\trssi = le32_to_cpu(scbval.val);\n\tsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = rssi;\n\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,\n\t\t\t\t     sizeof(pktcnt));\n\tif (err) {\n\t\tbrcmf_err(\"BRCMF_C_GET_GET_PKTCNTS error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_RX_DROP_MISC) |\n\t\t\t BIT(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t BIT(NL80211_STA_INFO_TX_FAILED);\n\tsinfo->rx_packets = le32_to_cpu(pktcnt.rx_good_pkt);\n\tsinfo->rx_dropped_misc = le32_to_cpu(pktcnt.rx_bad_pkt);\n\tsinfo->tx_packets = le32_to_cpu(pktcnt.tx_good_pkt);\n\tsinfo->tx_failed  = le32_to_cpu(pktcnt.tx_bad_pkt);\n\n\treturn 0;\n}\n",
        "linevul": 4.7317233111243695e-05,
        "sysevr": 0.2346150279045105,
        "devign": 2.93870518254723e-29
    },
    {
        "code": "struct cpumask *blk_mq_tags_cpumask(struct blk_mq_tags *tags)\n{\n\treturn tags->cpumask;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9",
        "vul_func_with_fix": "struct cpumask *blk_mq_tags_cpumask(struct blk_mq_tags *tags)\n{\n\treturn tags->cpumask;\n}\n",
        "linevul": 8.51481527206488e-05,
        "sysevr": 0.1432364284992218,
        "devign": 0.007260127458721399
    },
    {
        "code": " static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n {\n \tstruct flakey_c *fc = ti->private;\n \n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462",
        "vul_func_with_fix": " static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n {\n \tstruct flakey_c *fc = ti->private;\n//fix_flaw_line_below:\n//\tstruct dm_dev *dev = fc->dev;\n//fix_flaw_line_below:\n//\tint r = 0;\n \n//flaw_line_below:\n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n//fix_flaw_line_below:\n//\t/*\n//fix_flaw_line_below:\n//\t * Only pass ioctls through if the device sizes match exactly.\n//fix_flaw_line_below:\n//\t */\n//fix_flaw_line_below:\n//\tif (fc->start ||\n//fix_flaw_line_below:\n//\t    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\n//fix_flaw_line_below:\n//\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\n }\n",
        "linevul": 0.9983689188957214,
        "sysevr": 0.12985628843307495,
        "devign": 0.9878033995628357
    },
    {
        "code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\t/* Walk through the list of cached ASCONF-ACKs and find the\n\t * ack chunk whose serial number matches that of the request.\n\t */\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa",
        "vul_func_with_fix": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\t/* Walk through the list of cached ASCONF-ACKs and find the\n\t * ack chunk whose serial number matches that of the request.\n\t */\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "linevul": 5.078477624920197e-05,
        "sysevr": 0.20295779407024384,
        "devign": 2.8651445518335095e-06
    },
    {
        "code": "int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t    struct kvm_io_device *dev)\n{\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tbus = kvm->buses[bus_idx];\n\tif (bus->dev_count > NR_IOBUS_DEVS-1)\n\t\treturn -ENOSPC;\n\n\tnew_bus = kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\tmemcpy(new_bus, bus, sizeof(struct kvm_io_bus));\n\tnew_bus->devs[new_bus->dev_count++] = dev;\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e",
        "vul_func_with_fix": "int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t    struct kvm_io_device *dev)\n{\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tbus = kvm->buses[bus_idx];\n\tif (bus->dev_count > NR_IOBUS_DEVS-1)\n\t\treturn -ENOSPC;\n\n\tnew_bus = kzalloc(sizeof(struct kvm_io_bus), GFP_KERNEL);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\tmemcpy(new_bus, bus, sizeof(struct kvm_io_bus));\n\tnew_bus->devs[new_bus->dev_count++] = dev;\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\n\treturn 0;\n}\n",
        "linevul": 4.870835618930869e-05,
        "sysevr": 0.15405572950839996,
        "devign": 0.01743626594543457
    },
    {
        "code": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tvcpu_load(vcpu);\n\tr = kvm_arch_vcpu_reset(vcpu);\n\tif (r == 0)\n\t\tr = kvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\tif (r < 0)\n\t\tgoto free_vcpu;\n\n\treturn 0;\nfree_vcpu:\n\tkvm_x86_ops->vcpu_free(vcpu);\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fc3a9157d3148ab91039c75423da8ef97be3e105",
        "vul_func_with_fix": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tvcpu_load(vcpu);\n\tr = kvm_arch_vcpu_reset(vcpu);\n\tif (r == 0)\n\t\tr = kvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\tif (r < 0)\n\t\tgoto free_vcpu;\n\n\treturn 0;\nfree_vcpu:\n\tkvm_x86_ops->vcpu_free(vcpu);\n\treturn r;\n}\n",
        "linevul": 4.742298915516585e-05,
        "sysevr": 0.15392881631851196,
        "devign": 0.008906158618628979
    },
    {
        "code": "void rpc_free(void *buffer)\n{\n\tsize_t size;\n\tstruct rpc_buffer *buf;\n\n\tif (!buffer)\n\t\treturn;\n\n\tbuf = container_of(buffer, struct rpc_buffer, data);\n\tsize = buf->len;\n\n\tdprintk(\"RPC:       freeing buffer of size %zu at %p\\n\",\n\t\t\tsize, buf);\n\n\tif (size <= RPC_BUFFER_MAXSIZE)\n\t\tmempool_free(buf, rpc_buffer_mempool);\n\telse\n\t\tkfree(buf);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f",
        "vul_func_with_fix": "void rpc_free(void *buffer)\n{\n\tsize_t size;\n\tstruct rpc_buffer *buf;\n\n\tif (!buffer)\n\t\treturn;\n\n\tbuf = container_of(buffer, struct rpc_buffer, data);\n\tsize = buf->len;\n\n\tdprintk(\"RPC:       freeing buffer of size %zu at %p\\n\",\n\t\t\tsize, buf);\n\n\tif (size <= RPC_BUFFER_MAXSIZE)\n\t\tmempool_free(buf, rpc_buffer_mempool);\n\telse\n\t\tkfree(buf);\n}\n",
        "linevul": 5.087163663120009e-05,
        "sysevr": 0.16764195263385773,
        "devign": 5.644025828296928e-13
    },
    {
        "code": "static ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\ttrace_nfs4_get_acl(inode, ret);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\ttrace_nfs4_get_acl(inode, ret);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n",
        "linevul": 5.9420486650196835e-05,
        "sysevr": 0.12422649562358856,
        "devign": 3.8493190466848453e-23
    },
    {
        "code": "static void __always_inline vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static void __always_inline vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}\n",
        "linevul": 5.6391356338281184e-05,
        "sysevr": 0.16095420718193054,
        "devign": 0.6544154286384583
    },
    {
        "code": "static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_dentry_info *root_info;\n \tconst char *err = \"Getting sb failed\";\n \tstruct inode *inode;\n \tstruct path path;\n \tint rc;\n \n \tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n \t\tgoto out;\n \t}\n \n\trc = ecryptfs_parse_options(sbi, raw_data);\n \tif (rc) {\n \t\terr = \"Error parsing options\";\n \t\tgoto out;\n\t}\n\n\ts = sget(fs_type, NULL, set_anon_super, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\ts->s_flags = flags;\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n \t\t\t\"known incompatibilities\\n\");\n \t\tgoto out_free;\n \t}\n \tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_alloc_root(inode);\n\tif (!s->s_root) {\n\t\tiput(inode);\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\tecryptfs_set_dentry_lower(s->s_root, path.dentry);\n\tecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97",
        "vul_func_with_fix": "static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,\n\t\t\tconst char *dev_name, void *raw_data)\n{\n\tstruct super_block *s;\n\tstruct ecryptfs_sb_info *sbi;\n\tstruct ecryptfs_dentry_info *root_info;\n \tconst char *err = \"Getting sb failed\";\n \tstruct inode *inode;\n \tstruct path path;\n//fix_flaw_line_below:\n//\tuid_t check_ruid;\n \tint rc;\n \n \tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n\tif (!sbi) {\n\t\trc = -ENOMEM;\n \t\tgoto out;\n \t}\n \n//flaw_line_below:\n\trc = ecryptfs_parse_options(sbi, raw_data);\n//fix_flaw_line_below:\n//\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n \tif (rc) {\n \t\terr = \"Error parsing options\";\n \t\tgoto out;\n\t}\n\n\ts = sget(fs_type, NULL, set_anon_super, NULL);\n\tif (IS_ERR(s)) {\n\t\trc = PTR_ERR(s);\n\t\tgoto out;\n\t}\n\n\ts->s_flags = flags;\n\trc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\tgoto out1;\n\n\tecryptfs_set_superblock_private(s, sbi);\n\ts->s_bdi = &sbi->bdi;\n\n\t/* ->kill_sb() will take care of sbi after that point */\n\tsbi = NULL;\n\ts->s_op = &ecryptfs_sops;\n\ts->s_d_op = &ecryptfs_dops;\n\n\terr = \"Reading sb failed\";\n\trc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");\n\t\tgoto out1;\n\t}\n\tif (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Mount on filesystem of type \"\n\t\t\t\"eCryptfs explicitly disallowed due to \"\n \t\t\t\"known incompatibilities\\n\");\n \t\tgoto out_free;\n \t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {\n//fix_flaw_line_below:\n//\t\trc = -EPERM;\n//fix_flaw_line_below:\n//\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n//fix_flaw_line_below:\n//\t\t       \"requested user (uid: %d)\\n\",\n//fix_flaw_line_below:\n//\t\t       path.dentry->d_inode->i_uid, current_uid());\n//fix_flaw_line_below:\n//\t\tgoto out_free;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n\ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n\n\tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n\trc = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_free;\n\n\ts->s_root = d_alloc_root(inode);\n\tif (!s->s_root) {\n\t\tiput(inode);\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = -ENOMEM;\n\troot_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);\n\tif (!root_info)\n\t\tgoto out_free;\n\n\t/* ->kill_sb() will take care of root_info */\n\tecryptfs_set_dentry_private(s->s_root, root_info);\n\tecryptfs_set_dentry_lower(s->s_root, path.dentry);\n\tecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);\n\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nout_free:\n\tpath_put(&path);\nout1:\n\tdeactivate_locked_super(s);\nout:\n\tif (sbi) {\n\t\tecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);\n\t\tkmem_cache_free(ecryptfs_sb_info_cache, sbi);\n\t}\n\tprintk(KERN_ERR \"%s; rc = [%d]\\n\", err, rc);\n\treturn ERR_PTR(rc);\n}\n",
        "linevul": 0.9995406866073608,
        "sysevr": 0.1765032559633255,
        "devign": 0.9991006851196289
    },
    {
        "code": "int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct i387_fxsave_struct *fxsave =\n\t\t\t&vcpu->arch.guest_fpu.state->fxsave;\n\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof fxsave->xmm_space);\n\n\treturn 0;\n}\n",
        "linevul": 4.941416045767255e-05,
        "sysevr": 0.18695852160453796,
        "devign": 3.156558747718918e-08
    },
    {
        "code": "static int qib_do_user_init(struct file *fp,\n\t\t\t    const struct qib_user_info *uinfo)\n{\n\tint ret;\n\tstruct qib_ctxtdata *rcd = ctxt_fp(fp);\n\tstruct qib_devdata *dd;\n\tunsigned uctxt;\n\n\t/* Subctxts don't need to initialize anything since master did it. */\n\tif (subctxt_fp(fp)) {\n\t\tret = wait_event_interruptible(rcd->wait,\n\t\t\t!test_bit(QIB_CTXT_MASTER_UNINIT, &rcd->flag));\n\t\tgoto bail;\n\t}\n\n\tdd = rcd->dd;\n\n\t/* some ctxts may get extra buffers, calculate that here */\n\tuctxt = rcd->ctxt - dd->first_user_ctxt;\n\tif (uctxt < dd->ctxts_extrabuf) {\n\t\trcd->piocnt = dd->pbufsctxt + 1;\n\t\trcd->pio_base = rcd->piocnt * uctxt;\n\t} else {\n\t\trcd->piocnt = dd->pbufsctxt;\n\t\trcd->pio_base = rcd->piocnt * uctxt +\n\t\t\tdd->ctxts_extrabuf;\n\t}\n\n\t/*\n\t * All user buffers are 2KB buffers.  If we ever support\n\t * giving 4KB buffers to user processes, this will need some\n\t * work.  Can't use piobufbase directly, because it has\n\t * both 2K and 4K buffer base values.  So check and handle.\n\t */\n\tif ((rcd->pio_base + rcd->piocnt) > dd->piobcnt2k) {\n\t\tif (rcd->pio_base >= dd->piobcnt2k) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t    \"%u:ctxt%u: no 2KB buffers available\\n\",\n\t\t\t\t    dd->unit, rcd->ctxt);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto bail;\n\t\t}\n\t\trcd->piocnt = dd->piobcnt2k - rcd->pio_base;\n\t\tqib_dev_err(dd, \"Ctxt%u: would use 4KB bufs, using %u\\n\",\n\t\t\t    rcd->ctxt, rcd->piocnt);\n\t}\n\n\trcd->piobufs = dd->pio2k_bufbase + rcd->pio_base * dd->palign;\n\tqib_chg_pioavailkernel(dd, rcd->pio_base, rcd->piocnt,\n\t\t\t       TXCHK_CHG_TYPE_USER, rcd);\n\t/*\n\t * try to ensure that processes start up with consistent avail update\n\t * for their own range, at least.   If system very quiet, it might\n\t * have the in-memory copy out of date at startup for this range of\n\t * buffers, when a context gets re-used.  Do after the chg_pioavail\n\t * and before the rest of setup, so it's \"almost certain\" the dma\n\t * will have occurred (can't 100% guarantee, but should be many\n\t * decimals of 9s, with this ordering), given how much else happens\n\t * after this.\n\t */\n\tdd->f_sendctrl(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\n\n\t/*\n\t * Now allocate the rcvhdr Q and eager TIDs; skip the TID\n\t * array for time being.  If rcd->ctxt > chip-supported,\n\t * we need to do extra stuff here to handle by handling overflow\n\t * through ctxt 0, someday\n\t */\n\tret = qib_create_rcvhdrq(dd, rcd);\n\tif (!ret)\n\t\tret = qib_setup_eagerbufs(rcd);\n\tif (ret)\n\t\tgoto bail_pio;\n\n\trcd->tidcursor = 0; /* start at beginning after open */\n\n\t/* initialize poll variables... */\n\trcd->urgent = 0;\n\trcd->urgent_poll = 0;\n\n\t/*\n\t * Now enable the ctxt for receive.\n\t * For chips that are set to DMA the tail register to memory\n\t * when they change (and when the update bit transitions from\n\t * 0 to 1.  So for those chips, we turn it off and then back on.\n\t * This will (very briefly) affect any other open ctxts, but the\n\t * duration is very short, and therefore isn't an issue.  We\n\t * explicitly set the in-memory tail copy to 0 beforehand, so we\n\t * don't have to wait to be sure the DMA update has happened\n\t * (chip resets head/tail to 0 on transition to enable).\n\t */\n\tif (rcd->rcvhdrtail_kvaddr)\n\t\tqib_clear_rcvhdrtail(rcd);\n\n\tdd->f_rcvctrl(rcd->ppd, QIB_RCVCTRL_CTXT_ENB | QIB_RCVCTRL_TIDFLOW_ENB,\n\t\t      rcd->ctxt);\n\n\t/* Notify any waiting slaves */\n\tif (rcd->subctxt_cnt) {\n\t\tclear_bit(QIB_CTXT_MASTER_UNINIT, &rcd->flag);\n\t\twake_up(&rcd->wait);\n\t}\n\treturn 0;\n\nbail_pio:\n\tqib_chg_pioavailkernel(dd, rcd->pio_base, rcd->piocnt,\n\t\t\t       TXCHK_CHG_TYPE_KERN, rcd);\nbail:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static int qib_do_user_init(struct file *fp,\n\t\t\t    const struct qib_user_info *uinfo)\n{\n\tint ret;\n\tstruct qib_ctxtdata *rcd = ctxt_fp(fp);\n\tstruct qib_devdata *dd;\n\tunsigned uctxt;\n\n\t/* Subctxts don't need to initialize anything since master did it. */\n\tif (subctxt_fp(fp)) {\n\t\tret = wait_event_interruptible(rcd->wait,\n\t\t\t!test_bit(QIB_CTXT_MASTER_UNINIT, &rcd->flag));\n\t\tgoto bail;\n\t}\n\n\tdd = rcd->dd;\n\n\t/* some ctxts may get extra buffers, calculate that here */\n\tuctxt = rcd->ctxt - dd->first_user_ctxt;\n\tif (uctxt < dd->ctxts_extrabuf) {\n\t\trcd->piocnt = dd->pbufsctxt + 1;\n\t\trcd->pio_base = rcd->piocnt * uctxt;\n\t} else {\n\t\trcd->piocnt = dd->pbufsctxt;\n\t\trcd->pio_base = rcd->piocnt * uctxt +\n\t\t\tdd->ctxts_extrabuf;\n\t}\n\n\t/*\n\t * All user buffers are 2KB buffers.  If we ever support\n\t * giving 4KB buffers to user processes, this will need some\n\t * work.  Can't use piobufbase directly, because it has\n\t * both 2K and 4K buffer base values.  So check and handle.\n\t */\n\tif ((rcd->pio_base + rcd->piocnt) > dd->piobcnt2k) {\n\t\tif (rcd->pio_base >= dd->piobcnt2k) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t    \"%u:ctxt%u: no 2KB buffers available\\n\",\n\t\t\t\t    dd->unit, rcd->ctxt);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto bail;\n\t\t}\n\t\trcd->piocnt = dd->piobcnt2k - rcd->pio_base;\n\t\tqib_dev_err(dd, \"Ctxt%u: would use 4KB bufs, using %u\\n\",\n\t\t\t    rcd->ctxt, rcd->piocnt);\n\t}\n\n\trcd->piobufs = dd->pio2k_bufbase + rcd->pio_base * dd->palign;\n\tqib_chg_pioavailkernel(dd, rcd->pio_base, rcd->piocnt,\n\t\t\t       TXCHK_CHG_TYPE_USER, rcd);\n\t/*\n\t * try to ensure that processes start up with consistent avail update\n\t * for their own range, at least.   If system very quiet, it might\n\t * have the in-memory copy out of date at startup for this range of\n\t * buffers, when a context gets re-used.  Do after the chg_pioavail\n\t * and before the rest of setup, so it's \"almost certain\" the dma\n\t * will have occurred (can't 100% guarantee, but should be many\n\t * decimals of 9s, with this ordering), given how much else happens\n\t * after this.\n\t */\n\tdd->f_sendctrl(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\n\n\t/*\n\t * Now allocate the rcvhdr Q and eager TIDs; skip the TID\n\t * array for time being.  If rcd->ctxt > chip-supported,\n\t * we need to do extra stuff here to handle by handling overflow\n\t * through ctxt 0, someday\n\t */\n\tret = qib_create_rcvhdrq(dd, rcd);\n\tif (!ret)\n\t\tret = qib_setup_eagerbufs(rcd);\n\tif (ret)\n\t\tgoto bail_pio;\n\n\trcd->tidcursor = 0; /* start at beginning after open */\n\n\t/* initialize poll variables... */\n\trcd->urgent = 0;\n\trcd->urgent_poll = 0;\n\n\t/*\n\t * Now enable the ctxt for receive.\n\t * For chips that are set to DMA the tail register to memory\n\t * when they change (and when the update bit transitions from\n\t * 0 to 1.  So for those chips, we turn it off and then back on.\n\t * This will (very briefly) affect any other open ctxts, but the\n\t * duration is very short, and therefore isn't an issue.  We\n\t * explicitly set the in-memory tail copy to 0 beforehand, so we\n\t * don't have to wait to be sure the DMA update has happened\n\t * (chip resets head/tail to 0 on transition to enable).\n\t */\n\tif (rcd->rcvhdrtail_kvaddr)\n\t\tqib_clear_rcvhdrtail(rcd);\n\n\tdd->f_rcvctrl(rcd->ppd, QIB_RCVCTRL_CTXT_ENB | QIB_RCVCTRL_TIDFLOW_ENB,\n\t\t      rcd->ctxt);\n\n\t/* Notify any waiting slaves */\n\tif (rcd->subctxt_cnt) {\n\t\tclear_bit(QIB_CTXT_MASTER_UNINIT, &rcd->flag);\n\t\twake_up(&rcd->wait);\n\t}\n\treturn 0;\n\nbail_pio:\n\tqib_chg_pioavailkernel(dd, rcd->pio_base, rcd->piocnt,\n\t\t\t       TXCHK_CHG_TYPE_KERN, rcd);\nbail:\n\treturn ret;\n}\n",
        "linevul": 9.30454334593378e-05,
        "sysevr": 0.19920775294303894,
        "devign": 2.4239534468506463e-07
    },
    {
        "code": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7",
        "vul_func_with_fix": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}\n",
        "linevul": 8.20582645246759e-05,
        "sysevr": 0.17600888013839722,
        "devign": 9.100072202272713e-05
    },
    {
        "code": "static void shutdown_smi(void *send_info)\n{\n\tstruct smi_info *smi_info = send_info;\n\n\tif (smi_info->dev_group_added) {\n\t\tdevice_remove_group(smi_info->io.dev, &ipmi_si_dev_attr_group);\n\t\tsmi_info->dev_group_added = false;\n\t}\n\tif (smi_info->io.dev)\n\t\tdev_set_drvdata(smi_info->io.dev, NULL);\n\n\t/*\n\t * Make sure that interrupts, the timer and the thread are\n\t * stopped and will not run again.\n\t */\n\tsmi_info->interrupt_disabled = true;\n\tif (smi_info->io.irq_cleanup) {\n\t\tsmi_info->io.irq_cleanup(&smi_info->io);\n\t\tsmi_info->io.irq_cleanup = NULL;\n\t}\n\tstop_timer_and_thread(smi_info);\n\n\t/*\n\t * Wait until we know that we are out of any interrupt\n\t * handlers might have been running before we freed the\n\t * interrupt.\n\t */\n\tsynchronize_rcu();\n\n\t/*\n\t * Timeouts are stopped, now make sure the interrupts are off\n\t * in the BMC.  Note that timers and CPU interrupts are off,\n\t * so no need for locks.\n\t */\n\twhile (smi_info->curr_msg || (smi_info->si_state != SI_NORMAL)) {\n\t\tpoll(smi_info);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tif (smi_info->handlers)\n\t\tdisable_si_irq(smi_info);\n\twhile (smi_info->curr_msg || (smi_info->si_state != SI_NORMAL)) {\n\t\tpoll(smi_info);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tif (smi_info->handlers)\n\t\tsmi_info->handlers->cleanup(smi_info->si_sm);\n\n\tif (smi_info->io.addr_source_cleanup) {\n\t\tsmi_info->io.addr_source_cleanup(&smi_info->io);\n\t\tsmi_info->io.addr_source_cleanup = NULL;\n\t}\n\tif (smi_info->io.io_cleanup) {\n\t\tsmi_info->io.io_cleanup(&smi_info->io);\n\t\tsmi_info->io.io_cleanup = NULL;\n\t}\n\n\tkfree(smi_info->si_sm);\n\tsmi_info->si_sm = NULL;\n\n\tsmi_info->intf = NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
        "vul_func_with_fix": "static void shutdown_smi(void *send_info)\n{\n\tstruct smi_info *smi_info = send_info;\n\n\tif (smi_info->dev_group_added) {\n\t\tdevice_remove_group(smi_info->io.dev, &ipmi_si_dev_attr_group);\n\t\tsmi_info->dev_group_added = false;\n\t}\n\tif (smi_info->io.dev)\n\t\tdev_set_drvdata(smi_info->io.dev, NULL);\n\n\t/*\n\t * Make sure that interrupts, the timer and the thread are\n\t * stopped and will not run again.\n\t */\n\tsmi_info->interrupt_disabled = true;\n\tif (smi_info->io.irq_cleanup) {\n\t\tsmi_info->io.irq_cleanup(&smi_info->io);\n\t\tsmi_info->io.irq_cleanup = NULL;\n\t}\n\tstop_timer_and_thread(smi_info);\n\n\t/*\n\t * Wait until we know that we are out of any interrupt\n\t * handlers might have been running before we freed the\n\t * interrupt.\n\t */\n\tsynchronize_rcu();\n\n\t/*\n\t * Timeouts are stopped, now make sure the interrupts are off\n\t * in the BMC.  Note that timers and CPU interrupts are off,\n\t * so no need for locks.\n\t */\n\twhile (smi_info->curr_msg || (smi_info->si_state != SI_NORMAL)) {\n\t\tpoll(smi_info);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tif (smi_info->handlers)\n\t\tdisable_si_irq(smi_info);\n\twhile (smi_info->curr_msg || (smi_info->si_state != SI_NORMAL)) {\n\t\tpoll(smi_info);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tif (smi_info->handlers)\n\t\tsmi_info->handlers->cleanup(smi_info->si_sm);\n\n\tif (smi_info->io.addr_source_cleanup) {\n\t\tsmi_info->io.addr_source_cleanup(&smi_info->io);\n\t\tsmi_info->io.addr_source_cleanup = NULL;\n\t}\n\tif (smi_info->io.io_cleanup) {\n\t\tsmi_info->io.io_cleanup(&smi_info->io);\n\t\tsmi_info->io.io_cleanup = NULL;\n\t}\n\n\tkfree(smi_info->si_sm);\n\tsmi_info->si_sm = NULL;\n\n\tsmi_info->intf = NULL;\n}\n",
        "linevul": 6.21362414676696e-05,
        "sysevr": 0.18243160843849182,
        "devign": 1.0483065970845473e-08
    },
    {
        "code": "static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size,\n\t\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint copied = 0;\n\tint target;\n\tint err = 0;\n\tlong timeo;\n\n\terr = -EOPNOTSUPP;\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n\tmsg->msg_namelen = 0;\n \t/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n\t */\n\terr = -EAGAIN;\n\tif (sk->sk_state == CAIF_CONNECTING)\n\t\tgoto out;\n\n\tcaif_read_lock(sk);\n\ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n\n\tdo {\n\t\tint chunk;\n\t\tstruct sk_buff *skb;\n\n\t\tlock_sock(sk);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tcaif_check_flow_release(sk);\n\n\t\tif (skb == NULL) {\n\t\t\tif (copied >= target)\n\t\t\t\tgoto unlock;\n\t\t\t/*\n\t\t\t *\tPOSIX 1003.1g mandates this order.\n\t\t\t */\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\terr = -ECONNRESET;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tgoto unlock;\n\n\t\t\terr = -EPIPE;\n\t\t\tif (sk->sk_state != CAIF_CONNECTED)\n\t\t\t\tgoto unlock;\n\t\t\tif (sock_flag(sk, SOCK_DEAD))\n\t\t\t\tgoto unlock;\n\n\t\t\trelease_sock(sk);\n\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\n\t\t\tcaif_read_unlock(sk);\n\n\t\t\ttimeo = caif_stream_data_wait(sk, timeo);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcaif_read_lock(sk);\n\t\t\tcontinue;\nunlock:\n\t\t\trelease_sock(sk);\n\t\t\tbreak;\n\t\t}\n\t\trelease_sock(sk);\n\t\tchunk = min_t(unsigned int, skb->len, size);\n\t\tif (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_pull(skb, chunk);\n\n\t\t\t/* put the skb back if we didn't use it up. */\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * It is questionable, see note in unix_dgram_recvmsg.\n\t\t\t */\n\t\t\t/* put message back and return */\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\tcaif_read_unlock(sk);\n\nout:\n\treturn copied ? : err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size,\n\t\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint copied = 0;\n\tint target;\n\tint err = 0;\n\tlong timeo;\n\n\terr = -EOPNOTSUPP;\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n//flaw_line_below:\n\tmsg->msg_namelen = 0;\n//flaw_line_below:\n\n \t/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n\t */\n\terr = -EAGAIN;\n\tif (sk->sk_state == CAIF_CONNECTING)\n\t\tgoto out;\n\n\tcaif_read_lock(sk);\n\ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n\n\tdo {\n\t\tint chunk;\n\t\tstruct sk_buff *skb;\n\n\t\tlock_sock(sk);\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tcaif_check_flow_release(sk);\n\n\t\tif (skb == NULL) {\n\t\t\tif (copied >= target)\n\t\t\t\tgoto unlock;\n\t\t\t/*\n\t\t\t *\tPOSIX 1003.1g mandates this order.\n\t\t\t */\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\terr = -ECONNRESET;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tgoto unlock;\n\n\t\t\terr = -EPIPE;\n\t\t\tif (sk->sk_state != CAIF_CONNECTED)\n\t\t\t\tgoto unlock;\n\t\t\tif (sock_flag(sk, SOCK_DEAD))\n\t\t\t\tgoto unlock;\n\n\t\t\trelease_sock(sk);\n\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\n\t\t\tcaif_read_unlock(sk);\n\n\t\t\ttimeo = caif_stream_data_wait(sk, timeo);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcaif_read_lock(sk);\n\t\t\tcontinue;\nunlock:\n\t\t\trelease_sock(sk);\n\t\t\tbreak;\n\t\t}\n\t\trelease_sock(sk);\n\t\tchunk = min_t(unsigned int, skb->len, size);\n\t\tif (memcpy_toiovec(msg->msg_iov, skb->data, chunk)) {\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tskb_pull(skb, chunk);\n\n\t\t\t/* put the skb back if we didn't use it up. */\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * It is questionable, see note in unix_dgram_recvmsg.\n\t\t\t */\n\t\t\t/* put message back and return */\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\tcaif_read_unlock(sk);\n\nout:\n\treturn copied ? : err;\n}\n",
        "linevul": 0.9989272952079773,
        "sysevr": 0.1920880675315857,
        "devign": 0.9999967813491821
    },
    {
        "code": "static void pppol2tp_next_session(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\tpd->session = l2tp_session_find_nth(pd->tunnel, pd->session_idx);\n\tpd->session_idx++;\n\n\tif (pd->session == NULL) {\n\t\tpd->session_idx = 0;\n\t\tpppol2tp_next_tunnel(net, pd);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf",
        "vul_func_with_fix": "static void pppol2tp_next_session(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\tpd->session = l2tp_session_find_nth(pd->tunnel, pd->session_idx);\n\tpd->session_idx++;\n\n\tif (pd->session == NULL) {\n\t\tpd->session_idx = 0;\n\t\tpppol2tp_next_tunnel(net, pd);\n\t}\n}\n",
        "linevul": 6.336313526844606e-05,
        "sysevr": 0.12308082729578018,
        "devign": 2.0114157735229288e-12
    },
    {
        "code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n \t\tstruct xfrm_user_tmpl *up = &vec[i];\n \t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n \n \t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n \t\tup->family = kp->encap_family;\n \t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1f86840f897717f86d523a13e99a447e6a5d2fa5",
        "vul_func_with_fix": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n \t\tstruct xfrm_user_tmpl *up = &vec[i];\n \t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n \n//fix_flaw_line_below:\n//\t\tmemset(up, 0, sizeof(*up));\n \t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n \t\tup->family = kp->encap_family;\n \t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n",
        "linevul": 0.9997021555900574,
        "sysevr": 0.1711737960577011,
        "devign": 0.9956502318382263
    },
    {
        "code": "mark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 &&\n\t\t\t     unconditional(&e->ipv6)) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
        "vul_func_with_fix": "mark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ip6t_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n//flaw_line_below:\n\t\t\tif ((e->target_offset == sizeof(struct ip6t_entry) &&\n//fix_flaw_line_below:\n//\t\t\tif ((unconditional(e) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n//flaw_line_below:\n\t\t\t     t->verdict < 0 &&\n//flaw_line_below:\n\t\t\t     unconditional(&e->ipv6)) || visited) {\n//fix_flaw_line_below:\n//\t\t\t     t->verdict < 0) || visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ip6t_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ip6t_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}\n",
        "linevul": 6.565375224454328e-05,
        "sysevr": 0.1951342672109604,
        "devign": 0.9825155735015869
    },
    {
        "code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n;\n\t\t\tif (!body->unit_size)\n \t\t\t\tbreak;\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8",
        "vul_func_with_fix": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n//flaw_line_below:\n\t\t\tint n;\n//flaw_line_below:\n\t\t\tif (!body->unit_size)\n//fix_flaw_line_below:\n//\t\t\tunsigned int n;\n//fix_flaw_line_below:\n//\t\t\tif (!body->unit_size ||\n//fix_flaw_line_below:\n//\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n \t\t\t\tbreak;\n//flaw_line_below:\n\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n//fix_flaw_line_below:\n//\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}\n",
        "linevul": 0.9991987347602844,
        "sysevr": 0.13929250836372375,
        "devign": 0.9996523857116699
    },
    {
        "code": "void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982",
        "vul_func_with_fix": "void write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}\n",
        "linevul": 8.212809188989922e-05,
        "sysevr": 0.16080878674983978,
        "devign": 0.08718317002058029
    },
    {
        "code": "void udp_proc_unregister(struct net *net, struct udp_seq_afinfo *afinfo)\n{\n\tproc_net_remove(net, afinfo->name);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "void udp_proc_unregister(struct net *net, struct udp_seq_afinfo *afinfo)\n{\n\tproc_net_remove(net, afinfo->name);\n}\n",
        "linevul": 7.550201553385705e-05,
        "sysevr": 0.15330778062343597,
        "devign": 9.927893552230671e-05
    },
    {
        "code": "static int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_usersa_info *p;\n\tstruct xfrm_usersa_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = xfrm_sa_len(x);\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\t}\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->pid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\n\t\tid->spi = x->id.spi;\n\t\tid->family = x->props.family;\n\t\tid->proto = x->id.proto;\n\n\t\tattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_usersa_info *p;\n\tstruct xfrm_usersa_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = xfrm_sa_len(x);\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\t}\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->pid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\n\t\tid->spi = x->id.spi;\n\t\tid->family = x->props.family;\n\t\tid->proto = x->id.proto;\n\n\t\tattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n",
        "linevul": 0.0002589315117802471,
        "sysevr": 0.17368383705615997,
        "devign": 2.099016299286998e-18
    },
    {
        "code": "static void __reg_bound_offset(struct bpf_reg_state *reg)\n{\n\treg->var_off = tnum_intersect(reg->var_off,\n\t\t\t\t      tnum_range(reg->umin_value,\n\t\t\t\t\t\t reg->umax_value));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
        "vul_func_with_fix": "static void __reg_bound_offset(struct bpf_reg_state *reg)\n{\n\treg->var_off = tnum_intersect(reg->var_off,\n\t\t\t\t      tnum_range(reg->umin_value,\n\t\t\t\t\t\t reg->umax_value));\n}\n",
        "linevul": 5.375698674470186e-05,
        "sysevr": 0.13025878369808197,
        "devign": 5.976762596122953e-13
    },
    {
        "code": "CIFSSMBLogoff(const int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcFYI(1, \"In SMBLogoff for session disconnect\");\n\n\t/*\n\t * BB: do we need to check validity of ses and server? They should\n\t * always be valid since we have an active reference. If not, that\n\t * should probably be a BUG()\n\t */\n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tif (ses->need_reconnect)\n\t\tgoto session_already_dead; /* no need to send SMBlogoff if uid\n\t\t\t\t\t      already closed due to reconnect */\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = GetNextMid(ses->server);\n\n\tif (ses->server->sec_mode &\n\t\t   (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (struct smb_hdr *) pSMB, 0);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* if session dead then we do not need to do ulogoff,\n\t\tsince server closed smb session, no sense reporting\n\t\terror */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd",
        "vul_func_with_fix": "CIFSSMBLogoff(const int xid, struct cifs_ses *ses)\n{\n\tLOGOFF_ANDX_REQ *pSMB;\n\tint rc = 0;\n\n\tcFYI(1, \"In SMBLogoff for session disconnect\");\n\n\t/*\n\t * BB: do we need to check validity of ses and server? They should\n\t * always be valid since we have an active reference. If not, that\n\t * should probably be a BUG()\n\t */\n\tif (!ses || !ses->server)\n\t\treturn -EIO;\n\n\tmutex_lock(&ses->session_mutex);\n\tif (ses->need_reconnect)\n\t\tgoto session_already_dead; /* no need to send SMBlogoff if uid\n\t\t\t\t\t      already closed due to reconnect */\n\trc = small_smb_init(SMB_COM_LOGOFF_ANDX, 2, NULL, (void **)&pSMB);\n\tif (rc) {\n\t\tmutex_unlock(&ses->session_mutex);\n\t\treturn rc;\n\t}\n\n\tpSMB->hdr.Mid = GetNextMid(ses->server);\n\n\tif (ses->server->sec_mode &\n\t\t   (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\t\tpSMB->hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tpSMB->hdr.Uid = ses->Suid;\n\n\tpSMB->AndXCommand = 0xFF;\n\trc = SendReceiveNoRsp(xid, ses, (struct smb_hdr *) pSMB, 0);\nsession_already_dead:\n\tmutex_unlock(&ses->session_mutex);\n\n\t/* if session dead then we do not need to do ulogoff,\n\t\tsince server closed smb session, no sense reporting\n\t\terror */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\treturn rc;\n}\n",
        "linevul": 4.701516081695445e-05,
        "sysevr": 0.1900147795677185,
        "devign": 9.687667335001038e-10
    },
    {
        "code": "CIFSSMBQFSPosixInfo(const int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSPosixInfo\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd",
        "vul_func_with_fix": "CIFSSMBQFSPosixInfo(const int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In QFSPosixInfo\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"Send error in QFSUnixInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}\n",
        "linevul": 6.322492117760703e-05,
        "sysevr": 0.24890203773975372,
        "devign": 2.280897235783608e-24
    },
    {
        "code": "static inline bool tun_is_little_endian(struct tun_struct *tun)\n{\n\treturn tun->flags & TUN_VNET_LE ||\n\t\ttun_legacy_is_little_endian(tun);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d",
        "vul_func_with_fix": "static inline bool tun_is_little_endian(struct tun_struct *tun)\n{\n\treturn tun->flags & TUN_VNET_LE ||\n\t\ttun_legacy_is_little_endian(tun);\n}\n",
        "linevul": 5.2847102779196575e-05,
        "sysevr": 0.12466900050640106,
        "devign": 0.0005878054071217775
    },
    {
        "code": "static int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kzalloc(sizeof(struct hlist_head) * size, GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\tif (!ftrace_profile_bits) {\n\t\tsize--;\n\n\t\tfor (; size; size >>= 1)\n\t\t\tftrace_profile_bits++;\n\t}\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6a76f8c0ab19f215af2a3442870eeb5f0e81998d",
        "vul_func_with_fix": "static int ftrace_profile_init_cpu(int cpu)\n{\n\tstruct ftrace_profile_stat *stat;\n\tint size;\n\n\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\tif (stat->hash) {\n\t\t/* If the profile is already created, simply reset it */\n\t\tftrace_profile_reset(stat);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We are profiling all functions, but usually only a few thousand\n\t * functions are hit. We'll make a hash of 1024 items.\n\t */\n\tsize = FTRACE_PROFILE_HASH_SIZE;\n\n\tstat->hash = kzalloc(sizeof(struct hlist_head) * size, GFP_KERNEL);\n\n\tif (!stat->hash)\n\t\treturn -ENOMEM;\n\n\tif (!ftrace_profile_bits) {\n\t\tsize--;\n\n\t\tfor (; size; size >>= 1)\n\t\t\tftrace_profile_bits++;\n\t}\n\n\t/* Preallocate the function profiling pages */\n\tif (ftrace_profile_pages_init(stat) < 0) {\n\t\tkfree(stat->hash);\n\t\tstat->hash = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 9.524283086648211e-05,
        "sysevr": 0.13674485683441162,
        "devign": 2.0161846864899897e-21
    },
    {
        "code": "static int qeth_ulp_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpstpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_connection_r,\n\t       QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (!strncmp(\"00S\", QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t\t     3)) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"olmlimit\");\n\t\tdev_err(&card->gdev->dev, \"A connection could not be \"\n\t\t\t\"established because of an OLM limit\\n\");\n\t\tiob->rc = -EMLINK;\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62",
        "vul_func_with_fix": "static int qeth_ulp_setup_cb(struct qeth_card *card, struct qeth_reply *reply,\n\t\tunsigned long data)\n{\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpstpcb\");\n\n\tiob = (struct qeth_cmd_buffer *) data;\n\tmemcpy(&card->token.ulp_connection_r,\n\t       QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t       QETH_MPC_TOKEN_LENGTH);\n\tif (!strncmp(\"00S\", QETH_ULP_SETUP_RESP_CONNECTION_TOKEN(iob->data),\n\t\t     3)) {\n\t\tQETH_DBF_TEXT(SETUP, 2, \"olmlimit\");\n\t\tdev_err(&card->gdev->dev, \"A connection could not be \"\n\t\t\t\"established because of an OLM limit\\n\");\n\t\tiob->rc = -EMLINK;\n\t}\n\tQETH_DBF_TEXT_(SETUP, 2, \"  rc%d\", iob->rc);\n\treturn 0;\n}\n",
        "linevul": 5.703944407287054e-05,
        "sysevr": 0.14559581875801086,
        "devign": 2.7423556047539988e-12
    },
    {
        "code": "int netlink_add_tap(struct netlink_tap *nt)\n{\n\tif (unlikely(nt->dev->type != ARPHRD_NETLINK))\n\t\treturn -EINVAL;\n\n\tspin_lock(&netlink_tap_lock);\n\tlist_add_rcu(&nt->list, &netlink_tap_all);\n\tspin_unlock(&netlink_tap_lock);\n\n\t__module_get(nt->module);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92964c79b357efd980812c4de5c1fd2ec8bb5520",
        "vul_func_with_fix": "int netlink_add_tap(struct netlink_tap *nt)\n{\n\tif (unlikely(nt->dev->type != ARPHRD_NETLINK))\n\t\treturn -EINVAL;\n\n\tspin_lock(&netlink_tap_lock);\n\tlist_add_rcu(&nt->list, &netlink_tap_all);\n\tspin_unlock(&netlink_tap_lock);\n\n\t__module_get(nt->module);\n\n\treturn 0;\n}\n",
        "linevul": 5.116149623063393e-05,
        "sysevr": 0.15222232043743134,
        "devign": 5.0172418303295885e-12
    },
    {
        "code": "static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd",
        "vul_func_with_fix": "static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n",
        "linevul": 5.5989530665101483e-05,
        "sysevr": 0.14278419315814972,
        "devign": 2.6180260181973836e-09
    },
    {
        "code": "static int decode_putfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTFH);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int decode_putfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTFH);\n}\n",
        "linevul": 8.804209937807173e-05,
        "sysevr": 0.12880076467990875,
        "devign": 1.6499938055858365e-06
    },
    {
        "code": "static void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2c5816b4beccc8ba709144539f6fdd764f8fa49c",
        "vul_func_with_fix": "static void cuse_fc_release(struct fuse_conn *fc)\n{\n\tstruct cuse_conn *cc = fc_to_cc(fc);\n\tkfree_rcu(cc, fc.rcu);\n}\n",
        "linevul": 5.331929787644185e-05,
        "sysevr": 0.12780191004276276,
        "devign": 0.001184750464744866
    },
    {
        "code": "static unsigned int tipc_poll(struct file *file, struct socket *sock,\n\t\t\t      poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tu32 mask = 0;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\n\tswitch ((int)sock->state) {\n\tcase SS_UNCONNECTED:\n\t\tif (!tsk->link_cong)\n\t\t\tmask |= POLLOUT;\n\t\tbreak;\n\tcase SS_READY:\n\tcase SS_CONNECTED:\n\t\tif (!tsk->link_cong && !tsk_conn_cong(tsk))\n\t\t\tmask |= POLLOUT;\n\t\t/* fall thru' */\n\tcase SS_CONNECTING:\n\tcase SS_LISTENING:\n\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\tmask |= (POLLIN | POLLRDNORM);\n\t\tbreak;\n\tcase SS_DISCONNECTING:\n\t\tmask = (POLLIN | POLLRDNORM | POLLHUP);\n\t\tbreak;\n\t}\n\n\treturn mask;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/45e093ae2830cd1264677d47ff9a95a71f5d9f9c",
        "vul_func_with_fix": "static unsigned int tipc_poll(struct file *file, struct socket *sock,\n\t\t\t      poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tu32 mask = 0;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\n\tswitch ((int)sock->state) {\n\tcase SS_UNCONNECTED:\n\t\tif (!tsk->link_cong)\n\t\t\tmask |= POLLOUT;\n\t\tbreak;\n\tcase SS_READY:\n\tcase SS_CONNECTED:\n\t\tif (!tsk->link_cong && !tsk_conn_cong(tsk))\n\t\t\tmask |= POLLOUT;\n\t\t/* fall thru' */\n\tcase SS_CONNECTING:\n\tcase SS_LISTENING:\n\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\tmask |= (POLLIN | POLLRDNORM);\n\t\tbreak;\n\tcase SS_DISCONNECTING:\n\t\tmask = (POLLIN | POLLRDNORM | POLLHUP);\n\t\tbreak;\n\t}\n\n\treturn mask;\n}\n",
        "linevul": 7.054449088172987e-05,
        "sysevr": 0.13043610751628876,
        "devign": 2.9410656901458196e-18
    },
    {
        "code": "vhost_scsi_wwn_show_attr_version(struct target_fabric_configfs *tf,\n\t\t\t\tchar *page)\n{\n\treturn sprintf(page, \"TCM_VHOST fabric module %s on %s/%s\"\n\t\t\"on \"UTS_RELEASE\"\\n\", VHOST_SCSI_VERSION, utsname()->sysname,\n\t\tutsname()->machine);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c",
        "vul_func_with_fix": "vhost_scsi_wwn_show_attr_version(struct target_fabric_configfs *tf,\n\t\t\t\tchar *page)\n{\n\treturn sprintf(page, \"TCM_VHOST fabric module %s on %s/%s\"\n\t\t\"on \"UTS_RELEASE\"\\n\", VHOST_SCSI_VERSION, utsname()->sysname,\n\t\tutsname()->machine);\n}\n",
        "linevul": 7.840483885956928e-05,
        "sysevr": 0.16041946411132812,
        "devign": 1.2705634162557544e-06
    },
    {
        "code": "static handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext4_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text4_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
        "vul_func_with_fix": "static handle_t *start_transaction(struct inode *inode)\n{\n\thandle_t *result;\n\n\tresult = ext4_journal_start(inode, blocks_for_truncate(inode));\n\tif (!IS_ERR(result))\n\t\treturn result;\n\n\text4_std_error(inode->i_sb, PTR_ERR(result));\n\treturn result;\n}\n",
        "linevul": 7.644375000381842e-05,
        "sysevr": 0.12836875021457672,
        "devign": 0.00023857402266003191
    },
    {
        "code": "nfs4_layoutreturn_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (nfs41_setup_sequence(lrp->clp->cl_session, &lrp->args.seq_args,\n\t\t\t\t&lrp->res.seq_res, 0, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "nfs4_layoutreturn_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (nfs41_setup_sequence(lrp->clp->cl_session, &lrp->args.seq_args,\n\t\t\t\t&lrp->res.seq_res, 0, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n",
        "linevul": 5.13589839101769e-05,
        "sysevr": 0.15393486618995667,
        "devign": 2.759686811109306e-16
    },
    {
        "code": "static inline unsigned long *__fetch_reg_addr_kern(unsigned int reg,\n\t\t\t\t\t\t   struct pt_regs *regs)\n{\n\tBUG_ON(reg >= 16);\n\tBUG_ON(regs->tstate & TSTATE_PRIV);\n\n\treturn &regs->u_regs[reg];\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline unsigned long *__fetch_reg_addr_kern(unsigned int reg,\n\t\t\t\t\t\t   struct pt_regs *regs)\n{\n\tBUG_ON(reg >= 16);\n\tBUG_ON(regs->tstate & TSTATE_PRIV);\n\n\treturn &regs->u_regs[reg];\n}\n",
        "linevul": 5.313564543030225e-05,
        "sysevr": 0.13233177363872528,
        "devign": 8.802077354630455e-05
    },
    {
        "code": "static __be32 bond_glean_dev_ip(struct net_device *dev)\n{\n\tstruct in_device *idev;\n\tstruct in_ifaddr *ifa;\n\t__be32 addr = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tidev = __in_dev_get_rcu(dev);\n\tif (!idev)\n\t\tgoto out;\n\n\tifa = idev->ifa_list;\n\tif (!ifa)\n\t\tgoto out;\n\n\taddr = ifa->ifa_local;\nout:\n\trcu_read_unlock();\n\treturn addr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static __be32 bond_glean_dev_ip(struct net_device *dev)\n{\n\tstruct in_device *idev;\n\tstruct in_ifaddr *ifa;\n\t__be32 addr = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tidev = __in_dev_get_rcu(dev);\n\tif (!idev)\n\t\tgoto out;\n\n\tifa = idev->ifa_list;\n\tif (!ifa)\n\t\tgoto out;\n\n\taddr = ifa->ifa_local;\nout:\n\trcu_read_unlock();\n\treturn addr;\n}\n",
        "linevul": 4.963561877957545e-05,
        "sysevr": 0.12933610379695892,
        "devign": 2.614126210826904e-15
    },
    {
        "code": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tunsigned long iovlen;\n\tstruct iovec *iov;\n\tint err = -EAGAIN;\n\tint used;\n \tlong copied = 0;\n \n \tlock_sock(sk);\n\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\n\t\tchar __user *from = iov->iov_base;\n\n\t\twhile (seglen) {\n\t\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t\t       struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg;\n\n\t\t\twhile (!sg->length)\n\t\t\t\tsg++;\n\n\t\t\tused = ctx->used;\n\t\t\tif (!used) {\n\t\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tused = min_t(unsigned long, used, seglen);\n\n\t\t\tused = af_alg_make_sg(&ctx->rsgl, from, used, 1);\n\t\t\terr = used;\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\n\t\t\tif (ctx->more || used < ctx->used)\n\t\t\t\tused -= used % bs;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!used)\n\t\t\t\tgoto free;\n\n\t\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t\t     ctx->iv);\n\n\t\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tcopied += used;\n\t\t\tfrom += used;\n\t\t\tseglen -= used;\n\t\t\tskcipher_pull_sgl(sk, used);\n\t\t}\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tunsigned long iovlen;\n\tstruct iovec *iov;\n\tint err = -EAGAIN;\n\tint used;\n \tlong copied = 0;\n \n \tlock_sock(sk);\n//flaw_line_below:\n\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\n\t\tchar __user *from = iov->iov_base;\n\n\t\twhile (seglen) {\n\t\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t\t       struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg;\n\n\t\t\twhile (!sg->length)\n\t\t\t\tsg++;\n\n\t\t\tused = ctx->used;\n\t\t\tif (!used) {\n\t\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tused = min_t(unsigned long, used, seglen);\n\n\t\t\tused = af_alg_make_sg(&ctx->rsgl, from, used, 1);\n\t\t\terr = used;\n\t\t\tif (err < 0)\n\t\t\t\tgoto unlock;\n\n\t\t\tif (ctx->more || used < ctx->used)\n\t\t\t\tused -= used % bs;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!used)\n\t\t\t\tgoto free;\n\n\t\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t\t     ctx->iv);\n\n\t\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tcopied += used;\n\t\t\tfrom += used;\n\t\t\tseglen -= used;\n\t\t\tskcipher_pull_sgl(sk, used);\n\t\t}\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n",
        "linevul": 0.9996070265769958,
        "sysevr": 0.16582991182804108,
        "devign": 0.9989270567893982
    },
    {
        "code": "static int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8b01fc86b9f425899f8a3a8fc1c47d73c2c20543",
        "vul_func_with_fix": "static int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 5.249430250842124e-05,
        "sysevr": 0.12552139163017273,
        "devign": 3.006874749189592e-10
    },
    {
        "code": "static void pppol2tp_session_sock_put(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps->sock)\n\t\tsock_put(ps->sock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3cf521f7dc87c031617fd47e4b7aa2593c2f3daf",
        "vul_func_with_fix": "static void pppol2tp_session_sock_put(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tif (ps->sock)\n\t\tsock_put(ps->sock);\n}\n",
        "linevul": 5.690846228390001e-05,
        "sysevr": 0.12712013721466064,
        "devign": 2.3229879131392295e-10
    },
    {
        "code": "static int drm_mode_create_standard_connector_properties(struct drm_device *dev)\n{\n\tstruct drm_property *edid;\n\tstruct drm_property *dpms;\n\tint i;\n\n\t/*\n\t * Standard properties (apply to all connectors)\n\t */\n\tedid = drm_property_create(dev, DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"EDID\", 0);\n\tdev->mode_config.edid_property = edid;\n\n\tdpms = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t   \"DPMS\", ARRAY_SIZE(drm_dpms_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dpms_enum_list); i++)\n\t\tdrm_property_add_enum(dpms, i, drm_dpms_enum_list[i].type,\n\t\t\t\t      drm_dpms_enum_list[i].name);\n\tdev->mode_config.dpms_property = dpms;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2",
        "vul_func_with_fix": "static int drm_mode_create_standard_connector_properties(struct drm_device *dev)\n{\n\tstruct drm_property *edid;\n\tstruct drm_property *dpms;\n\tint i;\n\n\t/*\n\t * Standard properties (apply to all connectors)\n\t */\n\tedid = drm_property_create(dev, DRM_MODE_PROP_BLOB |\n\t\t\t\t   DRM_MODE_PROP_IMMUTABLE,\n\t\t\t\t   \"EDID\", 0);\n\tdev->mode_config.edid_property = edid;\n\n\tdpms = drm_property_create(dev, DRM_MODE_PROP_ENUM,\n\t\t\t\t   \"DPMS\", ARRAY_SIZE(drm_dpms_enum_list));\n\tfor (i = 0; i < ARRAY_SIZE(drm_dpms_enum_list); i++)\n\t\tdrm_property_add_enum(dpms, i, drm_dpms_enum_list[i].type,\n\t\t\t\t      drm_dpms_enum_list[i].name);\n\tdev->mode_config.dpms_property = dpms;\n\n\treturn 0;\n}\n",
        "linevul": 5.432245598058216e-05,
        "sysevr": 0.1301691234111786,
        "devign": 2.4518212980717546e-12
    },
    {
        "code": "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct sock *ssk)\n{\n\tint ret;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tret = -ECONNREFUSED;\n\tif (nlk->netlink_rcv != NULL) {\n\t\t/* We could do a netlink_deliver_tap(skb) here as well\n\t\t * but since this is intended for the kernel only, we\n\t\t * should rather let it stay under the hood.\n\t\t */\n\n\t\tret = skb->len;\n\t\tnetlink_skb_set_owner_r(skb, sk);\n\t\tNETLINK_CB(skb).sk = ssk;\n\t\tnlk->netlink_rcv(skb);\n\t\tconsume_skb(skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\tsock_put(sk);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct sock *ssk)\n{\n\tint ret;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tret = -ECONNREFUSED;\n\tif (nlk->netlink_rcv != NULL) {\n\t\t/* We could do a netlink_deliver_tap(skb) here as well\n\t\t * but since this is intended for the kernel only, we\n\t\t * should rather let it stay under the hood.\n\t\t */\n\n\t\tret = skb->len;\n\t\tnetlink_skb_set_owner_r(skb, sk);\n\t\tNETLINK_CB(skb).sk = ssk;\n\t\tnlk->netlink_rcv(skb);\n\t\tconsume_skb(skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\tsock_put(sk);\n\treturn ret;\n}\n",
        "linevul": 4.7820947656873614e-05,
        "sysevr": 0.13781815767288208,
        "devign": 0.0
    },
    {
        "code": "static int vbg_input_open(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\tu32 feat = VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE | VMMDEV_MOUSE_NEW_PROTOCOL;\n\tint ret;\n\n\tret = vbg_core_set_mouse_status(gdev, feat);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bd23a7269834dc7c1f93e83535d16ebc44b75eba",
        "vul_func_with_fix": "static int vbg_input_open(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\tu32 feat = VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE | VMMDEV_MOUSE_NEW_PROTOCOL;\n\tint ret;\n\n\tret = vbg_core_set_mouse_status(gdev, feat);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
        "linevul": 4.52926178695634e-05,
        "sysevr": 0.12782257795333862,
        "devign": 0.0001583525590831414
    },
    {
        "code": "static __be16 efx_tso_check_protocol(struct sk_buff *skb)\n{\n\t__be16 protocol = skb->protocol;\n\n\tEFX_BUG_ON_PARANOID(((struct ethhdr *)skb->data)->h_proto !=\n\t\t\t    protocol);\n\tif (protocol == htons(ETH_P_8021Q)) {\n\t\t/* Find the encapsulated protocol; reset network header\n\t\t * and transport header based on that. */\n\t\tstruct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;\n\t\tprotocol = veh->h_vlan_encapsulated_proto;\n\t\tskb_set_network_header(skb, sizeof(*veh));\n\t\tif (protocol == htons(ETH_P_IP))\n\t\t\tskb_set_transport_header(skb, sizeof(*veh) +\n\t\t\t\t\t\t 4 * ip_hdr(skb)->ihl);\n\t\telse if (protocol == htons(ETH_P_IPV6))\n\t\t\tskb_set_transport_header(skb, sizeof(*veh) +\n\t\t\t\t\t\t sizeof(struct ipv6hdr));\n\t}\n\n\tif (protocol == htons(ETH_P_IP)) {\n\t\tEFX_BUG_ON_PARANOID(ip_hdr(skb)->protocol != IPPROTO_TCP);\n\t} else {\n\t\tEFX_BUG_ON_PARANOID(protocol != htons(ETH_P_IPV6));\n\t\tEFX_BUG_ON_PARANOID(ipv6_hdr(skb)->nexthdr != NEXTHDR_TCP);\n\t}\n\tEFX_BUG_ON_PARANOID((PTR_DIFF(tcp_hdr(skb), skb->data)\n\t\t\t     + (tcp_hdr(skb)->doff << 2u)) >\n\t\t\t    skb_headlen(skb));\n\n\treturn protocol;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "vul_func_with_fix": "static __be16 efx_tso_check_protocol(struct sk_buff *skb)\n{\n\t__be16 protocol = skb->protocol;\n\n\tEFX_BUG_ON_PARANOID(((struct ethhdr *)skb->data)->h_proto !=\n\t\t\t    protocol);\n\tif (protocol == htons(ETH_P_8021Q)) {\n\t\t/* Find the encapsulated protocol; reset network header\n\t\t * and transport header based on that. */\n\t\tstruct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;\n\t\tprotocol = veh->h_vlan_encapsulated_proto;\n\t\tskb_set_network_header(skb, sizeof(*veh));\n\t\tif (protocol == htons(ETH_P_IP))\n\t\t\tskb_set_transport_header(skb, sizeof(*veh) +\n\t\t\t\t\t\t 4 * ip_hdr(skb)->ihl);\n\t\telse if (protocol == htons(ETH_P_IPV6))\n\t\t\tskb_set_transport_header(skb, sizeof(*veh) +\n\t\t\t\t\t\t sizeof(struct ipv6hdr));\n\t}\n\n\tif (protocol == htons(ETH_P_IP)) {\n\t\tEFX_BUG_ON_PARANOID(ip_hdr(skb)->protocol != IPPROTO_TCP);\n\t} else {\n\t\tEFX_BUG_ON_PARANOID(protocol != htons(ETH_P_IPV6));\n\t\tEFX_BUG_ON_PARANOID(ipv6_hdr(skb)->nexthdr != NEXTHDR_TCP);\n\t}\n\tEFX_BUG_ON_PARANOID((PTR_DIFF(tcp_hdr(skb), skb->data)\n\t\t\t     + (tcp_hdr(skb)->doff << 2u)) >\n\t\t\t    skb_headlen(skb));\n\n\treturn protocol;\n}\n",
        "linevul": 4.8171685193665326e-05,
        "sysevr": 0.13203103840351105,
        "devign": 0.00972727220505476
    },
    {
        "code": "static void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags)\n{\n\tunsigned changed = vcpu->arch.hflags ^ emul_flags;\n\n\tvcpu->arch.hflags = emul_flags;\n\n\tif (changed & HF_SMM_MASK)\n\t\tkvm_smm_changed(vcpu);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8",
        "vul_func_with_fix": "static void kvm_set_hflags(struct kvm_vcpu *vcpu, unsigned emul_flags)\n{\n\tunsigned changed = vcpu->arch.hflags ^ emul_flags;\n\n\tvcpu->arch.hflags = emul_flags;\n\n\tif (changed & HF_SMM_MASK)\n\t\tkvm_smm_changed(vcpu);\n}\n",
        "linevul": 4.789008016814478e-05,
        "sysevr": 0.12229540944099426,
        "devign": 1.7845384547854337e-07
    },
    {
        "code": "int fscrypt_get_crypt_info(struct inode *inode)\n {\n \tstruct fscrypt_info *crypt_info;\n \tstruct fscrypt_context ctx;\n\tstruct crypto_skcipher *ctfm;\n\tconst char *cipher_str;\n\tint keysize;\n \tu8 *raw_key = NULL;\n \tint res;\n \n \tres = fscrypt_initialize(inode->i_sb->s_cop->flags);\n \tif (res)\n \t\treturn res;\n \n \tif (!inode->i_sb->s_cop->get_context)\n \t\treturn -EOPNOTSUPP;\nretry:\n\tcrypt_info = ACCESS_ONCE(inode->i_crypt_info);\n\tif (crypt_info) {\n\t\tif (!crypt_info->ci_keyring_key ||\n\t\t\t\tkey_validate(crypt_info->ci_keyring_key) == 0)\n\t\t\treturn 0;\n\t\tfscrypt_put_encryption_info(inode, crypt_info);\n\t\tgoto retry;\n\t}\n \n \tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n \tif (res < 0) {\n\t\tif (!fscrypt_dummy_context_enabled(inode) ||\n\t\t    inode->i_sb->s_cop->is_encrypted(inode))\n\t\t\treturn res;\n\t\t/* Fake up a context for an unencrypted directory */\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t} else if (res != sizeof(ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tif (ctx.flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tcrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_flags = ctx.flags;\n \tcrypt_info->ci_data_mode = ctx.contents_encryption_mode;\n \tcrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\n \tcrypt_info->ci_ctfm = NULL;\n\tcrypt_info->ci_keyring_key = NULL;\n \tmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\n \t\t\t\tsizeof(crypt_info->ci_master_key));\n \n\tres = determine_cipher_type(crypt_info, inode, &cipher_str, &keysize);\n\tif (res)\n\t\tgoto out;\n\n\t/*\n\t * This cannot be a stack buffer because it is passed to the scatterlist\n\t * crypto API as part of key derivation.\n\t */\n\tres = -ENOMEM;\n\traw_key = kmalloc(FS_MAX_KEY_SIZE, GFP_NOFS);\n\tif (!raw_key)\n\t\tgoto out;\n\n\tres = validate_user_key(crypt_info, &ctx, raw_key, FS_KEY_DESC_PREFIX);\n\tif (res && inode->i_sb->s_cop->key_prefix) {\n\t\tint res2 = validate_user_key(crypt_info, &ctx, raw_key,\n\t\t\t\t\t     inode->i_sb->s_cop->key_prefix);\n\t\tif (res2) {\n\t\t\tif (res2 == -ENOKEY)\n\t\t\t\tres = -ENOKEY;\n\t\t\tgoto out;\n\t\t}\n\t} else if (res) {\n\t\tgoto out;\n\t}\n\tctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\n\tif (!ctfm || IS_ERR(ctfm)) {\n\t\tres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: error %d (inode %u) allocating crypto tfm\\n\",\n\t\t       __func__, res, (unsigned) inode->i_ino);\n\t\tgoto out;\n\t}\n\tcrypt_info->ci_ctfm = ctfm;\n\tcrypto_skcipher_clear_flags(ctfm, ~0);\n\tcrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tres = crypto_skcipher_setkey(ctfm, raw_key, keysize);\n \tif (res)\n \t\tgoto out;\n \n\tkzfree(raw_key);\n\traw_key = NULL;\n\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {\n\t\tput_crypt_info(crypt_info);\n\t\tgoto retry;\n\t}\n\treturn 0;\n out:\n \tif (res == -ENOKEY)\n \t\tres = 0;\n \tput_crypt_info(crypt_info);\n \tkzfree(raw_key);\n \treturn res;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "vul_func_with_fix": "int fscrypt_get_crypt_info(struct inode *inode)\n//fix_flaw_line_below:\n//int fscrypt_get_encryption_info(struct inode *inode)\n {\n \tstruct fscrypt_info *crypt_info;\n \tstruct fscrypt_context ctx;\n\tstruct crypto_skcipher *ctfm;\n\tconst char *cipher_str;\n\tint keysize;\n \tu8 *raw_key = NULL;\n \tint res;\n \n//fix_flaw_line_below:\n//\tif (inode->i_crypt_info)\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\n \tres = fscrypt_initialize(inode->i_sb->s_cop->flags);\n \tif (res)\n \t\treturn res;\n \n \tif (!inode->i_sb->s_cop->get_context)\n \t\treturn -EOPNOTSUPP;\n//flaw_line_below:\nretry:\n//flaw_line_below:\n\tcrypt_info = ACCESS_ONCE(inode->i_crypt_info);\n//flaw_line_below:\n\tif (crypt_info) {\n//flaw_line_below:\n\t\tif (!crypt_info->ci_keyring_key ||\n//flaw_line_below:\n\t\t\t\tkey_validate(crypt_info->ci_keyring_key) == 0)\n//flaw_line_below:\n\t\t\treturn 0;\n//flaw_line_below:\n\t\tfscrypt_put_encryption_info(inode, crypt_info);\n//flaw_line_below:\n\t\tgoto retry;\n//flaw_line_below:\n\t}\n \n \tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n \tif (res < 0) {\n\t\tif (!fscrypt_dummy_context_enabled(inode) ||\n\t\t    inode->i_sb->s_cop->is_encrypted(inode))\n\t\t\treturn res;\n\t\t/* Fake up a context for an unencrypted directory */\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t} else if (res != sizeof(ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tif (ctx.flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tcrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_flags = ctx.flags;\n \tcrypt_info->ci_data_mode = ctx.contents_encryption_mode;\n \tcrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\n \tcrypt_info->ci_ctfm = NULL;\n//flaw_line_below:\n\tcrypt_info->ci_keyring_key = NULL;\n \tmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\n \t\t\t\tsizeof(crypt_info->ci_master_key));\n \n\tres = determine_cipher_type(crypt_info, inode, &cipher_str, &keysize);\n\tif (res)\n\t\tgoto out;\n\n\t/*\n\t * This cannot be a stack buffer because it is passed to the scatterlist\n\t * crypto API as part of key derivation.\n\t */\n\tres = -ENOMEM;\n\traw_key = kmalloc(FS_MAX_KEY_SIZE, GFP_NOFS);\n\tif (!raw_key)\n\t\tgoto out;\n\n\tres = validate_user_key(crypt_info, &ctx, raw_key, FS_KEY_DESC_PREFIX);\n\tif (res && inode->i_sb->s_cop->key_prefix) {\n\t\tint res2 = validate_user_key(crypt_info, &ctx, raw_key,\n\t\t\t\t\t     inode->i_sb->s_cop->key_prefix);\n\t\tif (res2) {\n\t\t\tif (res2 == -ENOKEY)\n\t\t\t\tres = -ENOKEY;\n\t\t\tgoto out;\n\t\t}\n\t} else if (res) {\n\t\tgoto out;\n\t}\n\tctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\n\tif (!ctfm || IS_ERR(ctfm)) {\n\t\tres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: error %d (inode %u) allocating crypto tfm\\n\",\n\t\t       __func__, res, (unsigned) inode->i_ino);\n\t\tgoto out;\n\t}\n\tcrypt_info->ci_ctfm = ctfm;\n\tcrypto_skcipher_clear_flags(ctfm, ~0);\n\tcrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tres = crypto_skcipher_setkey(ctfm, raw_key, keysize);\n \tif (res)\n \t\tgoto out;\n \n//flaw_line_below:\n\tkzfree(raw_key);\n//flaw_line_below:\n\traw_key = NULL;\n//flaw_line_below:\n\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {\n//flaw_line_below:\n\t\tput_crypt_info(crypt_info);\n//flaw_line_below:\n\t\tgoto retry;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\treturn 0;\n//flaw_line_below:\n\n//fix_flaw_line_below:\n//\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) == NULL)\n//fix_flaw_line_below:\n//\t\tcrypt_info = NULL;\n out:\n \tif (res == -ENOKEY)\n \t\tres = 0;\n \tput_crypt_info(crypt_info);\n \tkzfree(raw_key);\n \treturn res;\n }\n",
        "linevul": 0.9996472597122192,
        "sysevr": 0.20908930897712708,
        "devign": 0.9547243118286133
    },
    {
        "code": "static bool tcp_try_undo_recovery(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_may_undo(tp)) {\n\t\tint mib_idx;\n\n\t\t/* Happy end! We did not retransmit anything\n\t\t * or our original transmission succeeded.\n\t\t */\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t}\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\n\t\t/* Hold old state until something *above* high_seq\n\t\t * is ACKed. For Reno it is MUST to prevent false\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\n\t\ttcp_moderate_cwnd(tp);\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\t\treturn true;\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390",
        "vul_func_with_fix": "static bool tcp_try_undo_recovery(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_may_undo(tp)) {\n\t\tint mib_idx;\n\n\t\t/* Happy end! We did not retransmit anything\n\t\t * or our original transmission succeeded.\n\t\t */\n\t\tDBGUNDO(sk, inet_csk(sk)->icsk_ca_state == TCP_CA_Loss ? \"loss\" : \"retrans\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tif (inet_csk(sk)->icsk_ca_state == TCP_CA_Loss)\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSUNDO;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPFULLUNDO;\n\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t}\n\tif (tp->snd_una == tp->high_seq && tcp_is_reno(tp)) {\n\t\t/* Hold old state until something *above* high_seq\n\t\t * is ACKed. For Reno it is MUST to prevent false\n\t\t * fast retransmits (RFC2582). SACK TCP is safe. */\n\t\ttcp_moderate_cwnd(tp);\n\t\tif (!tcp_any_retrans_done(sk))\n\t\t\ttp->retrans_stamp = 0;\n\t\treturn true;\n\t}\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n\treturn false;\n}\n",
        "linevul": 5.12897277076263e-05,
        "sysevr": 0.1297784447669983,
        "devign": 2.1247416494246218e-16
    },
    {
        "code": "int vhost_init_used(struct vhost_virtqueue *vq)\n{\n\tint r;\n\tif (!vq->private_data)\n\t\treturn 0;\n\n\tr = vhost_update_used_flags(vq);\n\tif (r)\n\t\treturn r;\n\tvq->signalled_used_valid = false;\n\treturn get_user(vq->last_used_idx, &vq->used->idx);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bd97120fc3d1a11f3124c7c9ba1d91f51829eb85",
        "vul_func_with_fix": "int vhost_init_used(struct vhost_virtqueue *vq)\n{\n\tint r;\n\tif (!vq->private_data)\n\t\treturn 0;\n\n\tr = vhost_update_used_flags(vq);\n\tif (r)\n\t\treturn r;\n\tvq->signalled_used_valid = false;\n\treturn get_user(vq->last_used_idx, &vq->used->idx);\n}\n",
        "linevul": 5.971849168417975e-05,
        "sysevr": 0.15566487610340118,
        "devign": 2.7165606297785416e-05
    },
    {
        "code": "static int collect_events(struct perf_event *group, int max_count,\n\t\t\t  struct perf_event *evts[], unsigned long *events,\n\t\t\t  int *current_idx)\n{\n\tstruct perf_event *event;\n\tint n = 0;\n\n\tif (!is_software_event(group)) {\n\t\tif (n >= max_count)\n\t\t\treturn -1;\n\t\tevts[n] = group;\n\t\tevents[n] = group->hw.event_base;\n\t\tcurrent_idx[n++] = PIC_NO_INDEX;\n\t}\n\tlist_for_each_entry(event, &group->sibling_list, group_entry) {\n\t\tif (!is_software_event(event) &&\n\t\t    event->state != PERF_EVENT_STATE_OFF) {\n\t\t\tif (n >= max_count)\n\t\t\t\treturn -1;\n\t\t\tevts[n] = event;\n\t\t\tevents[n] = event->hw.event_base;\n\t\t\tcurrent_idx[n++] = PIC_NO_INDEX;\n\t\t}\n\t}\n\treturn n;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int collect_events(struct perf_event *group, int max_count,\n\t\t\t  struct perf_event *evts[], unsigned long *events,\n\t\t\t  int *current_idx)\n{\n\tstruct perf_event *event;\n\tint n = 0;\n\n\tif (!is_software_event(group)) {\n\t\tif (n >= max_count)\n\t\t\treturn -1;\n\t\tevts[n] = group;\n\t\tevents[n] = group->hw.event_base;\n\t\tcurrent_idx[n++] = PIC_NO_INDEX;\n\t}\n\tlist_for_each_entry(event, &group->sibling_list, group_entry) {\n\t\tif (!is_software_event(event) &&\n\t\t    event->state != PERF_EVENT_STATE_OFF) {\n\t\t\tif (n >= max_count)\n\t\t\t\treturn -1;\n\t\t\tevts[n] = event;\n\t\t\tevents[n] = event->hw.event_base;\n\t\t\tcurrent_idx[n++] = PIC_NO_INDEX;\n\t\t}\n\t}\n\treturn n;\n}\n",
        "linevul": 0.00012736568169202656,
        "sysevr": 0.1543569266796112,
        "devign": 0.0
    },
    {
        "code": "static int virtnet_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct virtnet_info *vi = netdev_priv(dev);\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, &vid, sizeof(vid));\n\n\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_VLAN,\n\t\t\t\t  VIRTIO_NET_CTRL_VLAN_ADD, &sg))\n\t\tdev_warn(&dev->dev, \"Failed to add VLAN ID %d.\\n\", vid);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39",
        "vul_func_with_fix": "static int virtnet_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct virtnet_info *vi = netdev_priv(dev);\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, &vid, sizeof(vid));\n\n\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_VLAN,\n\t\t\t\t  VIRTIO_NET_CTRL_VLAN_ADD, &sg))\n\t\tdev_warn(&dev->dev, \"Failed to add VLAN ID %d.\\n\", vid);\n\treturn 0;\n}\n",
        "linevul": 4.5014450734015554e-05,
        "sysevr": 0.12550540268421173,
        "devign": 0.00012056890409439802
    },
    {
        "code": "void genl_notify(const struct genl_family *family, struct sk_buff *skb,\n\t\t struct genl_info *info, u32 group, gfp_t flags)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct sock *sk = net->genl_sock;\n\tint report = 0;\n\n\tif (info->nlhdr)\n\t\treport = nlmsg_report(info->nlhdr);\n\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn;\n\tgroup = family->mcgrp_offset + group;\n\tnlmsg_notify(sk, skb, info->snd_portid, group, report, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2",
        "vul_func_with_fix": "void genl_notify(const struct genl_family *family, struct sk_buff *skb,\n\t\t struct genl_info *info, u32 group, gfp_t flags)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct sock *sk = net->genl_sock;\n\tint report = 0;\n\n\tif (info->nlhdr)\n\t\treport = nlmsg_report(info->nlhdr);\n\n\tif (WARN_ON_ONCE(group >= family->n_mcgrps))\n\t\treturn;\n\tgroup = family->mcgrp_offset + group;\n\tnlmsg_notify(sk, skb, info->snd_portid, group, report, flags);\n}\n",
        "linevul": 4.813742998521775e-05,
        "sysevr": 0.21192896366119385,
        "devign": 1.0077775186800864e-05
    },
    {
        "code": "static inline void __invvpid(int ext, u16 vpid, gva_t gva)\n{\n    struct {\n\tu64 vpid : 16;\n\tu64 rsvd : 48;\n\tu64 gva;\n    } operand = { vpid, 0, gva };\n\n    asm volatile (__ex(ASM_VMX_INVVPID)\n\t\t  /* CF==1 or ZF==1 --> rc = -1 */\n\t\t  \"; ja 1f ; ud2 ; 1:\"\n\t\t  : : \"a\"(&operand), \"c\"(ext) : \"cc\", \"memory\");\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static inline void __invvpid(int ext, u16 vpid, gva_t gva)\n{\n    struct {\n\tu64 vpid : 16;\n\tu64 rsvd : 48;\n\tu64 gva;\n    } operand = { vpid, 0, gva };\n\n    asm volatile (__ex(ASM_VMX_INVVPID)\n\t\t  /* CF==1 or ZF==1 --> rc = -1 */\n\t\t  \"; ja 1f ; ud2 ; 1:\"\n\t\t  : : \"a\"(&operand), \"c\"(ext) : \"cc\", \"memory\");\n}\n",
        "linevul": 4.7208206524373963e-05,
        "sysevr": 0.13271653652191162,
        "devign": 2.1785464809909172e-07
    },
    {
        "code": "static void digi_dtr_rts(struct usb_serial_port *port, int on)\n{\n\t/* Adjust DTR and RTS */\n\tdigi_set_modem_signals(port, on * (TIOCM_DTR|TIOCM_RTS), 1);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5a07975ad0a36708c6b0a5b9fea1ff811d0b0c1f",
        "vul_func_with_fix": "static void digi_dtr_rts(struct usb_serial_port *port, int on)\n{\n\t/* Adjust DTR and RTS */\n\tdigi_set_modem_signals(port, on * (TIOCM_DTR|TIOCM_RTS), 1);\n}\n",
        "linevul": 5.3207852033665404e-05,
        "sysevr": 0.12372998893260956,
        "devign": 0.00021552442922256887
    },
    {
        "code": "void kvm_arch_hardware_disable(void *garbage)\n{\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e8180dcaa8470ceca21109f143876fdcd9fe050a",
        "vul_func_with_fix": "void kvm_arch_hardware_disable(void *garbage)\n{\n}\n",
        "linevul": 4.807393634109758e-05,
        "sysevr": 0.15830755233764648,
        "devign": 1.8940439986181445e-05
    },
    {
        "code": "static int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_accessres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server,\n\t\t\t!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int nfs4_xdr_dec_access(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_accessres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_access(xdr, res);\n\tif (status != 0)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->fattr, res->server,\n\t\t\t!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}\n",
        "linevul": 5.0820144679164514e-05,
        "sysevr": 0.13581278920173645,
        "devign": 1.6794924898952618e-34
    },
    {
        "code": "static ssize_t __send_to_port(struct port *port, struct scatterlist *sg,\n\t\t\t      int nents, size_t in_count,\n\t\t\t      void *data, bool nonblock)\n{\n\tstruct virtqueue *out_vq;\n\tint err;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tout_vq = port->out_vq;\n\n\tspin_lock_irqsave(&port->outvq_lock, flags);\n\n\treclaim_consumed_buffers(port);\n\n\terr = virtqueue_add_outbuf(out_vq, sg, nents, data, GFP_ATOMIC);\n\n\t/* Tell Host to go! */\n\tvirtqueue_kick(out_vq);\n\n\tif (err) {\n\t\tin_count = 0;\n\t\tgoto done;\n\t}\n\n\tif (out_vq->num_free == 0)\n\t\tport->outvq_full = true;\n\n\tif (nonblock)\n\t\tgoto done;\n\n\t/*\n\t * Wait till the host acknowledges it pushed out the data we\n\t * sent.  This is done for data from the hvc_console; the tty\n\t * operations are performed with spinlocks held so we can't\n\t * sleep here.  An alternative would be to copy the data to a\n\t * buffer and relax the spinning requirement.  The downside is\n\t * we need to kmalloc a GFP_ATOMIC buffer each time the\n\t * console driver writes something out.\n\t */\n\twhile (!virtqueue_get_buf(out_vq, &len)\n\t\t&& !virtqueue_is_broken(out_vq))\n\t\tcpu_relax();\ndone:\n\tspin_unlock_irqrestore(&port->outvq_lock, flags);\n\n\tport->stats.bytes_sent += in_count;\n\t/*\n\t * We're expected to return the amount of data we wrote -- all\n\t * of it\n\t */\n\treturn in_count;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4baad50297d84bde1a7ad45e50c73adae4a2192",
        "vul_func_with_fix": "static ssize_t __send_to_port(struct port *port, struct scatterlist *sg,\n\t\t\t      int nents, size_t in_count,\n\t\t\t      void *data, bool nonblock)\n{\n\tstruct virtqueue *out_vq;\n\tint err;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tout_vq = port->out_vq;\n\n\tspin_lock_irqsave(&port->outvq_lock, flags);\n\n\treclaim_consumed_buffers(port);\n\n\terr = virtqueue_add_outbuf(out_vq, sg, nents, data, GFP_ATOMIC);\n\n\t/* Tell Host to go! */\n\tvirtqueue_kick(out_vq);\n\n\tif (err) {\n\t\tin_count = 0;\n\t\tgoto done;\n\t}\n\n\tif (out_vq->num_free == 0)\n\t\tport->outvq_full = true;\n\n\tif (nonblock)\n\t\tgoto done;\n\n\t/*\n\t * Wait till the host acknowledges it pushed out the data we\n\t * sent.  This is done for data from the hvc_console; the tty\n\t * operations are performed with spinlocks held so we can't\n\t * sleep here.  An alternative would be to copy the data to a\n\t * buffer and relax the spinning requirement.  The downside is\n\t * we need to kmalloc a GFP_ATOMIC buffer each time the\n\t * console driver writes something out.\n\t */\n\twhile (!virtqueue_get_buf(out_vq, &len)\n\t\t&& !virtqueue_is_broken(out_vq))\n\t\tcpu_relax();\ndone:\n\tspin_unlock_irqrestore(&port->outvq_lock, flags);\n\n\tport->stats.bytes_sent += in_count;\n\t/*\n\t * We're expected to return the amount of data we wrote -- all\n\t * of it\n\t */\n\treturn in_count;\n}\n",
        "linevul": 6.943735934328288e-05,
        "sysevr": 0.19843262434005737,
        "devign": 4.515720529749585e-22
    },
    {
        "code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n\t\t\treturn ret;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n\treturn count;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/853bc26a7ea39e354b9f8889ae7ad1492ffa28d2",
        "vul_func_with_fix": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n//flaw_line_below:\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n//fix_flaw_line_below:\n//\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; /* XXX */\n \n//fix_flaw_line_below:\n//\to2nm_lock_subsystem();\n//fix_flaw_line_below:\n//\tcluster = to_o2nm_cluster_from_node(node);\n//fix_flaw_line_below:\n//\tif (!cluster) {\n//fix_flaw_line_below:\n//\t\tret = -EINVAL;\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \t/* the only failure case is trying to set a new local node\n \t * when a different one is already set */\n \tif (tmp && tmp == cluster->cl_has_local &&\n//flaw_line_below:\n\t    cluster->cl_local_node != node->nd_num)\n//flaw_line_below:\n\t\treturn -EBUSY;\n//fix_flaw_line_below:\n//\t    cluster->cl_local_node != node->nd_num) {\n//fix_flaw_line_below:\n//\t\tret = -EBUSY;\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n \n \t/* bring up the rx thread if we're setting the new local node. */\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n//flaw_line_below:\n\t\t\treturn ret;\n//fix_flaw_line_below:\n//\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n//flaw_line_below:\n\treturn count;\n//fix_flaw_line_below:\n//\tret = count;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//out:\n//fix_flaw_line_below:\n//\to2nm_unlock_subsystem();\n//fix_flaw_line_below:\n//\treturn ret;\n }\n",
        "linevul": 0.9990971088409424,
        "sysevr": 0.138567253947258,
        "devign": 0.06116519495844841
    },
    {
        "code": "int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    __put_user(info->var.yres, &f->fb_height) ||\n\t\t    __put_user(info->var.xres, &f->fb_width) ||\n\t\t    __put_user(fb_depth, &f->fb_depth) ||\n\t\t    __put_user(0, &f->fb_cmsize) ||\n\t\t    __put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n \t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n\t\tint index, count, i;\n \n \t\tif (get_user(index, &c->index) ||\n \t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n \t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tint index, count, i;\n \t\tu8 red, green, blue;\n \n \t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde",
        "vul_func_with_fix": "int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,\n\t\t\tstruct fb_info *info,\n\t\t\tint type, int fb_depth, unsigned long fb_size)\n{\n\tswitch(cmd) {\n\tcase FBIOGTYPE: {\n\t\tstruct fbtype __user *f = (struct fbtype __user *) arg;\n\n\t\tif (put_user(type, &f->fb_type) ||\n\t\t    __put_user(info->var.yres, &f->fb_height) ||\n\t\t    __put_user(info->var.xres, &f->fb_width) ||\n\t\t    __put_user(fb_depth, &f->fb_depth) ||\n\t\t    __put_user(0, &f->fb_cmsize) ||\n\t\t    __put_user(fb_size, &f->fb_cmsize))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n \t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n//flaw_line_below:\n\t\tint index, count, i;\n//fix_flaw_line_below:\n//\t\tunsigned int index, count, i;\n \n \t\tif (get_user(index, &c->index) ||\n \t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\tcmap.green = &green;\n\t\tcmap.blue = &blue;\n\t\tcmap.transp = NULL;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint err;\n\n\t\t\tif (get_user(red8, &ured[i]) ||\n\t\t\t    get_user(green8, &ugreen[i]) ||\n\t\t\t    get_user(blue8, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tred = red8 << 8;\n\t\t\tgreen = green8 << 8;\n\t\t\tblue = blue8 << 8;\n\n\t\t\tcmap.start = index + i;\n\t\t\terr = fb_set_cmap(&cmap, info);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n \t\tunsigned char __user *ugreen;\n \t\tunsigned char __user *ublue;\n \t\tstruct fb_cmap *cmap = &info->cmap;\n//flaw_line_below:\n\t\tint index, count, i;\n//fix_flaw_line_below:\n//\t\tunsigned int index, count, i;\n \t\tu8 red, green, blue;\n \n \t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tred = cmap->red[index + i] >> 8;\n\t\t\tgreen = cmap->green[index + i] >> 8;\n\t\t\tblue = cmap->blue[index + i] >> 8;\n\t\t\tif (put_user(red, &ured[i]) ||\n\t\t\t    put_user(green, &ugreen[i]) ||\n\t\t\t    put_user(blue, &ublue[i]))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "linevul": 6.374227814376354e-05,
        "sysevr": 0.27490586042404175,
        "devign": 0.9991700649261475
    },
    {
        "code": "static int qeth_core_thaw(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->thaw)\n\t\treturn card->discipline->thaw(gdev);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62",
        "vul_func_with_fix": "static int qeth_core_thaw(struct ccwgroup_device *gdev)\n{\n\tstruct qeth_card *card = dev_get_drvdata(&gdev->dev);\n\tif (card->discipline && card->discipline->thaw)\n\t\treturn card->discipline->thaw(gdev);\n\treturn 0;\n}\n",
        "linevul": 4.920448918710463e-05,
        "sysevr": 0.12811440229415894,
        "devign": 1.9019527286445737e-08
    },
    {
        "code": "static void nfs40_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\tnfs4_sequence_done(task, data->seq_res);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static void nfs40_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\tnfs4_sequence_done(task, data->seq_res);\n}\n",
        "linevul": 8.464621350867674e-05,
        "sysevr": 0.12569396197795868,
        "devign": 3.931404979340414e-09
    },
    {
        "code": "static void cma_release_dev(struct rdma_id_private *id_priv)\n{\n\tmutex_lock(&lock);\n\tlist_del(&id_priv->list);\n\tcma_deref_dev(id_priv->cma_dev);\n\tid_priv->cma_dev = NULL;\n\tmutex_unlock(&lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867",
        "vul_func_with_fix": "static void cma_release_dev(struct rdma_id_private *id_priv)\n{\n\tmutex_lock(&lock);\n\tlist_del(&id_priv->list);\n\tcma_deref_dev(id_priv->cma_dev);\n\tid_priv->cma_dev = NULL;\n\tmutex_unlock(&lock);\n}\n",
        "linevul": 9.24205087358132e-05,
        "sysevr": 0.1279982179403305,
        "devign": 1.306961650016092e-07
    },
    {
        "code": "void kvm_arch_sync_events(struct kvm *kvm)\n{\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "void kvm_arch_sync_events(struct kvm *kvm)\n{\n\tkvm_free_all_assigned_devices(kvm);\n\tkvm_free_pit(kvm);\n}\n",
        "linevul": 4.743700992548838e-05,
        "sysevr": 0.15591317415237427,
        "devign": 0.0017579466802999377
    },
    {
        "code": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n \tstruct genericPartitionMap *gpm;\n \tuint16_t ident;\n \tstruct buffer_head *bh;\n \tint ret = 0;\n \n \tbh = udf_read_tagged(sb, block, block, &ident);\n \tif (!bh)\n \t\treturn 1;\n \tBUG_ON(ident != TAG_IDENT_LVD);\n \tlvd = (struct logicalVolDesc *)bh->b_data;\n \n \tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n \tif (ret)\n \t\tgoto out_bh;\n \n \tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n \t     i++, offset += gpm->partitionMapLength) {\n \t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n \t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tuint32_t loc;\n\t\t\t\tstruct sparingTable *st;\n\t\t\t\tstruct sparablePartitionMap *spm =\n\t\t\t\t\t(struct sparablePartitionMap *)gpm;\n\n\t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =\n\t\t\t\t\t\tle16_to_cpu(spm->packetLength);\n\t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {\n\t\t\t\t\tstruct buffer_head *bh2;\n\n\t\t\t\t\tloc = le32_to_cpu(\n\t\t\t\t\t\tspm->locSparingTable[j]);\n\t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,\n\t\t\t\t\t\t\t     &ident);\n\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = bh2;\n\n\t\t\t\t\tif (bh2 == NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh2->b_data;\n\t\t\t\t\tif (ident != 0 || strncmp(\n\t\t\t\t\t\tst->sparingIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARING,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {\n\t\t\t\t\t\tbrelse(bh2);\n\t\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/adee11b2085bee90bd8f4f52123ffb07882d6256",
        "vul_func_with_fix": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n \tstruct genericPartitionMap *gpm;\n \tuint16_t ident;\n \tstruct buffer_head *bh;\n//fix_flaw_line_below:\n//\tunsigned int table_len;\n \tint ret = 0;\n \n \tbh = udf_read_tagged(sb, block, block, &ident);\n \tif (!bh)\n \t\treturn 1;\n \tBUG_ON(ident != TAG_IDENT_LVD);\n \tlvd = (struct logicalVolDesc *)bh->b_data;\n//fix_flaw_line_below:\n//\ttable_len = le32_to_cpu(lvd->mapTableLength);\n//fix_flaw_line_below:\n//\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n//fix_flaw_line_below:\n//\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n//fix_flaw_line_below:\n//\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n//fix_flaw_line_below:\n//\t\t\tsb->s_blocksize - sizeof(*lvd));\n//fix_flaw_line_below:\n//\t\tgoto out_bh;\n//fix_flaw_line_below:\n//\t}\n \n \tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n \tif (ret)\n \t\tgoto out_bh;\n \n \tfor (i = 0, offset = 0;\n//flaw_line_below:\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n//fix_flaw_line_below:\n//\t     i < sbi->s_partitions && offset < table_len;\n \t     i++, offset += gpm->partitionMapLength) {\n \t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n \t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(gpm1->partitionNum);\n\t\t\tmap->s_partition_func = NULL;\n\t\t} else if (type == 2) {\n\t\t\tstruct udfPartitionMap2 *upm2 =\n\t\t\t\t\t\t(struct udfPartitionMap2 *)gpm;\n\t\t\tif (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,\n\t\t\t\t\t\tstrlen(UDF_ID_VIRTUAL))) {\n\t\t\t\tu16 suf =\n\t\t\t\t\tle16_to_cpu(((__le16 *)upm2->partIdent.\n\t\t\t\t\t\t\tidentSuffix)[0]);\n\t\t\t\tif (suf < 0x0200) {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP15;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt15;\n\t\t\t\t} else {\n\t\t\t\t\tmap->s_partition_type =\n\t\t\t\t\t\t\tUDF_VIRTUAL_MAP20;\n\t\t\t\t\tmap->s_partition_func =\n\t\t\t\t\t\t\tudf_get_pblock_virt20;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARABLE,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARABLE))) {\n\t\t\t\tuint32_t loc;\n\t\t\t\tstruct sparingTable *st;\n\t\t\t\tstruct sparablePartitionMap *spm =\n\t\t\t\t\t(struct sparablePartitionMap *)gpm;\n\n\t\t\t\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\t\t\t\tmap->s_type_specific.s_sparing.s_packet_len =\n\t\t\t\t\t\tle16_to_cpu(spm->packetLength);\n\t\t\t\tfor (j = 0; j < spm->numSparingTables; j++) {\n\t\t\t\t\tstruct buffer_head *bh2;\n\n\t\t\t\t\tloc = le32_to_cpu(\n\t\t\t\t\t\tspm->locSparingTable[j]);\n\t\t\t\t\tbh2 = udf_read_tagged(sb, loc, loc,\n\t\t\t\t\t\t\t     &ident);\n\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = bh2;\n\n\t\t\t\t\tif (bh2 == NULL)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh2->b_data;\n\t\t\t\t\tif (ident != 0 || strncmp(\n\t\t\t\t\t\tst->sparingIdent.ident,\n\t\t\t\t\t\tUDF_ID_SPARING,\n\t\t\t\t\t\tstrlen(UDF_ID_SPARING))) {\n\t\t\t\t\t\tbrelse(bh2);\n\t\t\t\t\t\tmap->s_type_specific.s_sparing.\n\t\t\t\t\t\t\ts_spar_map[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap->s_partition_func = udf_get_pblock_spar15;\n\t\t\t} else if (!strncmp(upm2->partIdent.ident,\n\t\t\t\t\t\tUDF_ID_METADATA,\n\t\t\t\t\t\tstrlen(UDF_ID_METADATA))) {\n\t\t\t\tstruct udf_meta_data *mdata =\n\t\t\t\t\t&map->s_type_specific.s_metadata;\n\t\t\t\tstruct metadataPartitionMap *mdm =\n\t\t\t\t\t\t(struct metadataPartitionMap *)\n\t\t\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\t\t\tudf_debug(\"Parsing Logical vol part %d type %d  id=%s\\n\",\n\t\t\t\t\t  i, type, UDF_ID_METADATA);\n\n\t\t\t\tmap->s_partition_type = UDF_METADATA_MAP25;\n\t\t\t\tmap->s_partition_func = udf_get_pblock_meta25;\n\n\t\t\t\tmdata->s_meta_file_loc   =\n\t\t\t\t\tle32_to_cpu(mdm->metadataFileLoc);\n\t\t\t\tmdata->s_mirror_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataMirrorFileLoc);\n\t\t\t\tmdata->s_bitmap_file_loc =\n\t\t\t\t\tle32_to_cpu(mdm->metadataBitmapFileLoc);\n\t\t\t\tmdata->s_alloc_unit_size =\n\t\t\t\t\tle32_to_cpu(mdm->allocUnitSize);\n\t\t\t\tmdata->s_align_unit_size =\n\t\t\t\t\tle16_to_cpu(mdm->alignUnitSize);\n\t\t\t\tif (mdm->flags & 0x01)\n\t\t\t\t\tmdata->s_flags |= MF_DUPLICATE_MD;\n\n\t\t\t\tudf_debug(\"Metadata Ident suffix=0x%x\\n\",\n\t\t\t\t\t  le16_to_cpu(*(__le16 *)\n\t\t\t\t\t\t      mdm->partIdent.identSuffix));\n\t\t\t\tudf_debug(\"Metadata part num=%d\\n\",\n\t\t\t\t\t  le16_to_cpu(mdm->partitionNum));\n\t\t\t\tudf_debug(\"Metadata part alloc unit size=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->allocUnitSize));\n\t\t\t\tudf_debug(\"Metadata file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataFileLoc));\n\t\t\t\tudf_debug(\"Mirror file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataMirrorFileLoc));\n\t\t\t\tudf_debug(\"Bitmap file loc=%d\\n\",\n\t\t\t\t\t  le32_to_cpu(mdm->metadataBitmapFileLoc));\n\t\t\t\tudf_debug(\"Flags: %d %d\\n\",\n\t\t\t\t\t  mdata->s_flags, mdm->flags);\n\t\t\t} else {\n\t\t\t\tudf_debug(\"Unknown ident: %s\\n\",\n\t\t\t\t\t  upm2->partIdent.ident);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);\n\t\t\tmap->s_partition_num = le16_to_cpu(upm2->partitionNum);\n\t\t}\n\t\tudf_debug(\"Partition (%d:%d) type %d on volume %d\\n\",\n\t\t\t  i, map->s_partition_num, type, map->s_volumeseqnum);\n\t}\n\n\tif (fileset) {\n\t\tstruct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);\n\n\t\t*fileset = lelb_to_cpu(la->extLocation);\n\t\tudf_debug(\"FileSet found in LogicalVolDesc at block=%d, partition=%d\\n\",\n\t\t\t  fileset->logicalBlockNum,\n\t\t\t  fileset->partitionReferenceNum);\n\t}\n\tif (lvd->integritySeqExt.extLength)\n\t\tudf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));\n\nout_bh:\n\tbrelse(bh);\n\treturn ret;\n}\n",
        "linevul": 0.9995166063308716,
        "sysevr": 0.1556251347064972,
        "devign": 9.092659452632127e-20
    },
    {
        "code": "static void *established_get_next(struct seq_file *seq, void *cur)\n{\n\tstruct sock *sk = cur;\n\tstruct hlist_nulls_node *node;\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\t++st->num;\n\t++st->offset;\n\n\tsk = sk_nulls_next(sk);\n\n\tsk_nulls_for_each_from(sk, node) {\n\t\tif (sk->sk_family == st->family && net_eq(sock_net(sk), net))\n\t\t\treturn sk;\n\t}\n\n\tspin_unlock_bh(inet_ehash_lockp(&tcp_hashinfo, st->bucket));\n\t++st->bucket;\n\treturn established_get_first(seq);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "vul_func_with_fix": "static void *established_get_next(struct seq_file *seq, void *cur)\n{\n\tstruct sock *sk = cur;\n\tstruct hlist_nulls_node *node;\n\tstruct tcp_iter_state *st = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\t++st->num;\n\t++st->offset;\n\n\tsk = sk_nulls_next(sk);\n\n\tsk_nulls_for_each_from(sk, node) {\n\t\tif (sk->sk_family == st->family && net_eq(sock_net(sk), net))\n\t\t\treturn sk;\n\t}\n\n\tspin_unlock_bh(inet_ehash_lockp(&tcp_hashinfo, st->bucket));\n\t++st->bucket;\n\treturn established_get_first(seq);\n}\n",
        "linevul": 6.91338354954496e-05,
        "sysevr": 0.12397733330726624,
        "devign": 3.3942766721978184e-32
    },
    {
        "code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n \t\t\tbreak;\n \t\tif (ACCESS_ONCE(ctx->released) ||\n \t\t    fatal_signal_pending(current)) {\n \t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n \t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n \t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252",
        "vul_func_with_fix": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\n\tspin_lock(&ctx->event_wqh.lock);\n\t/*\n\t * After the __add_wait_queue the uwq is visible to userland\n\t * through poll/read().\n\t */\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n \t\t\tbreak;\n \t\tif (ACCESS_ONCE(ctx->released) ||\n \t\t    fatal_signal_pending(current)) {\n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * &ewq->wq may be queued in fork_event, but\n//fix_flaw_line_below:\n//\t\t\t * __remove_wait_queue ignores the head\n//fix_flaw_line_below:\n//\t\t\t * parameter. It would be a problem if it\n//fix_flaw_line_below:\n//\t\t\t * didn't.\n//fix_flaw_line_below:\n//\t\t\t */\n \t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n \t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n \t\t\t\tstruct userfaultfd_ctx *new;\n\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\n\t/*\n\t * ctx may go away after this if the userfault pseudo fd is\n\t * already released.\n\t */\nout:\n\tuserfaultfd_ctx_put(ctx);\n}\n",
        "linevul": 0.9980081915855408,
        "sysevr": 0.1308698207139969,
        "devign": 0.9997125267982483
    },
    {
        "code": "static void hash_release(void *private)\n{\n\tcrypto_free_ahash(private);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/72a763d805a48ac8c0bf48fdb510e84c12de51fe",
        "vul_func_with_fix": "static void hash_release(void *private)\n{\n\tcrypto_free_ahash(private);\n}\n",
        "linevul": 6.67678177705966e-05,
        "sysevr": 0.12852126359939575,
        "devign": 2.538508958593866e-09
    },
    {
        "code": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n {\n\tstruct perf_event *event = file->private_data;\n \tvoid (*func)(struct perf_event *);\n \tu32 flags = arg;\n \n \tswitch (cmd) {\n \tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = perf_event_enable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = perf_event_disable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = perf_event_reset;\n \t\tbreak;\n \n \tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn perf_event_refresh(event, arg);\n \n \tcase PERF_EVENT_IOC_PERIOD:\n \t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n \treturn 0;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
        "vul_func_with_fix": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n//fix_flaw_line_below:\n//static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)\n {\n//flaw_line_below:\n\tstruct perf_event *event = file->private_data;\n \tvoid (*func)(struct perf_event *);\n \tu32 flags = arg;\n \n \tswitch (cmd) {\n \tcase PERF_EVENT_IOC_ENABLE:\n//flaw_line_below:\n\t\tfunc = perf_event_enable;\n//fix_flaw_line_below:\n//\t\tfunc = _perf_event_enable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_DISABLE:\n//flaw_line_below:\n\t\tfunc = perf_event_disable;\n//fix_flaw_line_below:\n//\t\tfunc = _perf_event_disable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_RESET:\n//flaw_line_below:\n\t\tfunc = perf_event_reset;\n//fix_flaw_line_below:\n//\t\tfunc = _perf_event_reset;\n \t\tbreak;\n \n \tcase PERF_EVENT_IOC_REFRESH:\n//flaw_line_below:\n\t\treturn perf_event_refresh(event, arg);\n//fix_flaw_line_below:\n//\t\treturn _perf_event_refresh(event, arg);\n \n \tcase PERF_EVENT_IOC_PERIOD:\n \t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n \treturn 0;\n }\n",
        "linevul": 0.9990628361701965,
        "sysevr": 0.1366868019104004,
        "devign": 0.9994933605194092
    },
    {
        "code": "static void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f",
        "vul_func_with_fix": "static void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n",
        "linevul": 6.117862358223647e-05,
        "sysevr": 0.12852126359939575,
        "devign": 0.005675324704498053
    },
    {
        "code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\t/* C1 described at the top of this file */\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\t/* C2 and C3 */\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n \n \t/*\n \t * Borrow tag from the first request since they can't\n\t * be in flight at the same time.\n \t */\n \tif (q->mq_ops) {\n \t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n \t\tflush_rq->tag = first_rq->tag;\n \t}\n \n \tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9",
        "vul_func_with_fix": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\t/* C1 described at the top of this file */\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\t/* C2 and C3 */\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n \n \t/*\n \t * Borrow tag from the first request since they can't\n//flaw_line_below:\n\t * be in flight at the same time.\n//fix_flaw_line_below:\n//\t * be in flight at the same time. And acquire the tag's\n//fix_flaw_line_below:\n//\t * ownership for flush req.\n \t */\n \tif (q->mq_ops) {\n//fix_flaw_line_below:\n//\t\tstruct blk_mq_hw_ctx *hctx;\n//fix_flaw_line_below:\n//\n \t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n \t\tflush_rq->tag = first_rq->tag;\n//fix_flaw_line_below:\n//\t\tfq->orig_rq = first_rq;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n//fix_flaw_line_below:\n//\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n \t}\n \n \tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}\n",
        "linevul": 0.0002336060133529827,
        "sysevr": 0.2043619006872177,
        "devign": 0.9927444458007812
    },
    {
        "code": "armv6pmu_get_event_idx(struct cpu_hw_events *cpuc,\n\t\t       struct hw_perf_event *event)\n{\n\t/* Always place a cycle counter into the cycle counter. */\n\tif (ARMV6_PERFCTR_CPU_CYCLES == event->config_base) {\n\t\tif (test_and_set_bit(ARMV6_CYCLE_COUNTER, cpuc->used_mask))\n\t\t\treturn -EAGAIN;\n\n\t\treturn ARMV6_CYCLE_COUNTER;\n\t} else {\n\t\t/*\n\t\t * For anything other than a cycle counter, try and use\n\t\t * counter0 and counter1.\n\t\t */\n\t\tif (!test_and_set_bit(ARMV6_COUNTER1, cpuc->used_mask))\n\t\t\treturn ARMV6_COUNTER1;\n\n\t\tif (!test_and_set_bit(ARMV6_COUNTER0, cpuc->used_mask))\n\t\t\treturn ARMV6_COUNTER0;\n\n\t\t/* The counters are all in use. */\n\t\treturn -EAGAIN;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "armv6pmu_get_event_idx(struct cpu_hw_events *cpuc,\n\t\t       struct hw_perf_event *event)\n{\n\t/* Always place a cycle counter into the cycle counter. */\n\tif (ARMV6_PERFCTR_CPU_CYCLES == event->config_base) {\n\t\tif (test_and_set_bit(ARMV6_CYCLE_COUNTER, cpuc->used_mask))\n\t\t\treturn -EAGAIN;\n\n\t\treturn ARMV6_CYCLE_COUNTER;\n\t} else {\n\t\t/*\n\t\t * For anything other than a cycle counter, try and use\n\t\t * counter0 and counter1.\n\t\t */\n\t\tif (!test_and_set_bit(ARMV6_COUNTER1, cpuc->used_mask))\n\t\t\treturn ARMV6_COUNTER1;\n\n\t\tif (!test_and_set_bit(ARMV6_COUNTER0, cpuc->used_mask))\n\t\t\treturn ARMV6_COUNTER0;\n\n\t\t/* The counters are all in use. */\n\t\treturn -EAGAIN;\n\t}\n}\n",
        "linevul": 5.336334652383812e-05,
        "sysevr": 0.18011504411697388,
        "devign": 6.567863694507793e-19
    },
    {
        "code": "static int dccp_kmemdup_sysctl_table(struct net *net, struct nf_proto_net *pn,\n\t\t\t\t     struct dccp_net *dn)\n{\n#ifdef CONFIG_SYSCTL\n\tif (pn->ctl_table)\n\t\treturn 0;\n\n\tpn->ctl_table = kmemdup(dccp_sysctl_table,\n\t\t\t\tsizeof(dccp_sysctl_table),\n\t\t\t\tGFP_KERNEL);\n\tif (!pn->ctl_table)\n\t\treturn -ENOMEM;\n\n\tpn->ctl_table[0].data = &dn->dccp_timeout[CT_DCCP_REQUEST];\n\tpn->ctl_table[1].data = &dn->dccp_timeout[CT_DCCP_RESPOND];\n\tpn->ctl_table[2].data = &dn->dccp_timeout[CT_DCCP_PARTOPEN];\n\tpn->ctl_table[3].data = &dn->dccp_timeout[CT_DCCP_OPEN];\n\tpn->ctl_table[4].data = &dn->dccp_timeout[CT_DCCP_CLOSEREQ];\n\tpn->ctl_table[5].data = &dn->dccp_timeout[CT_DCCP_CLOSING];\n\tpn->ctl_table[6].data = &dn->dccp_timeout[CT_DCCP_TIMEWAIT];\n\tpn->ctl_table[7].data = &dn->dccp_loose;\n\n\t/* Don't export sysctls to unprivileged users */\n\tif (net->user_ns != &init_user_ns)\n\t\tpn->ctl_table[0].procname = NULL;\n#endif\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92",
        "vul_func_with_fix": "static int dccp_kmemdup_sysctl_table(struct net *net, struct nf_proto_net *pn,\n\t\t\t\t     struct dccp_net *dn)\n{\n#ifdef CONFIG_SYSCTL\n\tif (pn->ctl_table)\n\t\treturn 0;\n\n\tpn->ctl_table = kmemdup(dccp_sysctl_table,\n\t\t\t\tsizeof(dccp_sysctl_table),\n\t\t\t\tGFP_KERNEL);\n\tif (!pn->ctl_table)\n\t\treturn -ENOMEM;\n\n\tpn->ctl_table[0].data = &dn->dccp_timeout[CT_DCCP_REQUEST];\n\tpn->ctl_table[1].data = &dn->dccp_timeout[CT_DCCP_RESPOND];\n\tpn->ctl_table[2].data = &dn->dccp_timeout[CT_DCCP_PARTOPEN];\n\tpn->ctl_table[3].data = &dn->dccp_timeout[CT_DCCP_OPEN];\n\tpn->ctl_table[4].data = &dn->dccp_timeout[CT_DCCP_CLOSEREQ];\n\tpn->ctl_table[5].data = &dn->dccp_timeout[CT_DCCP_CLOSING];\n\tpn->ctl_table[6].data = &dn->dccp_timeout[CT_DCCP_TIMEWAIT];\n\tpn->ctl_table[7].data = &dn->dccp_loose;\n\n\t/* Don't export sysctls to unprivileged users */\n\tif (net->user_ns != &init_user_ns)\n\t\tpn->ctl_table[0].procname = NULL;\n#endif\n\treturn 0;\n}\n",
        "linevul": 6.658578058704734e-05,
        "sysevr": 0.176763653755188,
        "devign": 3.0898521144918047e-17
    },
    {
        "code": "super_1_rdev_size_change(struct md_rdev *rdev, sector_t num_sectors)\n{\n\tstruct mdp_superblock_1 *sb;\n\tsector_t max_sectors;\n\tif (num_sectors && num_sectors < rdev->mddev->dev_sectors)\n\t\treturn 0; /* component must fit device */\n\tif (rdev->data_offset != rdev->new_data_offset)\n\t\treturn 0; /* too confusing */\n\tif (rdev->sb_start < rdev->data_offset) {\n\t\t/* minor versions 1 and 2; superblock before data */\n\t\tmax_sectors = i_size_read(rdev->bdev->bd_inode) >> 9;\n\t\tmax_sectors -= rdev->data_offset;\n\t\tif (!num_sectors || num_sectors > max_sectors)\n\t\t\tnum_sectors = max_sectors;\n\t} else if (rdev->mddev->bitmap_info.offset) {\n\t\t/* minor version 0 with bitmap we can't move */\n\t\treturn 0;\n\t} else {\n\t\t/* minor version 0; superblock after data */\n\t\tsector_t sb_start;\n\t\tsb_start = (i_size_read(rdev->bdev->bd_inode) >> 9) - 8*2;\n\t\tsb_start &= ~(sector_t)(4*2 - 1);\n\t\tmax_sectors = rdev->sectors + sb_start - rdev->sb_start;\n\t\tif (!num_sectors || num_sectors > max_sectors)\n\t\t\tnum_sectors = max_sectors;\n\t\trdev->sb_start = sb_start;\n\t}\n\tsb = page_address(rdev->sb_page);\n\tsb->data_size = cpu_to_le64(num_sectors);\n\tsb->super_offset = rdev->sb_start;\n\tsb->sb_csum = calc_sb_1_csum(sb);\n\tmd_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,\n\t\t       rdev->sb_page);\n\tmd_super_wait(rdev->mddev);\n\treturn num_sectors;\n\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "super_1_rdev_size_change(struct md_rdev *rdev, sector_t num_sectors)\n{\n\tstruct mdp_superblock_1 *sb;\n\tsector_t max_sectors;\n\tif (num_sectors && num_sectors < rdev->mddev->dev_sectors)\n\t\treturn 0; /* component must fit device */\n\tif (rdev->data_offset != rdev->new_data_offset)\n\t\treturn 0; /* too confusing */\n\tif (rdev->sb_start < rdev->data_offset) {\n\t\t/* minor versions 1 and 2; superblock before data */\n\t\tmax_sectors = i_size_read(rdev->bdev->bd_inode) >> 9;\n\t\tmax_sectors -= rdev->data_offset;\n\t\tif (!num_sectors || num_sectors > max_sectors)\n\t\t\tnum_sectors = max_sectors;\n\t} else if (rdev->mddev->bitmap_info.offset) {\n\t\t/* minor version 0 with bitmap we can't move */\n\t\treturn 0;\n\t} else {\n\t\t/* minor version 0; superblock after data */\n\t\tsector_t sb_start;\n\t\tsb_start = (i_size_read(rdev->bdev->bd_inode) >> 9) - 8*2;\n\t\tsb_start &= ~(sector_t)(4*2 - 1);\n\t\tmax_sectors = rdev->sectors + sb_start - rdev->sb_start;\n\t\tif (!num_sectors || num_sectors > max_sectors)\n\t\t\tnum_sectors = max_sectors;\n\t\trdev->sb_start = sb_start;\n\t}\n\tsb = page_address(rdev->sb_page);\n\tsb->data_size = cpu_to_le64(num_sectors);\n\tsb->super_offset = rdev->sb_start;\n\tsb->sb_csum = calc_sb_1_csum(sb);\n\tmd_super_write(rdev->mddev, rdev, rdev->sb_start, rdev->sb_size,\n\t\t       rdev->sb_page);\n\tmd_super_wait(rdev->mddev);\n\treturn num_sectors;\n\n}\n",
        "linevul": 0.00015724904369562864,
        "sysevr": 0.21342290937900543,
        "devign": 1.4765291441526168e-30
    },
    {
        "code": "static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\t/*\n\t * Get and reset the IRQ flags\n\t */\n\tpmnc = armv7_pmnc_getreset_flags();\n\n\t/*\n\t * Did an overflow occur?\n\t */\n\tif (!armv7_pmnc_has_overflowed(pmnc))\n\t\treturn IRQ_NONE;\n\n\t/*\n\t * Handle the counter(s) overflow(s)\n\t */\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have a single interrupt for all counters. Check that\n\t\t * each counter has overflowed before we process it.\n\t\t */\n\t\tif (!armv7_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n\t\tif (perf_event_overflow(event, 0, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \n\t/*\n\t * Handle the pending perf events.\n\t *\n\t * Note: this call *must* be run with interrupts disabled. For\n\t * platforms that can have the PMU interrupts raised as an NMI, this\n\t * will not work.\n\t */\n\tirq_work_run();\n\n\treturn IRQ_HANDLED;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\t/*\n\t * Get and reset the IRQ flags\n\t */\n\tpmnc = armv7_pmnc_getreset_flags();\n\n\t/*\n\t * Did an overflow occur?\n\t */\n\tif (!armv7_pmnc_has_overflowed(pmnc))\n\t\treturn IRQ_NONE;\n\n\t/*\n\t * Handle the counter(s) overflow(s)\n\t */\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have a single interrupt for all counters. Check that\n\t\t * each counter has overflowed before we process it.\n\t\t */\n\t\tif (!armv7_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n//flaw_line_below:\n\t\tif (perf_event_overflow(event, 0, &data, regs))\n//fix_flaw_line_below:\n//\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \n\t/*\n\t * Handle the pending perf events.\n\t *\n\t * Note: this call *must* be run with interrupts disabled. For\n\t * platforms that can have the PMU interrupts raised as an NMI, this\n\t * will not work.\n\t */\n\tirq_work_run();\n\n\treturn IRQ_HANDLED;\n}\n",
        "linevul": 5.719129694625735e-05,
        "sysevr": 0.16469313204288483,
        "devign": 1.4461036812463135e-09
    },
    {
        "code": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n \t\t\t\t     const char *buf, size_t count)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n \n \tif (count > PATH_MAX)\n \t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n \tif (cp)\n \t\t*cp = '\\0';\n \n \tif (strlen(driver_override)) {\n \t\tpdev->driver_override = driver_override;\n \t} else {\n \t\tkfree(driver_override);\n \t\tpdev->driver_override = NULL;\n \t}\n \n \tkfree(old);\n \n\treturn count;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154",
        "vul_func_with_fix": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n \t\t\t\t     const char *buf, size_t count)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n//flaw_line_below:\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n//fix_flaw_line_below:\n//\tchar *driver_override, *old, *cp;\n \n \tif (count > PATH_MAX)\n \t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n \tif (cp)\n \t\t*cp = '\\0';\n \n//fix_flaw_line_below:\n//\tdevice_lock(dev);\n//fix_flaw_line_below:\n//\told = pdev->driver_override;\n \tif (strlen(driver_override)) {\n \t\tpdev->driver_override = driver_override;\n \t} else {\n \t\tkfree(driver_override);\n \t\tpdev->driver_override = NULL;\n \t}\n//fix_flaw_line_below:\n//\tdevice_unlock(dev);\n \n \tkfree(old);\n \n\treturn count;\n}\n",
        "linevul": 0.9996134638786316,
        "sysevr": 0.137218177318573,
        "devign": 4.579486660153805e-31
    },
    {
        "code": "static int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea",
        "vul_func_with_fix": "static int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n",
        "linevul": 5.080914343125187e-05,
        "sysevr": 0.12509508430957794,
        "devign": 0.4990455210208893
    },
    {
        "code": "packet_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint ret;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tswitch (optname) {\n\tcase PACKET_ADD_MEMBERSHIP:\n\tcase PACKET_DROP_MEMBERSHIP:\n\t{\n\t\tstruct packet_mreq_max mreq;\n\t\tint len = optlen;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tif (len < sizeof(struct packet_mreq))\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(mreq))\n\t\t\tlen = sizeof(mreq);\n\t\tif (copy_from_user(&mreq, optval, len))\n\t\t\treturn -EFAULT;\n\t\tif (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\n\t\t\treturn -EINVAL;\n\t\tif (optname == PACKET_ADD_MEMBERSHIP)\n\t\t\tret = packet_mc_add(sk, &mreq);\n\t\telse\n\t\t\tret = packet_mc_drop(sk, &mreq);\n\t\treturn ret;\n\t}\n\n\tcase PACKET_RX_RING:\n\tcase PACKET_TX_RING:\n\t{\n\t\tunion tpacket_req_u req_u;\n\t\tint len;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\t\tlen = sizeof(req_u.req);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\tdefault:\n\t\t\tlen = sizeof(req_u.req3);\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&req_u.req, optval, len))\n\t\t\treturn -EFAULT;\n\t\treturn packet_set_ring(sk, &req_u, 0,\n\t\t\toptname == PACKET_TX_RING);\n\t}\n\tcase PACKET_COPY_THRESH:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpkt_sk(sk)->copy_thresh = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VERSION:\n\t{\n\t\tint val;\n \n \t\tif (optlen != sizeof(val))\n \t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n \t\tif (copy_from_user(&val, optval, sizeof(val)))\n \t\t\treturn -EFAULT;\n \t\tswitch (val) {\n \t\tcase TPACKET_V1:\n \t\tcase TPACKET_V2:\n \t\tcase TPACKET_V3:\n\t\t\tpo->tp_version = val;\n\t\t\treturn 0;\n \t\tdefault:\n \t\t\treturn -EINVAL;\n \t\t}\n \t}\n \tcase PACKET_RESERVE:\n \t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_reserve = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_LOSS:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_loss = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_AUXDATA:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->auxdata = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_ORIGDEV:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->origdev = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VNET_HDR:\n\t{\n\t\tint val;\n\n\t\tif (sock->type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->has_vnet_hdr = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_TIMESTAMP:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->tp_tstamp = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_FANOUT:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\treturn fanout_add(sk, val & 0xffff, val >> 16);\n\t}\n\tcase PACKET_FANOUT_DATA:\n\t{\n\t\tif (!po->fanout)\n\t\t\treturn -EINVAL;\n\n\t\treturn fanout_set_data(po, optval, optlen);\n\t}\n\tcase PACKET_TX_HAS_OFF:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_tx_has_off = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_QDISC_BYPASS:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->xmit = val ? packet_direct_xmit : dev_queue_xmit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c",
        "vul_func_with_fix": "packet_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tint ret;\n\n\tif (level != SOL_PACKET)\n\t\treturn -ENOPROTOOPT;\n\n\tswitch (optname) {\n\tcase PACKET_ADD_MEMBERSHIP:\n\tcase PACKET_DROP_MEMBERSHIP:\n\t{\n\t\tstruct packet_mreq_max mreq;\n\t\tint len = optlen;\n\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\tif (len < sizeof(struct packet_mreq))\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(mreq))\n\t\t\tlen = sizeof(mreq);\n\t\tif (copy_from_user(&mreq, optval, len))\n\t\t\treturn -EFAULT;\n\t\tif (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))\n\t\t\treturn -EINVAL;\n\t\tif (optname == PACKET_ADD_MEMBERSHIP)\n\t\t\tret = packet_mc_add(sk, &mreq);\n\t\telse\n\t\t\tret = packet_mc_drop(sk, &mreq);\n\t\treturn ret;\n\t}\n\n\tcase PACKET_RX_RING:\n\tcase PACKET_TX_RING:\n\t{\n\t\tunion tpacket_req_u req_u;\n\t\tint len;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\tcase TPACKET_V2:\n\t\t\tlen = sizeof(req_u.req);\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\tdefault:\n\t\t\tlen = sizeof(req_u.req3);\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&req_u.req, optval, len))\n\t\t\treturn -EFAULT;\n\t\treturn packet_set_ring(sk, &req_u, 0,\n\t\t\toptname == PACKET_TX_RING);\n\t}\n\tcase PACKET_COPY_THRESH:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpkt_sk(sk)->copy_thresh = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VERSION:\n\t{\n\t\tint val;\n \n \t\tif (optlen != sizeof(val))\n \t\t\treturn -EINVAL;\n//flaw_line_below:\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n//flaw_line_below:\n\t\t\treturn -EBUSY;\n \t\tif (copy_from_user(&val, optval, sizeof(val)))\n \t\t\treturn -EFAULT;\n \t\tswitch (val) {\n \t\tcase TPACKET_V1:\n \t\tcase TPACKET_V2:\n \t\tcase TPACKET_V3:\n//flaw_line_below:\n\t\t\tpo->tp_version = val;\n//flaw_line_below:\n\t\t\treturn 0;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n \t\tdefault:\n \t\t\treturn -EINVAL;\n \t\t}\n//fix_flaw_line_below:\n//\t\tlock_sock(sk);\n//fix_flaw_line_below:\n//\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {\n//fix_flaw_line_below:\n//\t\t\tret = -EBUSY;\n//fix_flaw_line_below:\n//\t\t} else {\n//fix_flaw_line_below:\n//\t\t\tpo->tp_version = val;\n//fix_flaw_line_below:\n//\t\t\tret = 0;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\trelease_sock(sk);\n//fix_flaw_line_below:\n//\t\treturn ret;\n \t}\n \tcase PACKET_RESERVE:\n \t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_reserve = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_LOSS:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_loss = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_AUXDATA:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->auxdata = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_ORIGDEV:\n\t{\n\t\tint val;\n\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->origdev = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_VNET_HDR:\n\t{\n\t\tint val;\n\n\t\tif (sock->type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (optlen < sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->has_vnet_hdr = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_TIMESTAMP:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->tp_tstamp = val;\n\t\treturn 0;\n\t}\n\tcase PACKET_FANOUT:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\treturn fanout_add(sk, val & 0xffff, val >> 16);\n\t}\n\tcase PACKET_FANOUT_DATA:\n\t{\n\t\tif (!po->fanout)\n\t\t\treturn -EINVAL;\n\n\t\treturn fanout_set_data(po, optval, optlen);\n\t}\n\tcase PACKET_TX_HAS_OFF:\n\t{\n\t\tunsigned int val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\t\tpo->tp_tx_has_off = !!val;\n\t\treturn 0;\n\t}\n\tcase PACKET_QDISC_BYPASS:\n\t{\n\t\tint val;\n\n\t\tif (optlen != sizeof(val))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\t\treturn -EFAULT;\n\n\t\tpo->xmit = val ? packet_direct_xmit : dev_queue_xmit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n",
        "linevul": 0.00013058762124273926,
        "sysevr": 0.1642453670501709,
        "devign": 0.6093581318855286
    },
    {
        "code": "static void rxrpc_rxk5_free(struct rxk5_key *rxk5)\n{\n\tint loop;\n\n\trxrpc_free_krb5_principal(&rxk5->client);\n\trxrpc_free_krb5_principal(&rxk5->server);\n\trxrpc_free_krb5_tagged(&rxk5->session);\n\n\tif (rxk5->addresses) {\n\t\tfor (loop = rxk5->n_addresses - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->addresses[loop]);\n\t\tkfree(rxk5->addresses);\n\t}\n\tif (rxk5->authdata) {\n\t\tfor (loop = rxk5->n_authdata - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->authdata[loop]);\n\t\tkfree(rxk5->authdata);\n\t}\n\n\tkfree(rxk5->ticket);\n\tkfree(rxk5->ticket2);\n\tkfree(rxk5);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static void rxrpc_rxk5_free(struct rxk5_key *rxk5)\n{\n\tint loop;\n\n\trxrpc_free_krb5_principal(&rxk5->client);\n\trxrpc_free_krb5_principal(&rxk5->server);\n\trxrpc_free_krb5_tagged(&rxk5->session);\n\n\tif (rxk5->addresses) {\n\t\tfor (loop = rxk5->n_addresses - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->addresses[loop]);\n\t\tkfree(rxk5->addresses);\n\t}\n\tif (rxk5->authdata) {\n\t\tfor (loop = rxk5->n_authdata - 1; loop >= 0; loop--)\n\t\t\trxrpc_free_krb5_tagged(&rxk5->authdata[loop]);\n\t\tkfree(rxk5->authdata);\n\t}\n\n\tkfree(rxk5->ticket);\n\tkfree(rxk5->ticket2);\n\tkfree(rxk5);\n}\n",
        "linevul": 5.3733667300548404e-05,
        "sysevr": 0.12947385013103485,
        "devign": 2.7057795240481575e-11
    },
    {
        "code": "static int resize_buffer_duplicate_size(struct trace_buffer *trace_buf,\n\t\t\t\t\tstruct trace_buffer *size_buf, int cpu_id)\n{\n\tint cpu, ret = 0;\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu)->entries, cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tper_cpu_ptr(trace_buf->data, cpu)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu)->entries;\n\t\t}\n\t} else {\n\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu_id)->entries, cpu_id);\n\t\tif (ret == 0)\n\t\t\tper_cpu_ptr(trace_buf->data, cpu_id)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu_id)->entries;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "static int resize_buffer_duplicate_size(struct trace_buffer *trace_buf,\n\t\t\t\t\tstruct trace_buffer *size_buf, int cpu_id)\n{\n\tint cpu, ret = 0;\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu)->entries, cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tper_cpu_ptr(trace_buf->data, cpu)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu)->entries;\n\t\t}\n\t} else {\n\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu_id)->entries, cpu_id);\n\t\tif (ret == 0)\n\t\t\tper_cpu_ptr(trace_buf->data, cpu_id)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu_id)->entries;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 0.0001503986568422988,
        "sysevr": 0.12315573543310165,
        "devign": 0.00014360042405314744
    },
    {
        "code": "list_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tif (is_software_event(event))\n\t\t\tevent->group_flags |= PERF_GROUP_SOFTWARE;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tctx->nr_cgroups++;\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tif (!ctx->nr_events)\n\t\tperf_pmu_rotate_start(ctx->pmu);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "list_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tif (is_software_event(event))\n\t\t\tevent->group_flags |= PERF_GROUP_SOFTWARE;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tctx->nr_cgroups++;\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tif (!ctx->nr_events)\n\t\tperf_pmu_rotate_start(ctx->pmu);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n}\n",
        "linevul": 6.0531623603310436e-05,
        "sysevr": 0.185831218957901,
        "devign": 1.8763767298831245e-27
    },
    {
        "code": "int vhost_vq_access_ok(struct vhost_virtqueue *vq)\n{\n\treturn vq_access_ok(vq, vq->num, vq->desc, vq->avail, vq->used) &&\n\t\tvq_log_access_ok(vq, vq->log_base);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5",
        "vul_func_with_fix": "int vhost_vq_access_ok(struct vhost_virtqueue *vq)\n{\n\treturn vq_access_ok(vq, vq->num, vq->desc, vq->avail, vq->used) &&\n\t\tvq_log_access_ok(vq, vq->log_base);\n}\n",
        "linevul": 6.500536255771294e-05,
        "sysevr": 0.15150992572307587,
        "devign": 0.0005747686373069882
    },
    {
        "code": "void svc_rdma_xdr_encode_write_list(struct rpcrdma_msg *rmsgp, int chunks)\n{\n\tstruct rpcrdma_write_array *ary;\n\t/* no read-list */\n\trmsgp->rm_body.rm_chunks[0] = xdr_zero;\n\t/* write-array discrim */\n\tary = (struct rpcrdma_write_array *)\n\t\t&rmsgp->rm_body.rm_chunks[1];\n\tary->wc_discrim = xdr_one;\n\tary->wc_nchunks = cpu_to_be32(chunks);\n\t/* write-list terminator */\n\tary->wc_array[chunks].wc_target.rs_handle = xdr_zero;\n\t/* reply-array discriminator */\n\tary->wc_array[chunks].wc_target.rs_length = xdr_zero;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "void svc_rdma_xdr_encode_write_list(struct rpcrdma_msg *rmsgp, int chunks)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tstruct rpcrdma_write_array *ary;\n//flaw_line_below:\n\n//flaw_line_below:\n\t/* no read-list */\n//flaw_line_below:\n\trmsgp->rm_body.rm_chunks[0] = xdr_zero;\n//flaw_line_below:\n\n//flaw_line_below:\n\t/* write-array discrim */\n//flaw_line_below:\n\tary = (struct rpcrdma_write_array *)\n//flaw_line_below:\n\t\t&rmsgp->rm_body.rm_chunks[1];\n//flaw_line_below:\n\tary->wc_discrim = xdr_one;\n//flaw_line_below:\n\tary->wc_nchunks = cpu_to_be32(chunks);\n//flaw_line_below:\n\n//flaw_line_below:\n\t/* write-list terminator */\n//flaw_line_below:\n\tary->wc_array[chunks].wc_target.rs_handle = xdr_zero;\n//flaw_line_below:\n\n//flaw_line_below:\n\t/* reply-array discriminator */\n//flaw_line_below:\n\tary->wc_array[chunks].wc_target.rs_length = xdr_zero;\n//flaw_line_below:\n}\n",
        "linevul": 0.04344263672828674,
        "sysevr": 0.178214430809021,
        "devign": 0.021153736859560013
    },
    {
        "code": " static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n \treturn 0;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": " static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n//fix_flaw_line_below:\n//\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n",
        "linevul": 0.9989113807678223,
        "sysevr": 0.12901869416236877,
        "devign": 0.9666756391525269
    },
    {
        "code": "static sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4",
        "vul_func_with_fix": "static sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n",
        "linevul": 8.494450594298542e-05,
        "sysevr": 0.13296407461166382,
        "devign": 0.00022563931997865438
    },
    {
        "code": "static int hns_roce_del_gid(struct ib_device *device, u8 port_num,\n\t\t\t    unsigned int index, void **context)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(device);\n\tstruct ib_gid_attr zattr = { };\n\tunion ib_gid zgid = { {0} };\n\tu8 port = port_num - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port >= hr_dev->caps.num_ports)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tret = hr_dev->hw->set_gid(hr_dev, port, index, &zgid, &zattr);\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/df7e40425813c50cd252e6f5e348a81ef1acae56",
        "vul_func_with_fix": "static int hns_roce_del_gid(struct ib_device *device, u8 port_num,\n\t\t\t    unsigned int index, void **context)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(device);\n\tstruct ib_gid_attr zattr = { };\n\tunion ib_gid zgid = { {0} };\n\tu8 port = port_num - 1;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port >= hr_dev->caps.num_ports)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&hr_dev->iboe.lock, flags);\n\n\tret = hr_dev->hw->set_gid(hr_dev, port, index, &zgid, &zattr);\n\n\tspin_unlock_irqrestore(&hr_dev->iboe.lock, flags);\n\n\treturn ret;\n}\n",
        "linevul": 5.070570477982983e-05,
        "sysevr": 0.13070356845855713,
        "devign": 3.806212362530898e-17
    },
    {
        "code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\n\tif (!(dev->flags & IFF_UP) ||\n\t    (skb->len > (dev->mtu + dev->hard_header_len))) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/256df2f3879efdb2e9808bdb1b54b16fbb11fa38",
        "vul_func_with_fix": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\n\tif (!(dev->flags & IFF_UP) ||\n\t    (skb->len > (dev->mtu + dev->hard_header_len))) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}\n",
        "linevul": 4.792279651155695e-05,
        "sysevr": 0.15469542145729065,
        "devign": 9.078822924485493e-29
    },
    {
        "code": "static int usb_get_report(struct usb_device *dev,\n\t\t\t  struct usb_host_interface *inter, unsigned char type,\n\t\t\t  unsigned char id, void *buf, int size)\n{\n\treturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t       USB_REQ_GET_REPORT,\n\t\t\t       USB_DIR_IN | USB_TYPE_CLASS |\n\t\t\t       USB_RECIP_INTERFACE, (type << 8) + id,\n\t\t\t       inter->desc.bInterfaceNumber, buf, size,\n\t\t\t       GET_TIMEOUT*HZ);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4ec0ef3a82125efc36173062a50624550a900ae0",
        "vul_func_with_fix": "static int usb_get_report(struct usb_device *dev,\n\t\t\t  struct usb_host_interface *inter, unsigned char type,\n\t\t\t  unsigned char id, void *buf, int size)\n{\n\treturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t       USB_REQ_GET_REPORT,\n\t\t\t       USB_DIR_IN | USB_TYPE_CLASS |\n\t\t\t       USB_RECIP_INTERFACE, (type << 8) + id,\n\t\t\t       inter->desc.bInterfaceNumber, buf, size,\n\t\t\t       GET_TIMEOUT*HZ);\n}\n",
        "linevul": 0.0001391896657878533,
        "sysevr": 0.12086113542318344,
        "devign": 2.1875119273317978e-05
    },
    {
        "code": "int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cf01fb9985e8deb25ccf0ea54d916b8871ae0e62",
        "vul_func_with_fix": "int do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err;\n\tnodemask_t tmp;\n\n\terr = migrate_prep();\n\tif (err)\n\t\treturn err;\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tup_read(&mm->mmap_sem);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}\n",
        "linevul": 0.0001009862608043477,
        "sysevr": 0.2504807710647583,
        "devign": 2.1355482334900525e-24
    },
    {
        "code": "void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6caabe7f197d3466d238f70915d65301f1716626",
        "vul_func_with_fix": "void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}\n",
        "linevul": 6.223598029464483e-05,
        "sysevr": 0.168756365776062,
        "devign": 2.6287680717384095e-21
    },
    {
        "code": "nfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n",
        "linevul": 9.642959048505872e-05,
        "sysevr": 0.16160742938518524,
        "devign": 1.1920079181527987e-13
    },
    {
        "code": "static int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)\n{\n\tbool nmi_safe = false;\n\n\tswitch (clk_id) {\n\tcase CLOCK_MONOTONIC:\n\t\tevent->clock = &ktime_get_mono_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_MONOTONIC_RAW:\n\t\tevent->clock = &ktime_get_raw_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_REALTIME:\n\t\tevent->clock = &ktime_get_real_ns;\n\t\tbreak;\n\n\tcase CLOCK_BOOTTIME:\n\t\tevent->clock = &ktime_get_boot_ns;\n\t\tbreak;\n\n\tcase CLOCK_TAI:\n\t\tevent->clock = &ktime_get_tai_ns;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!nmi_safe && !(event->pmu->capabilities & PERF_PMU_CAP_NO_NMI))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "vul_func_with_fix": "static int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)\n{\n\tbool nmi_safe = false;\n\n\tswitch (clk_id) {\n\tcase CLOCK_MONOTONIC:\n\t\tevent->clock = &ktime_get_mono_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_MONOTONIC_RAW:\n\t\tevent->clock = &ktime_get_raw_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase CLOCK_REALTIME:\n\t\tevent->clock = &ktime_get_real_ns;\n\t\tbreak;\n\n\tcase CLOCK_BOOTTIME:\n\t\tevent->clock = &ktime_get_boot_ns;\n\t\tbreak;\n\n\tcase CLOCK_TAI:\n\t\tevent->clock = &ktime_get_tai_ns;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!nmi_safe && !(event->pmu->capabilities & PERF_PMU_CAP_NO_NMI))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "linevul": 5.2178671467117965e-05,
        "sysevr": 0.16064666211605072,
        "devign": 1.8284266831749216e-20
    },
    {
        "code": "ar6000_connect_event(struct ar6_softc *ar, u16 channel, u8 *bssid,\n                     u16 listenInterval, u16 beaconInterval,\n                     NETWORK_TYPE networkType, u8 beaconIeLen,\n                     u8 assocReqLen, u8 assocRespLen,\n                     u8 *assocInfo)\n{\n    union iwreq_data wrqu;\n    int i, beacon_ie_pos, assoc_resp_ie_pos, assoc_req_ie_pos;\n    static const char *tag1 = \"ASSOCINFO(ReqIEs=\";\n    static const char *tag2 = \"ASSOCRESPIE=\";\n    static const char *beaconIetag = \"BEACONIE=\";\n    char buf[WMI_CONTROL_MSG_MAX_LEN * 2 + strlen(tag1) + 1];\n    char *pos;\n    u8 key_op_ctrl;\n    unsigned long flags;\n    struct ieee80211req_key *ik;\n    CRYPTO_TYPE keyType = NONE_CRYPT;\n\n    if(ar->arNetworkType & AP_NETWORK) {\n        struct net_device *dev = ar->arNetDev;\n        if(memcmp(dev->dev_addr, bssid, ATH_MAC_LEN)==0) {\n            ar->arACS = channel;\n            ik = &ar->ap_mode_bkey;\n\n            switch(ar->arAuthMode) {\n            case NONE_AUTH:\n                if(ar->arPairwiseCrypto == WEP_CRYPT) {\n                    ar6000_install_static_wep_keys(ar);\n                }\n#ifdef WAPI_ENABLE\n                else if(ar->arPairwiseCrypto == WAPI_CRYPT) {\n                    ap_set_wapi_key(ar, ik);\n                }\n#endif\n                break;\n            case WPA_PSK_AUTH:\n            case WPA2_PSK_AUTH:\n            case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n                switch (ik->ik_type) {\n                    case IEEE80211_CIPHER_TKIP:\n                        keyType = TKIP_CRYPT;\n                        break;\n                    case IEEE80211_CIPHER_AES_CCM:\n                        keyType = AES_CRYPT;\n                        break;\n                    default:\n                       goto skip_key;\n                }\n                wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, keyType, GROUP_USAGE,\n                                ik->ik_keylen, (u8 *)&ik->ik_keyrsc,\n                                ik->ik_keydata, KEY_OP_INIT_VAL, ik->ik_macaddr,\n                                SYNC_BOTH_WMIFLAG);\n\n                break;\n            }\nskip_key:\n            ar->arConnected  = true;\n            return;\n        }\n\n        A_PRINTF(\"NEW STA %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \\n \"\n            \" AID=%d \\n\", bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5], channel);\n        switch ((listenInterval>>8)&0xFF) {\n            case OPEN_AUTH:\n                A_PRINTF(\"AUTH: OPEN\\n\");\n                break;\n            case SHARED_AUTH:\n                A_PRINTF(\"AUTH: SHARED\\n\");\n                break;\n            default:\n                A_PRINTF(\"AUTH: Unknown\\n\");\n                break;\n        }\n        switch (listenInterval&0xFF) {\n            case WPA_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA-PSK\\n\");\n                break;\n            case WPA2_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA2-PSK\\n\");\n                break;\n            default:\n                A_PRINTF(\"KeyMgmt: NONE\\n\");\n                break;\n        }\n        switch (beaconInterval) {\n            case AES_CRYPT:\n                A_PRINTF(\"Cipher: AES\\n\");\n                break;\n            case TKIP_CRYPT:\n                A_PRINTF(\"Cipher: TKIP\\n\");\n                break;\n            case WEP_CRYPT:\n                A_PRINTF(\"Cipher: WEP\\n\");\n                break;\n#ifdef WAPI_ENABLE\n            case WAPI_CRYPT:\n                A_PRINTF(\"Cipher: WAPI\\n\");\n                break;\n#endif\n            default:\n                A_PRINTF(\"Cipher: NONE\\n\");\n                break;\n        }\n\n        add_new_sta(ar, bssid, channel /*aid*/,\n            assocInfo /* WPA IE */, assocRespLen /* IE len */,\n            listenInterval&0xFF /* Keymgmt */, beaconInterval /* cipher */,\n            (listenInterval>>8)&0xFF /* auth alg */);\n\n        /* Send event to application */\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        memcpy(wrqu.addr.sa_data, bssid, ATH_MAC_LEN);\n        wireless_send_event(ar->arNetDev, IWEVREGISTERED, &wrqu, NULL);\n        /* In case the queue is stopped when we switch modes, this will\n         * wake it up\n         */\n        netif_wake_queue(ar->arNetDev);\n        return;\n    }\n\n    ar6k_cfg80211_connect_event(ar, channel, bssid,\n                                listenInterval, beaconInterval,\n                                networkType, beaconIeLen,\n                                assocReqLen, assocRespLen,\n                                assocInfo);\n\n    memcpy(ar->arBssid, bssid, sizeof(ar->arBssid));\n    ar->arBssChannel = channel;\n\n    A_PRINTF(\"AR6000 connected event on freq %d \", channel);\n    A_PRINTF(\"with bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \"\n            \" listenInterval=%d, beaconInterval = %d, beaconIeLen = %d assocReqLen=%d\"\n            \" assocRespLen =%d\\n\",\n             bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5],\n             listenInterval, beaconInterval,\n             beaconIeLen, assocReqLen, assocRespLen);\n    if (networkType & ADHOC_NETWORK) {\n        if (networkType & ADHOC_CREATOR) {\n            A_PRINTF(\"Network: Adhoc (Creator)\\n\");\n        } else {\n            A_PRINTF(\"Network: Adhoc (Joiner)\\n\");\n        }\n    } else {\n        A_PRINTF(\"Network: Infrastructure\\n\");\n    }\n\n    if ((ar->arNetworkType == INFRA_NETWORK)) {\n        wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB);\n    }\n\n    if (beaconIeLen && (sizeof(buf) > (9 + beaconIeLen * 2))) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nBeaconIEs= \"));\n\n        beacon_ie_pos = 0;\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", beaconIetag);\n        pos = buf + 9;\n        for (i = beacon_ie_pos; i < beacon_ie_pos + beaconIeLen; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocRespLen && (sizeof(buf) > (12 + (assocRespLen * 2))))\n    {\n        assoc_resp_ie_pos = beaconIeLen + assocReqLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16)  +  /* status Code */\n                            sizeof(u16)  ;  /* associd */\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag2);\n        pos = buf + 12;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nAssocRespIEs= \"));\n        /*\n         * The Association Response Frame w.o. the WLAN header is delivered to\n         * the host, so skip over to the IEs\n         */\n        for (i = assoc_resp_ie_pos; i < assoc_resp_ie_pos + assocRespLen - 6; i++)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocReqLen && (sizeof(buf) > (17 + (assocReqLen * 2)))) {\n        /*\n         * assoc Request includes capability and listen interval. Skip these.\n         */\n        assoc_req_ie_pos =  beaconIeLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16);    /* listen interval */\n\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag1);\n        pos = buf + 17;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"AssocReqIEs= \"));\n        for (i = assoc_req_ie_pos; i < assoc_req_ie_pos + assocReqLen - 4; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (ar->user_savedkeys_stat == USER_SAVEDKEYS_STAT_RUN &&\n        ar->user_saved_keys.keyOk == true)\n    {\n        key_op_ctrl = KEY_OP_VALID_MASK & ~KEY_OP_INIT_TSC;\n\n        if (ar->user_key_ctrl & AR6000_USER_SETKEYS_RSC_UNCHANGED) {\n            key_op_ctrl &= ~KEY_OP_INIT_RSC;\n        } else {\n            key_op_ctrl |= KEY_OP_INIT_RSC;\n        }\n        ar6000_reinstall_keys(ar, key_op_ctrl);\n    }\n\n    netif_wake_queue(ar->arNetDev);\n\n    /* Update connect & link status atomically */\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    ar->arConnectPending = false;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    /* reset the rx aggr state */\n    aggr_reset_state(ar->aggr_cntxt);\n    reconnect_flag = 0;\n\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    memcpy(wrqu.addr.sa_data, bssid, IEEE80211_ADDR_LEN);\n    wrqu.addr.sa_family = ARPHRD_ETHER;\n    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);\n    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable) {\n        A_MEMZERO(ar->arNodeMap, sizeof(ar->arNodeMap));\n        ar->arNodeNum = 0;\n        ar->arNexEpId = ENDPOINT_2;\n    }\n   if (!ar->arUserBssFilter) {\n        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n   }\n\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "ar6000_connect_event(struct ar6_softc *ar, u16 channel, u8 *bssid,\n                     u16 listenInterval, u16 beaconInterval,\n                     NETWORK_TYPE networkType, u8 beaconIeLen,\n                     u8 assocReqLen, u8 assocRespLen,\n                     u8 *assocInfo)\n{\n    union iwreq_data wrqu;\n    int i, beacon_ie_pos, assoc_resp_ie_pos, assoc_req_ie_pos;\n    static const char *tag1 = \"ASSOCINFO(ReqIEs=\";\n    static const char *tag2 = \"ASSOCRESPIE=\";\n    static const char *beaconIetag = \"BEACONIE=\";\n    char buf[WMI_CONTROL_MSG_MAX_LEN * 2 + strlen(tag1) + 1];\n    char *pos;\n    u8 key_op_ctrl;\n    unsigned long flags;\n    struct ieee80211req_key *ik;\n    CRYPTO_TYPE keyType = NONE_CRYPT;\n\n    if(ar->arNetworkType & AP_NETWORK) {\n        struct net_device *dev = ar->arNetDev;\n        if(memcmp(dev->dev_addr, bssid, ATH_MAC_LEN)==0) {\n            ar->arACS = channel;\n            ik = &ar->ap_mode_bkey;\n\n            switch(ar->arAuthMode) {\n            case NONE_AUTH:\n                if(ar->arPairwiseCrypto == WEP_CRYPT) {\n                    ar6000_install_static_wep_keys(ar);\n                }\n#ifdef WAPI_ENABLE\n                else if(ar->arPairwiseCrypto == WAPI_CRYPT) {\n                    ap_set_wapi_key(ar, ik);\n                }\n#endif\n                break;\n            case WPA_PSK_AUTH:\n            case WPA2_PSK_AUTH:\n            case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n                switch (ik->ik_type) {\n                    case IEEE80211_CIPHER_TKIP:\n                        keyType = TKIP_CRYPT;\n                        break;\n                    case IEEE80211_CIPHER_AES_CCM:\n                        keyType = AES_CRYPT;\n                        break;\n                    default:\n                       goto skip_key;\n                }\n                wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, keyType, GROUP_USAGE,\n                                ik->ik_keylen, (u8 *)&ik->ik_keyrsc,\n                                ik->ik_keydata, KEY_OP_INIT_VAL, ik->ik_macaddr,\n                                SYNC_BOTH_WMIFLAG);\n\n                break;\n            }\nskip_key:\n            ar->arConnected  = true;\n            return;\n        }\n\n        A_PRINTF(\"NEW STA %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \\n \"\n            \" AID=%d \\n\", bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5], channel);\n        switch ((listenInterval>>8)&0xFF) {\n            case OPEN_AUTH:\n                A_PRINTF(\"AUTH: OPEN\\n\");\n                break;\n            case SHARED_AUTH:\n                A_PRINTF(\"AUTH: SHARED\\n\");\n                break;\n            default:\n                A_PRINTF(\"AUTH: Unknown\\n\");\n                break;\n        }\n        switch (listenInterval&0xFF) {\n            case WPA_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA-PSK\\n\");\n                break;\n            case WPA2_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA2-PSK\\n\");\n                break;\n            default:\n                A_PRINTF(\"KeyMgmt: NONE\\n\");\n                break;\n        }\n        switch (beaconInterval) {\n            case AES_CRYPT:\n                A_PRINTF(\"Cipher: AES\\n\");\n                break;\n            case TKIP_CRYPT:\n                A_PRINTF(\"Cipher: TKIP\\n\");\n                break;\n            case WEP_CRYPT:\n                A_PRINTF(\"Cipher: WEP\\n\");\n                break;\n#ifdef WAPI_ENABLE\n            case WAPI_CRYPT:\n                A_PRINTF(\"Cipher: WAPI\\n\");\n                break;\n#endif\n            default:\n                A_PRINTF(\"Cipher: NONE\\n\");\n                break;\n        }\n\n        add_new_sta(ar, bssid, channel /*aid*/,\n            assocInfo /* WPA IE */, assocRespLen /* IE len */,\n            listenInterval&0xFF /* Keymgmt */, beaconInterval /* cipher */,\n            (listenInterval>>8)&0xFF /* auth alg */);\n\n        /* Send event to application */\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        memcpy(wrqu.addr.sa_data, bssid, ATH_MAC_LEN);\n        wireless_send_event(ar->arNetDev, IWEVREGISTERED, &wrqu, NULL);\n        /* In case the queue is stopped when we switch modes, this will\n         * wake it up\n         */\n        netif_wake_queue(ar->arNetDev);\n        return;\n    }\n\n    ar6k_cfg80211_connect_event(ar, channel, bssid,\n                                listenInterval, beaconInterval,\n                                networkType, beaconIeLen,\n                                assocReqLen, assocRespLen,\n                                assocInfo);\n\n    memcpy(ar->arBssid, bssid, sizeof(ar->arBssid));\n    ar->arBssChannel = channel;\n\n    A_PRINTF(\"AR6000 connected event on freq %d \", channel);\n    A_PRINTF(\"with bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \"\n            \" listenInterval=%d, beaconInterval = %d, beaconIeLen = %d assocReqLen=%d\"\n            \" assocRespLen =%d\\n\",\n             bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5],\n             listenInterval, beaconInterval,\n             beaconIeLen, assocReqLen, assocRespLen);\n    if (networkType & ADHOC_NETWORK) {\n        if (networkType & ADHOC_CREATOR) {\n            A_PRINTF(\"Network: Adhoc (Creator)\\n\");\n        } else {\n            A_PRINTF(\"Network: Adhoc (Joiner)\\n\");\n        }\n    } else {\n        A_PRINTF(\"Network: Infrastructure\\n\");\n    }\n\n    if ((ar->arNetworkType == INFRA_NETWORK)) {\n        wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB);\n    }\n\n    if (beaconIeLen && (sizeof(buf) > (9 + beaconIeLen * 2))) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nBeaconIEs= \"));\n\n        beacon_ie_pos = 0;\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", beaconIetag);\n        pos = buf + 9;\n        for (i = beacon_ie_pos; i < beacon_ie_pos + beaconIeLen; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocRespLen && (sizeof(buf) > (12 + (assocRespLen * 2))))\n    {\n        assoc_resp_ie_pos = beaconIeLen + assocReqLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16)  +  /* status Code */\n                            sizeof(u16)  ;  /* associd */\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag2);\n        pos = buf + 12;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nAssocRespIEs= \"));\n        /*\n         * The Association Response Frame w.o. the WLAN header is delivered to\n         * the host, so skip over to the IEs\n         */\n        for (i = assoc_resp_ie_pos; i < assoc_resp_ie_pos + assocRespLen - 6; i++)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocReqLen && (sizeof(buf) > (17 + (assocReqLen * 2)))) {\n        /*\n         * assoc Request includes capability and listen interval. Skip these.\n         */\n        assoc_req_ie_pos =  beaconIeLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16);    /* listen interval */\n\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag1);\n        pos = buf + 17;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"AssocReqIEs= \"));\n        for (i = assoc_req_ie_pos; i < assoc_req_ie_pos + assocReqLen - 4; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (ar->user_savedkeys_stat == USER_SAVEDKEYS_STAT_RUN &&\n        ar->user_saved_keys.keyOk == true)\n    {\n        key_op_ctrl = KEY_OP_VALID_MASK & ~KEY_OP_INIT_TSC;\n\n        if (ar->user_key_ctrl & AR6000_USER_SETKEYS_RSC_UNCHANGED) {\n            key_op_ctrl &= ~KEY_OP_INIT_RSC;\n        } else {\n            key_op_ctrl |= KEY_OP_INIT_RSC;\n        }\n        ar6000_reinstall_keys(ar, key_op_ctrl);\n    }\n\n    netif_wake_queue(ar->arNetDev);\n\n    /* Update connect & link status atomically */\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    ar->arConnectPending = false;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    /* reset the rx aggr state */\n    aggr_reset_state(ar->aggr_cntxt);\n    reconnect_flag = 0;\n\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    memcpy(wrqu.addr.sa_data, bssid, IEEE80211_ADDR_LEN);\n    wrqu.addr.sa_family = ARPHRD_ETHER;\n    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);\n    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable) {\n        A_MEMZERO(ar->arNodeMap, sizeof(ar->arNodeMap));\n        ar->arNodeNum = 0;\n        ar->arNexEpId = ENDPOINT_2;\n    }\n   if (!ar->arUserBssFilter) {\n        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n   }\n\n}\n",
        "linevul": 5.8447847550269216e-05,
        "sysevr": 0.324928879737854,
        "devign": 1.7244232359792994e-35
    },
    {
        "code": "struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (ret < local_nr_pages) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n \t\toffset = offset_in_page(uaddr);\n \t\tfor (j = cur_page; j < page_limit; j++) {\n \t\t\tunsigned int bytes = PAGE_SIZE - offset;\n \n \t\t\tif (len <= 0)\n \t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n \t\t\t\t\t    bytes)\n \t\t\t\tbreak;\n \n \t\t\tlen -= bytes;\n \t\t\toffset = 0;\n \t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tfor (j = 0; j < nr_pages; j++) {\n\t\tif (!pages[j])\n\t\t\tbreak;\n\t\tput_page(pages[j]);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467",
        "vul_func_with_fix": "struct bio *bio_map_user_iov(struct request_queue *q,\n\t\t\t     const struct iov_iter *iter,\n\t\t\t     gfp_t gfp_mask)\n{\n\tint j;\n\tint nr_pages = 0;\n\tstruct page **pages;\n\tstruct bio *bio;\n\tint cur_page = 0;\n\tint ret, offset;\n\tstruct iov_iter i;\n\tstruct iovec iov;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\n\t\t/*\n\t\t * Overflow, abort\n\t\t */\n\t\tif (end < start)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnr_pages += end - start;\n\t\t/*\n\t\t * buffer must be aligned to at least logical block size for now\n\t\t */\n\t\tif (uaddr & queue_dma_alignment(q))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_pages)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = -ENOMEM;\n\tpages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);\n\tif (!pages)\n\t\tgoto out;\n\n\tiov_for_each(iov, i, *iter) {\n\t\tunsigned long uaddr = (unsigned long) iov.iov_base;\n\t\tunsigned long len = iov.iov_len;\n\t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tunsigned long start = uaddr >> PAGE_SHIFT;\n\t\tconst int local_nr_pages = end - start;\n\t\tconst int page_limit = cur_page + local_nr_pages;\n\n\t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n\t\t\t\t(iter->type & WRITE) != WRITE,\n\t\t\t\t&pages[cur_page]);\n\t\tif (ret < local_nr_pages) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n \t\toffset = offset_in_page(uaddr);\n \t\tfor (j = cur_page; j < page_limit; j++) {\n \t\t\tunsigned int bytes = PAGE_SIZE - offset;\n//fix_flaw_line_below:\n//\t\t\tunsigned short prev_bi_vcnt = bio->bi_vcnt;\n \n \t\t\tif (len <= 0)\n \t\t\t\tbreak;\n\t\t\t\n\t\t\tif (bytes > len)\n\t\t\t\tbytes = len;\n\n\t\t\t/*\n\t\t\t * sorry...\n\t\t\t */\n\t\t\tif (bio_add_pc_page(q, bio, pages[j], bytes, offset) <\n \t\t\t\t\t    bytes)\n \t\t\t\tbreak;\n \n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * check if vector was merged with previous\n//fix_flaw_line_below:\n//\t\t\t * drop page reference if needed\n//fix_flaw_line_below:\n//\t\t\t */\n//fix_flaw_line_below:\n//\t\t\tif (bio->bi_vcnt == prev_bi_vcnt)\n//fix_flaw_line_below:\n//\t\t\t\tput_page(pages[j]);\n//fix_flaw_line_below:\n//\n \t\t\tlen -= bytes;\n \t\t\toffset = 0;\n \t\t}\n\n\t\tcur_page = j;\n\t\t/*\n\t\t * release the pages we didn't map into the bio, if any\n\t\t */\n\t\twhile (j < page_limit)\n\t\t\tput_page(pages[j++]);\n\t}\n\n\tkfree(pages);\n\n\tbio_set_flag(bio, BIO_USER_MAPPED);\n\n\t/*\n\t * subtle -- if bio_map_user_iov() ended up bouncing a bio,\n\t * it would normally disappear when its bi_end_io is run.\n\t * however, we need it for the unmap, so grab an extra\n\t * reference to it\n\t */\n\tbio_get(bio);\n\treturn bio;\n\n out_unmap:\n\tfor (j = 0; j < nr_pages; j++) {\n\t\tif (!pages[j])\n\t\t\tbreak;\n\t\tput_page(pages[j]);\n\t}\n out:\n\tkfree(pages);\n\tbio_put(bio);\n\treturn ERR_PTR(ret);\n}\n",
        "linevul": 0.9865183234214783,
        "sysevr": 0.21628016233444214,
        "devign": 0.9816934466362
    },
    {
        "code": "static int _regulator_call_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t       int min_uV, int max_uV,\n\t\t\t\t       unsigned *selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = _regulator_get_voltage(rdev);\n\tdata.min_uV = min_uV;\n\tdata.max_uV = max_uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "vul_func_with_fix": "static int _regulator_call_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t       int min_uV, int max_uV,\n\t\t\t\t       unsigned *selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = _regulator_get_voltage(rdev);\n\tdata.min_uV = min_uV;\n\tdata.max_uV = max_uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n",
        "linevul": 5.217040961724706e-05,
        "sysevr": 0.13305826485157013,
        "devign": 0.27018192410469055
    },
    {
        "code": "static struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->dcid == cid)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
        "vul_func_with_fix": "static struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)\n{\n\tstruct sock *s;\n\tfor (s = l->head; s; s = l2cap_pi(s)->next_c) {\n\t\tif (l2cap_pi(s)->dcid == cid)\n\t\t\tbreak;\n\t}\n\treturn s;\n}\n",
        "linevul": 5.4912514315219596e-05,
        "sysevr": 0.11961694061756134,
        "devign": 1.9536440607620387e-12
    },
    {
        "code": "static void *xt_match_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn xt_mttg_seq_start(seq, pos, false);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c",
        "vul_func_with_fix": "static void *xt_match_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn xt_mttg_seq_start(seq, pos, false);\n}\n",
        "linevul": 5.2675928600365296e-05,
        "sysevr": 0.1337057501077652,
        "devign": 1.8754377379082143e-05
    },
    {
        "code": "cifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b",
        "vul_func_with_fix": "cifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n",
        "linevul": 4.969496148987673e-05,
        "sysevr": 0.15836475789546967,
        "devign": 9.505247788865745e-08
    },
    {
        "code": "static struct svc_xprt *svc_rdma_bc_create(struct svc_serv *serv,\n\t\t\t\t\t   struct net *net,\n\t\t\t\t\t   struct sockaddr *sa, int salen,\n\t\t\t\t\t   int flags)\n{\n\tstruct svcxprt_rdma *cma_xprt;\n\tstruct svc_xprt *xprt;\n\n\tcma_xprt = rdma_create_xprt(serv, 0);\n\tif (!cma_xprt)\n\t\treturn ERR_PTR(-ENOMEM);\n\txprt = &cma_xprt->sc_xprt;\n\n\tsvc_xprt_init(net, &svc_rdma_bc_class, xprt, serv);\n\tset_bit(XPT_CONG_CTRL, &xprt->xpt_flags);\n\tserv->sv_bc_xprt = xprt;\n\n\tdprintk(\"svcrdma: %s(%p)\\n\", __func__, xprt);\n\treturn xprt;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static struct svc_xprt *svc_rdma_bc_create(struct svc_serv *serv,\n\t\t\t\t\t   struct net *net,\n\t\t\t\t\t   struct sockaddr *sa, int salen,\n\t\t\t\t\t   int flags)\n{\n\tstruct svcxprt_rdma *cma_xprt;\n\tstruct svc_xprt *xprt;\n\n\tcma_xprt = rdma_create_xprt(serv, 0);\n\tif (!cma_xprt)\n\t\treturn ERR_PTR(-ENOMEM);\n\txprt = &cma_xprt->sc_xprt;\n\n\tsvc_xprt_init(net, &svc_rdma_bc_class, xprt, serv);\n\tset_bit(XPT_CONG_CTRL, &xprt->xpt_flags);\n\tserv->sv_bc_xprt = xprt;\n\n\tdprintk(\"svcrdma: %s(%p)\\n\", __func__, xprt);\n\treturn xprt;\n}\n",
        "linevul": 0.0010452510323375463,
        "sysevr": 0.13645972311496735,
        "devign": 4.6369300066295693e-10
    },
    {
        "code": "static int pmcraid_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\tpmcraid_shutdown(pdev);\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpci_set_drvdata(pinstance->pdev, pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d",
        "vul_func_with_fix": "static int pmcraid_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\tpmcraid_shutdown(pdev);\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpci_set_drvdata(pinstance->pdev, pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n",
        "linevul": 5.142887675901875e-05,
        "sysevr": 0.12848062813282013,
        "devign": 6.259751472725839e-08
    },
    {
        "code": "static void ip6_append_data_mtu(int *mtu,\n \t\t\t\tint *maxfraglen,\n \t\t\t\tunsigned int fragheaderlen,\n \t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n {\n \tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n \t\tif (skb == NULL) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n \t\t\t * this fragment is not first, the headers\n \t\t\t * space is regarded as data space.\n \t\t\t */\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n \t\t}\n \t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n \t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be",
        "vul_func_with_fix": "static void ip6_append_data_mtu(int *mtu,\n//fix_flaw_line_below:\n//static void ip6_append_data_mtu(unsigned int *mtu,\n \t\t\t\tint *maxfraglen,\n \t\t\t\tunsigned int fragheaderlen,\n \t\t\t\tstruct sk_buff *skb,\n//flaw_line_below:\n\t\t\t\tstruct rt6_info *rt)\n//fix_flaw_line_below:\n//\t\t\t\tstruct rt6_info *rt,\n//fix_flaw_line_below:\n//\t\t\t\tbool pmtuprobe)\n {\n \tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n \t\tif (skb == NULL) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n \t\t\t * this fragment is not first, the headers\n \t\t\t * space is regarded as data space.\n \t\t\t */\n//flaw_line_below:\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n//fix_flaw_line_below:\n//\t\t\t*mtu = min(*mtu, pmtuprobe ?\n//fix_flaw_line_below:\n//\t\t\t\t   rt->dst.dev->mtu :\n//fix_flaw_line_below:\n//\t\t\t\t   dst_mtu(rt->dst.path));\n \t\t}\n \t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n \t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n",
        "linevul": 0.999383807182312,
        "sysevr": 0.12945526838302612,
        "devign": 0.999902606010437
    },
    {
        "code": "struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/acff81ec2c79492b180fade3c2894425cd35a545",
        "vul_func_with_fix": "struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}\n",
        "linevul": 0.00021160674805287272,
        "sysevr": 0.17124739289283752,
        "devign": 2.2173970992689362e-10
    },
    {
        "code": "static int isdn_net_ioctl(struct net_device *dev,\n\t\t\t  struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tswitch (lp->p_encap) {\n#ifdef CONFIG_ISDN_PPP\n\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\treturn isdn_ppp_dev_ioctl(dev, ifr, cmd);\n#endif\n\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\treturn isdn_ciscohdlck_dev_ioctl(dev, ifr, cmd);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static int isdn_net_ioctl(struct net_device *dev,\n\t\t\t  struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tswitch (lp->p_encap) {\n#ifdef CONFIG_ISDN_PPP\n\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\treturn isdn_ppp_dev_ioctl(dev, ifr, cmd);\n#endif\n\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\treturn isdn_ciscohdlck_dev_ioctl(dev, ifr, cmd);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "linevul": 4.762211756315082e-05,
        "sysevr": 0.12305936217308044,
        "devign": 1.1769320240606618e-10
    },
    {
        "code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n \tif (!ci)\n \t\treturn;\n \n\tkey_put(ci->ci_keyring_key);\n \tcrypto_free_skcipher(ci->ci_ctfm);\n \tkmem_cache_free(fscrypt_info_cachep, ci);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "vul_func_with_fix": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n \tif (!ci)\n \t\treturn;\n \n//flaw_line_below:\n\tkey_put(ci->ci_keyring_key);\n \tcrypto_free_skcipher(ci->ci_ctfm);\n \tkmem_cache_free(fscrypt_info_cachep, ci);\n }\n",
        "linevul": 0.9987297654151917,
        "sysevr": 0.12857657670974731,
        "devign": 0.9204409718513489
    },
    {
        "code": "static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n\tmsg->msg_namelen = sizeof(*sipx);\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n \t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n \t}\n \trc = copied;\n \nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *sipx = (struct sockaddr_ipx *)msg->msg_name;\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb)\n\t\tgoto out;\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, sizeof(struct ipxhdr), msg->msg_iov,\n\t\t\t\t     copied);\n\tif (rc)\n\t\tgoto out_free;\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n//flaw_line_below:\n\tmsg->msg_namelen = sizeof(*sipx);\n//flaw_line_below:\n\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n \t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n//fix_flaw_line_below:\n//\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
        "linevul": 0.0031827909406274557,
        "sysevr": 0.1704104095697403,
        "devign": 4.492493044239154e-10
    },
    {
        "code": "static void perf_branch_stack_sched_in(struct task_struct *prev,\n\t\t\t\t       struct task_struct *task)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\t/* no need to flush branch stack if not changing task */\n\tif (prev == task)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\t\t/*\n\t\t * check if the context has at least one\n\t\t * event using PERF_SAMPLE_BRANCH_STACK\n\t\t */\n\t\tif (cpuctx->ctx.nr_branch_stack > 0\n\t\t    && pmu->flush_branch_stack) {\n\n\t\t\tpmu = cpuctx->ctx.pmu;\n\n\t\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\n\t\t\tperf_pmu_disable(pmu);\n\n\t\t\tpmu->flush_branch_stack();\n\n\t\t\tperf_pmu_enable(pmu);\n\n\t\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tlocal_irq_restore(flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8176cced706b5e5d15887584150764894e94e02f",
        "vul_func_with_fix": "static void perf_branch_stack_sched_in(struct task_struct *prev,\n\t\t\t\t       struct task_struct *task)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\t/* no need to flush branch stack if not changing task */\n\tif (prev == task)\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\t\t/*\n\t\t * check if the context has at least one\n\t\t * event using PERF_SAMPLE_BRANCH_STACK\n\t\t */\n\t\tif (cpuctx->ctx.nr_branch_stack > 0\n\t\t    && pmu->flush_branch_stack) {\n\n\t\t\tpmu = cpuctx->ctx.pmu;\n\n\t\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\n\t\t\tperf_pmu_disable(pmu);\n\n\t\t\tpmu->flush_branch_stack();\n\n\t\t\tperf_pmu_enable(pmu);\n\n\t\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tlocal_irq_restore(flags);\n}\n",
        "linevul": 5.2176183089613914e-05,
        "sysevr": 0.1272323727607727,
        "devign": 0.0
    },
    {
        "code": "static void mac80211_hwsim_remove_interface(\n\tstruct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_check_magic(vif);\n\thwsim_clear_magic(vif);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "vul_func_with_fix": "static void mac80211_hwsim_remove_interface(\n\tstruct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\twiphy_dbg(hw->wiphy, \"%s (type=%d mac_addr=%pM)\\n\",\n\t\t  __func__, ieee80211_vif_type_p2p(vif),\n\t\t  vif->addr);\n\thwsim_check_magic(vif);\n\thwsim_clear_magic(vif);\n}\n",
        "linevul": 5.033363777329214e-05,
        "sysevr": 0.12851837277412415,
        "devign": 0.0009093288681469858
    },
    {
        "code": "static int swapin_walk_pmd_entry(pmd_t *pmd, unsigned long start,\n\tunsigned long end, struct mm_walk *walk)\n{\n\tpte_t *orig_pte;\n\tstruct vm_area_struct *vma = walk->private;\n\tunsigned long index;\n\n\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\treturn 0;\n\n\tfor (index = start; index != end; index += PAGE_SIZE) {\n\t\tpte_t pte;\n\t\tswp_entry_t entry;\n\t\tstruct page *page;\n\t\tspinlock_t *ptl;\n\n\t\torig_pte = pte_offset_map_lock(vma->vm_mm, pmd, start, &ptl);\n\t\tpte = *(orig_pte + ((index - start) / PAGE_SIZE));\n\t\tpte_unmap_unlock(orig_pte, ptl);\n\n\t\tif (pte_present(pte) || pte_none(pte))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\n\t\tpage = read_swap_cache_async(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tvma, index, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91",
        "vul_func_with_fix": "static int swapin_walk_pmd_entry(pmd_t *pmd, unsigned long start,\n\tunsigned long end, struct mm_walk *walk)\n{\n\tpte_t *orig_pte;\n\tstruct vm_area_struct *vma = walk->private;\n\tunsigned long index;\n\n\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n\t\treturn 0;\n\n\tfor (index = start; index != end; index += PAGE_SIZE) {\n\t\tpte_t pte;\n\t\tswp_entry_t entry;\n\t\tstruct page *page;\n\t\tspinlock_t *ptl;\n\n\t\torig_pte = pte_offset_map_lock(vma->vm_mm, pmd, start, &ptl);\n\t\tpte = *(orig_pte + ((index - start) / PAGE_SIZE));\n\t\tpte_unmap_unlock(orig_pte, ptl);\n\n\t\tif (pte_present(pte) || pte_none(pte))\n\t\t\tcontinue;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (unlikely(non_swap_entry(entry)))\n\t\t\tcontinue;\n\n\t\tpage = read_swap_cache_async(entry, GFP_HIGHUSER_MOVABLE,\n\t\t\t\t\t\t\tvma, index, false);\n\t\tif (page)\n\t\t\tput_page(page);\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 0.00028605989064089954,
        "sysevr": 0.12570244073867798,
        "devign": 1.5968920770719805e-23
    },
    {
        "code": "static int verify_newsa_info(struct xfrm_usersa_info *p,\n\t\t\t     struct nlattr **attrs)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tswitch (p->family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = -EINVAL;\n\tswitch (p->id.proto) {\n\tcase IPPROTO_AH:\n\t\tif ((!attrs[XFRMA_ALG_AUTH]\t&&\n\t\t     !attrs[XFRMA_ALG_AUTH_TRUNC]) ||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_ESP:\n\t\tif (attrs[XFRMA_ALG_COMP])\n\t\t\tgoto out;\n\t\tif (!attrs[XFRMA_ALG_AUTH] &&\n\t\t    !attrs[XFRMA_ALG_AUTH_TRUNC] &&\n\t\t    !attrs[XFRMA_ALG_CRYPT] &&\n\t\t    !attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif ((attrs[XFRMA_ALG_AUTH] ||\n\t\t     attrs[XFRMA_ALG_AUTH_TRUNC] ||\n\t\t     attrs[XFRMA_ALG_CRYPT]) &&\n\t\t    attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif (attrs[XFRMA_TFCPAD] &&\n\t\t    p->mode != XFRM_MODE_TUNNEL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\tif (!attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\tif (attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ENCAP]\t\t||\n\t\t    attrs[XFRMA_SEC_CTX]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    !attrs[XFRMA_COADDR])\n\t\t\tgoto out;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif ((err = verify_aead(attrs)))\n\t\tgoto out;\n\tif ((err = verify_auth_trunc(attrs)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\n\t\tgoto out;\n\tif ((err = verify_sec_ctx_len(attrs)))\n\t\tgoto out;\n\tif ((err = verify_replay(p, attrs)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tswitch (p->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_BEET:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static int verify_newsa_info(struct xfrm_usersa_info *p,\n\t\t\t     struct nlattr **attrs)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tswitch (p->family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = -EINVAL;\n\tswitch (p->id.proto) {\n\tcase IPPROTO_AH:\n\t\tif ((!attrs[XFRMA_ALG_AUTH]\t&&\n\t\t     !attrs[XFRMA_ALG_AUTH_TRUNC]) ||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_ESP:\n\t\tif (attrs[XFRMA_ALG_COMP])\n\t\t\tgoto out;\n\t\tif (!attrs[XFRMA_ALG_AUTH] &&\n\t\t    !attrs[XFRMA_ALG_AUTH_TRUNC] &&\n\t\t    !attrs[XFRMA_ALG_CRYPT] &&\n\t\t    !attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif ((attrs[XFRMA_ALG_AUTH] ||\n\t\t     attrs[XFRMA_ALG_AUTH_TRUNC] ||\n\t\t     attrs[XFRMA_ALG_CRYPT]) &&\n\t\t    attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif (attrs[XFRMA_TFCPAD] &&\n\t\t    p->mode != XFRM_MODE_TUNNEL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\tif (!attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\tif (attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ENCAP]\t\t||\n\t\t    attrs[XFRMA_SEC_CTX]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    !attrs[XFRMA_COADDR])\n\t\t\tgoto out;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif ((err = verify_aead(attrs)))\n\t\tgoto out;\n\tif ((err = verify_auth_trunc(attrs)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\n\t\tgoto out;\n\tif ((err = verify_sec_ctx_len(attrs)))\n\t\tgoto out;\n\tif ((err = verify_replay(p, attrs)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tswitch (p->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_BEET:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n",
        "linevul": 5.877280273125507e-05,
        "sysevr": 0.19279398024082184,
        "devign": 1.1106044518470053e-22
    },
    {
        "code": "static void tg3_read_hwsb_ver(struct tg3 *tp)\n{\n\tu32 val, major, minor;\n\n\t/* Use native endian representation */\n\tif (tg3_nvram_read(tp, TG3_NVM_HWSB_CFG1, &val))\n\t\treturn;\n\n\tmajor = (val & TG3_NVM_HWSB_CFG1_MAJMSK) >>\n\t\tTG3_NVM_HWSB_CFG1_MAJSFT;\n\tminor = (val & TG3_NVM_HWSB_CFG1_MINMSK) >>\n\t\tTG3_NVM_HWSB_CFG1_MINSFT;\n\n\tsnprintf(&tp->fw_ver[0], 32, \"sb v%d.%02d\", major, minor);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
        "vul_func_with_fix": "static void tg3_read_hwsb_ver(struct tg3 *tp)\n{\n\tu32 val, major, minor;\n\n\t/* Use native endian representation */\n\tif (tg3_nvram_read(tp, TG3_NVM_HWSB_CFG1, &val))\n\t\treturn;\n\n\tmajor = (val & TG3_NVM_HWSB_CFG1_MAJMSK) >>\n\t\tTG3_NVM_HWSB_CFG1_MAJSFT;\n\tminor = (val & TG3_NVM_HWSB_CFG1_MINMSK) >>\n\t\tTG3_NVM_HWSB_CFG1_MINSFT;\n\n\tsnprintf(&tp->fw_ver[0], 32, \"sb v%d.%02d\", major, minor);\n}\n",
        "linevul": 4.806756624020636e-05,
        "sysevr": 0.12280707061290741,
        "devign": 4.542519309325144e-05
    },
    {
        "code": "sta_t *ieee80211_find_conn_for_aid(struct ar6_softc *ar, u8 aid)\n{\n    sta_t *conn = NULL;\n    u8 ctr;\n\n    for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n        if (ar->sta_list[ctr].aid == aid) {\n            conn = &ar->sta_list[ctr];\n            break;\n        }\n    }\n    return conn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "sta_t *ieee80211_find_conn_for_aid(struct ar6_softc *ar, u8 aid)\n{\n    sta_t *conn = NULL;\n    u8 ctr;\n\n    for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n        if (ar->sta_list[ctr].aid == aid) {\n            conn = &ar->sta_list[ctr];\n            break;\n        }\n    }\n    return conn;\n}\n",
        "linevul": 4.836888547288254e-05,
        "sysevr": 0.1712539792060852,
        "devign": 5.779866369077461e-20
    },
    {
        "code": "static void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e9c6a182649f4259db704ae15a91ac820e63b0ca",
        "vul_func_with_fix": "static void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n",
        "linevul": 0.00010450978152221069,
        "sysevr": 0.12534551322460175,
        "devign": 4.1137250932280606e-16
    },
    {
        "code": "static inline int verify_replay(struct xfrm_usersa_info *p,\n \t\t\t\tstruct nlattr **attrs)\n {\n \tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n \n\tif ((p->flags & XFRM_STATE_ESN) && !rt)\n\t\treturn -EINVAL;\n \n \tif (!rt)\n \t\treturn 0;\n\n\tif (p->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/ecd7918745234e423dd87fcc0c077da557909720",
        "vul_func_with_fix": "static inline int verify_replay(struct xfrm_usersa_info *p,\n \t\t\t\tstruct nlattr **attrs)\n {\n \tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n//fix_flaw_line_below:\n//\tstruct xfrm_replay_state_esn *rs;\n \n//flaw_line_below:\n\tif ((p->flags & XFRM_STATE_ESN) && !rt)\n//flaw_line_below:\n\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\tif (p->flags & XFRM_STATE_ESN) {\n//fix_flaw_line_below:\n//\t\tif (!rt)\n//fix_flaw_line_below:\n//\t\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\trs = nla_data(rt);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\n//fix_flaw_line_below:\n//\t\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\n//fix_flaw_line_below:\n//\t\t    nla_len(rt) != sizeof(*rs))\n//fix_flaw_line_below:\n//\t\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\t}\n \n \tif (!rt)\n \t\treturn 0;\n\n\tif (p->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "linevul": 0.9995508790016174,
        "sysevr": 0.11928097158670425,
        "devign": 0.9997777342796326
    },
    {
        "code": "static void free_all_urbs(pegasus_t *pegasus)\n{\n\tusb_free_urb(pegasus->intr_urb);\n\tusb_free_urb(pegasus->tx_urb);\n\tusb_free_urb(pegasus->rx_urb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5593523f968bc86d42a035c6df47d5e0979b5ace",
        "vul_func_with_fix": "static void free_all_urbs(pegasus_t *pegasus)\n{\n\tusb_free_urb(pegasus->intr_urb);\n\tusb_free_urb(pegasus->tx_urb);\n\tusb_free_urb(pegasus->rx_urb);\n}\n",
        "linevul": 0.00012899543798994273,
        "sysevr": 0.12852126359939575,
        "devign": 0.3370784819126129
    },
    {
        "code": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84",
        "vul_func_with_fix": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}\n",
        "linevul": 0.00012149079702794552,
        "sysevr": 0.12831978499889374,
        "devign": 0.00032025828841142356
    },
    {
        "code": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n \n \tif (S_ISDIR(inode->i_mode)) {\n \t\t/* DACs are overridable for directories */\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n \t\t\treturn 0;\n \t\tif (!(mask & MAY_WRITE))\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n \t\t\t\treturn 0;\n \t\treturn -EACCES;\n \t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n \t * at least one exec bit set.\n \t */\n \tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n \t\t\treturn 0;\n \n \t/*\n \t * Searching includes executable on directories, else just read.\n \t */\n \tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n \tif (mask == MAY_READ)\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n \t\t\treturn 0;\n \n \treturn -EACCES;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03",
        "vul_func_with_fix": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n \n \tif (S_ISDIR(inode->i_mode)) {\n \t\t/* DACs are overridable for directories */\n//flaw_line_below:\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n//fix_flaw_line_below:\n//\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n \t\t\treturn 0;\n \t\tif (!(mask & MAY_WRITE))\n//flaw_line_below:\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n//fix_flaw_line_below:\n//\t\t\tif (capable_wrt_inode_uidgid(inode,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n \t\t\t\treturn 0;\n \t\treturn -EACCES;\n \t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n \t * at least one exec bit set.\n \t */\n \tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n//flaw_line_below:\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n//fix_flaw_line_below:\n//\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n \t\t\treturn 0;\n \n \t/*\n \t * Searching includes executable on directories, else just read.\n \t */\n \tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n \tif (mask == MAY_READ)\n//flaw_line_below:\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n//fix_flaw_line_below:\n//\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n \t\t\treturn 0;\n \n \treturn -EACCES;\n}\n",
        "linevul": 0.9992475509643555,
        "sysevr": 0.1741902232170105,
        "devign": 0.9999277591705322
    },
    {
        "code": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982",
        "vul_func_with_fix": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n//fix_flaw_line_below:\n//\tif (!test_opt(sbi, FLUSH_MERGE))\n//fix_flaw_line_below:\n//\t\treturn err;\n//fix_flaw_line_below:\n//\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n",
        "linevul": 0.9992314577102661,
        "sysevr": 0.21188373863697052,
        "devign": 0.9977681636810303
    },
    {
        "code": "unsigned int kmem_cache_size(struct kmem_cache *s)\n{\n\treturn s->objsize;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "unsigned int kmem_cache_size(struct kmem_cache *s)\n{\n\treturn s->objsize;\n}\n",
        "linevul": 0.00020654314721468836,
        "sysevr": 0.14466212689876556,
        "devign": 0.005750025622546673
    },
    {
        "code": "static void netlink_overrun(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tif (!(nlk->flags & NETLINK_F_RECV_NO_ENOBUFS)) {\n\t\tif (!test_and_set_bit(NETLINK_S_CONGESTED,\n\t\t\t\t      &nlk_sk(sk)->state)) {\n\t\t\tsk->sk_err = ENOBUFS;\n\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n\tatomic_inc(&sk->sk_drops);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92964c79b357efd980812c4de5c1fd2ec8bb5520",
        "vul_func_with_fix": "static void netlink_overrun(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tif (!(nlk->flags & NETLINK_F_RECV_NO_ENOBUFS)) {\n\t\tif (!test_and_set_bit(NETLINK_S_CONGESTED,\n\t\t\t\t      &nlk_sk(sk)->state)) {\n\t\t\tsk->sk_err = ENOBUFS;\n\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n\tatomic_inc(&sk->sk_drops);\n}\n",
        "linevul": 9.857425902737305e-05,
        "sysevr": 0.12134125083684921,
        "devign": 7.362779683899381e-14
    },
    {
        "code": "int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tconst struct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto csum_error;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable, proto);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\tif (sk) {\n\t\tint ret;\n\n\t\tif (!uh->check && !udp_sk(sk)->no_check6_rx) {\n\t\t\tsock_put(sk);\n\t\t\tudp6_csum_zero_error(skb);\n\t\t\tgoto csum_error;\n\t\t}\n\n\t\tif (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))\n\t\t\tskb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,\n\t\t\t\t\t\t ip6_compute_pseudo);\n\n\t\tret = udpv6_queue_rcv_skb(sk, skb);\n\t\tsock_put(sk);\n\n\t\t/* a return value > 0 means to resubmit the input, but\n\t\t * it wants the return to be -protocol, or 0\n\t\t */\n\t\tif (ret > 0)\n\t\t\treturn -ret;\n\n\t\treturn 0;\n\t}\n\n\tif (!uh->check) {\n\t\tudp6_csum_zero_error(skb);\n\t\tgoto csum_error;\n\t}\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard;\n\n\tif (udp_lib_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n\nshort_packet:\n\tnet_dbg_ratelimited(\"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t\t    proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t\t    saddr, ntohs(uh->source),\n\t\t\t    ulen, skb->len,\n\t\t\t    daddr, ntohs(uh->dest));\n\tgoto discard;\ncsum_error:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0",
        "vul_func_with_fix": "int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tconst struct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto csum_error;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable, proto);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\tif (sk) {\n\t\tint ret;\n\n\t\tif (!uh->check && !udp_sk(sk)->no_check6_rx) {\n\t\t\tsock_put(sk);\n\t\t\tudp6_csum_zero_error(skb);\n\t\t\tgoto csum_error;\n\t\t}\n\n\t\tif (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))\n\t\t\tskb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,\n\t\t\t\t\t\t ip6_compute_pseudo);\n\n\t\tret = udpv6_queue_rcv_skb(sk, skb);\n\t\tsock_put(sk);\n\n\t\t/* a return value > 0 means to resubmit the input, but\n\t\t * it wants the return to be -protocol, or 0\n\t\t */\n\t\tif (ret > 0)\n\t\t\treturn -ret;\n\n\t\treturn 0;\n\t}\n\n\tif (!uh->check) {\n\t\tudp6_csum_zero_error(skb);\n\t\tgoto csum_error;\n\t}\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard;\n\n\tif (udp_lib_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n\nshort_packet:\n\tnet_dbg_ratelimited(\"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t\t    proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t\t    saddr, ntohs(uh->source),\n\t\t\t    ulen, skb->len,\n\t\t\t    daddr, ntohs(uh->dest));\n\tgoto discard;\ncsum_error:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}\n",
        "linevul": 8.364785026060417e-05,
        "sysevr": 0.2446490228176117,
        "devign": 0.0
    },
    {
        "code": "static int rds_ib_conn_info_visitor(struct rds_connection *conn,\n\t\t\t\t    void *buffer)\n{\n\tstruct rds_info_rdma_connection *iinfo = buffer;\n\tstruct rds_ib_connection *ic;\n\n\t/* We will only ever look at IB transports */\n\tif (conn->c_trans != &rds_ib_transport)\n\t\treturn 0;\n\n\tiinfo->src_addr = conn->c_laddr;\n\tiinfo->dst_addr = conn->c_faddr;\n\n\tmemset(&iinfo->src_gid, 0, sizeof(iinfo->src_gid));\n\tmemset(&iinfo->dst_gid, 0, sizeof(iinfo->dst_gid));\n\tif (rds_conn_state(conn) == RDS_CONN_UP) {\n\t\tstruct rds_ib_device *rds_ibdev;\n\t\tstruct rdma_dev_addr *dev_addr;\n\n\t\tic = conn->c_transport_data;\n\t\tdev_addr = &ic->i_cm_id->route.addr.dev_addr;\n\n\t\trdma_addr_get_sgid(dev_addr, (union ib_gid *) &iinfo->src_gid);\n\t\trdma_addr_get_dgid(dev_addr, (union ib_gid *) &iinfo->dst_gid);\n\n\t\trds_ibdev = ic->rds_ibdev;\n\t\tiinfo->max_send_wr = ic->i_send_ring.w_nr;\n\t\tiinfo->max_recv_wr = ic->i_recv_ring.w_nr;\n\t\tiinfo->max_send_sge = rds_ibdev->max_sge;\n\t\trds_ib_get_mr_info(rds_ibdev, iinfo);\n\t}\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2349758acf1874e4c2b93fe41d072336f1a31d0",
        "vul_func_with_fix": "static int rds_ib_conn_info_visitor(struct rds_connection *conn,\n\t\t\t\t    void *buffer)\n{\n\tstruct rds_info_rdma_connection *iinfo = buffer;\n\tstruct rds_ib_connection *ic;\n\n\t/* We will only ever look at IB transports */\n\tif (conn->c_trans != &rds_ib_transport)\n\t\treturn 0;\n\n\tiinfo->src_addr = conn->c_laddr;\n\tiinfo->dst_addr = conn->c_faddr;\n\n\tmemset(&iinfo->src_gid, 0, sizeof(iinfo->src_gid));\n\tmemset(&iinfo->dst_gid, 0, sizeof(iinfo->dst_gid));\n\tif (rds_conn_state(conn) == RDS_CONN_UP) {\n\t\tstruct rds_ib_device *rds_ibdev;\n\t\tstruct rdma_dev_addr *dev_addr;\n\n\t\tic = conn->c_transport_data;\n\t\tdev_addr = &ic->i_cm_id->route.addr.dev_addr;\n\n\t\trdma_addr_get_sgid(dev_addr, (union ib_gid *) &iinfo->src_gid);\n\t\trdma_addr_get_dgid(dev_addr, (union ib_gid *) &iinfo->dst_gid);\n\n\t\trds_ibdev = ic->rds_ibdev;\n\t\tiinfo->max_send_wr = ic->i_send_ring.w_nr;\n\t\tiinfo->max_recv_wr = ic->i_recv_ring.w_nr;\n\t\tiinfo->max_send_sge = rds_ibdev->max_sge;\n\t\trds_ib_get_mr_info(rds_ibdev, iinfo);\n\t}\n\treturn 1;\n}\n",
        "linevul": 8.191558299586177e-05,
        "sysevr": 0.13446389138698578,
        "devign": 2.3263245552129774e-08
    },
    {
        "code": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5",
        "vul_func_with_fix": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\n\tpr_debug(\"Sending CC\\n\");\n\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\t/* If the socket parameters are not set, use the local ones */\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n//fix_flaw_line_below:\n//\tif (!miux_tlv) {\n//fix_flaw_line_below:\n//\t\terr = -ENOMEM;\n//fix_flaw_line_below:\n//\t\tgoto error_tlv;\n//fix_flaw_line_below:\n//\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n//fix_flaw_line_below:\n//\tif (!rw_tlv) {\n//fix_flaw_line_below:\n//\t\terr = -ENOMEM;\n//fix_flaw_line_below:\n//\t\tgoto error_tlv;\n//fix_flaw_line_below:\n//\t}\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\n\tskb_queue_tail(&local->tx_queue, skb);\n\n\terr = 0;\n\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\n\treturn err;\n}\n",
        "linevul": 0.9991642236709595,
        "sysevr": 0.17313067615032196,
        "devign": 0.9872740507125854
    },
    {
        "code": "int kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tslot->arch.lpage_info[i - 1] = kvm_kvzalloc(lpages *\n\t\t\t\t\tsizeof(*slot->arch.lpage_info[i - 1]));\n\t\tif (!slot->arch.lpage_info[i - 1])\n\t\t\tgoto out_free;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][0].write_count = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][lpages - 1].write_count = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tslot->arch.lpage_info[i - 1][j].write_count = 1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvm_kvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvm_kvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd",
        "vul_func_with_fix": "int kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,\n\t\t\t    unsigned long npages)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = gfn_to_index(slot->base_gfn + npages - 1,\n\t\t\t\t      slot->base_gfn, level) + 1;\n\n\t\tslot->arch.rmap[i] =\n\t\t\tkvm_kvzalloc(lpages * sizeof(*slot->arch.rmap[i]));\n\t\tif (!slot->arch.rmap[i])\n\t\t\tgoto out_free;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tslot->arch.lpage_info[i - 1] = kvm_kvzalloc(lpages *\n\t\t\t\t\tsizeof(*slot->arch.lpage_info[i - 1]));\n\t\tif (!slot->arch.lpage_info[i - 1])\n\t\t\tgoto out_free;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][0].write_count = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tslot->arch.lpage_info[i - 1][lpages - 1].write_count = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, or if explicitly asked to, disable large page\n\t\t * support for this slot\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1) ||\n\t\t    !kvm_largepages_enabled()) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tslot->arch.lpage_info[i - 1][j].write_count = 1;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvm_kvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tkvm_kvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n",
        "linevul": 4.871216515311971e-05,
        "sysevr": 0.1749146580696106,
        "devign": 0.0
    },
    {
        "code": "static int __init multi_init(void)\n{\n\tint ret, i;\n\tstruct pci_dev  *dev = NULL;\n\n\tif(fcr_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tfcr_arr[i] = 0x01;\n\t\t\t\n\t\t}\n\t}\n\tif(deep_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tdeep[i] = 1;\n\t\t\t\n\t\t}\n\t}\n\tif(rtr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        rtr[i] = 0x10;\n                }\n        }\n\tif(ttr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        ttr[i] = 0x38;\n                }\n        }\n\n\nprintk(\"MULTI INIT\\n\");\n\tfor( i=0; i< mp_nrpcibrds; i++)\n\t{\n\n\t\twhile( (dev = pci_get_device(mp_pciboards[i].vendor_id, mp_pciboards[i].device_id, dev) ) )\n\n\t\t{\nprintk(\"FOUND~~~\\n\");\n\t\t\t{\n\t\t\t\tint status;\n\t        \t\tpci_disable_device(dev);\n\t        \t\tstatus = pci_enable_device(dev);\n            \n\t   \t\t     \tif (status != 0)\n        \t\t\t{ \n               \t\t\t\tprintk(\"Multiport Board Enable Fail !\\n\\n\");\n               \t\t\t\tstatus = -ENXIO;\n                \t\t\treturn status;\n           \t\t\t}\n\t\t\t}\n\n\t\t\tinit_mp_dev(dev, mp_pciboards[i]);\t\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_IRQS; i++)\n\t\tspin_lock_init(&irq_lists[i].lock);\n\n\tret = mp_register_driver(&multi_reg);\n\n\tif (ret >= 0)\n\t\tmulti_register_ports(&multi_reg);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
        "vul_func_with_fix": "static int __init multi_init(void)\n{\n\tint ret, i;\n\tstruct pci_dev  *dev = NULL;\n\n\tif(fcr_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tfcr_arr[i] = 0x01;\n\t\t\t\n\t\t}\n\t}\n\tif(deep_count==0)\n\t{\n\t\tfor(i=0;i<256;i++)\n\t\t{\n\t\t\tdeep[i] = 1;\n\t\t\t\n\t\t}\n\t}\n\tif(rtr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        rtr[i] = 0x10;\n                }\n        }\n\tif(ttr_count==0)\n        {\n                for(i=0;i<256;i++)\n                {\n                        ttr[i] = 0x38;\n                }\n        }\n\n\nprintk(\"MULTI INIT\\n\");\n\tfor( i=0; i< mp_nrpcibrds; i++)\n\t{\n\n\t\twhile( (dev = pci_get_device(mp_pciboards[i].vendor_id, mp_pciboards[i].device_id, dev) ) )\n\n\t\t{\nprintk(\"FOUND~~~\\n\");\n//\tCent OS bug fix\n//\t\t\tif (mp_pciboards[i].device_id & 0x0800)\n\t\t\t{\n\t\t\t\tint status;\n\t        \t\tpci_disable_device(dev);\n\t        \t\tstatus = pci_enable_device(dev);\n            \n\t   \t\t     \tif (status != 0)\n        \t\t\t{ \n               \t\t\t\tprintk(\"Multiport Board Enable Fail !\\n\\n\");\n               \t\t\t\tstatus = -ENXIO;\n                \t\t\treturn status;\n           \t\t\t}\n\t\t\t}\n\n\t\t\tinit_mp_dev(dev, mp_pciboards[i]);\t\n\t\t}\n\t}\n\n\tfor (i = 0; i < NR_IRQS; i++)\n\t\tspin_lock_init(&irq_lists[i].lock);\n\n\tret = mp_register_driver(&multi_reg);\n\n\tif (ret >= 0)\n\t\tmulti_register_ports(&multi_reg);\n\n\treturn ret;\n}\n",
        "linevul": 0.00719180004671216,
        "sysevr": 0.15632981061935425,
        "devign": 0.39490023255348206
    },
    {
        "code": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
        "vul_func_with_fix": "static int obj_offset(struct kmem_cache *cachep)\n{\n\treturn cachep->obj_offset;\n}\n",
        "linevul": 0.00014198478311300278,
        "sysevr": 0.12933406233787537,
        "devign": 0.0003515984572004527
    },
    {
        "code": "static void bond_arp_send(struct net_device *slave_dev, int arp_op, __be32 dest_ip, __be32 src_ip, unsigned short vlan_id)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"arp %d on slave %s: dst %x src %x vid %d\\n\", arp_op,\n\t\t slave_dev->name, dest_ip, src_ip, vlan_id);\n\n\tskb = arp_create(arp_op, ETH_P_ARP, dest_ip, slave_dev, src_ip,\n\t\t\t NULL, slave_dev->dev_addr, NULL);\n\n\tif (!skb) {\n\t\tpr_err(\"ARP packet allocation failed\\n\");\n\t\treturn;\n\t}\n\tif (vlan_id) {\n\t\tskb = vlan_put_tag(skb, vlan_id);\n\t\tif (!skb) {\n\t\t\tpr_err(\"failed to insert VLAN tag\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tarp_xmit(skb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static void bond_arp_send(struct net_device *slave_dev, int arp_op, __be32 dest_ip, __be32 src_ip, unsigned short vlan_id)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"arp %d on slave %s: dst %x src %x vid %d\\n\", arp_op,\n\t\t slave_dev->name, dest_ip, src_ip, vlan_id);\n\n\tskb = arp_create(arp_op, ETH_P_ARP, dest_ip, slave_dev, src_ip,\n\t\t\t NULL, slave_dev->dev_addr, NULL);\n\n\tif (!skb) {\n\t\tpr_err(\"ARP packet allocation failed\\n\");\n\t\treturn;\n\t}\n\tif (vlan_id) {\n\t\tskb = vlan_put_tag(skb, vlan_id);\n\t\tif (!skb) {\n\t\t\tpr_err(\"failed to insert VLAN tag\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tarp_xmit(skb);\n}\n",
        "linevul": 4.945819455315359e-05,
        "sysevr": 0.11262644827365875,
        "devign": 0.0
    },
    {
        "code": "static int insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tretval = -ENOMEM;\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tentry = pte_mkspecial(pfn_pte(pfn, prot));\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\n\tretval = 0;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static int insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tunsigned long pfn, pgprot_t prot)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint retval;\n\tpte_t *pte, entry;\n\tspinlock_t *ptl;\n\n\tretval = -ENOMEM;\n\tpte = get_locked_pte(mm, addr, &ptl);\n\tif (!pte)\n\t\tgoto out;\n\tretval = -EBUSY;\n\tif (!pte_none(*pte))\n\t\tgoto out_unlock;\n\n\t/* Ok, finally just insert the thing.. */\n\tentry = pte_mkspecial(pfn_pte(pfn, prot));\n\tset_pte_at(mm, addr, pte, entry);\n\tupdate_mmu_cache(vma, addr, pte); /* XXX: why not for insert_page? */\n\n\tretval = 0;\nout_unlock:\n\tpte_unmap_unlock(pte, ptl);\nout:\n\treturn retval;\n}\n",
        "linevul": 0.0004335155535954982,
        "sysevr": 0.12546518445014954,
        "devign": 2.8505712846658344e-23
    },
    {
        "code": "static inline int illegal_highdma(struct net_device *dev, struct sk_buff *skb)\n{\n#ifdef CONFIG_HIGHMEM\n\tint i;\n\n\tif (dev->features & NETIF_F_HIGHDMA)\n\t\treturn 0;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++)\n\t\tif (PageHighMem(skb_shinfo(skb)->frags[i].page))\n\t\t\treturn 1;\n\n#endif\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867",
        "vul_func_with_fix": "static inline int illegal_highdma(struct net_device *dev, struct sk_buff *skb)\n{\n#ifdef CONFIG_HIGHMEM\n\tint i;\n\n\tif (dev->features & NETIF_F_HIGHDMA)\n\t\treturn 0;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++)\n\t\tif (PageHighMem(skb_shinfo(skb)->frags[i].page))\n\t\t\treturn 1;\n\n#endif\n\treturn 0;\n}\n",
        "linevul": 6.155931623652577e-05,
        "sysevr": 0.11791978776454926,
        "devign": 7.609588025587073e-27
    },
    {
        "code": "static void mac80211_hwsim_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_control *control,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tbool ack;\n\tu32 _portid;\n\n\tif (WARN_ON(skb->len < 10)) {\n\t\t/* Should not happen; just a sanity check for addr1 use */\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (!data->use_chanctx) {\n\t\tchannel = data->channel;\n\t} else if (txi->hw_queue == 4) {\n\t\tchannel = data->tmp_chan;\n\t} else {\n\t\tchanctx_conf = rcu_dereference(txi->control.vif->chanctx_conf);\n\t\tif (chanctx_conf)\n\t\t\tchannel = chanctx_conf->def.chan;\n\t\telse\n\t\t\tchannel = NULL;\n\t}\n\n\tif (WARN(!channel, \"TX w/o channel - queue = %d\\n\", txi->hw_queue)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (data->idle && !data->tmp_chan) {\n\t\twiphy_dbg(hw->wiphy, \"Trying to TX when idle - reject\\n\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (txi->control.vif)\n\t\thwsim_check_magic(txi->control.vif);\n\tif (control->sta)\n\t\thwsim_check_sta_magic(control->sta);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\n\tif (skb->len >= 24 + 8 &&\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t/* fake header transmission time */\n\t\tstruct ieee80211_mgmt *mgmt;\n\t\tstruct ieee80211_rate *txrate;\n\t\tu64 ts;\n\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\ttxrate = ieee80211_get_tx_rate(hw, txi);\n\t\tts = mac80211_hwsim_get_tsf_raw();\n\t\tmgmt->u.probe_resp.timestamp =\n\t\t\tcpu_to_le64(ts + data->tsf_offset +\n\t\t\t\t    24 * 8 * 10 / txrate->bitrate);\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, channel);\n\n\t/* wmediumd mode check */\n\t_portid = READ_ONCE(data->wmediumd);\n\n\tif (_portid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid);\n\n\t/* NO wmediumd detected, perfect medium simulation */\n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\n\n\tif (ack && skb->len >= 16)\n\t\tmac80211_hwsim_monitor_ack(channel, hdr->addr2);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\t/* frame was transmitted at most favorable rate at first attempt */\n\ttxi->control.rates[0].count = 1;\n\ttxi->control.rates[1].idx = -1;\n\n\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "vul_func_with_fix": "static void mac80211_hwsim_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_control *control,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tbool ack;\n\tu32 _portid;\n\n\tif (WARN_ON(skb->len < 10)) {\n\t\t/* Should not happen; just a sanity check for addr1 use */\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (!data->use_chanctx) {\n\t\tchannel = data->channel;\n\t} else if (txi->hw_queue == 4) {\n\t\tchannel = data->tmp_chan;\n\t} else {\n\t\tchanctx_conf = rcu_dereference(txi->control.vif->chanctx_conf);\n\t\tif (chanctx_conf)\n\t\t\tchannel = chanctx_conf->def.chan;\n\t\telse\n\t\t\tchannel = NULL;\n\t}\n\n\tif (WARN(!channel, \"TX w/o channel - queue = %d\\n\", txi->hw_queue)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (data->idle && !data->tmp_chan) {\n\t\twiphy_dbg(hw->wiphy, \"Trying to TX when idle - reject\\n\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (txi->control.vif)\n\t\thwsim_check_magic(txi->control.vif);\n\tif (control->sta)\n\t\thwsim_check_sta_magic(control->sta);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\n\tif (skb->len >= 24 + 8 &&\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t/* fake header transmission time */\n\t\tstruct ieee80211_mgmt *mgmt;\n\t\tstruct ieee80211_rate *txrate;\n\t\tu64 ts;\n\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\ttxrate = ieee80211_get_tx_rate(hw, txi);\n\t\tts = mac80211_hwsim_get_tsf_raw();\n\t\tmgmt->u.probe_resp.timestamp =\n\t\t\tcpu_to_le64(ts + data->tsf_offset +\n\t\t\t\t    24 * 8 * 10 / txrate->bitrate);\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, channel);\n\n\t/* wmediumd mode check */\n\t_portid = READ_ONCE(data->wmediumd);\n\n\tif (_portid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid);\n\n\t/* NO wmediumd detected, perfect medium simulation */\n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\n\n\tif (ack && skb->len >= 16)\n\t\tmac80211_hwsim_monitor_ack(channel, hdr->addr2);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\t/* frame was transmitted at most favorable rate at first attempt */\n\ttxi->control.rates[0].count = 1;\n\ttxi->control.rates[1].idx = -1;\n\n\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n",
        "linevul": 9.319515083916485e-05,
        "sysevr": 0.16698408126831055,
        "devign": 0.0
    },
    {
        "code": "__ip_vs_svc_fwm_find(struct net *net, int af, __u32 fwmark)\n{\n\tunsigned int hash;\n\tstruct ip_vs_service *svc;\n\n\t/* Check for fwmark addressed entries */\n\thash = ip_vs_svc_fwm_hashkey(net, fwmark);\n\n\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[hash], f_list) {\n\t\tif (svc->fwmark == fwmark && svc->af == af\n\t\t    && net_eq(svc->net, net)) {\n\t\t\t/* HIT */\n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2d8a041b7bfe1097af21441cb77d6af95f4f4680",
        "vul_func_with_fix": "__ip_vs_svc_fwm_find(struct net *net, int af, __u32 fwmark)\n{\n\tunsigned int hash;\n\tstruct ip_vs_service *svc;\n\n\t/* Check for fwmark addressed entries */\n\thash = ip_vs_svc_fwm_hashkey(net, fwmark);\n\n\tlist_for_each_entry(svc, &ip_vs_svc_fwm_table[hash], f_list) {\n\t\tif (svc->fwmark == fwmark && svc->af == af\n\t\t    && net_eq(svc->net, net)) {\n\t\t\t/* HIT */\n\t\t\treturn svc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "linevul": 7.048866973491386e-05,
        "sysevr": 0.15524837374687195,
        "devign": 1.5024189973223724e-25
    },
    {
        "code": "static int lo_write_transfer(struct loop_device *lo, struct request *rq,\n\t\tloff_t pos)\n{\n\tstruct bio_vec bvec, b;\n\tstruct req_iterator iter;\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\trq_for_each_segment(bvec, rq, iter) {\n\t\tret = lo_do_transfer(lo, WRITE, page, 0, bvec.bv_page,\n\t\t\tbvec.bv_offset, bvec.bv_len, pos >> 9);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\n\t\tb.bv_page = page;\n\t\tb.bv_offset = 0;\n\t\tb.bv_len = bvec.bv_len;\n\t\tret = lo_write_bvec(lo->lo_backing_file, &b, &pos);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\t__free_page(page);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
        "vul_func_with_fix": "static int lo_write_transfer(struct loop_device *lo, struct request *rq,\n\t\tloff_t pos)\n{\n\tstruct bio_vec bvec, b;\n\tstruct req_iterator iter;\n\tstruct page *page;\n\tint ret = 0;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\trq_for_each_segment(bvec, rq, iter) {\n\t\tret = lo_do_transfer(lo, WRITE, page, 0, bvec.bv_page,\n\t\t\tbvec.bv_offset, bvec.bv_len, pos >> 9);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\n\t\tb.bv_page = page;\n\t\tb.bv_offset = 0;\n\t\tb.bv_len = bvec.bv_len;\n\t\tret = lo_write_bvec(lo->lo_backing_file, &b, &pos);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\t__free_page(page);\n\treturn ret;\n}\n",
        "linevul": 6.245393888093531e-05,
        "sysevr": 0.1219375804066658,
        "devign": 2.0163450770160907e-11
    },
    {
        "code": "static void encode_stateid(struct xdr_stream *xdr, const struct nfs_open_context *ctx)\n{\n\tnfs4_stateid stateid;\n\t__be32 *p;\n\n\tRESERVE_SPACE(NFS4_STATEID_SIZE);\n\tif (ctx->state != NULL) {\n\t\tnfs4_copy_stateid(&stateid, ctx->state, ctx->lockowner);\n\t\tWRITEMEM(stateid.data, NFS4_STATEID_SIZE);\n\t} else\n\t\tWRITEMEM(zero_stateid.data, NFS4_STATEID_SIZE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static void encode_stateid(struct xdr_stream *xdr, const struct nfs_open_context *ctx)\n{\n\tnfs4_stateid stateid;\n\t__be32 *p;\n\n\tRESERVE_SPACE(NFS4_STATEID_SIZE);\n\tif (ctx->state != NULL) {\n\t\tnfs4_copy_stateid(&stateid, ctx->state, ctx->lockowner);\n\t\tWRITEMEM(stateid.data, NFS4_STATEID_SIZE);\n\t} else\n\t\tWRITEMEM(zero_stateid.data, NFS4_STATEID_SIZE);\n}\n",
        "linevul": 6.002463123877533e-05,
        "sysevr": 0.12948907911777496,
        "devign": 1.2316452746574669e-08
    },
    {
        "code": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* Read the descriptor data */\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\n\tstatus = valid_csum(rom_desc, buffer);\n\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\n\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e",
        "vul_func_with_fix": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t/* Read the descriptor data */\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\n\tstatus = valid_csum(rom_desc, buffer);\n\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\n\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}\n",
        "linevul": 8.930904732551426e-05,
        "sysevr": 0.16248762607574463,
        "devign": 1.4134164898404709e-27
    },
    {
        "code": "bool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ca4da5dd1f99fe9c59f1709fb43e818b18ad20e0",
        "vul_func_with_fix": "bool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n",
        "linevul": 0.12858471274375916,
        "sysevr": 0.16679947078227997,
        "devign": 0.9996237754821777
    },
    {
        "code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n \n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n \n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713",
        "vul_func_with_fix": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n \n//flaw_line_below:\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n//fix_flaw_line_below:\n//\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n//fix_flaw_line_below:\n//\t\t\t\t\tGFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n \n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n",
        "linevul": 0.9992122650146484,
        "sysevr": 0.14775066077709198,
        "devign": 0.9992930889129639
    },
    {
        "code": "do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\n\tif (notify_page_fault(regs, fsr))\n\t\treturn 0;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t/*\n\t * As per x86, we may deadlock here.  However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->ARM_pc))\n\t\t\tgoto no_context;\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in\n\t\t * which case, we'll have missed the might_sleep() from\n\t\t * down_read()\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) &&\n\t\t    !search_exception_tables(regs->ARM_pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n \tfault = __do_page_fault(mm, addr, fsr, tsk);\n \tup_read(&mm->mmap_sem);\n \n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, addr);\n \tif (fault & VM_FAULT_MAJOR)\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, regs, addr);\n \telse if (fault & VM_FAULT_MINOR)\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, regs, addr);\n \n \t/*\n \t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP | VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we\n\t\t * got oom-killed)\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we are in kernel mode at this point, we\n\t * have no context to handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to\n\t\t * successfully fix up this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that\n\t\t * isn't in our memory map..\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, fsr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, fsr, regs);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\n\tif (notify_page_fault(regs, fsr))\n\t\treturn 0;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t/*\n\t * As per x86, we may deadlock here.  However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->ARM_pc))\n\t\t\tgoto no_context;\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in\n\t\t * which case, we'll have missed the might_sleep() from\n\t\t * down_read()\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) &&\n\t\t    !search_exception_tables(regs->ARM_pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n \tfault = __do_page_fault(mm, addr, fsr, tsk);\n \tup_read(&mm->mmap_sem);\n \n//flaw_line_below:\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, addr);\n//fix_flaw_line_below:\n//\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n \tif (fault & VM_FAULT_MAJOR)\n//flaw_line_below:\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, regs, addr);\n//fix_flaw_line_below:\n//\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, addr);\n \telse if (fault & VM_FAULT_MINOR)\n//flaw_line_below:\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, regs, addr);\n//fix_flaw_line_below:\n//\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, addr);\n \n \t/*\n \t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP | VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we\n\t\t * got oom-killed)\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we are in kernel mode at this point, we\n\t * have no context to handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to\n\t\t * successfully fix up this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that\n\t\t * isn't in our memory map..\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, fsr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, fsr, regs);\n\treturn 0;\n}\n",
        "linevul": 0.00011475432256702334,
        "sysevr": 0.34801018238067627,
        "devign": 0.26256370544433594
    },
    {
        "code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n \n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1bb57e940e1958e40d51f2078f50c3a96a9b2d75",
        "vul_func_with_fix": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n//flaw_line_below:\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n//flaw_line_below:\n\n//flaw_line_below:\n\tstruct netdev_desc *desc;\n//flaw_line_below:\n\tint i;\n//fix_flaw_line_below:\n//\tstruct mii_ioctl_data *miidata = if_mii(rq);\n \n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE:\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 1:\n//flaw_line_below:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n//fix_flaw_line_below:\n//\tcase SIOCGMIIPHY:\n//fix_flaw_line_below:\n//\t\tmiidata->phy_id = phy_addr;\n \t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 2:\n//flaw_line_below:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n//fix_flaw_line_below:\n//\tcase SIOCGMIIREG:\n//fix_flaw_line_below:\n//\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 3:\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 4:\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 5:\n//flaw_line_below:\n\t\tnetif_stop_queue (dev);\n//fix_flaw_line_below:\n//\tcase SIOCSMIIREG:\n//fix_flaw_line_below:\n//\t\tif (!capable(CAP_NET_ADMIN))\n//fix_flaw_line_below:\n//\t\t\treturn -EPERM;\n//fix_flaw_line_below:\n//\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n \t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 6:\n//flaw_line_below:\n\t\tnetif_wake_queue (dev);\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 7:\n//flaw_line_below:\n\t\tprintk\n//flaw_line_below:\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n//flaw_line_below:\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n//flaw_line_below:\n\t\t     np->old_rx);\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\tcase SIOCDEVPRIVATE + 8:\n//flaw_line_below:\n\t\tprintk(\"TX ring:\\n\");\n//flaw_line_below:\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n//flaw_line_below:\n\t\t\tdesc = &np->tx_ring[i];\n//flaw_line_below:\n\t\t\tprintk\n//flaw_line_below:\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n//flaw_line_below:\n\t\t\t     i,\n//flaw_line_below:\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n//flaw_line_below:\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n//flaw_line_below:\n\t\t\t     (u32)le64_to_cpu(desc->status),\n//flaw_line_below:\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n//flaw_line_below:\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n//flaw_line_below:\n\t\t\tprintk (\"\\n\");\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t\tprintk (\"\\n\");\n//flaw_line_below:\n\t\tbreak;\n//flaw_line_below:\n\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}\n\treturn 0;\n}\n",
        "linevul": 0.9996328353881836,
        "sysevr": 0.2596854865550995,
        "devign": 1.4608647234126693e-06
    },
    {
        "code": "static void unfill_desc(struct hnae_ring *ring)\n{\n\tring_ptr_move_bw(ring, next_to_use);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2",
        "vul_func_with_fix": "static void unfill_desc(struct hnae_ring *ring)\n{\n\tring_ptr_move_bw(ring, next_to_use);\n}\n",
        "linevul": 6.189111445564777e-05,
        "sysevr": 0.12844990193843842,
        "devign": 4.220920800435124e-06
    },
    {
        "code": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69",
        "vul_func_with_fix": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n//flaw_line_below:\n\tif (addr_len)\n//flaw_line_below:\n\t\t*addr_len = sizeof(sa);\n//flaw_line_below:\n\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n//flaw_line_below:\n\tif (msg->msg_name != NULL)\n//flaw_line_below:\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n//fix_flaw_line_below:\n//\tif (msg->msg_name != NULL) {\n//fix_flaw_line_below:\n//\t\tmemcpy(msg->msg_name, &sa, sizeof(sa));\n//fix_flaw_line_below:\n//\t\t*addr_len = sizeof(sa);\n//fix_flaw_line_below:\n//\t}\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n",
        "linevul": 0.999359667301178,
        "sysevr": 0.13142114877700806,
        "devign": 4.188638047519788e-10
    },
    {
        "code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\n\t/* Make sure incoming skb has non-bogus data. */\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\n\t/* Remove first entry, as this is the destination for the rest of the\n\t * fragments.\n\t */\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n \tkfree(entry);\n \n \t/* Make room for the rest of the fragments. */\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n \t\tkfree_skb(skb_out);\n \t\tskb_out = NULL;\n \t\tgoto free;\n\t}\n\n\t/* Move the existing MAC header to just before the payload. (Override\n\t * the fragment header.)\n\t */\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\n\t/* Copy the payload of the each fragment into the last skb */\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\n\nfree:\n\t/* Locking is not needed, because 'chain' is not part of any orig. */\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b",
        "vul_func_with_fix": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\n\t/* Make sure incoming skb has non-bogus data. */\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\n\t/* Remove first entry, as this is the destination for the rest of the\n\t * fragments.\n\t */\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n \tkfree(entry);\n \n \t/* Make room for the rest of the fragments. */\n//flaw_line_below:\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n//fix_flaw_line_below:\n//\tif (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {\n \t\tkfree_skb(skb_out);\n \t\tskb_out = NULL;\n \t\tgoto free;\n\t}\n\n\t/* Move the existing MAC header to just before the payload. (Override\n\t * the fragment header.)\n\t */\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\n\t/* Copy the payload of the each fragment into the last skb */\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\n\nfree:\n\t/* Locking is not needed, because 'chain' is not part of any orig. */\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}\n",
        "linevul": 0.0019563138484954834,
        "sysevr": 0.2867249548435211,
        "devign": 0.9999055862426758
    },
    {
        "code": "int netdev_refcnt_read(const struct net_device *dev)\n{\n\tint i, refcnt = 0;\n\n\tfor_each_possible_cpu(i)\n\t\trefcnt += *per_cpu_ptr(dev->pcpu_refcnt, i);\n\treturn refcnt;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "int netdev_refcnt_read(const struct net_device *dev)\n{\n\tint i, refcnt = 0;\n\n\tfor_each_possible_cpu(i)\n\t\trefcnt += *per_cpu_ptr(dev->pcpu_refcnt, i);\n\treturn refcnt;\n}\n",
        "linevul": 5.842527752975002e-05,
        "sysevr": 0.1448661983013153,
        "devign": 4.912646090815542e-06
    },
    {
        "code": "static void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void watchdog_interrupt_count(void)\n{\n\t__this_cpu_inc(hrtimer_interrupts);\n}\n",
        "linevul": 5.518407851923257e-05,
        "sysevr": 0.12852126359939575,
        "devign": 5.368992468494926e-13
    },
    {
        "code": "static int cxusb_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_adapter *adap = (struct dvb_usb_adapter *)fe->dvb->priv;\n\tstruct cxusb_state *state = (struct cxusb_state *)adap->dev->priv;\n\tint ret;\n\n\tret = state->fe_read_status(fe, status);\n\n\t/* it need resync slave fifo when signal change from unlock to lock.*/\n\tif ((*status & FE_HAS_LOCK) && (!state->last_lock)) {\n\t\tmutex_lock(&state->stream_mutex);\n\t\tcxusb_streaming_ctrl(adap, 1);\n\t\tmutex_unlock(&state->stream_mutex);\n\t}\n\n\tstate->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3f190e3aec212fc8c61e202c51400afa7384d4bc",
        "vul_func_with_fix": "static int cxusb_read_status(struct dvb_frontend *fe,\n\t\t\t\t  enum fe_status *status)\n{\n\tstruct dvb_usb_adapter *adap = (struct dvb_usb_adapter *)fe->dvb->priv;\n\tstruct cxusb_state *state = (struct cxusb_state *)adap->dev->priv;\n\tint ret;\n\n\tret = state->fe_read_status(fe, status);\n\n\t/* it need resync slave fifo when signal change from unlock to lock.*/\n\tif ((*status & FE_HAS_LOCK) && (!state->last_lock)) {\n\t\tmutex_lock(&state->stream_mutex);\n\t\tcxusb_streaming_ctrl(adap, 1);\n\t\tmutex_unlock(&state->stream_mutex);\n\t}\n\n\tstate->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\n\treturn ret;\n}\n",
        "linevul": 4.679017365560867e-05,
        "sysevr": 0.134247824549675,
        "devign": 0.00015250635624397546
    },
    {
        "code": "static void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(vcpu, cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tif (enable_unrestricted_guest || is_paging(vcpu) ||\n\t\t    is_guest_mode(vcpu))\n\t\t\tguest_cr3 = kvm_read_cr3(vcpu);\n\t\telse\n\t\t\tguest_cr3 = to_kvm_vmx(vcpu->kvm)->ept_identity_map_addr;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tvmx_flush_tlb(vcpu, true);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static void vmx_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(vcpu, cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\t\tif (enable_unrestricted_guest || is_paging(vcpu) ||\n\t\t    is_guest_mode(vcpu))\n\t\t\tguest_cr3 = kvm_read_cr3(vcpu);\n\t\telse\n\t\t\tguest_cr3 = to_kvm_vmx(vcpu->kvm)->ept_identity_map_addr;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tvmx_flush_tlb(vcpu, true);\n\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n",
        "linevul": 4.7990568418754265e-05,
        "sysevr": 0.12772318720817566,
        "devign": 0.0
    },
    {
        "code": "static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void __user *arg)\n{\n\tstruct snd_seq_running_info info;\n\tstruct snd_seq_client *cptr;\n\tint err = 0;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(info.client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n#ifdef SNDRV_BIG_ENDIAN\n\tif (! info.big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n#else\n\tif (info.big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\n#endif\n\tif (info.cpu_mode > sizeof(long)) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\tcptr->convert32 = (info.cpu_mode < sizeof(long));\n __err:\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/030e2c78d3a91dd0d27fef37e91950dde333eba1",
        "vul_func_with_fix": "static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void __user *arg)\n{\n\tstruct snd_seq_running_info info;\n\tstruct snd_seq_client *cptr;\n\tint err = 0;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(info.client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n#ifdef SNDRV_BIG_ENDIAN\n\tif (! info.big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n#else\n\tif (info.big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\n#endif\n\tif (info.cpu_mode > sizeof(long)) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\tcptr->convert32 = (info.cpu_mode < sizeof(long));\n __err:\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}\n",
        "linevul": 5.4870120948180556e-05,
        "sysevr": 0.1320459097623825,
        "devign": 0.6494643092155457
    },
    {
        "code": "static void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tBUG_ON(list_first_entry(&seqid->sequence->sequence->list, struct nfs_seqid, list) != seqid);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static void nfs_increment_seqid(int status, struct nfs_seqid *seqid)\n{\n\tBUG_ON(list_first_entry(&seqid->sequence->sequence->list, struct nfs_seqid, list) != seqid);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BAD_SEQID:\n\t\t\tif (seqid->sequence->flags & NFS_SEQID_CONFIRMED)\n\t\t\t\treturn;\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server returned a bad\"\n\t\t\t\t\t\" sequence-id error on an\"\n\t\t\t\t\t\" unconfirmed sequence %p!\\n\",\n\t\t\t\t\tseqid->sequence);\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_BADXDR:\n\t\tcase -NFS4ERR_RESOURCE:\n\t\tcase -NFS4ERR_NOFILEHANDLE:\n\t\t\t/* Non-seqid mutating errors */\n\t\t\treturn;\n\t};\n\t/*\n\t * Note: no locking needed as we are guaranteed to be first\n\t * on the sequence list\n\t */\n\tseqid->sequence->counter++;\n}\n",
        "linevul": 6.735687202308327e-05,
        "sysevr": 0.13827869296073914,
        "devign": 2.708624382796146e-15
    },
    {
        "code": "static void tg3_restore_pci_state(struct tg3 *tp)\n{\n\tu32 val;\n\n\t/* Re-enable indirect register accesses. */\n\tpci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\n\t\t\t       tp->misc_host_ctrl);\n\n\t/* Set MAX PCI retry to zero. */\n\tval = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0 &&\n\t    tg3_flag(tp, PCIX_MODE))\n\t\tval |= PCISTATE_RETRY_SAME_DMA;\n\t/* Allow reads and writes to the APE register and memory space. */\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\tval |= PCISTATE_ALLOW_APE_CTLSPC_WR |\n\t\t       PCISTATE_ALLOW_APE_SHMEM_WR |\n\t\t       PCISTATE_ALLOW_APE_PSPACE_WR;\n\tpci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);\n\n\tpci_write_config_word(tp->pdev, PCI_COMMAND, tp->pci_cmd);\n\n\tif (!tg3_flag(tp, PCI_EXPRESS)) {\n\t\tpci_write_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t\t      tp->pci_cacheline_sz);\n\t\tpci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER,\n\t\t\t\t      tp->pci_lat_timer);\n\t}\n\n\t/* Make sure PCI-X relaxed ordering bit is clear. */\n\tif (tg3_flag(tp, PCIX_MODE)) {\n\t\tu16 pcix_cmd;\n\n\t\tpci_read_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t     &pcix_cmd);\n\t\tpcix_cmd &= ~PCI_X_CMD_ERO;\n\t\tpci_write_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t      pcix_cmd);\n\t}\n\n\tif (tg3_flag(tp, 5780_CLASS)) {\n\n\t\t/* Chip reset on 5780 will reset MSI enable bit,\n\t\t * so need to restore it.\n\t\t */\n\t\tif (tg3_flag(tp, USING_MSI)) {\n\t\t\tu16 ctrl;\n\n\t\t\tpci_read_config_word(tp->pdev,\n\t\t\t\t\t     tp->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t\t     &ctrl);\n\t\t\tpci_write_config_word(tp->pdev,\n\t\t\t\t\t      tp->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t\t      ctrl | PCI_MSI_FLAGS_ENABLE);\n\t\t\tval = tr32(MSGINT_MODE);\n\t\t\ttw32(MSGINT_MODE, val | MSGINT_MODE_ENABLE);\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
        "vul_func_with_fix": "static void tg3_restore_pci_state(struct tg3 *tp)\n{\n\tu32 val;\n\n\t/* Re-enable indirect register accesses. */\n\tpci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\n\t\t\t       tp->misc_host_ctrl);\n\n\t/* Set MAX PCI retry to zero. */\n\tval = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0 &&\n\t    tg3_flag(tp, PCIX_MODE))\n\t\tval |= PCISTATE_RETRY_SAME_DMA;\n\t/* Allow reads and writes to the APE register and memory space. */\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\tval |= PCISTATE_ALLOW_APE_CTLSPC_WR |\n\t\t       PCISTATE_ALLOW_APE_SHMEM_WR |\n\t\t       PCISTATE_ALLOW_APE_PSPACE_WR;\n\tpci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);\n\n\tpci_write_config_word(tp->pdev, PCI_COMMAND, tp->pci_cmd);\n\n\tif (!tg3_flag(tp, PCI_EXPRESS)) {\n\t\tpci_write_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t\t      tp->pci_cacheline_sz);\n\t\tpci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER,\n\t\t\t\t      tp->pci_lat_timer);\n\t}\n\n\t/* Make sure PCI-X relaxed ordering bit is clear. */\n\tif (tg3_flag(tp, PCIX_MODE)) {\n\t\tu16 pcix_cmd;\n\n\t\tpci_read_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t     &pcix_cmd);\n\t\tpcix_cmd &= ~PCI_X_CMD_ERO;\n\t\tpci_write_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t      pcix_cmd);\n\t}\n\n\tif (tg3_flag(tp, 5780_CLASS)) {\n\n\t\t/* Chip reset on 5780 will reset MSI enable bit,\n\t\t * so need to restore it.\n\t\t */\n\t\tif (tg3_flag(tp, USING_MSI)) {\n\t\t\tu16 ctrl;\n\n\t\t\tpci_read_config_word(tp->pdev,\n\t\t\t\t\t     tp->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t\t     &ctrl);\n\t\t\tpci_write_config_word(tp->pdev,\n\t\t\t\t\t      tp->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t\t      ctrl | PCI_MSI_FLAGS_ENABLE);\n\t\t\tval = tr32(MSGINT_MODE);\n\t\t\ttw32(MSGINT_MODE, val | MSGINT_MODE_ENABLE);\n\t\t}\n\t}\n}\n",
        "linevul": 4.664863445213996e-05,
        "sysevr": 0.13306935131549835,
        "devign": 7.856460274013877e-12
    },
    {
        "code": "static struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.open_seqid))\n\t\tgoto out_free;\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->arg.lock_seqid = alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.lock_seqid))\n\t\tgoto out_free_seqid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_seqid.owner_id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tget_file(fl->fl_file);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.open_seqid))\n\t\tgoto out_free;\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->arg.lock_seqid = alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.lock_seqid))\n\t\tgoto out_free_seqid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_seqid.owner_id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tget_file(fl->fl_file);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n",
        "linevul": 0.0003631937725003809,
        "sysevr": 0.19905221462249756,
        "devign": 9.632085351540809e-09
    },
    {
        "code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\n\t\treturn err;\n\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn hidp_connection_del(&cd);\n\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16",
        "vul_func_with_fix": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n \t\t\tsockfd_put(csock);\n \t\t\treturn err;\n \t\t}\n//fix_flaw_line_below:\n//\t\tca.name[sizeof(ca.name)-1] = 0;\n \n \t\terr = hidp_connection_add(&ca, csock, isock);\n \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\n\t\treturn err;\n\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn hidp_connection_del(&cd);\n\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\t}\n\n\treturn -EINVAL;\n}\n",
        "linevul": 6.634378951275721e-05,
        "sysevr": 0.13296209275722504,
        "devign": 0.6123194694519043
    },
    {
        "code": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/197e7e521384a23b9e585178f3f11c9fa08274b9",
        "vul_func_with_fix": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}\n",
        "linevul": 7.06062710378319e-05,
        "sysevr": 0.16315215826034546,
        "devign": 3.279041950796252e-34
    },
    {
        "code": "static long do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tchar * name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\terror = user_path_parent(dfd, pathname, &nd, &name);\n\tif (error)\n\t\treturn error;\n\n\tswitch(nd.last_type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit3;\n\terror = security_path_rmdir(&nd.path, dentry);\n\tif (error)\n\t\tgoto exit4;\n\terror = vfs_rmdir(nd.path.dentry->d_inode, dentry);\nexit4:\n\tmnt_drop_write(nd.path.mnt);\nexit3:\n\tdput(dentry);\nexit2:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "vul_func_with_fix": "static long do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tchar * name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\terror = user_path_parent(dfd, pathname, &nd, &name);\n\tif (error)\n\t\treturn error;\n\n\tswitch(nd.last_type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit3;\n\terror = security_path_rmdir(&nd.path, dentry);\n\tif (error)\n\t\tgoto exit4;\n\terror = vfs_rmdir(nd.path.dentry->d_inode, dentry);\nexit4:\n\tmnt_drop_write(nd.path.mnt);\nexit3:\n\tdput(dentry);\nexit2:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\treturn error;\n}\n",
        "linevul": 6.984564970480278e-05,
        "sysevr": 0.16152843832969666,
        "devign": 0.6533179879188538
    },
    {
        "code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\t/* TH55 registers 2 ports.\n\t   Communication in from the UX50/TH55 uses bulk_in_endpointAddress\n\t   from port 0. Communication out to the UX50/TH55 uses\n\t   bulk_out_endpointAddress from port 1\n\n\t   Lets do a quick and dirty mapping\n \t */\n \n \t/* some sanity check */\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n \n \t/* port 0 now uses the modified endpoint Address */\n \tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cb3232138e37129e88240a98a1d2aba2187ff57c",
        "vul_func_with_fix": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\t/* TH55 registers 2 ports.\n\t   Communication in from the UX50/TH55 uses bulk_in_endpointAddress\n\t   from port 0. Communication out to the UX50/TH55 uses\n\t   bulk_out_endpointAddress from port 1\n\n\t   Lets do a quick and dirty mapping\n \t */\n \n \t/* some sanity check */\n//flaw_line_below:\n\tif (serial->num_ports < 2)\n//flaw_line_below:\n\t\treturn -1;\n//fix_flaw_line_below:\n//\tif (serial->num_bulk_out < 2) {\n//fix_flaw_line_below:\n//\t\tdev_err(&serial->interface->dev, \"missing bulk out endpoints\\n\");\n//fix_flaw_line_below:\n//\t\treturn -ENODEV;\n//fix_flaw_line_below:\n//\t}\n \n \t/* port 0 now uses the modified endpoint Address */\n \tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\n\treturn 0;\n}\n",
        "linevul": 0.9995009899139404,
        "sysevr": 0.1420334130525589,
        "devign": 2.113751179422252e-06
    },
    {
        "code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\n\t/* Try to get same port: if not, try to change it. */\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n \treturn ret;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/2690d97ade05c5325cbf7c72b94b90d265659886",
        "vul_func_with_fix": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n \t\t\t struct nf_conntrack_expect *exp)\n {\n \tchar buffer[sizeof(\"4294967296 65635\")];\n//fix_flaw_line_below:\n//\tstruct nf_conn *ct = exp->master;\n//fix_flaw_line_below:\n//\tunion nf_inet_addr newaddr;\n \tu_int16_t port;\n \tunsigned int ret;\n \n \t/* Reply comes from server. */\n//fix_flaw_line_below:\n//\tnewaddr = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3;\n//fix_flaw_line_below:\n//\n \texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n \texp->dir = IP_CT_DIR_REPLY;\n \texp->expectfn = nf_nat_follow_master;\n\n\t/* Try to get same port: if not, try to change it. */\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n \t}\n \n \tif (port == 0) {\n//flaw_line_below:\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n//fix_flaw_line_below:\n//\t\tnf_ct_helper_log(skb, ct, \"all ports in use\");\n \t\treturn NF_DROP;\n \t}\n \n//flaw_line_below:\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n//flaw_line_below:\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n//flaw_line_below:\n\t\t\t\t       strlen(buffer));\n//fix_flaw_line_below:\n//\t/* strlen(\"\\1DCC CHAT chat AAAAAAAA P\\1\\n\")=27\n//fix_flaw_line_below:\n//\t * strlen(\"\\1DCC SCHAT chat AAAAAAAA P\\1\\n\")=28\n//fix_flaw_line_below:\n//\t * strlen(\"\\1DCC SEND F AAAAAAAA P S\\1\\n\")=26\n//fix_flaw_line_below:\n//\t * strlen(\"\\1DCC MOVE F AAAAAAAA P S\\1\\n\")=26\n//fix_flaw_line_below:\n//\t * strlen(\"\\1DCC TSEND F AAAAAAAA P S\\1\\n\")=27\n//fix_flaw_line_below:\n//\t *\n//fix_flaw_line_below:\n//\t * AAAAAAAAA: bound addr (1.0.0.0==16777216, min 8 digits,\n//fix_flaw_line_below:\n//\t *                        255.255.255.255==4294967296, 10 digits)\n//fix_flaw_line_below:\n//\t * P:         bound port (min 1 d, max 5d (65635))\n//fix_flaw_line_below:\n//\t * F:         filename   (min 1 d )\n//fix_flaw_line_below:\n//\t * S:         size       (min 1 d )\n//fix_flaw_line_below:\n//\t * 0x01, \\n:  terminators\n//fix_flaw_line_below:\n//\t */\n//fix_flaw_line_below:\n//\t/* AAA = \"us\", ie. where server normally talks to. */\n//fix_flaw_line_below:\n//\tsnprintf(buffer, sizeof(buffer), \"%u %u\", ntohl(newaddr.ip), port);\n//fix_flaw_line_below:\n//\tpr_debug(\"nf_nat_irc: inserting '%s' == %pI4, port %u\\n\",\n//fix_flaw_line_below:\n//\t\t buffer, &newaddr.ip, port);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tret = nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff, matchoff,\n//fix_flaw_line_below:\n//\t\t\t\t       matchlen, buffer, strlen(buffer));\n \tif (ret != NF_ACCEPT) {\n//flaw_line_below:\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n//fix_flaw_line_below:\n//\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n \t\tnf_ct_unexpect_related(exp);\n \t}\n//fix_flaw_line_below:\n//\n \treturn ret;\n }\n",
        "linevul": 0.9996045231819153,
        "sysevr": 0.1378893405199051,
        "devign": 0.9943956136703491
    },
    {
        "code": "void bpf_prog_put_rcu(struct bpf_prog *prog)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt))\n\t\tcall_rcu(&prog->aux->rcu, __prog_put_common);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e",
        "vul_func_with_fix": "void bpf_prog_put_rcu(struct bpf_prog *prog)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt))\n\t\tcall_rcu(&prog->aux->rcu, __prog_put_common);\n}\n",
        "linevul": 5.386017437558621e-05,
        "sysevr": 0.15880709886550903,
        "devign": 0.003360629314556718
    },
    {
        "code": "intel_shared_regs_constraints(struct cpu_hw_events *cpuc,\n\t\t\t      struct perf_event *event)\n{\n\tstruct event_constraint *c = NULL, *d;\n\tstruct hw_perf_event_extra *xreg, *breg;\n\n\txreg = &event->hw.extra_reg;\n\tif (xreg->idx != EXTRA_REG_NONE) {\n\t\tc = __intel_shared_reg_get_constraints(cpuc, event, xreg);\n\t\tif (c == &emptyconstraint)\n\t\t\treturn c;\n\t}\n\tbreg = &event->hw.branch_reg;\n\tif (breg->idx != EXTRA_REG_NONE) {\n\t\td = __intel_shared_reg_get_constraints(cpuc, event, breg);\n\t\tif (d == &emptyconstraint) {\n\t\t\t__intel_shared_reg_put_constraints(cpuc, xreg);\n\t\t\tc = d;\n\t\t}\n\t}\n\treturn c;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f1923820c447e986a9da0fc6bf60c1dccdf0408e",
        "vul_func_with_fix": "intel_shared_regs_constraints(struct cpu_hw_events *cpuc,\n\t\t\t      struct perf_event *event)\n{\n\tstruct event_constraint *c = NULL, *d;\n\tstruct hw_perf_event_extra *xreg, *breg;\n\n\txreg = &event->hw.extra_reg;\n\tif (xreg->idx != EXTRA_REG_NONE) {\n\t\tc = __intel_shared_reg_get_constraints(cpuc, event, xreg);\n\t\tif (c == &emptyconstraint)\n\t\t\treturn c;\n\t}\n\tbreg = &event->hw.branch_reg;\n\tif (breg->idx != EXTRA_REG_NONE) {\n\t\td = __intel_shared_reg_get_constraints(cpuc, event, breg);\n\t\tif (d == &emptyconstraint) {\n\t\t\t__intel_shared_reg_put_constraints(cpuc, xreg);\n\t\t\tc = d;\n\t\t}\n\t}\n\treturn c;\n}\n",
        "linevul": 6.03145090281032e-05,
        "sysevr": 0.1833389848470688,
        "devign": 6.153483430746291e-19
    },
    {
        "code": "void ar6000_dtimexpiry_event(struct ar6_softc *ar)\n{\n    bool isMcastQueued = false;\n    struct sk_buff *skb = NULL;\n\n    /* If there are no associated STAs, ignore the DTIM expiry event.\n     * There can be potential race conditions where the last associated\n     * STA may disconnect & before the host could clear the 'Indicate DTIM'\n     * request to the firmware, the firmware would have just indicated a DTIM\n     * expiry event. The race is between 'clear DTIM expiry cmd' going\n     * from the host to the firmware & the DTIM expiry event happening from\n     * the firmware to the host.\n     */\n    if (ar->sta_list_index == 0) {\n        return;\n    }\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    isMcastQueued = A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq);\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    A_ASSERT(isMcastQueued == false);\n\n    /* Flush the mcast psq to the target */\n    /* Set the STA flag to DTIMExpired, so that the frame will go out */\n    ar->DTIMExpired = true;\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    while (!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n        skb = A_NETBUF_DEQUEUE(&ar->mcastpsq);\n        A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n        ar6000_data_tx(skb, ar->arNetDev);\n\n        A_MUTEX_LOCK(&ar->mcastpsqLock);\n    }\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    /* Reset the DTIMExpired flag back to 0 */\n    ar->DTIMExpired = false;\n\n    /* Clear the LSB of the BitMapCtl field of the TIM IE */\n    wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "void ar6000_dtimexpiry_event(struct ar6_softc *ar)\n{\n    bool isMcastQueued = false;\n    struct sk_buff *skb = NULL;\n\n    /* If there are no associated STAs, ignore the DTIM expiry event.\n     * There can be potential race conditions where the last associated\n     * STA may disconnect & before the host could clear the 'Indicate DTIM'\n     * request to the firmware, the firmware would have just indicated a DTIM\n     * expiry event. The race is between 'clear DTIM expiry cmd' going\n     * from the host to the firmware & the DTIM expiry event happening from\n     * the firmware to the host.\n     */\n    if (ar->sta_list_index == 0) {\n        return;\n    }\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    isMcastQueued = A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq);\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    A_ASSERT(isMcastQueued == false);\n\n    /* Flush the mcast psq to the target */\n    /* Set the STA flag to DTIMExpired, so that the frame will go out */\n    ar->DTIMExpired = true;\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    while (!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n        skb = A_NETBUF_DEQUEUE(&ar->mcastpsq);\n        A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n        ar6000_data_tx(skb, ar->arNetDev);\n\n        A_MUTEX_LOCK(&ar->mcastpsqLock);\n    }\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    /* Reset the DTIMExpired flag back to 0 */\n    ar->DTIMExpired = false;\n\n    /* Clear the LSB of the BitMapCtl field of the TIM IE */\n    wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 0);\n}\n",
        "linevul": 4.8084024456329644e-05,
        "sysevr": 0.21270503103733063,
        "devign": 4.036964583065128e-06
    },
    {
        "code": "static int airspy_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\n\tif (f->tuner == 0) {\n\t\tf->type = V4L2_TUNER_ADC;\n\t\tf->frequency = s->f_adc;\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tf->frequency = s->f_rf;\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848",
        "vul_func_with_fix": "static int airspy_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\n\tif (f->tuner == 0) {\n\t\tf->type = V4L2_TUNER_ADC;\n\t\tf->frequency = s->f_adc;\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tf->frequency = s->f_rf;\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 4.757305214297958e-05,
        "sysevr": 0.13470381498336792,
        "devign": 2.0648546527952887e-22
    },
    {
        "code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n \t\t     struct sock *sk, int tstype)\n {\n \tstruct sk_buff *skb;\n\tbool tsonly;\n \n \tif (!sk)\n \t\treturn;\n\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\n\tif (tsonly) {\n #ifdef CONFIG_INET\n \t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n \t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n \t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n #endif\n \t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n \t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n \telse\n \t\tskb->tstamp = ktime_get_real();\n \n\t__skb_complete_tx_timestamp(skb, sk, tstype);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a",
        "vul_func_with_fix": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n \t\t     struct sock *sk, int tstype)\n {\n \tstruct sk_buff *skb;\n//flaw_line_below:\n\tbool tsonly;\n//fix_flaw_line_below:\n//\tbool tsonly, opt_stats = false;\n \n \tif (!sk)\n \t\treturn;\n\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\n\tif (tsonly) {\n #ifdef CONFIG_INET\n \t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n \t\t    sk->sk_protocol == IPPROTO_TCP &&\n//flaw_line_below:\n\t\t    sk->sk_type == SOCK_STREAM)\n//fix_flaw_line_below:\n//\t\t    sk->sk_type == SOCK_STREAM) {\n \t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n//flaw_line_below:\n\t\telse\n//fix_flaw_line_below:\n//\t\t\topt_stats = true;\n//fix_flaw_line_below:\n//\t\t} else\n #endif\n \t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n \t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n \telse\n \t\tskb->tstamp = ktime_get_real();\n \n//flaw_line_below:\n\t__skb_complete_tx_timestamp(skb, sk, tstype);\n//fix_flaw_line_below:\n//\t__skb_complete_tx_timestamp(skb, sk, tstype, opt_stats);\n }\n",
        "linevul": 0.9996668100357056,
        "sysevr": 0.19588488340377808,
        "devign": 0.9992091059684753
    },
    {
        "code": "struct lruvec *mem_cgroup_lru_add_list(struct zone *zone, struct page *page,\n\t\t\t\t       enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\t/* compound_order() is stabilized through lru_lock */\n\tMEM_CGROUP_ZSTAT(mz, lru) += 1 << compound_order(page);\n\treturn &mz->lruvec;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/371528caec553785c37f73fa3926ea0de84f986f",
        "vul_func_with_fix": "struct lruvec *mem_cgroup_lru_add_list(struct zone *zone, struct page *page,\n\t\t\t\t       enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\t/* compound_order() is stabilized through lru_lock */\n\tMEM_CGROUP_ZSTAT(mz, lru) += 1 << compound_order(page);\n\treturn &mz->lruvec;\n}\n",
        "linevul": 7.851481495890766e-05,
        "sysevr": 0.1350765973329544,
        "devign": 1.6091541987783842e-10
    },
    {
        "code": "static void tg3_serdes_parallel_detect(struct tg3 *tp)\n{\n\tif (tp->serdes_counter) {\n\t\t/* Give autoneg time to complete. */\n\t\ttp->serdes_counter--;\n\t\treturn;\n\t}\n\n\tif (!tp->link_up &&\n\t    (tp->link_config.autoneg == AUTONEG_ENABLE)) {\n\t\tu32 bmcr;\n\n\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tu32 phy1, phy2;\n\n\t\t\t/* Select shadow register 0x1f */\n\t\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x7c00);\n\t\t\ttg3_readphy(tp, MII_TG3_MISC_SHDW, &phy1);\n\n\t\t\t/* Select expansion interrupt status register */\n\t\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t\t\t MII_TG3_DSP_EXP1_INT_STAT);\n\t\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\t\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\n\t\t\tif ((phy1 & 0x10) && !(phy2 & 0x20)) {\n\t\t\t\t/* We have signal detect and not receiving\n\t\t\t\t * config code words, link is up by parallel\n\t\t\t\t * detection.\n\t\t\t\t */\n\n\t\t\t\tbmcr &= ~BMCR_ANENABLE;\n\t\t\t\tbmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;\n\t\t\t\ttg3_writephy(tp, MII_BMCR, bmcr);\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_PARALLEL_DETECT;\n\t\t\t}\n\t\t}\n\t} else if (tp->link_up &&\n\t\t   (tp->link_config.autoneg == AUTONEG_ENABLE) &&\n\t\t   (tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT)) {\n\t\tu32 phy2;\n\n\t\t/* Select expansion interrupt status register */\n\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t\t MII_TG3_DSP_EXP1_INT_STAT);\n\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\t\tif (phy2 & 0x20) {\n\t\t\tu32 bmcr;\n\n\t\t\t/* Config code words received, turn on autoneg. */\n\t\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\t\ttg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANENABLE);\n\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
        "vul_func_with_fix": "static void tg3_serdes_parallel_detect(struct tg3 *tp)\n{\n\tif (tp->serdes_counter) {\n\t\t/* Give autoneg time to complete. */\n\t\ttp->serdes_counter--;\n\t\treturn;\n\t}\n\n\tif (!tp->link_up &&\n\t    (tp->link_config.autoneg == AUTONEG_ENABLE)) {\n\t\tu32 bmcr;\n\n\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tu32 phy1, phy2;\n\n\t\t\t/* Select shadow register 0x1f */\n\t\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x7c00);\n\t\t\ttg3_readphy(tp, MII_TG3_MISC_SHDW, &phy1);\n\n\t\t\t/* Select expansion interrupt status register */\n\t\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t\t\t MII_TG3_DSP_EXP1_INT_STAT);\n\t\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\t\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\n\t\t\tif ((phy1 & 0x10) && !(phy2 & 0x20)) {\n\t\t\t\t/* We have signal detect and not receiving\n\t\t\t\t * config code words, link is up by parallel\n\t\t\t\t * detection.\n\t\t\t\t */\n\n\t\t\t\tbmcr &= ~BMCR_ANENABLE;\n\t\t\t\tbmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;\n\t\t\t\ttg3_writephy(tp, MII_BMCR, bmcr);\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_PARALLEL_DETECT;\n\t\t\t}\n\t\t}\n\t} else if (tp->link_up &&\n\t\t   (tp->link_config.autoneg == AUTONEG_ENABLE) &&\n\t\t   (tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT)) {\n\t\tu32 phy2;\n\n\t\t/* Select expansion interrupt status register */\n\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t\t MII_TG3_DSP_EXP1_INT_STAT);\n\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\t\tif (phy2 & 0x20) {\n\t\t\tu32 bmcr;\n\n\t\t\t/* Config code words received, turn on autoneg. */\n\t\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\t\ttg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANENABLE);\n\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\n\t\t}\n\t}\n}\n",
        "linevul": 4.769520091940649e-05,
        "sysevr": 0.12628541886806488,
        "devign": 4.436375572458573e-11
    },
    {
        "code": "static struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tstruct sock *sk;\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tif (unlikely(sk = skb_steal_sock(skb)))\n\t\treturn sk;\n\treturn __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t udptable);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/87c48fa3b4630905f98268dde838ee43626a060c",
        "vul_func_with_fix": "static struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tstruct sock *sk;\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tif (unlikely(sk = skb_steal_sock(skb)))\n\t\treturn sk;\n\treturn __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t udptable);\n}\n",
        "linevul": 5.1660685130627826e-05,
        "sysevr": 0.1336466521024704,
        "devign": 0.0001729807845549658
    },
    {
        "code": "static inline int kvm_io_bus_cmp(const struct kvm_io_range *r1,\n\t\t\t\t const struct kvm_io_range *r2)\n{\n\tgpa_t addr1 = r1->addr;\n\tgpa_t addr2 = r2->addr;\n\n\tif (addr1 < addr2)\n\t\treturn -1;\n\n\t/* If r2->len == 0, match the exact address.  If r2->len != 0,\n\t * accept any overlapping write.  Any order is acceptable for\n\t * overlapping ranges, because kvm_io_bus_get_first_dev ensures\n\t * we process all of them.\n\t */\n\tif (r2->len) {\n\t\taddr1 += r1->len;\n\t\taddr2 += r2->len;\n\t}\n\n\tif (addr1 > addr2)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "vul_func_with_fix": "static inline int kvm_io_bus_cmp(const struct kvm_io_range *r1,\n\t\t\t\t const struct kvm_io_range *r2)\n{\n\tgpa_t addr1 = r1->addr;\n\tgpa_t addr2 = r2->addr;\n\n\tif (addr1 < addr2)\n\t\treturn -1;\n\n\t/* If r2->len == 0, match the exact address.  If r2->len != 0,\n\t * accept any overlapping write.  Any order is acceptable for\n\t * overlapping ranges, because kvm_io_bus_get_first_dev ensures\n\t * we process all of them.\n\t */\n\tif (r2->len) {\n\t\taddr1 += r1->len;\n\t\taddr2 += r2->len;\n\t}\n\n\tif (addr1 > addr2)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
        "linevul": 5.1500919653335586e-05,
        "sysevr": 0.12912382185459137,
        "devign": 1.4534584646952453e-10
    },
    {
        "code": "xfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c88547a8119e3b581318ab65e9b72f27f23e641d",
        "vul_func_with_fix": "xfs_da3_node_order(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*node1_bp,\n\tstruct xfs_buf\t*node2_bp)\n{\n\tstruct xfs_da_intnode\t*node1;\n\tstruct xfs_da_intnode\t*node2;\n\tstruct xfs_da_node_entry *btree1;\n\tstruct xfs_da_node_entry *btree2;\n\tstruct xfs_da3_icnode_hdr node1hdr;\n\tstruct xfs_da3_icnode_hdr node2hdr;\n\n\tnode1 = node1_bp->b_addr;\n\tnode2 = node2_bp->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&node1hdr, node1);\n\tdp->d_ops->node_hdr_from_disk(&node2hdr, node2);\n\tbtree1 = dp->d_ops->node_tree_p(node1);\n\tbtree2 = dp->d_ops->node_tree_p(node2);\n\n\tif (node1hdr.count > 0 && node2hdr.count > 0 &&\n\t    ((be32_to_cpu(btree2[0].hashval) < be32_to_cpu(btree1[0].hashval)) ||\n\t     (be32_to_cpu(btree2[node2hdr.count - 1].hashval) <\n\t      be32_to_cpu(btree1[node1hdr.count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
        "linevul": 8.131512731779367e-05,
        "sysevr": 0.18849493563175201,
        "devign": 1.6424347513917858e-26
    },
    {
        "code": "static ssize_t tracing_splice_read_pipe(struct file *filp,\n\t\t\t\t\tloff_t *ppos,\n\t\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct page *pages_def[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial_def[PIPE_DEF_BUFFERS];\n\tstruct trace_iterator *iter = filp->private_data;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages\t= 0, /* This gets updated below. */\n\t\t.nr_pages_max\t= PIPE_DEF_BUFFERS,\n\t\t.ops\t\t= &tracing_pipe_buf_ops,\n\t\t.spd_release\t= tracing_spd_release_pipe,\n\t};\n\tssize_t ret;\n\tsize_t rem;\n\tunsigned int i;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&iter->mutex);\n\n\tif (iter->trace->splice_read) {\n\t\tret = iter->trace->splice_read(iter, filp,\n\t\t\t\t\t       ppos, pipe, len, flags);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\tret = tracing_wait_pipe(filp);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\n\tif (!iter->ent && !trace_find_next_entry_inc(iter)) {\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\n\t/* Fill as many pages as possible. */\n\tfor (i = 0, rem = len; i < spd.nr_pages_max && rem; i++) {\n\t\tspd.pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!spd.pages[i])\n\t\t\tbreak;\n\n\t\trem = tracing_fill_pipe_page(rem, iter);\n\n\t\t/* Copy the data into the page, so we can start over. */\n\t\tret = trace_seq_to_buffer(&iter->seq,\n\t\t\t\t\t  page_address(spd.pages[i]),\n\t\t\t\t\t  trace_seq_used(&iter->seq));\n\t\tif (ret < 0) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tbreak;\n\t\t}\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = trace_seq_used(&iter->seq);\n\n\t\ttrace_seq_init(&iter->seq);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\tmutex_unlock(&iter->mutex);\n\n\tspd.nr_pages = i;\n\n\tif (i)\n\t\tret = splice_to_pipe(pipe, &spd);\n\telse\n\t\tret = 0;\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n\nout_err:\n\tmutex_unlock(&iter->mutex);\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "static ssize_t tracing_splice_read_pipe(struct file *filp,\n\t\t\t\t\tloff_t *ppos,\n\t\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct page *pages_def[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial_def[PIPE_DEF_BUFFERS];\n\tstruct trace_iterator *iter = filp->private_data;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages\t= 0, /* This gets updated below. */\n\t\t.nr_pages_max\t= PIPE_DEF_BUFFERS,\n\t\t.ops\t\t= &tracing_pipe_buf_ops,\n\t\t.spd_release\t= tracing_spd_release_pipe,\n\t};\n\tssize_t ret;\n\tsize_t rem;\n\tunsigned int i;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&iter->mutex);\n\n\tif (iter->trace->splice_read) {\n\t\tret = iter->trace->splice_read(iter, filp,\n\t\t\t\t\t       ppos, pipe, len, flags);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\tret = tracing_wait_pipe(filp);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\n\tif (!iter->ent && !trace_find_next_entry_inc(iter)) {\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\n\t/* Fill as many pages as possible. */\n\tfor (i = 0, rem = len; i < spd.nr_pages_max && rem; i++) {\n\t\tspd.pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!spd.pages[i])\n\t\t\tbreak;\n\n\t\trem = tracing_fill_pipe_page(rem, iter);\n\n\t\t/* Copy the data into the page, so we can start over. */\n\t\tret = trace_seq_to_buffer(&iter->seq,\n\t\t\t\t\t  page_address(spd.pages[i]),\n\t\t\t\t\t  trace_seq_used(&iter->seq));\n\t\tif (ret < 0) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tbreak;\n\t\t}\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = trace_seq_used(&iter->seq);\n\n\t\ttrace_seq_init(&iter->seq);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\tmutex_unlock(&iter->mutex);\n\n\tspd.nr_pages = i;\n\n\tif (i)\n\t\tret = splice_to_pipe(pipe, &spd);\n\telse\n\t\tret = 0;\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n\nout_err:\n\tmutex_unlock(&iter->mutex);\n\tgoto out;\n}\n",
        "linevul": 0.00036425740108825266,
        "sysevr": 0.16110087931156158,
        "devign": 0.11540407687425613
    },
    {
        "code": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n \t\t\trv = -ENODEV;\n \t\t\tgoto err;\n \t\t}\n \t\ti++;\n \t\tif (file->f_flags & O_NONBLOCK) {\n \t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n \t\t\tspin_unlock_irq(&desc->iuspin);\n \t\t\tgoto retry;\n \t\t}\n \t\tif (!desc->reslength) { /* zero length read */\n \t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n \t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
        "vul_func_with_fix": "static ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock); /*concurrent reads */\n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = ACCESS_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n \t\t\trv = -ENODEV;\n \t\t\tgoto err;\n \t\t}\n//fix_flaw_line_below:\n//\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n//fix_flaw_line_below:\n//\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n//fix_flaw_line_below:\n//\t\t\trv = -ENOBUFS;\n//fix_flaw_line_below:\n//\t\t\tgoto err;\n//fix_flaw_line_below:\n//\t\t}\n \t\ti++;\n \t\tif (file->f_flags & O_NONBLOCK) {\n \t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = cntr ? cntr : -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t/* may have happened while we slept */\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) { /* read completed, error happened */\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * recheck whether we've lost the race\n\t\t * against the completion handler\n\t\t */\n\t\tif (!test_bit(WDM_READ, &desc->flags)) { /* lost race */\n \t\t\tspin_unlock_irq(&desc->iuspin);\n \t\t\tgoto retry;\n \t\t}\n//fix_flaw_line_below:\n//\n \t\tif (!desc->reslength) { /* zero length read */\n \t\t\tdev_dbg(&desc->intf->dev, \"%s: zero length - clearing WDM_READ\\n\", __func__);\n \t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t/* in case we had outstanding data */\n\tif (!desc->length)\n\t\tclear_bit(WDM_READ, &desc->flags);\n\n\tspin_unlock_irq(&desc->iuspin);\n\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}\n",
        "linevul": 0.9991468191146851,
        "sysevr": 0.21884630620479584,
        "devign": 0.6756815314292908
    },
    {
        "code": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}\n",
        "linevul": 8.316071034641936e-05,
        "sysevr": 0.1258600801229477,
        "devign": 6.398813638952561e-06
    },
    {
        "code": "static int md4_update(struct shash_desc *desc, const u8 *data, unsigned int len)\n{\n\tstruct md4_ctx *mctx = shash_desc_ctx(desc);\n\tconst u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\n\n\tmctx->byte_count += len;\n\n\tif (avail > len) {\n\t\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t       data, len);\n\t\treturn 0;\n\t}\n\n\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t       data, avail);\n\n\tmd4_transform_helper(mctx);\n\tdata += avail;\n\tlen -= avail;\n\n\twhile (len >= sizeof(mctx->block)) {\n\t\tmemcpy(mctx->block, data, sizeof(mctx->block));\n\t\tmd4_transform_helper(mctx);\n\t\tdata += sizeof(mctx->block);\n\t\tlen -= sizeof(mctx->block);\n\t}\n\n\tmemcpy(mctx->block, data, len);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int md4_update(struct shash_desc *desc, const u8 *data, unsigned int len)\n{\n\tstruct md4_ctx *mctx = shash_desc_ctx(desc);\n\tconst u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\n\n\tmctx->byte_count += len;\n\n\tif (avail > len) {\n\t\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t\t       data, len);\n\t\treturn 0;\n\t}\n\n\tmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\n\t       data, avail);\n\n\tmd4_transform_helper(mctx);\n\tdata += avail;\n\tlen -= avail;\n\n\twhile (len >= sizeof(mctx->block)) {\n\t\tmemcpy(mctx->block, data, sizeof(mctx->block));\n\t\tmd4_transform_helper(mctx);\n\t\tdata += sizeof(mctx->block);\n\t\tlen -= sizeof(mctx->block);\n\t}\n\n\tmemcpy(mctx->block, data, len);\n\n\treturn 0;\n}\n",
        "linevul": 5.835010597365908e-05,
        "sysevr": 0.146821990609169,
        "devign": 1.7373865475629746e-14
    },
    {
        "code": "static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\tvmcs12->vm_entry_intr_info_field);\n\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\tvmcs12->vm_entry_exception_error_code);\n\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\tvmcs12->vm_entry_instruction_len);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\tvmcs12->guest_interruptibility_info);\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\texec_control &= ~(PIN_BASED_VMX_PREEMPTION_TIMER |\n                          PIN_BASED_POSTED_INTR);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t *\n\t * A problem with this approach (when !enable_ept) is that L1 may be\n\t * injected with more page faults than it asked for. This could have\n\t * caused problems, but in practice existing hypervisors don't care.\n\t * To fix this, we will need to emulate the PFEC checking (on the L1\n\t * page tables), using walk_addr(), when injecting PFs to L1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx_secondary_exec_control(vmx);\n\t\tif (!vmx->rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n                                  SECONDARY_EXEC_APIC_REGISTER_VIRT);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS))\n\t\t\texec_control |= vmcs12->secondary_vm_exec_control;\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {\n\t\t\t/*\n\t\t\t * If translation failed, no matter: This feature asks\n\t\t\t * to exit when accessing the given address, and if it\n\t\t\t * can never be accessed, this feature won't do\n\t\t\t * anything anyway.\n\t\t\t */\n\t\t\tif (!vmx->nested.apic_access_page)\n\t\t\t\texec_control &=\n\t\t\t\t  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\telse\n\t\t\t\tvmcs_write64(APIC_ACCESS_ADDR,\n\t\t\t\t  page_to_phys(vmx->nested.apic_access_page));\n\t\t} else if (vm_need_virtualize_apic_accesses(vmx->vcpu.kvm)) {\n\t\t\texec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\t}\n\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\tif (exec_control & CPU_BASED_TPR_SHADOW) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\tpage_to_phys(vmx->nested.virtual_apic_page));\n\t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n\t}\n\n\t/*\n\t * Merging of IO and MSR bitmaps not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_MSR_BITMAPS;\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvmx->nested.vmcs01_tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tkvm_mmu_unload(vcpu);\n\t\tnested_ept_init_mmu_context(vcpu);\n\t}\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, with possibly a modified\n\t * TS bit (for lazy fpu) and bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\t/* shadow page tables on either EPT or shadow page tables */\n\tkvm_set_cr3(vcpu, vmcs12->guest_cr3);\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\tvmcs12->vm_entry_intr_info_field);\n\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\tvmcs12->vm_entry_exception_error_code);\n\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\tvmcs12->vm_entry_instruction_len);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\tvmcs12->guest_interruptibility_info);\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\texec_control &= ~(PIN_BASED_VMX_PREEMPTION_TIMER |\n                          PIN_BASED_POSTED_INTR);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t *\n\t * A problem with this approach (when !enable_ept) is that L1 may be\n\t * injected with more page faults than it asked for. This could have\n\t * caused problems, but in practice existing hypervisors don't care.\n\t * To fix this, we will need to emulate the PFEC checking (on the L1\n\t * page tables), using walk_addr(), when injecting PFs to L1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx_secondary_exec_control(vmx);\n\t\tif (!vmx->rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n                                  SECONDARY_EXEC_APIC_REGISTER_VIRT);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS))\n\t\t\texec_control |= vmcs12->secondary_vm_exec_control;\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES) {\n\t\t\t/*\n\t\t\t * If translation failed, no matter: This feature asks\n\t\t\t * to exit when accessing the given address, and if it\n\t\t\t * can never be accessed, this feature won't do\n\t\t\t * anything anyway.\n\t\t\t */\n\t\t\tif (!vmx->nested.apic_access_page)\n\t\t\t\texec_control &=\n\t\t\t\t  ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\telse\n\t\t\t\tvmcs_write64(APIC_ACCESS_ADDR,\n\t\t\t\t  page_to_phys(vmx->nested.apic_access_page));\n\t\t} else if (vm_need_virtualize_apic_accesses(vmx->vcpu.kvm)) {\n\t\t\texec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\t}\n\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\tif (exec_control & CPU_BASED_TPR_SHADOW) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\tpage_to_phys(vmx->nested.virtual_apic_page));\n\t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n\t}\n\n\t/*\n\t * Merging of IO and MSR bitmaps not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_MSR_BITMAPS;\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvmx->nested.vmcs01_tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vmx->nested.vmcs01_tsc_offset);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * Trivially support vpid by letting L2s share their parent\n\t\t * L1's vpid. TODO: move to a more elaborate solution, giving\n\t\t * each L2 its own vpid and exposing the vpid feature to L1.\n\t\t */\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\tvmx_flush_tlb(vcpu);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tkvm_mmu_unload(vcpu);\n\t\tnested_ept_init_mmu_context(vcpu);\n\t}\n\n\tif (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, with possibly a modified\n\t * TS bit (for lazy fpu) and bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\t/* shadow page tables on either EPT or shadow page tables */\n\tkvm_set_cr3(vcpu, vmcs12->guest_cr3);\n\tkvm_mmu_reset_context(vcpu);\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n}\n",
        "linevul": 5.1709233957808465e-05,
        "sysevr": 0.2687205970287323,
        "devign": 1.5847606601790675e-16
    },
    {
        "code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n \n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n \n \t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n \t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f",
        "vul_func_with_fix": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n \n//flaw_line_below:\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n//fix_flaw_line_below:\n//\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n//fix_flaw_line_below:\n//\t\t\t\tmnt_has_parent(p) &&\n//fix_flaw_line_below:\n//\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n//fix_flaw_line_below:\n//\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n \n \t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n \t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}\n",
        "linevul": 6.64434555801563e-05,
        "sysevr": 0.12527567148208618,
        "devign": 0.9986873269081116
    },
    {
        "code": "static void k_getrusage(struct task_struct *p, int who, struct rusage *r)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tcputime_t tgutime, tgstime, utime, stime;\n\tunsigned long maxrss = 0;\n\n\tmemset((char *) r, 0, sizeof *r);\n\tutime = stime = 0;\n\n\tif (who == RUSAGE_THREAD) {\n\t\ttask_times(current, &utime, &stime);\n\t\taccumulate_thread_rusage(p, r);\n\t\tmaxrss = p->signal->maxrss;\n\t\tgoto out;\n\t}\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn;\n\n\tswitch (who) {\n\t\tcase RUSAGE_BOTH:\n\t\tcase RUSAGE_CHILDREN:\n\t\t\tutime = p->signal->cutime;\n\t\t\tstime = p->signal->cstime;\n\t\t\tr->ru_nvcsw = p->signal->cnvcsw;\n\t\t\tr->ru_nivcsw = p->signal->cnivcsw;\n\t\t\tr->ru_minflt = p->signal->cmin_flt;\n\t\t\tr->ru_majflt = p->signal->cmaj_flt;\n\t\t\tr->ru_inblock = p->signal->cinblock;\n\t\t\tr->ru_oublock = p->signal->coublock;\n\t\t\tmaxrss = p->signal->cmaxrss;\n\n\t\t\tif (who == RUSAGE_CHILDREN)\n\t\t\t\tbreak;\n\n\t\tcase RUSAGE_SELF:\n\t\t\tthread_group_times(p, &tgutime, &tgstime);\n\t\t\tutime += tgutime;\n\t\t\tstime += tgstime;\n\t\t\tr->ru_nvcsw += p->signal->nvcsw;\n\t\t\tr->ru_nivcsw += p->signal->nivcsw;\n\t\t\tr->ru_minflt += p->signal->min_flt;\n\t\t\tr->ru_majflt += p->signal->maj_flt;\n\t\t\tr->ru_inblock += p->signal->inblock;\n\t\t\tr->ru_oublock += p->signal->oublock;\n\t\t\tif (maxrss < p->signal->maxrss)\n\t\t\t\tmaxrss = p->signal->maxrss;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\taccumulate_thread_rusage(t, r);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != p);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tunlock_task_sighand(p, &flags);\n\nout:\n\tcputime_to_timeval(utime, &r->ru_utime);\n\tcputime_to_timeval(stime, &r->ru_stime);\n\n\tif (who != RUSAGE_CHILDREN) {\n\t\tstruct mm_struct *mm = get_task_mm(p);\n\t\tif (mm) {\n\t\t\tsetmax_mm_hiwater_rss(&maxrss, mm);\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\tr->ru_maxrss = maxrss * (PAGE_SIZE / 1024); /* convert pages to KBs */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2702b1526c7278c4d65d78de209a465d4de2885e",
        "vul_func_with_fix": "static void k_getrusage(struct task_struct *p, int who, struct rusage *r)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tcputime_t tgutime, tgstime, utime, stime;\n\tunsigned long maxrss = 0;\n\n\tmemset((char *) r, 0, sizeof *r);\n\tutime = stime = 0;\n\n\tif (who == RUSAGE_THREAD) {\n\t\ttask_times(current, &utime, &stime);\n\t\taccumulate_thread_rusage(p, r);\n\t\tmaxrss = p->signal->maxrss;\n\t\tgoto out;\n\t}\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn;\n\n\tswitch (who) {\n\t\tcase RUSAGE_BOTH:\n\t\tcase RUSAGE_CHILDREN:\n\t\t\tutime = p->signal->cutime;\n\t\t\tstime = p->signal->cstime;\n\t\t\tr->ru_nvcsw = p->signal->cnvcsw;\n\t\t\tr->ru_nivcsw = p->signal->cnivcsw;\n\t\t\tr->ru_minflt = p->signal->cmin_flt;\n\t\t\tr->ru_majflt = p->signal->cmaj_flt;\n\t\t\tr->ru_inblock = p->signal->cinblock;\n\t\t\tr->ru_oublock = p->signal->coublock;\n\t\t\tmaxrss = p->signal->cmaxrss;\n\n\t\t\tif (who == RUSAGE_CHILDREN)\n\t\t\t\tbreak;\n\n\t\tcase RUSAGE_SELF:\n\t\t\tthread_group_times(p, &tgutime, &tgstime);\n\t\t\tutime += tgutime;\n\t\t\tstime += tgstime;\n\t\t\tr->ru_nvcsw += p->signal->nvcsw;\n\t\t\tr->ru_nivcsw += p->signal->nivcsw;\n\t\t\tr->ru_minflt += p->signal->min_flt;\n\t\t\tr->ru_majflt += p->signal->maj_flt;\n\t\t\tr->ru_inblock += p->signal->inblock;\n\t\t\tr->ru_oublock += p->signal->oublock;\n\t\t\tif (maxrss < p->signal->maxrss)\n\t\t\t\tmaxrss = p->signal->maxrss;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\taccumulate_thread_rusage(t, r);\n\t\t\t\tt = next_thread(t);\n\t\t\t} while (t != p);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tunlock_task_sighand(p, &flags);\n\nout:\n\tcputime_to_timeval(utime, &r->ru_utime);\n\tcputime_to_timeval(stime, &r->ru_stime);\n\n\tif (who != RUSAGE_CHILDREN) {\n\t\tstruct mm_struct *mm = get_task_mm(p);\n\t\tif (mm) {\n\t\t\tsetmax_mm_hiwater_rss(&maxrss, mm);\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\tr->ru_maxrss = maxrss * (PAGE_SIZE / 1024); /* convert pages to KBs */\n}\n",
        "linevul": 4.8249843530356884e-05,
        "sysevr": 0.19771549105644226,
        "devign": 1.7719213683126123e-13
    },
    {
        "code": "static inline void __x86_pmu_enable_event(struct hw_perf_event *hwc,\n\t\t\t\t\t  u64 enable_mask)\n{\n\tif (hwc->extra_reg)\n\t\twrmsrl(hwc->extra_reg, hwc->extra_config);\n\twrmsrl(hwc->config_base, hwc->config | enable_mask);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline void __x86_pmu_enable_event(struct hw_perf_event *hwc,\n\t\t\t\t\t  u64 enable_mask)\n{\n\tif (hwc->extra_reg)\n\t\twrmsrl(hwc->extra_reg, hwc->extra_config);\n\twrmsrl(hwc->config_base, hwc->config | enable_mask);\n}\n",
        "linevul": 5.123419396113604e-05,
        "sysevr": 0.1261269599199295,
        "devign": 1.6435471039688565e-11
    },
    {
        "code": "static void notify_cmos_timer(void)\n{\n\tif (!no_sync_cmos_clock)\n\t\tmod_timer(&sync_cmos_timer, jiffies + 1);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static void notify_cmos_timer(void)\n{\n\tif (!no_sync_cmos_clock)\n\t\tmod_timer(&sync_cmos_timer, jiffies + 1);\n}\n",
        "linevul": 0.00010869336256291717,
        "sysevr": 0.13235995173454285,
        "devign": 0.8480319976806641
    },
    {
        "code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n \tint err = 0;\n \n \ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n \tif (tu->timeri) {\n \t\tsnd_timer_close(tu->timeri);\n \t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n \t}\n \n       __err:\n      \tmutex_unlock(&tu->tread_sem);\n \treturn err;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/af368027a49a751d6ff4ee9e3f9961f35bb4fede",
        "vul_func_with_fix": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n \tint err = 0;\n \n \ttu = file->private_data;\n//flaw_line_below:\n\tmutex_lock(&tu->tread_sem);\n \tif (tu->timeri) {\n \t\tsnd_timer_close(tu->timeri);\n \t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n \t}\n \n       __err:\n//flaw_line_below:\n      \tmutex_unlock(&tu->tread_sem);\n \treturn err;\n }\n",
        "linevul": 0.9995331764221191,
        "sysevr": 0.15763859450817108,
        "devign": 0.6722208857536316
    },
    {
        "code": "static void snd_usb_mixer_inactivate(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4",
        "vul_func_with_fix": "static void snd_usb_mixer_inactivate(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}\n",
        "linevul": 0.01526887621730566,
        "sysevr": 0.12857694923877716,
        "devign": 0.7367692589759827
    },
    {
        "code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\n\t/* if the deadline is ahead of our clock, nothing to do */\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\n\t/*\n\t * If the local deadline has passed we have to consider the\n\t * possibility that our sched_clock is 'fast' and the global deadline\n\t * has not truly expired.\n\t *\n\t * Fortunately we can check determine whether this the case by checking\n\t * whether the global deadline(cfs_b->expires_seq) has advanced.\n\t */\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\t/* extend local deadline, drift is bounded above by 2 ticks */\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\t/* global deadline is ahead, expiration has passed */\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\n\t/* if the deadline is ahead of our clock, nothing to do */\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\n\t/*\n\t * If the local deadline has passed we have to consider the\n\t * possibility that our sched_clock is 'fast' and the global deadline\n\t * has not truly expired.\n\t *\n\t * Fortunately we can check determine whether this the case by checking\n\t * whether the global deadline(cfs_b->expires_seq) has advanced.\n\t */\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\t/* extend local deadline, drift is bounded above by 2 ticks */\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\t/* global deadline is ahead, expiration has passed */\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}\n",
        "linevul": 6.004890747135505e-05,
        "sysevr": 0.1519366353750229,
        "devign": 5.4253378038993105e-06
    },
    {
        "code": "xfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t mp->m_sb.sb_blocksize, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -=\n\t\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t\t mp->m_sb.sb_blocksize, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n \t\tname_rmt->valueblk = 0;\n \t\targs->rmtblkno = 1;\n \t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n \t}\n \txfs_trans_log_buf(args->trans, bp,\n \t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "vul_func_with_fix": "xfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t mp->m_sb.sb_blocksize, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -=\n\t\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t\t mp->m_sb.sb_blocksize, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n \t\tname_rmt->valueblk = 0;\n \t\targs->rmtblkno = 1;\n \t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n//fix_flaw_line_below:\n//\t\targs->rmtvaluelen = args->valuelen;\n \t}\n \txfs_trans_log_buf(args->trans, bp,\n \t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}\n",
        "linevul": 0.005796488374471664,
        "sysevr": 0.26607003808021545,
        "devign": 0.9905253052711487
    },
    {
        "code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "vul_func_with_fix": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}\n",
        "linevul": 7.115525659173727e-05,
        "sysevr": 0.12843367457389832,
        "devign": 3.453751499203628e-13
    },
    {
        "code": "nvmet_fc_alloc_target_assoc(struct nvmet_fc_tgtport *tgtport)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc, *tmpassoc;\n\tunsigned long flags;\n\tu64 ran;\n\tint idx;\n\tbool needrandom = true;\n\n\tassoc = kzalloc(sizeof(*assoc), GFP_KERNEL);\n\tif (!assoc)\n\t\treturn NULL;\n\n\tidx = ida_simple_get(&tgtport->assoc_cnt, 0, 0, GFP_KERNEL);\n\tif (idx < 0)\n\t\tgoto out_free_assoc;\n\n\tif (!nvmet_fc_tgtport_get(tgtport))\n\t\tgoto out_ida_put;\n\n\tassoc->tgtport = tgtport;\n\tassoc->a_id = idx;\n\tINIT_LIST_HEAD(&assoc->a_list);\n\tkref_init(&assoc->ref);\n\n\twhile (needrandom) {\n\t\tget_random_bytes(&ran, sizeof(ran) - BYTES_FOR_QID);\n\t\tran = ran << BYTES_FOR_QID_SHIFT;\n\n\t\tspin_lock_irqsave(&tgtport->lock, flags);\n\t\tneedrandom = false;\n\t\tlist_for_each_entry(tmpassoc, &tgtport->assoc_list, a_list)\n\t\t\tif (ran == tmpassoc->association_id) {\n\t\t\t\tneedrandom = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!needrandom) {\n\t\t\tassoc->association_id = ran;\n\t\t\tlist_add_tail(&assoc->a_list, &tgtport->assoc_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t}\n\n\treturn assoc;\n\nout_ida_put:\n\tida_simple_remove(&tgtport->assoc_cnt, idx);\nout_free_assoc:\n\tkfree(assoc);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0c319d3a144d4b8f1ea2047fd614d2149b68f889",
        "vul_func_with_fix": "nvmet_fc_alloc_target_assoc(struct nvmet_fc_tgtport *tgtport)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc, *tmpassoc;\n\tunsigned long flags;\n\tu64 ran;\n\tint idx;\n\tbool needrandom = true;\n\n\tassoc = kzalloc(sizeof(*assoc), GFP_KERNEL);\n\tif (!assoc)\n\t\treturn NULL;\n\n\tidx = ida_simple_get(&tgtport->assoc_cnt, 0, 0, GFP_KERNEL);\n\tif (idx < 0)\n\t\tgoto out_free_assoc;\n\n\tif (!nvmet_fc_tgtport_get(tgtport))\n\t\tgoto out_ida_put;\n\n\tassoc->tgtport = tgtport;\n\tassoc->a_id = idx;\n\tINIT_LIST_HEAD(&assoc->a_list);\n\tkref_init(&assoc->ref);\n\n\twhile (needrandom) {\n\t\tget_random_bytes(&ran, sizeof(ran) - BYTES_FOR_QID);\n\t\tran = ran << BYTES_FOR_QID_SHIFT;\n\n\t\tspin_lock_irqsave(&tgtport->lock, flags);\n\t\tneedrandom = false;\n\t\tlist_for_each_entry(tmpassoc, &tgtport->assoc_list, a_list)\n\t\t\tif (ran == tmpassoc->association_id) {\n\t\t\t\tneedrandom = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!needrandom) {\n\t\t\tassoc->association_id = ran;\n\t\t\tlist_add_tail(&assoc->a_list, &tgtport->assoc_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t}\n\n\treturn assoc;\n\nout_ida_put:\n\tida_simple_remove(&tgtport->assoc_cnt, idx);\nout_free_assoc:\n\tkfree(assoc);\n\treturn NULL;\n}\n",
        "linevul": 0.00011451570026110858,
        "sysevr": 0.23159734904766083,
        "devign": 5.993544771598636e-09
    },
    {
        "code": "static void restart_grace(void)\n{\n\tif (nlmsvc_ops) {\n\t\tstruct net *net = &init_net;\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tcancel_delayed_work_sync(&ln->grace_period_end);\n\t\tlocks_end_grace(&ln->lockd_manager);\n\t\tnlmsvc_invalidate_all();\n\t\tset_grace_period(net);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static void restart_grace(void)\n{\n\tif (nlmsvc_ops) {\n\t\tstruct net *net = &init_net;\n\t\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\t\tcancel_delayed_work_sync(&ln->grace_period_end);\n\t\tlocks_end_grace(&ln->lockd_manager);\n\t\tnlmsvc_invalidate_all();\n\t\tset_grace_period(net);\n\t}\n}\n",
        "linevul": 7.194082718342543e-05,
        "sysevr": 0.12467783689498901,
        "devign": 3.2775982245652514e-15
    },
    {
        "code": "static void blowfish_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tblowfish_enc_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static void blowfish_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tblowfish_enc_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n",
        "linevul": 5.957481334917247e-05,
        "sysevr": 0.12573373317718506,
        "devign": 0.0005564570892602205
    },
    {
        "code": "u64 current_tick_length(void)\n{\n\treturn tick_length;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "u64 current_tick_length(void)\n{\n\treturn tick_length;\n}\n",
        "linevul": 5.311568747856654e-05,
        "sysevr": 0.16393518447875977,
        "devign": 4.2212495434887365e-13
    },
    {
        "code": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (ioctl) {\n\tcase KVM_ARM_VCPU_INIT: {\n\t\tstruct kvm_vcpu_init init;\n\n\t\tif (copy_from_user(&init, argp, sizeof(init)))\n\t\t\treturn -EFAULT;\n\n\t\treturn kvm_vcpu_set_target(vcpu, &init);\n\n\t}\n \tcase KVM_SET_ONE_REG:\n \tcase KVM_GET_ONE_REG: {\n \t\tstruct kvm_one_reg reg;\n \t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n \t\t\treturn -EFAULT;\n \t\tif (ioctl == KVM_SET_ONE_REG)\n\t\t\treturn kvm_arm_set_reg(vcpu, &reg);\n\t\telse\n\t\t\treturn kvm_arm_get_reg(vcpu, &reg);\n\t}\n\tcase KVM_GET_REG_LIST: {\n\t\tstruct kvm_reg_list __user *user_list = argp;\n \t\tstruct kvm_reg_list reg_list;\n \t\tunsigned n;\n \n \t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))\n \t\t\treturn -EFAULT;\n \t\tn = reg_list.n;\n\t\treg_list.n = kvm_arm_num_regs(vcpu);\n\t\tif (copy_to_user(user_list, &reg_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tif (n < reg_list.n)\n\t\t\treturn -E2BIG;\n\t\treturn kvm_arm_copy_reg_indices(vcpu, user_list->reg);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e8180dcaa8470ceca21109f143876fdcd9fe050a",
        "vul_func_with_fix": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (ioctl) {\n\tcase KVM_ARM_VCPU_INIT: {\n\t\tstruct kvm_vcpu_init init;\n\n\t\tif (copy_from_user(&init, argp, sizeof(init)))\n\t\t\treturn -EFAULT;\n\n\t\treturn kvm_vcpu_set_target(vcpu, &init);\n\n\t}\n \tcase KVM_SET_ONE_REG:\n \tcase KVM_GET_ONE_REG: {\n \t\tstruct kvm_one_reg reg;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n//fix_flaw_line_below:\n//\t\t\treturn -ENOEXEC;\n//fix_flaw_line_below:\n//\n \t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n \t\t\treturn -EFAULT;\n \t\tif (ioctl == KVM_SET_ONE_REG)\n\t\t\treturn kvm_arm_set_reg(vcpu, &reg);\n\t\telse\n\t\t\treturn kvm_arm_get_reg(vcpu, &reg);\n\t}\n\tcase KVM_GET_REG_LIST: {\n\t\tstruct kvm_reg_list __user *user_list = argp;\n \t\tstruct kvm_reg_list reg_list;\n \t\tunsigned n;\n \n//fix_flaw_line_below:\n//\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n//fix_flaw_line_below:\n//\t\t\treturn -ENOEXEC;\n//fix_flaw_line_below:\n//\n \t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))\n \t\t\treturn -EFAULT;\n \t\tn = reg_list.n;\n\t\treg_list.n = kvm_arm_num_regs(vcpu);\n\t\tif (copy_to_user(user_list, &reg_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tif (n < reg_list.n)\n\t\t\treturn -E2BIG;\n\t\treturn kvm_arm_copy_reg_indices(vcpu, user_list->reg);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "linevul": 0.998755693435669,
        "sysevr": 0.19438010454177856,
        "devign": 1.0
    },
    {
        "code": "static inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}\n",
        "linevul": 7.35184657969512e-05,
        "sysevr": 0.13093945384025574,
        "devign": 6.665502587566152e-05
    },
    {
        "code": "static int ldm_parse_dgr3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR3_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x24, r_diskid);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x24, r_id1);\n\t\tlen = r_id2;\n\t} else {\n\t\tr_id1 = 0;\n\t\tr_id2 = 0;\n\t\tlen = r_diskid;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\tldm_get_vstr (buffer + 0x18 + r_name, dgrp->disk_id,\n\t\tsizeof (dgrp->disk_id));\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4",
        "vul_func_with_fix": "static int ldm_parse_dgr3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR3_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x24, r_diskid);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x24, r_id1);\n\t\tlen = r_id2;\n\t} else {\n\t\tr_id1 = 0;\n\t\tr_id2 = 0;\n\t\tlen = r_diskid;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\tldm_get_vstr (buffer + 0x18 + r_name, dgrp->disk_id,\n\t\tsizeof (dgrp->disk_id));\n\treturn true;\n}\n",
        "linevul": 5.783667802461423e-05,
        "sysevr": 0.13935448229312897,
        "devign": 4.97274747421339e-13
    },
    {
        "code": "static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)\n{\n\tint ia32_fxstate = (buf != buf_fx);\n\tstruct task_struct *tsk = current;\n\tstruct fpu *fpu = &tsk->thread.fpu;\n\tint state_size = fpu_kernel_xstate_size;\n\tu64 xfeatures = 0;\n\tint fx_only = 0;\n\n\tia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||\n\t\t\t IS_ENABLED(CONFIG_IA32_EMULATION));\n\n\tif (!buf) {\n\t\tfpu__clear(fpu);\n\t\treturn 0;\n\t}\n\n\tif (!access_ok(VERIFY_READ, buf, size))\n\t\treturn -EACCES;\n\n\tfpu__activate_curr(fpu);\n\n\tif (!static_cpu_has(X86_FEATURE_FPU))\n\t\treturn fpregs_soft_set(current, NULL,\n\t\t\t\t       0, sizeof(struct user_i387_ia32_struct),\n\t\t\t\t       NULL, buf) != 0;\n\n\tif (use_xsave()) {\n\t\tstruct _fpx_sw_bytes fx_sw_user;\n\t\tif (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {\n\t\t\t/*\n\t\t\t * Couldn't find the extended state information in the\n\t\t\t * memory layout. Restore just the FP/SSE and init all\n\t\t\t * the other extended state.\n\t\t\t */\n\t\t\tstate_size = sizeof(struct fxregs_state);\n\t\t\tfx_only = 1;\n\t\t\ttrace_x86_fpu_xstate_check_failed(fpu);\n\t\t} else {\n\t\t\tstate_size = fx_sw_user.xstate_size;\n\t\t\txfeatures = fx_sw_user.xfeatures;\n\t\t}\n\t}\n\n\tif (ia32_fxstate) {\n\t\t/*\n\t\t * For 32-bit frames with fxstate, copy the user state to the\n\t\t * thread's fpu state, reconstruct fxstate from the fsave\n\t\t * header. Sanitize the copied state etc.\n\t\t */\n\t\tstruct fpu *fpu = &tsk->thread.fpu;\n\t\tstruct user_i387_ia32_struct env;\n\t\tint err = 0;\n\n\t\t/*\n\t\t * Drop the current fpu which clears fpu->fpstate_active. This ensures\n\t\t * that any context-switch during the copy of the new state,\n\t\t * avoids the intermediate state from getting restored/saved.\n\t\t * Thus avoiding the new restored state from getting corrupted.\n\t\t * We will be ready to restore/save the state only after\n\t\t * fpu->fpstate_active is again set.\n \t\t */\n \t\tfpu__drop(fpu);\n \n\t\tif (using_compacted_format())\n \t\t\terr = copy_user_to_xstate(&fpu->state.xsave, buf_fx);\n\t\telse\n \t\t\terr = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);\n \n \t\tif (err || __copy_from_user(&env, buf, sizeof(env))) {\n \t\t\tfpstate_init(&fpu->state);\n \t\t\ttrace_x86_fpu_init_state(fpu);\n\t\t\terr = -1;\n\t\t} else {\n\t\t\tsanitize_restored_xstate(tsk, &env, xfeatures, fx_only);\n\t\t}\n\n\t\tfpu->fpstate_active = 1;\n\t\tpreempt_disable();\n\t\tfpu__restore(fpu);\n\t\tpreempt_enable();\n\n\t\treturn err;\n\t} else {\n\t\t/*\n\t\t * For 64-bit frames and 32-bit fsave frames, restore the user\n\t\t * state to the registers directly (with exceptions handled).\n\t\t */\n\t\tuser_fpu_begin();\n\t\tif (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {\n\t\t\tfpu__clear(fpu);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/814fb7bb7db5433757d76f4c4502c96fc53b0b5e",
        "vul_func_with_fix": "static int __fpu__restore_sig(void __user *buf, void __user *buf_fx, int size)\n{\n\tint ia32_fxstate = (buf != buf_fx);\n\tstruct task_struct *tsk = current;\n\tstruct fpu *fpu = &tsk->thread.fpu;\n\tint state_size = fpu_kernel_xstate_size;\n\tu64 xfeatures = 0;\n\tint fx_only = 0;\n\n\tia32_fxstate &= (IS_ENABLED(CONFIG_X86_32) ||\n\t\t\t IS_ENABLED(CONFIG_IA32_EMULATION));\n\n\tif (!buf) {\n\t\tfpu__clear(fpu);\n\t\treturn 0;\n\t}\n\n\tif (!access_ok(VERIFY_READ, buf, size))\n\t\treturn -EACCES;\n\n\tfpu__activate_curr(fpu);\n\n\tif (!static_cpu_has(X86_FEATURE_FPU))\n\t\treturn fpregs_soft_set(current, NULL,\n\t\t\t\t       0, sizeof(struct user_i387_ia32_struct),\n\t\t\t\t       NULL, buf) != 0;\n\n\tif (use_xsave()) {\n\t\tstruct _fpx_sw_bytes fx_sw_user;\n\t\tif (unlikely(check_for_xstate(buf_fx, buf_fx, &fx_sw_user))) {\n\t\t\t/*\n\t\t\t * Couldn't find the extended state information in the\n\t\t\t * memory layout. Restore just the FP/SSE and init all\n\t\t\t * the other extended state.\n\t\t\t */\n\t\t\tstate_size = sizeof(struct fxregs_state);\n\t\t\tfx_only = 1;\n\t\t\ttrace_x86_fpu_xstate_check_failed(fpu);\n\t\t} else {\n\t\t\tstate_size = fx_sw_user.xstate_size;\n\t\t\txfeatures = fx_sw_user.xfeatures;\n\t\t}\n\t}\n\n\tif (ia32_fxstate) {\n\t\t/*\n\t\t * For 32-bit frames with fxstate, copy the user state to the\n\t\t * thread's fpu state, reconstruct fxstate from the fsave\n\t\t * header. Sanitize the copied state etc.\n\t\t */\n\t\tstruct fpu *fpu = &tsk->thread.fpu;\n\t\tstruct user_i387_ia32_struct env;\n\t\tint err = 0;\n\n\t\t/*\n\t\t * Drop the current fpu which clears fpu->fpstate_active. This ensures\n\t\t * that any context-switch during the copy of the new state,\n\t\t * avoids the intermediate state from getting restored/saved.\n\t\t * Thus avoiding the new restored state from getting corrupted.\n\t\t * We will be ready to restore/save the state only after\n\t\t * fpu->fpstate_active is again set.\n \t\t */\n \t\tfpu__drop(fpu);\n \n//flaw_line_below:\n\t\tif (using_compacted_format())\n//fix_flaw_line_below:\n//\t\tif (using_compacted_format()) {\n \t\t\terr = copy_user_to_xstate(&fpu->state.xsave, buf_fx);\n//flaw_line_below:\n\t\telse\n//fix_flaw_line_below:\n//\t\t} else {\n \t\t\terr = __copy_from_user(&fpu->state.xsave, buf_fx, state_size);\n \n//fix_flaw_line_below:\n//\t\t\t/* xcomp_bv must be 0 when using uncompacted format */\n//fix_flaw_line_below:\n//\t\t\tif (!err && state_size > offsetof(struct xregs_state, header) && fpu->state.xsave.header.xcomp_bv)\n//fix_flaw_line_below:\n//\t\t\t\terr = -EINVAL;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n \t\tif (err || __copy_from_user(&env, buf, sizeof(env))) {\n \t\t\tfpstate_init(&fpu->state);\n \t\t\ttrace_x86_fpu_init_state(fpu);\n\t\t\terr = -1;\n\t\t} else {\n\t\t\tsanitize_restored_xstate(tsk, &env, xfeatures, fx_only);\n\t\t}\n\n\t\tfpu->fpstate_active = 1;\n\t\tpreempt_disable();\n\t\tfpu__restore(fpu);\n\t\tpreempt_enable();\n\n\t\treturn err;\n\t} else {\n\t\t/*\n\t\t * For 64-bit frames and 32-bit fsave frames, restore the user\n\t\t * state to the registers directly (with exceptions handled).\n\t\t */\n\t\tuser_fpu_begin();\n\t\tif (copy_user_to_fpregs_zeroing(buf_fx, xfeatures, fx_only)) {\n\t\t\tfpu__clear(fpu);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 7.176787767093629e-05,
        "sysevr": 0.22286124527454376,
        "devign": 0.6213901042938232
    },
    {
        "code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \n \tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n \tint ret;\n \n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n \t\treturn ERR_PTR(-EINVAL);\n \n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c",
        "vul_func_with_fix": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \n \tstruct vhost_scsi_tpg *tpg;\n//flaw_line_below:\n\tunsigned long tpgt;\n//fix_flaw_line_below:\n//\tu16 tpgt;\n \tint ret;\n \n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n//flaw_line_below:\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n//fix_flaw_line_below:\n//\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n \t\treturn ERR_PTR(-EINVAL);\n \n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}\n",
        "linevul": 0.9996634721755981,
        "sysevr": 0.14820727705955505,
        "devign": 0.9966869950294495
    },
    {
        "code": "static void nfs4_xdr_enc_getdeviceinfo(struct rpc_rqst *req,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       struct nfs4_getdeviceinfo_args *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_getdeviceinfo(xdr, args, &hdr);\n\n\t/* set up reply kvec. Subtract notification bitmap max size (2)\n\t * so that notification bitmap is put in xdr_buf tail */\n\txdr_inline_pages(&req->rq_rcv_buf, (hdr.replen - 2) << 2,\n\t\t\t args->pdev->pages, args->pdev->pgbase,\n\t\t\t args->pdev->pglen);\n\n\tencode_nops(&hdr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static void nfs4_xdr_enc_getdeviceinfo(struct rpc_rqst *req,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       struct nfs4_getdeviceinfo_args *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_getdeviceinfo(xdr, args, &hdr);\n\n\t/* set up reply kvec. Subtract notification bitmap max size (2)\n\t * so that notification bitmap is put in xdr_buf tail */\n\txdr_inline_pages(&req->rq_rcv_buf, (hdr.replen - 2) << 2,\n\t\t\t args->pdev->pages, args->pdev->pgbase,\n\t\t\t args->pdev->pglen);\n\n\tencode_nops(&hdr);\n}\n",
        "linevul": 6.540891627082601e-05,
        "sysevr": 0.15106742084026337,
        "devign": 2.552740241412721e-09
    },
    {
        "code": "static void l2tp_eth_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev = spriv->dev;\n\n\tseq_printf(m, \"   interface %s\\n\", dev->name);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static void l2tp_eth_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev = spriv->dev;\n\n\tseq_printf(m, \"   interface %s\\n\", dev->name);\n}\n",
        "linevul": 4.9020010919775814e-05,
        "sysevr": 0.1268487274646759,
        "devign": 0.00017853479948826134
    },
    {
        "code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\t/* Walk through the list of cached ASCONF-ACKs and find the\n \t * ack chunk whose serial number matches that of the request.\n \t */\n \tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n \t\tif (ack->subh.addip_hdr->serial == serial) {\n \t\t\tsctp_chunk_hold(ack);\n \t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b69040d8e39f20d5215a03502a8e8b4c6ab78395",
        "vul_func_with_fix": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\t/* Walk through the list of cached ASCONF-ACKs and find the\n \t * ack chunk whose serial number matches that of the request.\n \t */\n \tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n//fix_flaw_line_below:\n//\t\tif (sctp_chunk_pending(ack))\n//fix_flaw_line_below:\n//\t\t\tcontinue;\n \t\tif (ack->subh.addip_hdr->serial == serial) {\n \t\t\tsctp_chunk_hold(ack);\n \t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "linevul": 0.9982709884643555,
        "sysevr": 0.20295779407024384,
        "devign": 2.8651445518335095e-06
    },
    {
        "code": "int crypto_init_shash_ops_async(struct crypto_tfm *tfm)\n{\n\tstruct crypto_alg *calg = tfm->__crt_alg;\n\tstruct shash_alg *alg = __crypto_shash_alg(calg);\n\tstruct crypto_ahash *crt = __crypto_ahash_cast(tfm);\n\tstruct crypto_shash **ctx = crypto_tfm_ctx(tfm);\n\tstruct crypto_shash *shash;\n\n\tif (!crypto_mod_get(calg))\n\t\treturn -EAGAIN;\n\n\tshash = crypto_create_tfm(calg, &crypto_shash_type);\n\tif (IS_ERR(shash)) {\n\t\tcrypto_mod_put(calg);\n\t\treturn PTR_ERR(shash);\n\t}\n\n\t*ctx = shash;\n\ttfm->exit = crypto_exit_shash_ops_async;\n\n\tcrt->init = shash_async_init;\n\tcrt->update = shash_async_update;\n\tcrt->final = shash_async_final;\n\tcrt->finup = shash_async_finup;\n\tcrt->digest = shash_async_digest;\n\n\tif (alg->setkey)\n\t\tcrt->setkey = shash_async_setkey;\n\tif (alg->export)\n\t\tcrt->export = shash_async_export;\n\tif (alg->import)\n\t\tcrt->import = shash_async_import;\n\n\tcrt->reqsize = sizeof(struct shash_desc) + crypto_shash_descsize(shash);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "vul_func_with_fix": "int crypto_init_shash_ops_async(struct crypto_tfm *tfm)\n{\n\tstruct crypto_alg *calg = tfm->__crt_alg;\n\tstruct shash_alg *alg = __crypto_shash_alg(calg);\n\tstruct crypto_ahash *crt = __crypto_ahash_cast(tfm);\n\tstruct crypto_shash **ctx = crypto_tfm_ctx(tfm);\n\tstruct crypto_shash *shash;\n\n\tif (!crypto_mod_get(calg))\n\t\treturn -EAGAIN;\n\n\tshash = crypto_create_tfm(calg, &crypto_shash_type);\n\tif (IS_ERR(shash)) {\n\t\tcrypto_mod_put(calg);\n\t\treturn PTR_ERR(shash);\n\t}\n\n\t*ctx = shash;\n\ttfm->exit = crypto_exit_shash_ops_async;\n\n\tcrt->init = shash_async_init;\n\tcrt->update = shash_async_update;\n\tcrt->final = shash_async_final;\n\tcrt->finup = shash_async_finup;\n\tcrt->digest = shash_async_digest;\n\n\tif (alg->setkey)\n\t\tcrt->setkey = shash_async_setkey;\n\tif (alg->export)\n\t\tcrt->export = shash_async_export;\n\tif (alg->import)\n\t\tcrt->import = shash_async_import;\n\n\tcrt->reqsize = sizeof(struct shash_desc) + crypto_shash_descsize(shash);\n\n\treturn 0;\n}\n",
        "linevul": 4.9307593144476414e-05,
        "sysevr": 0.2360062152147293,
        "devign": 2.6664429242373444e-06
    },
    {
        "code": "static void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *parent;\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16",
        "vul_func_with_fix": "static void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *parent;\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n",
        "linevul": 5.416882049757987e-05,
        "sysevr": 0.12688301503658295,
        "devign": 0.000341970706358552
    },
    {
        "code": "xfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958",
        "vul_func_with_fix": "xfs_iozero(\n\tstruct xfs_inode\t*ip,\t/* inode\t\t\t*/\n\tloff_t\t\t\tpos,\t/* offset in file\t\t*/\n\tsize_t\t\t\tcount)\t/* size of data to zero\t\t*/\n{\n\tstruct page\t\t*page;\n\tstruct address_space\t*mapping;\n\tint\t\t\tstatus;\n\n\tmapping = VFS_I(ip)->i_mapping;\n\tdo {\n\t\tunsigned offset, bytes;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE -1)); /* Within page */\n\t\tbytes = PAGE_CACHE_SIZE - offset;\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\n\t\tstatus = pagecache_write_begin(NULL, mapping, pos, bytes,\n\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t&page, &fsdata);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tzero_user(page, offset, bytes);\n\n\t\tstatus = pagecache_write_end(NULL, mapping, pos, bytes, bytes,\n\t\t\t\t\tpage, fsdata);\n\t\tWARN_ON(status <= 0); /* can't return less than zero! */\n\t\tpos += bytes;\n\t\tcount -= bytes;\n\t\tstatus = 0;\n\t} while (count);\n\n\treturn (-status);\n}\n",
        "linevul": 0.0002921581035479903,
        "sysevr": 0.24831008911132812,
        "devign": 1.8215910370761938e-19
    },
    {
        "code": "static void set_grace_period(struct net *net)\n{\n\tunsigned long grace_period = get_lockd_grace_period();\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tlocks_start_grace(net, &ln->lockd_manager);\n\tcancel_delayed_work_sync(&ln->grace_period_end);\n\tschedule_delayed_work(&ln->grace_period_end, grace_period);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static void set_grace_period(struct net *net)\n{\n\tunsigned long grace_period = get_lockd_grace_period();\n\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n\n\tlocks_start_grace(net, &ln->lockd_manager);\n\tcancel_delayed_work_sync(&ln->grace_period_end);\n\tschedule_delayed_work(&ln->grace_period_end, grace_period);\n}\n",
        "linevul": 5.950191552983597e-05,
        "sysevr": 0.12583871185779572,
        "devign": 1.6175077632851753e-07
    },
    {
        "code": "static int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51",
        "vul_func_with_fix": "static int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}\n",
        "linevul": 9.741360554471612e-05,
        "sysevr": 0.1274251490831375,
        "devign": 1.2896585709076813e-11
    },
    {
        "code": "test_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "test_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}\n",
        "linevul": 5.521976709133014e-05,
        "sysevr": 0.16261741518974304,
        "devign": 3.759694222615906e-10
    },
    {
        "code": "static inline int may_create(struct inode *dir, struct dentry *child)\n{\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "static inline int may_create(struct inode *dir, struct dentry *child)\n{\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n",
        "linevul": 7.701467984588817e-05,
        "sysevr": 0.11925327032804489,
        "devign": 1.312446158696634e-11
    },
    {
        "code": "static struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,\n\t\t\t\t\t\tstruct usb_host_config *config,\n\t\t\t\t\t\tu8 inum)\n{\n\tstruct usb_interface_assoc_descriptor *retval = NULL;\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\tint first_intf;\n\tint last_intf;\n\tint i;\n\n\tfor (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {\n\t\tintf_assoc = config->intf_assoc[i];\n\t\tif (intf_assoc->bInterfaceCount == 0)\n\t\t\tcontinue;\n\n\t\tfirst_intf = intf_assoc->bFirstInterface;\n\t\tlast_intf = first_intf + (intf_assoc->bInterfaceCount - 1);\n\t\tif (inum >= first_intf && inum <= last_intf) {\n\t\t\tif (!retval)\n\t\t\t\tretval = intf_assoc;\n\t\t\telse\n\t\t\t\tdev_err(&dev->dev, \"Interface #%d referenced\"\n\t\t\t\t\t\" by multiple IADs\\n\", inum);\n\t\t}\n\t}\n\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2e1c42391ff2556387b3cb6308b24f6f65619feb",
        "vul_func_with_fix": "static struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,\n\t\t\t\t\t\tstruct usb_host_config *config,\n\t\t\t\t\t\tu8 inum)\n{\n\tstruct usb_interface_assoc_descriptor *retval = NULL;\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\tint first_intf;\n\tint last_intf;\n\tint i;\n\n\tfor (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {\n\t\tintf_assoc = config->intf_assoc[i];\n\t\tif (intf_assoc->bInterfaceCount == 0)\n\t\t\tcontinue;\n\n\t\tfirst_intf = intf_assoc->bFirstInterface;\n\t\tlast_intf = first_intf + (intf_assoc->bInterfaceCount - 1);\n\t\tif (inum >= first_intf && inum <= last_intf) {\n\t\t\tif (!retval)\n\t\t\t\tretval = intf_assoc;\n\t\t\telse\n\t\t\t\tdev_err(&dev->dev, \"Interface #%d referenced\"\n\t\t\t\t\t\" by multiple IADs\\n\", inum);\n\t\t}\n\t}\n\n\treturn retval;\n}\n",
        "linevul": 0.0003305917780380696,
        "sysevr": 0.13835406303405762,
        "devign": 7.317242620584876e-24
    },
    {
        "code": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\n\t/*\n\t * If a transaction is not active; log and return.\n\t */\n\n\tif (!kvp_transaction.active) {\n\t\t/*\n\t\t * This is a spurious call!\n\t\t */\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\t/*\n\t * Copy the global state for completing the transaction. Note that\n\t * only one transaction can be active at a time.\n\t */\n\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\n\tkvp_transaction.active = false;\n\n\tif (channel->onchannel_callback == NULL)\n\t\t/*\n\t\t * We have raced with util driver being unloaded;\n\t\t * silently return.\n\t\t */\n\t\treturn;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\n\t/*\n\t * If the error parameter is set, terminate the host's enumeration.\n\t */\n\tif (error) {\n\t\t/*\n\t\t * We don't support this index or the we have timedout;\n\t\t * terminate the host-side iteration by returning an error.\n\t\t */\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\n\t/*\n \t * The windows host expects the key/value pair to be encoded\n \t * in utf16.\n \t */\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n \tkvp_data->data.key_size = 2*(keylen + 1); /* utf16 encoding */\n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n \tkvp_data->data.value_size = 2*(valuelen + 1); /* utf16 encoding */\n \n \tkvp_data->data.value_type = REG_SZ; /* all our values are strings */\n\ticmsghdrp->status = HV_S_OK;\n\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd",
        "vul_func_with_fix": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\n\t/*\n\t * If a transaction is not active; log and return.\n\t */\n\n\tif (!kvp_transaction.active) {\n\t\t/*\n\t\t * This is a spurious call!\n\t\t */\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\t/*\n\t * Copy the global state for completing the transaction. Note that\n\t * only one transaction can be active at a time.\n\t */\n\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\n\tkvp_transaction.active = false;\n\n\tif (channel->onchannel_callback == NULL)\n\t\t/*\n\t\t * We have raced with util driver being unloaded;\n\t\t * silently return.\n\t\t */\n\t\treturn;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\n\t/*\n\t * If the error parameter is set, terminate the host's enumeration.\n\t */\n\tif (error) {\n\t\t/*\n\t\t * We don't support this index or the we have timedout;\n\t\t * terminate the host-side iteration by returning an error.\n\t\t */\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\n\t/*\n \t * The windows host expects the key/value pair to be encoded\n \t * in utf16.\n \t */\n//flaw_line_below:\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n//flaw_line_below:\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n//fix_flaw_line_below:\n//\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,\n//fix_flaw_line_below:\n//\t\t\t\t(wchar_t *) kvp_data->data.key,\n//fix_flaw_line_below:\n//\t\t\t\tHV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);\n \tkvp_data->data.key_size = 2*(keylen + 1); /* utf16 encoding */\n//flaw_line_below:\n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n//flaw_line_below:\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n//fix_flaw_line_below:\n//\tvaluelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,\n//fix_flaw_line_below:\n//\t\t\t\t(wchar_t *) kvp_data->data.value,\n//fix_flaw_line_below:\n//\t\t\t\tHV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);\n \tkvp_data->data.value_size = 2*(valuelen + 1); /* utf16 encoding */\n \n \tkvp_data->data.value_type = REG_SZ; /* all our values are strings */\n\ticmsghdrp->status = HV_S_OK;\n\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n\n}\n",
        "linevul": 0.0001628520549274981,
        "sysevr": 0.2124336212873459,
        "devign": 0.9931489825248718
    },
    {
        "code": "int ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(net, sk, skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(net, sk, skb);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1",
        "vul_func_with_fix": "int ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(net, sk, skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(net, sk, skb);\n\n\treturn err;\n}\n",
        "linevul": 5.113954466651194e-05,
        "sysevr": 0.15668080747127533,
        "devign": 1.1044609608893251e-23
    },
    {
        "code": "static void mpi_receive_802_11(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tstruct sk_buff *skb = NULL;\n\tu16 len, hdrlen = 0;\n\t__le16 fc;\n\tstruct rx_hdr hdr;\n\tu16 gap;\n\tu16 *buffer;\n\tchar *ptr = ai->rxfids[0].virtual_host_addr + 4;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\tmemcpy ((char *)&hdr, ptr, sizeof(hdr));\n\tptr += sizeof(hdr);\n\t/* Bad CRC. Ignore packet */\n\tif (le16_to_cpu(hdr.status) & 2)\n\t\thdr.len = 0;\n\tif (ai->wifidev == NULL)\n\t\thdr.len = 0;\n\tlen = le16_to_cpu(hdr.len);\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto badrx;\n\t}\n\tif (len == 0)\n\t\tgoto badrx;\n\n\tfc = get_unaligned((__le16 *)ptr);\n\thdrlen = header_len(fc);\n\n\tskb = dev_alloc_skb( len + hdrlen + 2 );\n\tif ( !skb ) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto badrx;\n\t}\n\tbuffer = (u16*)skb_put (skb, len + hdrlen);\n\tmemcpy ((char *)buffer, ptr, hdrlen);\n\tptr += hdrlen;\n\tif (hdrlen == 24)\n\t\tptr += 6;\n\tgap = get_unaligned_le16(ptr);\n\tptr += sizeof(__le16);\n\tif (gap) {\n\t\tif (gap <= 8)\n\t\t\tptr += gap;\n\t\telse\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t    \"gaplen too big. Problems will follow...\");\n\t}\n\tmemcpy ((char *)buffer + hdrlen, ptr, len);\n\tptr += len;\n#ifdef IW_WIRELESS_SPY\t  /* defined in iw_handler.h */\n\tif (ai->spy_data.spy_number > 0) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\t\t/* Prepare spy data : addr + qual */\n\t\tsa = (char*)buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t| IW_QUAL_DBM;\n\t\t/* Update spy records */\n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif /* IW_WIRELESS_SPY */\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->dev = ai->wifidev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tnetif_rx( skb );\n\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static void mpi_receive_802_11(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tstruct sk_buff *skb = NULL;\n\tu16 len, hdrlen = 0;\n\t__le16 fc;\n\tstruct rx_hdr hdr;\n\tu16 gap;\n\tu16 *buffer;\n\tchar *ptr = ai->rxfids[0].virtual_host_addr + 4;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\tmemcpy ((char *)&hdr, ptr, sizeof(hdr));\n\tptr += sizeof(hdr);\n\t/* Bad CRC. Ignore packet */\n\tif (le16_to_cpu(hdr.status) & 2)\n\t\thdr.len = 0;\n\tif (ai->wifidev == NULL)\n\t\thdr.len = 0;\n\tlen = le16_to_cpu(hdr.len);\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto badrx;\n\t}\n\tif (len == 0)\n\t\tgoto badrx;\n\n\tfc = get_unaligned((__le16 *)ptr);\n\thdrlen = header_len(fc);\n\n\tskb = dev_alloc_skb( len + hdrlen + 2 );\n\tif ( !skb ) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto badrx;\n\t}\n\tbuffer = (u16*)skb_put (skb, len + hdrlen);\n\tmemcpy ((char *)buffer, ptr, hdrlen);\n\tptr += hdrlen;\n\tif (hdrlen == 24)\n\t\tptr += 6;\n\tgap = get_unaligned_le16(ptr);\n\tptr += sizeof(__le16);\n\tif (gap) {\n\t\tif (gap <= 8)\n\t\t\tptr += gap;\n\t\telse\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t    \"gaplen too big. Problems will follow...\");\n\t}\n\tmemcpy ((char *)buffer + hdrlen, ptr, len);\n\tptr += len;\n#ifdef IW_WIRELESS_SPY\t  /* defined in iw_handler.h */\n\tif (ai->spy_data.spy_number > 0) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\t\t/* Prepare spy data : addr + qual */\n\t\tsa = (char*)buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t| IW_QUAL_DBM;\n\t\t/* Update spy records */\n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif /* IW_WIRELESS_SPY */\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->dev = ai->wifidev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tnetif_rx( skb );\n\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n",
        "linevul": 7.296919648069888e-05,
        "sysevr": 0.23092466592788696,
        "devign": 0.04979056864976883
    },
    {
        "code": "static void netlink_compare_arg_init(struct netlink_compare_arg *arg,\n\t\t\t\t     struct net *net, u32 portid)\n{\n\tmemset(arg, 0, sizeof(*arg));\n\twrite_pnet(&arg->pnet, net);\n\targ->portid = portid;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92964c79b357efd980812c4de5c1fd2ec8bb5520",
        "vul_func_with_fix": "static void netlink_compare_arg_init(struct netlink_compare_arg *arg,\n\t\t\t\t     struct net *net, u32 portid)\n{\n\tmemset(arg, 0, sizeof(*arg));\n\twrite_pnet(&arg->pnet, net);\n\targ->portid = portid;\n}\n",
        "linevul": 5.876321665709838e-05,
        "sysevr": 0.12488654255867004,
        "devign": 0.0009701118688099086
    },
    {
        "code": "static int edge_port_probe(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\tint ret;\n\n\tedge_port = kzalloc(sizeof(*edge_port), GFP_KERNEL);\n\tif (!edge_port)\n\t\treturn -ENOMEM;\n\n\tret = kfifo_alloc(&edge_port->write_fifo, EDGE_OUT_BUF_SIZE,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (ret) {\n\t\tkfree(edge_port);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&edge_port->ep_lock);\n\tedge_port->port = port;\n\tedge_port->edge_serial = usb_get_serial_data(port->serial);\n\tedge_port->bUartMode = default_uart_mode;\n\n\tusb_set_serial_port_data(port, edge_port);\n\n\tret = edge_create_sysfs_attrs(port);\n\tif (ret) {\n\t\tkfifo_free(&edge_port->write_fifo);\n\t\tkfree(edge_port);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811",
        "vul_func_with_fix": "static int edge_port_probe(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\tint ret;\n\n\tedge_port = kzalloc(sizeof(*edge_port), GFP_KERNEL);\n\tif (!edge_port)\n\t\treturn -ENOMEM;\n\n\tret = kfifo_alloc(&edge_port->write_fifo, EDGE_OUT_BUF_SIZE,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (ret) {\n\t\tkfree(edge_port);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&edge_port->ep_lock);\n\tedge_port->port = port;\n\tedge_port->edge_serial = usb_get_serial_data(port->serial);\n\tedge_port->bUartMode = default_uart_mode;\n\n\tusb_set_serial_port_data(port, edge_port);\n\n\tret = edge_create_sysfs_attrs(port);\n\tif (ret) {\n\t\tkfifo_free(&edge_port->write_fifo);\n\t\tkfree(edge_port);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 7.18737646820955e-05,
        "sysevr": 0.15171627700328827,
        "devign": 1.5009991027881142e-09
    },
    {
        "code": "void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c",
        "vul_func_with_fix": "void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}\n",
        "linevul": 4.8822294047567993e-05,
        "sysevr": 0.17360882461071014,
        "devign": 9.726590199932161e-09
    },
    {
        "code": "static inline void fib6_walker_link(struct fib6_walker_t *w)\n{\n\twrite_lock_bh(&fib6_walker_lock);\n\tlist_add(&w->lh, &fib6_walkers);\n\twrite_unlock_bh(&fib6_walker_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2",
        "vul_func_with_fix": "static inline void fib6_walker_link(struct fib6_walker_t *w)\n{\n\twrite_lock_bh(&fib6_walker_lock);\n\tlist_add(&w->lh, &fib6_walkers);\n\twrite_unlock_bh(&fib6_walker_lock);\n}\n",
        "linevul": 0.00016066894750110805,
        "sysevr": 0.1256326287984848,
        "devign": 0.00735838245600462
    },
    {
        "code": "static inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\n\t      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\n\t      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\n\t      + userpolicy_type_attrsize();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\n\t      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\n\t      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\n\t      + userpolicy_type_attrsize();\n}\n",
        "linevul": 5.218573642196134e-05,
        "sysevr": 0.1357363611459732,
        "devign": 0.1524379998445511
    },
    {
        "code": "static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = restore_node_summary(sbi, segno, sum);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(new, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* update journal info */\n\tdown_write(&curseg->journal_rwsem);\n\tmemcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);\n\tup_write(&curseg->journal_rwsem);\n\n\tmemcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);\n\tmemcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d4fdf8ba0e5808ba9ad6b44337783bd9935e0982",
        "vul_func_with_fix": "static int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tint err;\n\n\t\t\terr = restore_node_summary(sbi, segno, sum);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(new, 1);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* update journal info */\n\tdown_write(&curseg->journal_rwsem);\n\tmemcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);\n\tup_write(&curseg->journal_rwsem);\n\n\tmemcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);\n\tmemcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}\n",
        "linevul": 0.0014410456642508507,
        "sysevr": 0.1598997265100479,
        "devign": 0.0
    },
    {
        "code": "static u32 __init armv8pmu_read_num_pmnc_events(void)\n{\n\tu32 nb_cnt;\n\n\t/* Read the nb of CNTx counters supported from PMNC */\n\tnb_cnt = (armv8pmu_pmcr_read() >> ARMV8_PMCR_N_SHIFT) & ARMV8_PMCR_N_MASK;\n\n\t/* Add the CPU cycles counter and return */\n\treturn nb_cnt + 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071",
        "vul_func_with_fix": "static u32 __init armv8pmu_read_num_pmnc_events(void)\n{\n\tu32 nb_cnt;\n\n\t/* Read the nb of CNTx counters supported from PMNC */\n\tnb_cnt = (armv8pmu_pmcr_read() >> ARMV8_PMCR_N_SHIFT) & ARMV8_PMCR_N_MASK;\n\n\t/* Add the CPU cycles counter and return */\n\treturn nb_cnt + 1;\n}\n",
        "linevul": 4.600131796905771e-05,
        "sysevr": 0.13293878734111786,
        "devign": 0.668436586856842
    },
    {
        "code": "static int wake_wide(struct task_struct *p)\n{\n\tunsigned int master = current->wakee_flips;\n\tunsigned int slave = p->wakee_flips;\n\tint factor = this_cpu_read(sd_llc_size);\n\n\tif (master < slave)\n\t\tswap(master, slave);\n\tif (slave < factor || master < slave * factor)\n\t\treturn 0;\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "static int wake_wide(struct task_struct *p)\n{\n\tunsigned int master = current->wakee_flips;\n\tunsigned int slave = p->wakee_flips;\n\tint factor = this_cpu_read(sd_llc_size);\n\n\tif (master < slave)\n\t\tswap(master, slave);\n\tif (slave < factor || master < slave * factor)\n\t\treturn 0;\n\treturn 1;\n}\n",
        "linevul": 5.28153614141047e-05,
        "sysevr": 0.12721113860607147,
        "devign": 0.001108663622289896
    },
    {
        "code": "static pfn_t hva_to_pfn(struct kvm *kvm, unsigned long addr, bool atomic,\n\t\t\tbool *async, bool write_fault, bool *writable)\n{\n\tstruct page *page[1];\n\tint npages = 0;\n\tpfn_t pfn;\n\n\t/* we can do it either atomically or asynchronously, not both */\n\tBUG_ON(atomic && async);\n\n\tBUG_ON(!write_fault && !writable);\n\n\tif (writable)\n\t\t*writable = true;\n\n\tif (atomic || async)\n\t\tnpages = __get_user_pages_fast(addr, 1, 1, page);\n\n\tif (unlikely(npages != 1) && !atomic) {\n\t\tmight_sleep();\n\n\t\tif (writable)\n\t\t\t*writable = write_fault;\n\n\t\tif (async) {\n\t\t\tdown_read(&current->mm->mmap_sem);\n\t\t\tnpages = get_user_page_nowait(current, current->mm,\n\t\t\t\t\t\t     addr, write_fault, page);\n\t\t\tup_read(&current->mm->mmap_sem);\n\t\t} else\n\t\t\tnpages = get_user_pages_fast(addr, 1, write_fault,\n\t\t\t\t\t\t     page);\n\n\t\t/* map read fault as writable if possible */\n\t\tif (unlikely(!write_fault) && npages == 1) {\n\t\t\tstruct page *wpage[1];\n\n\t\t\tnpages = __get_user_pages_fast(addr, 1, 1, wpage);\n\t\t\tif (npages == 1) {\n\t\t\t\t*writable = true;\n\t\t\t\tput_page(page[0]);\n\t\t\t\tpage[0] = wpage[0];\n\t\t\t}\n\t\t\tnpages = 1;\n\t\t}\n\t}\n\n\tif (unlikely(npages != 1)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (atomic)\n\t\t\treturn get_fault_pfn();\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tif (npages == -EHWPOISON ||\n\t\t\t(!async && check_user_page_hwpoison(addr))) {\n\t\t\tup_read(&current->mm->mmap_sem);\n\t\t\tget_page(hwpoison_page);\n\t\t\treturn page_to_pfn(hwpoison_page);\n\t\t}\n\n\t\tvma = find_vma_intersection(current->mm, addr, addr+1);\n\n\t\tif (vma == NULL)\n\t\t\tpfn = get_fault_pfn();\n\t\telse if ((vma->vm_flags & VM_PFNMAP)) {\n\t\t\tpfn = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\t\tvma->vm_pgoff;\n\t\t\tBUG_ON(!kvm_is_mmio_pfn(pfn));\n\t\t} else {\n\t\t\tif (async && (vma->vm_flags & VM_WRITE))\n\t\t\t\t*async = true;\n\t\t\tpfn = get_fault_pfn();\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t} else\n\t\tpfn = page_to_pfn(page[0]);\n\n\treturn pfn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/09ca8e1173bcb12e2a449698c9ae3b86a8a10195",
        "vul_func_with_fix": "static pfn_t hva_to_pfn(struct kvm *kvm, unsigned long addr, bool atomic,\n\t\t\tbool *async, bool write_fault, bool *writable)\n{\n\tstruct page *page[1];\n\tint npages = 0;\n\tpfn_t pfn;\n\n\t/* we can do it either atomically or asynchronously, not both */\n\tBUG_ON(atomic && async);\n\n\tBUG_ON(!write_fault && !writable);\n\n\tif (writable)\n\t\t*writable = true;\n\n\tif (atomic || async)\n\t\tnpages = __get_user_pages_fast(addr, 1, 1, page);\n\n\tif (unlikely(npages != 1) && !atomic) {\n\t\tmight_sleep();\n\n\t\tif (writable)\n\t\t\t*writable = write_fault;\n\n\t\tif (async) {\n\t\t\tdown_read(&current->mm->mmap_sem);\n\t\t\tnpages = get_user_page_nowait(current, current->mm,\n\t\t\t\t\t\t     addr, write_fault, page);\n\t\t\tup_read(&current->mm->mmap_sem);\n\t\t} else\n\t\t\tnpages = get_user_pages_fast(addr, 1, write_fault,\n\t\t\t\t\t\t     page);\n\n\t\t/* map read fault as writable if possible */\n\t\tif (unlikely(!write_fault) && npages == 1) {\n\t\t\tstruct page *wpage[1];\n\n\t\t\tnpages = __get_user_pages_fast(addr, 1, 1, wpage);\n\t\t\tif (npages == 1) {\n\t\t\t\t*writable = true;\n\t\t\t\tput_page(page[0]);\n\t\t\t\tpage[0] = wpage[0];\n\t\t\t}\n\t\t\tnpages = 1;\n\t\t}\n\t}\n\n\tif (unlikely(npages != 1)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (atomic)\n\t\t\treturn get_fault_pfn();\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tif (npages == -EHWPOISON ||\n\t\t\t(!async && check_user_page_hwpoison(addr))) {\n\t\t\tup_read(&current->mm->mmap_sem);\n\t\t\tget_page(hwpoison_page);\n\t\t\treturn page_to_pfn(hwpoison_page);\n\t\t}\n\n\t\tvma = find_vma_intersection(current->mm, addr, addr+1);\n\n\t\tif (vma == NULL)\n\t\t\tpfn = get_fault_pfn();\n\t\telse if ((vma->vm_flags & VM_PFNMAP)) {\n\t\t\tpfn = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\t\tvma->vm_pgoff;\n\t\t\tBUG_ON(!kvm_is_mmio_pfn(pfn));\n\t\t} else {\n\t\t\tif (async && (vma->vm_flags & VM_WRITE))\n\t\t\t\t*async = true;\n\t\t\tpfn = get_fault_pfn();\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t} else\n\t\tpfn = page_to_pfn(page[0]);\n\n\treturn pfn;\n}\n",
        "linevul": 6.299658707575873e-05,
        "sysevr": 0.12889373302459717,
        "devign": 4.656994131653578e-26
    },
    {
        "code": "static inline int lookup_last(struct nameidata *nd, struct path *path)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\treturn walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "static inline int lookup_last(struct nameidata *nd, struct path *path)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\treturn walk_component(nd, path, nd->flags & LOOKUP_FOLLOW);\n}\n",
        "linevul": 7.197912054834887e-05,
        "sysevr": 0.11960068345069885,
        "devign": 4.48539738684417e-09
    },
    {
        "code": "static int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, reg;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr = vmcs_readl(GUEST_DR7);\n\tif (dr & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr;\n\t\t\tvcpu->run->debug.arch.pc =\n\t\t\t\tvmcs_readl(GUEST_CS_BASE) +\n\t\t\t\tvmcs_readl(GUEST_RIP);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tvcpu->arch.dr6 |= DR6_BD;\n\t\t\tvmcs_writel(GUEST_DR7, vcpu->arch.dr7);\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\t\tif (!kvm_get_dr(vcpu, dr, &val))\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tkvm_set_dr(vcpu, dr, vcpu->arch.regs[reg]);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, reg;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr = vmcs_readl(GUEST_DR7);\n\tif (dr & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr;\n\t\t\tvcpu->run->debug.arch.pc =\n\t\t\t\tvmcs_readl(GUEST_CS_BASE) +\n\t\t\t\tvmcs_readl(GUEST_RIP);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\tvcpu->arch.dr6 |= DR6_BD;\n\t\t\tvmcs_writel(GUEST_DR7, vcpu->arch.dr7);\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\t\tif (!kvm_get_dr(vcpu, dr, &val))\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tkvm_set_dr(vcpu, dr, vcpu->arch.regs[reg]);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n",
        "linevul": 5.2546387451002374e-05,
        "sysevr": 0.15797017514705658,
        "devign": 6.998321350278607e-39
    },
    {
        "code": "static struct rfcomm_dev *rfcomm_dev_get(int id)\n{\n\tstruct rfcomm_dev *dev;\n\n\tspin_lock(&rfcomm_dev_lock);\n\n\tdev = __rfcomm_dev_get(id);\n\n\tif (dev) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tdev = NULL;\n\t\telse\n\t\t\ttty_port_get(&dev->port);\n\t}\n\n\tspin_unlock(&rfcomm_dev_lock);\n\n\treturn dev;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a",
        "vul_func_with_fix": "static struct rfcomm_dev *rfcomm_dev_get(int id)\n{\n\tstruct rfcomm_dev *dev;\n\n\tspin_lock(&rfcomm_dev_lock);\n\n\tdev = __rfcomm_dev_get(id);\n\n\tif (dev) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tdev = NULL;\n\t\telse\n\t\t\ttty_port_get(&dev->port);\n\t}\n\n\tspin_unlock(&rfcomm_dev_lock);\n\n\treturn dev;\n}\n",
        "linevul": 4.576696301228367e-05,
        "sysevr": 0.12790684401988983,
        "devign": 3.403339339142866e-17
    },
    {
        "code": "compat_find_calc_match(struct xt_entry_match *m,\n\t\t       const struct ipt_ip *ip,\n\t\t       int *size)\n{\n\tstruct xt_match *match;\n\n\tmatch = xt_request_find_match(NFPROTO_IPV4, m->u.user.name,\n\t\t\t\t      m->u.user.revision);\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\n\tm->u.kernel.match = match;\n\t*size += xt_compat_match_offset(match);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/57ebd808a97d7c5b1e1afb937c2db22beba3c1f8",
        "vul_func_with_fix": "compat_find_calc_match(struct xt_entry_match *m,\n\t\t       const struct ipt_ip *ip,\n\t\t       int *size)\n{\n\tstruct xt_match *match;\n\n\tmatch = xt_request_find_match(NFPROTO_IPV4, m->u.user.name,\n\t\t\t\t      m->u.user.revision);\n\tif (IS_ERR(match))\n\t\treturn PTR_ERR(match);\n\n\tm->u.kernel.match = match;\n\t*size += xt_compat_match_offset(match);\n\treturn 0;\n}\n",
        "linevul": 4.6942088374635205e-05,
        "sysevr": 0.1643608659505844,
        "devign": 6.300392933061838e-12
    },
    {
        "code": "static inline int dname_external(const struct dentry *dentry)\n{\n \treturn dentry->d_name.name != dentry->d_iname;\n }\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
        "vul_func_with_fix": "static inline int dname_external(const struct dentry *dentry)\n{\n \treturn dentry->d_name.name != dentry->d_iname;\n }\n",
        "linevul": 6.211988511495292e-05,
        "sysevr": 0.12093986570835114,
        "devign": 0.008454040624201298
    },
    {
        "code": "static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\n\t/*\n\t * Events on POWER7 can roll back if a speculative event doesn't\n\t * eventually complete. Unfortunately in some rare cases they will\n\t * raise a performance monitor exception. We need to catch this to\n\t * ensure we reset the PMC. In all cases the PMC will be 256 or less\n\t * cycles from overflow.\n\t *\n\t * We only do this if the first pass fails to find any overflowing\n\t * PMCs because a user might set a period of less than 256 and we\n\t * don't want to mistakenly reset them.\n\t */\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\n\t/*\n\t * Events on POWER7 can roll back if a speculative event doesn't\n\t * eventually complete. Unfortunately in some rare cases they will\n\t * raise a performance monitor exception. We need to catch this to\n\t * ensure we reset the PMC. In all cases the PMC will be 256 or less\n\t * cycles from overflow.\n\t *\n\t * We only do this if the first pass fails to find any overflowing\n\t * PMCs because a user might set a period of less than 256 and we\n\t * don't want to mistakenly reset them.\n\t */\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "linevul": 4.955091208103113e-05,
        "sysevr": 0.15225984156131744,
        "devign": 2.1259811402649098e-13
    },
    {
        "code": "CIFSSMBSetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tNTRANSACT_RSP *pSMBr = NULL;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\t\treturn (rc);\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_DACL);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *) &pSMBr->hdr.Protocol + data_offset,\n\t\t\t(char *) pntsd,\n\t\t\tacllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcFYI(1, \"SetCIFSACL bytes_returned: %d, rc: %d\", bytes_returned, rc);\n\tif (rc)\n\t\tcFYI(1, \"Set CIFS ACL returned %d\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd",
        "vul_func_with_fix": "CIFSSMBSetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,\n\t\t\tstruct cifs_ntsd *pntsd, __u32 acllen)\n{\n\t__u16 byte_count, param_count, data_count, param_offset, data_offset;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tSET_SEC_DESC_REQ *pSMB = NULL;\n\tNTRANSACT_RSP *pSMBr = NULL;\n\nsetCifsAclRetry:\n\trc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &pSMB,\n\t\t\t(void **) &pSMBr);\n\tif (rc)\n\t\t\treturn (rc);\n\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\n\tparam_count = 8;\n\tparam_offset = offsetof(struct smb_com_transaction_ssec_req, Fid) - 4;\n\tdata_count = acllen;\n\tdata_offset = param_offset + param_count;\n\tbyte_count = 3 /* pad */  + param_count;\n\n\tpSMB->DataCount = cpu_to_le32(data_count);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->MaxParameterCount = cpu_to_le32(4);\n\tpSMB->MaxDataCount = cpu_to_le32(16384);\n\tpSMB->ParameterCount = cpu_to_le32(param_count);\n\tpSMB->ParameterOffset = cpu_to_le32(param_offset);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->DataOffset = cpu_to_le32(data_offset);\n\tpSMB->SetupCount = 0;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_SET_SECURITY_DESC);\n\tpSMB->ByteCount = cpu_to_le16(byte_count+data_count);\n\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->Reserved2 = 0;\n\tpSMB->AclFlags = cpu_to_le32(CIFS_ACL_DACL);\n\n\tif (pntsd && acllen) {\n\t\tmemcpy((char *) &pSMBr->hdr.Protocol + data_offset,\n\t\t\t(char *) pntsd,\n\t\t\tacllen);\n\t\tinc_rfc1001_len(pSMB, byte_count + data_count);\n\t} else\n\t\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\n\tcFYI(1, \"SetCIFSACL bytes_returned: %d, rc: %d\", bytes_returned, rc);\n\tif (rc)\n\t\tcFYI(1, \"Set CIFS ACL returned %d\", rc);\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto setCifsAclRetry;\n\n\treturn (rc);\n}\n",
        "linevul": 4.887306931777857e-05,
        "sysevr": 0.2698308825492859,
        "devign": 7.4181930520183955e-25
    },
    {
        "code": "static void udp4_format_sock(struct sock *sp, struct seq_file *f,\n\t\tint bucket, int *len)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src  = inet->inet_rcv_saddr;\n\t__u16 destp\t  = ntohs(inet->inet_dport);\n\t__u16 srcp\t  = ntohs(inet->inet_sport);\n\n\tseq_printf(f, \"%5d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %pK %d%n\",\n\t\tbucket, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\tatomic_read(&sp->sk_refcnt), sp,\n\t\tatomic_read(&sp->sk_drops), len);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1",
        "vul_func_with_fix": "static void udp4_format_sock(struct sock *sp, struct seq_file *f,\n\t\tint bucket, int *len)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src  = inet->inet_rcv_saddr;\n\t__u16 destp\t  = ntohs(inet->inet_dport);\n\t__u16 srcp\t  = ntohs(inet->inet_sport);\n\n\tseq_printf(f, \"%5d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %pK %d%n\",\n\t\tbucket, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\tatomic_read(&sp->sk_refcnt), sp,\n\t\tatomic_read(&sp->sk_drops), len);\n}\n",
        "linevul": 9.90140251815319e-05,
        "sysevr": 0.1492922455072403,
        "devign": 3.638917238282108e-13
    },
    {
        "code": "static void release_pmc_hardware(void)\n{\n\tint i;\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\trelease_perfctr_nmi(x86_pmu_event_addr(i));\n\t\trelease_evntsel_nmi(x86_pmu_config_addr(i));\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void release_pmc_hardware(void)\n{\n\tint i;\n\n\tfor (i = 0; i < x86_pmu.num_counters; i++) {\n\t\trelease_perfctr_nmi(x86_pmu_event_addr(i));\n\t\trelease_evntsel_nmi(x86_pmu_config_addr(i));\n\t}\n}\n",
        "linevul": 4.766096026287414e-05,
        "sysevr": 0.12447935342788696,
        "devign": 5.656006774046318e-10
    },
    {
        "code": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "vul_func_with_fix": "static __always_inline long __get_user_pages_locked(struct task_struct *tsk,\n\t\t\t\t\t\tstruct mm_struct *mm,\n\t\t\t\t\t\tunsigned long start,\n\t\t\t\t\t\tunsigned long nr_pages,\n\t\t\t\t\t\tstruct page **pages,\n\t\t\t\t\t\tstruct vm_area_struct **vmas,\n\t\t\t\t\t\tint *locked,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tlong ret, pages_done;\n\tbool lock_dropped;\n\n\tif (locked) {\n\t\t/* if VM_FAULT_RETRY can be returned, vmas become invalid */\n\t\tBUG_ON(vmas);\n\t\t/* check caller initialized locked */\n\t\tBUG_ON(*locked != 1);\n\t}\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\n\tpages_done = 0;\n\tlock_dropped = false;\n\tfor (;;) {\n\t\tret = __get_user_pages(tsk, mm, start, nr_pages, flags, pages,\n\t\t\t\t       vmas, locked);\n\t\tif (!locked)\n\t\t\t/* VM_FAULT_RETRY couldn't trigger, bypass */\n\t\t\treturn ret;\n\n\t\t/* VM_FAULT_RETRY cannot return errors */\n\t\tif (!*locked) {\n\t\t\tBUG_ON(ret < 0);\n\t\t\tBUG_ON(ret >= nr_pages);\n\t\t}\n\n\t\tif (!pages)\n\t\t\t/* If it's a prefault don't insist harder */\n\t\t\treturn ret;\n\n\t\tif (ret > 0) {\n\t\t\tnr_pages -= ret;\n\t\t\tpages_done += ret;\n\t\t\tif (!nr_pages)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (*locked) {\n\t\t\t/*\n\t\t\t * VM_FAULT_RETRY didn't trigger or it was a\n\t\t\t * FOLL_NOWAIT.\n\t\t\t */\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\t/* VM_FAULT_RETRY triggered, so seek to the faulting offset */\n\t\tpages += ret;\n\t\tstart += ret << PAGE_SHIFT;\n\n\t\t/*\n\t\t * Repeat on the address that fired VM_FAULT_RETRY\n\t\t * without FAULT_FLAG_ALLOW_RETRY but with\n\t\t * FAULT_FLAG_TRIED.\n\t\t */\n\t\t*locked = 1;\n\t\tlock_dropped = true;\n\t\tdown_read(&mm->mmap_sem);\n\t\tret = __get_user_pages(tsk, mm, start, 1, flags | FOLL_TRIED,\n\t\t\t\t       pages, NULL, NULL);\n\t\tif (ret != 1) {\n\t\t\tBUG_ON(ret > 1);\n\t\t\tif (!pages_done)\n\t\t\t\tpages_done = ret;\n\t\t\tbreak;\n\t\t}\n\t\tnr_pages--;\n\t\tpages_done++;\n\t\tif (!nr_pages)\n\t\t\tbreak;\n\t\tpages++;\n\t\tstart += PAGE_SIZE;\n\t}\n\tif (lock_dropped && *locked) {\n\t\t/*\n\t\t * We must let the caller know we temporarily dropped the lock\n\t\t * and so the critical section protected by it was lost.\n\t\t */\n\t\tup_read(&mm->mmap_sem);\n\t\t*locked = 0;\n\t}\n\treturn pages_done;\n}\n",
        "linevul": 5.906175647396594e-05,
        "sysevr": 0.18045128881931305,
        "devign": 0.642385721206665
    },
    {
        "code": "void au1100fb_fb_rotate(struct fb_info *fbi, int angle)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_rotate %p %d\", fbi, angle);\n\n\tif (fbdev && (angle > 0) && !(angle % 90)) {\n\n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t\tfbdev->regs->lcd_control &= ~(LCD_CONTROL_SM_MASK);\n\t\tfbdev->regs->lcd_control |= ((angle/90) << LCD_CONTROL_SM_BIT);\n\n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
        "vul_func_with_fix": "void au1100fb_fb_rotate(struct fb_info *fbi, int angle)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_rotate %p %d\", fbi, angle);\n\n\tif (fbdev && (angle > 0) && !(angle % 90)) {\n\n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t\tfbdev->regs->lcd_control &= ~(LCD_CONTROL_SM_MASK);\n\t\tfbdev->regs->lcd_control |= ((angle/90) << LCD_CONTROL_SM_BIT);\n\n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t}\n}\n",
        "linevul": 4.764228651765734e-05,
        "sysevr": 0.16648881137371063,
        "devign": 1.3995362451169058e-06
    },
    {
        "code": "static struct tcp_md5sig_key *tcp_v6_reqsk_md5_lookup(struct sock *sk,\n\t\t\t\t\t\t      struct request_sock *req)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &inet6_rsk(req)->rmt_addr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static struct tcp_md5sig_key *tcp_v6_reqsk_md5_lookup(struct sock *sk,\n\t\t\t\t\t\t      struct request_sock *req)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &inet6_rsk(req)->rmt_addr);\n}\n",
        "linevul": 6.194873276399449e-05,
        "sysevr": 0.12523634731769562,
        "devign": 1.0044210472029413e-12
    },
    {
        "code": "static void cma_iboe_set_mgid(struct sockaddr *addr, union ib_gid *mgid)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;\n\n\tif (cma_any_addr(addr)) {\n\t\tmemset(mgid, 0, sizeof *mgid);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tmemcpy(mgid, &sin6->sin6_addr, sizeof *mgid);\n\t} else {\n\t\tmgid->raw[0] = 0xff;\n\t\tmgid->raw[1] = 0x0e;\n\t\tmgid->raw[2] = 0;\n\t\tmgid->raw[3] = 0;\n\t\tmgid->raw[4] = 0;\n\t\tmgid->raw[5] = 0;\n\t\tmgid->raw[6] = 0;\n\t\tmgid->raw[7] = 0;\n\t\tmgid->raw[8] = 0;\n\t\tmgid->raw[9] = 0;\n\t\tmgid->raw[10] = 0xff;\n\t\tmgid->raw[11] = 0xff;\n\t\t*(__be32 *)(&mgid->raw[12]) = sin->sin_addr.s_addr;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867",
        "vul_func_with_fix": "static void cma_iboe_set_mgid(struct sockaddr *addr, union ib_gid *mgid)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;\n\n\tif (cma_any_addr(addr)) {\n\t\tmemset(mgid, 0, sizeof *mgid);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tmemcpy(mgid, &sin6->sin6_addr, sizeof *mgid);\n\t} else {\n\t\tmgid->raw[0] = 0xff;\n\t\tmgid->raw[1] = 0x0e;\n\t\tmgid->raw[2] = 0;\n\t\tmgid->raw[3] = 0;\n\t\tmgid->raw[4] = 0;\n\t\tmgid->raw[5] = 0;\n\t\tmgid->raw[6] = 0;\n\t\tmgid->raw[7] = 0;\n\t\tmgid->raw[8] = 0;\n\t\tmgid->raw[9] = 0;\n\t\tmgid->raw[10] = 0xff;\n\t\tmgid->raw[11] = 0xff;\n\t\t*(__be32 *)(&mgid->raw[12]) = sin->sin_addr.s_addr;\n\t}\n}\n",
        "linevul": 5.5916374549269676e-05,
        "sysevr": 0.21758602559566498,
        "devign": 2.3397830895000027e-10
    },
    {
        "code": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int nr_pages, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint flags = FOLL_TOUCH;\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\tif (write)\n\t\tflags |= FOLL_WRITE;\n\tif (force)\n\t\tflags |= FOLL_FORCE;\n\n\treturn __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas,\n\t\t\t\tNULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, int nr_pages, int write, int force,\n\t\tstruct page **pages, struct vm_area_struct **vmas)\n{\n\tint flags = FOLL_TOUCH;\n\n\tif (pages)\n\t\tflags |= FOLL_GET;\n\tif (write)\n\t\tflags |= FOLL_WRITE;\n\tif (force)\n\t\tflags |= FOLL_FORCE;\n\n\treturn __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas,\n\t\t\t\tNULL);\n}\n",
        "linevul": 6.306209252215922e-05,
        "sysevr": 0.15137098729610443,
        "devign": 2.676553470775788e-14
    },
    {
        "code": "int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)\n{\n\tif (phy->attached_tproto & SAS_PROTOCOL_STP)\n\t\tdev->tproto = phy->attached_tproto;\n\tif (phy->attached_sata_dev)\n\t\tdev->tproto |= SAS_SATA_DEV;\n\n\tif (phy->attached_dev_type == SAS_SATA_PENDING)\n\t\tdev->dev_type = SAS_SATA_PENDING;\n\telse {\n\t\tint res;\n\n\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tres = sas_get_report_phy_sata(dev->parent, phy->phy_id,\n\t\t\t\t\t      &dev->sata_dev.rps_resp);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"report phy sata to %016llx:0x%x returned \"\n\t\t\t\t    \"0x%x\\n\", SAS_ADDR(dev->parent->sas_addr),\n\t\t\t\t    phy->phy_id, res);\n\t\t\treturn res;\n\t\t}\n\t\tmemcpy(dev->frame_rcvd, &dev->sata_dev.rps_resp.rps.fis,\n\t\t       sizeof(struct dev_to_host_fis));\n\t\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d",
        "vul_func_with_fix": "int sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)\n{\n\tif (phy->attached_tproto & SAS_PROTOCOL_STP)\n\t\tdev->tproto = phy->attached_tproto;\n\tif (phy->attached_sata_dev)\n\t\tdev->tproto |= SAS_SATA_DEV;\n\n\tif (phy->attached_dev_type == SAS_SATA_PENDING)\n\t\tdev->dev_type = SAS_SATA_PENDING;\n\telse {\n\t\tint res;\n\n\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tres = sas_get_report_phy_sata(dev->parent, phy->phy_id,\n\t\t\t\t\t      &dev->sata_dev.rps_resp);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"report phy sata to %016llx:0x%x returned \"\n\t\t\t\t    \"0x%x\\n\", SAS_ADDR(dev->parent->sas_addr),\n\t\t\t\t    phy->phy_id, res);\n\t\t\treturn res;\n\t\t}\n\t\tmemcpy(dev->frame_rcvd, &dev->sata_dev.rps_resp.rps.fis,\n\t\t       sizeof(struct dev_to_host_fis));\n\t\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\t}\n\treturn 0;\n}\n",
        "linevul": 7.682689465582371e-05,
        "sysevr": 0.17162777483463287,
        "devign": 2.6164950621274024e-19
    },
    {
        "code": "static int nfs4_xdr_enc_setattr(struct rpc_rqst *req, __be32 *p, struct nfs_setattrargs *args)\n\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 3,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if(status)\n                goto out;\n        status = encode_setattr(&xdr, args, args->server);\n        if(status)\n                goto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n        return status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int nfs4_xdr_enc_setattr(struct rpc_rqst *req, __be32 *p, struct nfs_setattrargs *args)\n\n{\n        struct xdr_stream xdr;\n        struct compound_hdr hdr = {\n                .nops   = 3,\n        };\n        int status;\n\n        xdr_init_encode(&xdr, &req->rq_snd_buf, p);\n        encode_compound_hdr(&xdr, &hdr);\n        status = encode_putfh(&xdr, args->fh);\n        if(status)\n                goto out;\n        status = encode_setattr(&xdr, args, args->server);\n        if(status)\n                goto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n        return status;\n}\n",
        "linevul": 0.00010056716564577073,
        "sysevr": 0.13187134265899658,
        "devign": 2.5537201283482933e-27
    },
    {
        "code": "int netif_rx(struct sk_buff *skb)\n{\n\tint ret;\n\n\t/* if netpoll wants it, pretend we never saw it */\n\tif (netpoll_rx(skb))\n\t\treturn NET_RX_DROP;\n\n\tif (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);\n\n\ttrace_netif_rx(skb);\n#ifdef CONFIG_RPS\n\t{\n\t\tstruct rps_dev_flow voidflow, *rflow = &voidflow;\n\t\tint cpu;\n\n\t\tpreempt_disable();\n\t\trcu_read_lock();\n\n\t\tcpu = get_rps_cpu(skb->dev, skb, &rflow);\n\t\tif (cpu < 0)\n\t\t\tcpu = smp_processor_id();\n\n\t\tret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);\n\n\t\trcu_read_unlock();\n\t\tpreempt_enable();\n\t}\n#else\n\t{\n\t\tunsigned int qtail;\n\t\tret = enqueue_to_backlog(skb, get_cpu(), &qtail);\n\t\tput_cpu();\n\t}\n#endif\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "int netif_rx(struct sk_buff *skb)\n{\n\tint ret;\n\n\t/* if netpoll wants it, pretend we never saw it */\n\tif (netpoll_rx(skb))\n\t\treturn NET_RX_DROP;\n\n\tif (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);\n\n\ttrace_netif_rx(skb);\n#ifdef CONFIG_RPS\n\t{\n\t\tstruct rps_dev_flow voidflow, *rflow = &voidflow;\n\t\tint cpu;\n\n\t\tpreempt_disable();\n\t\trcu_read_lock();\n\n\t\tcpu = get_rps_cpu(skb->dev, skb, &rflow);\n\t\tif (cpu < 0)\n\t\t\tcpu = smp_processor_id();\n\n\t\tret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);\n\n\t\trcu_read_unlock();\n\t\tpreempt_enable();\n\t}\n#else\n\t{\n\t\tunsigned int qtail;\n\t\tret = enqueue_to_backlog(skb, get_cpu(), &qtail);\n\t\tput_cpu();\n\t}\n#endif\n\treturn ret;\n}\n",
        "linevul": 4.9382695578970015e-05,
        "sysevr": 0.15870079398155212,
        "devign": 0.001234734314493835
    },
    {
        "code": "static int oz_dequeue_ep_urb(struct oz_port *port, u8 ep_addr, int in_dir,\n\t\t\tstruct urb *urb)\n{\n\tstruct oz_urb_link *urbl = NULL;\n\tstruct oz_endpoint *ep;\n\n\tspin_lock_bh(&port->ozhcd->hcd_lock);\n\tif (in_dir)\n\t\tep = port->in_ep[ep_addr];\n\telse\n\t\tep = port->out_ep[ep_addr];\n\tif (ep) {\n\t\tstruct list_head *e;\n\n\t\tlist_for_each(e, &ep->urb_list) {\n\t\t\turbl = list_entry(e, struct oz_urb_link, link);\n\t\t\tif (urbl->urb == urb) {\n\t\t\t\tlist_del_init(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\turbl = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&port->ozhcd->hcd_lock);\n\toz_free_urb_link(urbl);\n\treturn urbl ? 0 : -EIDRM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c",
        "vul_func_with_fix": "static int oz_dequeue_ep_urb(struct oz_port *port, u8 ep_addr, int in_dir,\n\t\t\tstruct urb *urb)\n{\n\tstruct oz_urb_link *urbl = NULL;\n\tstruct oz_endpoint *ep;\n\n\tspin_lock_bh(&port->ozhcd->hcd_lock);\n\tif (in_dir)\n\t\tep = port->in_ep[ep_addr];\n\telse\n\t\tep = port->out_ep[ep_addr];\n\tif (ep) {\n\t\tstruct list_head *e;\n\n\t\tlist_for_each(e, &ep->urb_list) {\n\t\t\turbl = list_entry(e, struct oz_urb_link, link);\n\t\t\tif (urbl->urb == urb) {\n\t\t\t\tlist_del_init(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\turbl = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&port->ozhcd->hcd_lock);\n\toz_free_urb_link(urbl);\n\treturn urbl ? 0 : -EIDRM;\n}\n",
        "linevul": 6.19755664956756e-05,
        "sysevr": 0.13478322327136993,
        "devign": 3.60248491126469e-15
    },
    {
        "code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\n\tefi_init();\n\tio_port_init();\n\n#ifdef CONFIG_IA64_GENERIC\n\t/* machvec needs to be parsed from the command line\n\t * before parse_early_param() is called to ensure\n\t * that ia64_mv is initialised before any command line\n\t * settings may cause console setup to occur\n\t */\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\n\tparse_early_param();\n\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n\n#ifdef CONFIG_ACPI\n\t/* Initialize the ACPI boot-time table parser */\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t/* happens, e.g., with the Ski simulator */\n# endif\n#endif /* CONFIG_APCI_BOOT */\n\n\tfind_memory();\n\n \t/* process SAL system table: */\n \tia64_sal_init(__va(efi.sal_systab));\n \n #ifdef CONFIG_SMP\n \tcpu_physical_id(0) = hard_smp_processor_id();\n #endif\n\n\tcpu_init();\t/* initialize the bootstrap CPU */\n\tmmu_context_init();\t/* initialize context_id bitmap */\n\n\tcheck_sal_cache_flush();\n\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\t/*\n\t\t * Non-legacy systems may route legacy VGA MMIO range to system\n\t\t * memory.  vga_con probes the MMIO hole, so memory looks like\n\t\t * a VGA device to it.  The EFI memory map can tell us if it's\n\t\t * memory so we can avoid this problem.\n\t\t */\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\n\t/* enable IA-64 Machine Check Abort Handling unless disabled */\n\tif (!nomca)\n\t\tia64_mca_init();\n\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4dcc29e1574d88f4465ba865ed82800032f76418",
        "vul_func_with_fix": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\n\tefi_init();\n\tio_port_init();\n\n#ifdef CONFIG_IA64_GENERIC\n\t/* machvec needs to be parsed from the command line\n\t * before parse_early_param() is called to ensure\n\t * that ia64_mv is initialised before any command line\n\t * settings may cause console setup to occur\n\t */\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\n\tparse_early_param();\n\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n\n#ifdef CONFIG_ACPI\n\t/* Initialize the ACPI boot-time table parser */\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t/* happens, e.g., with the Ski simulator */\n# endif\n#endif /* CONFIG_APCI_BOOT */\n\n\tfind_memory();\n\n \t/* process SAL system table: */\n \tia64_sal_init(__va(efi.sal_systab));\n \n//fix_flaw_line_below:\n//#ifdef CONFIG_ITANIUM\n//fix_flaw_line_below:\n//\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n//fix_flaw_line_below:\n//#else\n//fix_flaw_line_below:\n//\t{\n//fix_flaw_line_below:\n//\t\tu64 num_phys_stacked;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (ia64_pal_rse_info(&num_phys_stacked, 0) == 0 && num_phys_stacked > 96)\n//fix_flaw_line_below:\n//\t\t\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//#endif\n//fix_flaw_line_below:\n//\n #ifdef CONFIG_SMP\n \tcpu_physical_id(0) = hard_smp_processor_id();\n #endif\n\n\tcpu_init();\t/* initialize the bootstrap CPU */\n\tmmu_context_init();\t/* initialize context_id bitmap */\n\n\tcheck_sal_cache_flush();\n\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\t/*\n\t\t * Non-legacy systems may route legacy VGA MMIO range to system\n\t\t * memory.  vga_con probes the MMIO hole, so memory looks like\n\t\t * a VGA device to it.  The EFI memory map can tell us if it's\n\t\t * memory so we can avoid this problem.\n\t\t */\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\n\t/* enable IA-64 Machine Check Abort Handling unless disabled */\n\tif (!nomca)\n\t\tia64_mca_init();\n\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}\n",
        "linevul": 5.339367999113165e-05,
        "sysevr": 0.1752740889787674,
        "devign": 1.4030124142279301e-14
    },
    {
        "code": "static int em_smsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = 2;\n\tctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84",
        "vul_func_with_fix": "static int em_smsw(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.bytes = 2;\n\tctxt->dst.val = ctxt->ops->get_cr(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}\n",
        "linevul": 5.05862153659109e-05,
        "sysevr": 0.13005124032497406,
        "devign": 2.5571064270479837e-06
    },
    {
        "code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n \t\treturn -ENOKEY;\n \tp = key->payload.data[0];\n \tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n//flaw_line_below:\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n//fix_flaw_line_below:\n//\tif (key_is_negative(key))\n \t\treturn -ENOKEY;\n \tp = key->payload.data[0];\n \tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}\n",
        "linevul": 0.9994264841079712,
        "sysevr": 0.1615360528230667,
        "devign": 0.9999804496765137
    },
    {
        "code": "struct dentry *debugfs_lookup(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\n\tif (IS_ERR(parent))\n\t\treturn NULL;\n\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tinode_unlock(d_inode(parent));\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\tif (!d_really_is_positive(dentry)) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\treturn dentry;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
        "vul_func_with_fix": "struct dentry *debugfs_lookup(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\n\tif (IS_ERR(parent))\n\t\treturn NULL;\n\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tinode_unlock(d_inode(parent));\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\tif (!d_really_is_positive(dentry)) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\treturn dentry;\n}\n",
        "linevul": 6.570210825884715e-05,
        "sysevr": 0.1358732432126999,
        "devign": 4.599343319799868e-22
    },
    {
        "code": "static void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1e3921471354244f70fe268586ff94a97a6dd4df",
        "vul_func_with_fix": "static void set_vma_resv_flags(struct vm_area_struct *vma, unsigned long flags)\n{\n\tVM_BUG_ON_VMA(!is_vm_hugetlb_page(vma), vma);\n\tVM_BUG_ON_VMA(vma->vm_flags & VM_MAYSHARE, vma);\n\n\tset_vma_private_data(vma, get_vma_private_data(vma) | flags);\n}\n",
        "linevul": 0.00012204545782878995,
        "sysevr": 0.12838779389858246,
        "devign": 0.13433101773262024
    },
    {
        "code": "static void raw_err(struct sock *sk, struct sk_buff *skb, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tint err = 0;\n\tint harderr = 0;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tipv4_sk_update_pmtu(skb, sk, info);\n\telse if (type == ICMP_REDIRECT) {\n\t\tipv4_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\n\t/* Report error on raw socket, if:\n\t   1. User requested ip_recverr.\n\t   2. Socket is connected (otherwise the error indication\n\t      is useless without ip_recverr and error is hard.\n\t */\n\tif (!inet->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_SOURCE_QUENCH:\n\t\treturn;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tharderr = 1;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\terr = EHOSTUNREACH;\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tbreak;\n\t\terr = icmp_err_convert[code].errno;\n\t\tharderr = icmp_err_convert[code].fatal;\n\t\tif (code == ICMP_FRAG_NEEDED) {\n\t\t\tharderr = inet->pmtudisc != IP_PMTUDISC_DONT;\n\t\t\terr = EMSGSIZE;\n\t\t}\n\t}\n\n\tif (inet->recverr) {\n\t\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\t\tu8 *payload = skb->data + (iph->ihl << 2);\n\n\t\tif (inet->hdrincl)\n\t\t\tpayload = skb->data;\n\t\tip_icmp_error(sk, skb, err, 0, info, payload);\n\t}\n\n\tif (inet->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69",
        "vul_func_with_fix": "static void raw_err(struct sock *sk, struct sk_buff *skb, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tint err = 0;\n\tint harderr = 0;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tipv4_sk_update_pmtu(skb, sk, info);\n\telse if (type == ICMP_REDIRECT) {\n\t\tipv4_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\n\t/* Report error on raw socket, if:\n\t   1. User requested ip_recverr.\n\t   2. Socket is connected (otherwise the error indication\n\t      is useless without ip_recverr and error is hard.\n\t */\n\tif (!inet->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_SOURCE_QUENCH:\n\t\treturn;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tharderr = 1;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\terr = EHOSTUNREACH;\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tbreak;\n\t\terr = icmp_err_convert[code].errno;\n\t\tharderr = icmp_err_convert[code].fatal;\n\t\tif (code == ICMP_FRAG_NEEDED) {\n\t\t\tharderr = inet->pmtudisc != IP_PMTUDISC_DONT;\n\t\t\terr = EMSGSIZE;\n\t\t}\n\t}\n\n\tif (inet->recverr) {\n\t\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\t\tu8 *payload = skb->data + (iph->ihl << 2);\n\n\t\tif (inet->hdrincl)\n\t\t\tpayload = skb->data;\n\t\tip_icmp_error(sk, skb, err, 0, info, payload);\n\t}\n\n\tif (inet->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t}\n}\n",
        "linevul": 9.478998981649056e-05,
        "sysevr": 0.18977299332618713,
        "devign": 3.6228342836419345e-33
    },
    {
        "code": "static inline int rt_scope(int ifa_scope)\n{\n\tif (ifa_scope & IFA_HOST)\n\t\treturn RT_SCOPE_HOST;\n\telse if (ifa_scope & IFA_LINK)\n\t\treturn RT_SCOPE_LINK;\n\telse if (ifa_scope & IFA_SITE)\n\t\treturn RT_SCOPE_SITE;\n\telse\n\t\treturn RT_SCOPE_UNIVERSE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77751427a1ff25b27d47a4c36b12c3c8667855ac",
        "vul_func_with_fix": "static inline int rt_scope(int ifa_scope)\n{\n\tif (ifa_scope & IFA_HOST)\n\t\treturn RT_SCOPE_HOST;\n\telse if (ifa_scope & IFA_LINK)\n\t\treturn RT_SCOPE_LINK;\n\telse if (ifa_scope & IFA_SITE)\n\t\treturn RT_SCOPE_SITE;\n\telse\n\t\treturn RT_SCOPE_UNIVERSE;\n}\n",
        "linevul": 5.163236346561462e-05,
        "sysevr": 0.13922187685966492,
        "devign": 0.0005451776087284088
    },
    {
        "code": "bool kvm_vcpu_yield_to(struct kvm_vcpu *target)\n{\n\tstruct pid *pid;\n\tstruct task_struct *task = NULL;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tpid = rcu_dereference(target->pid);\n\tif (pid)\n\t\ttask = get_pid_task(target->pid, PIDTYPE_PID);\n\trcu_read_unlock();\n\tif (!task)\n\t\treturn ret;\n\tif (task->flags & PF_VCPU) {\n\t\tput_task_struct(task);\n\t\treturn ret;\n\t}\n\tret = yield_to(task, 1);\n\tput_task_struct(task);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/338c7dbadd2671189cec7faf64c84d01071b3f96",
        "vul_func_with_fix": "bool kvm_vcpu_yield_to(struct kvm_vcpu *target)\n{\n\tstruct pid *pid;\n\tstruct task_struct *task = NULL;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tpid = rcu_dereference(target->pid);\n\tif (pid)\n\t\ttask = get_pid_task(target->pid, PIDTYPE_PID);\n\trcu_read_unlock();\n\tif (!task)\n\t\treturn ret;\n\tif (task->flags & PF_VCPU) {\n\t\tput_task_struct(task);\n\t\treturn ret;\n\t}\n\tret = yield_to(task, 1);\n\tput_task_struct(task);\n\n\treturn ret;\n}\n",
        "linevul": 6.044469409971498e-05,
        "sysevr": 0.1439821571111679,
        "devign": 1.8524861278203936e-13
    },
    {
        "code": "static int override_release(char __user *release, int len)\n {\n \tint ret = 0;\n\tchar buf[65];\n \n \tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n \t\tint ndots = 0;\n \t\tunsigned v;\n \n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n \t}\n \treturn ret;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/2702b1526c7278c4d65d78de209a465d4de2885e",
        "vul_func_with_fix": "static int override_release(char __user *release, int len)\n//fix_flaw_line_below:\n//static int override_release(char __user *release, size_t len)\n {\n \tint ret = 0;\n//flaw_line_below:\n\tchar buf[65];\n \n \tif (current->personality & UNAME26) {\n//flaw_line_below:\n\t\tchar *rest = UTS_RELEASE;\n//fix_flaw_line_below:\n//\t\tconst char *rest = UTS_RELEASE;\n//fix_flaw_line_below:\n//\t\tchar buf[65] = { 0 };\n \t\tint ndots = 0;\n \t\tunsigned v;\n//fix_flaw_line_below:\n//\t\tsize_t copy;\n \n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n//flaw_line_below:\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n//flaw_line_below:\n\t\tret = copy_to_user(release, buf, len);\n//fix_flaw_line_below:\n//\t\tcopy = min(sizeof(buf), max_t(size_t, 1, len));\n//fix_flaw_line_below:\n//\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);\n//fix_flaw_line_below:\n//\t\tret = copy_to_user(release, buf, copy + 1);\n \t}\n \treturn ret;\n }\n",
        "linevul": 0.9994256496429443,
        "sysevr": 0.13542835414409637,
        "devign": 0.5890791416168213
    },
    {
        "code": "posix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef",
        "vul_func_with_fix": "posix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}\n",
        "linevul": 0.0022272600326687098,
        "sysevr": 0.1893451064825058,
        "devign": 3.449406722211279e-05
    },
    {
        "code": "static void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce",
        "vul_func_with_fix": "static void m_cache_vma(struct seq_file *m, struct vm_area_struct *vma)\n{\n\tif (m->count < m->size)\t/* vma is copied successfully */\n\t\tm->version = m_next_vma(m->private, vma) ? vma->vm_start : -1UL;\n}\n",
        "linevul": 0.037299733608961105,
        "sysevr": 0.12867914140224457,
        "devign": 6.238543210669578e-13
    },
    {
        "code": "static struct sk_buff *igmpv3_newpack(struct net_device *dev, int size)\n{\n\tstruct sk_buff *skb;\n\tstruct rtable *rt;\n\tstruct iphdr *pip;\n\tstruct igmpv3_report *pig;\n\tstruct net *net = dev_net(dev);\n\tstruct flowi4 fl4;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\n\twhile (1) {\n\t\tskb = alloc_skb(size + hlen + tlen,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t\tif (size < 256)\n\t\t\treturn NULL;\n\t}\n\tigmp_skb_size(skb) = size;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\tskb->dev = dev;\n\n\tskb_reserve(skb, hlen);\n\n\tskb_reset_network_header(skb);\n\tpip = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tpip->version  = 4;\n\tpip->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tpip->tos      = 0xc0;\n\tpip->frag_off = htons(IP_DF);\n\tpip->ttl      = 1;\n\tpip->daddr    = fl4.daddr;\n\tpip->saddr    = fl4.saddr;\n\tpip->protocol = IPPROTO_IGMP;\n\tpip->tot_len  = 0;\t/* filled in later */\n\tip_select_ident(pip, &rt->dst, NULL);\n\t((u8*)&pip[1])[0] = IPOPT_RA;\n\t((u8*)&pip[1])[1] = 4;\n\t((u8*)&pip[1])[2] = 0;\n\t((u8*)&pip[1])[3] = 0;\n\n\tskb->transport_header = skb->network_header + sizeof(struct iphdr) + 4;\n\tskb_put(skb, sizeof(*pig));\n\tpig = igmpv3_report_hdr(skb);\n\tpig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\tpig->resv1 = 0;\n\tpig->csum = 0;\n\tpig->resv2 = 0;\n\tpig->ngrec = 0;\n\treturn skb;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27",
        "vul_func_with_fix": "static struct sk_buff *igmpv3_newpack(struct net_device *dev, int size)\n{\n\tstruct sk_buff *skb;\n\tstruct rtable *rt;\n\tstruct iphdr *pip;\n\tstruct igmpv3_report *pig;\n\tstruct net *net = dev_net(dev);\n\tstruct flowi4 fl4;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\n\twhile (1) {\n\t\tskb = alloc_skb(size + hlen + tlen,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t\tif (size < 256)\n\t\t\treturn NULL;\n\t}\n\tigmp_skb_size(skb) = size;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\tskb->dev = dev;\n\n\tskb_reserve(skb, hlen);\n\n\tskb_reset_network_header(skb);\n\tpip = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tpip->version  = 4;\n\tpip->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tpip->tos      = 0xc0;\n\tpip->frag_off = htons(IP_DF);\n\tpip->ttl      = 1;\n\tpip->daddr    = fl4.daddr;\n\tpip->saddr    = fl4.saddr;\n\tpip->protocol = IPPROTO_IGMP;\n\tpip->tot_len  = 0;\t/* filled in later */\n\tip_select_ident(pip, &rt->dst, NULL);\n\t((u8*)&pip[1])[0] = IPOPT_RA;\n\t((u8*)&pip[1])[1] = 4;\n\t((u8*)&pip[1])[2] = 0;\n\t((u8*)&pip[1])[3] = 0;\n\n\tskb->transport_header = skb->network_header + sizeof(struct iphdr) + 4;\n\tskb_put(skb, sizeof(*pig));\n\tpig = igmpv3_report_hdr(skb);\n\tpig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\tpig->resv1 = 0;\n\tpig->csum = 0;\n\tpig->resv2 = 0;\n\tpig->ngrec = 0;\n\treturn skb;\n}\n",
        "linevul": 0.0005541571299545467,
        "sysevr": 0.2471637725830078,
        "devign": 6.154890996867834e-08
    },
    {
        "code": "int efx_reset(struct efx_nic *efx, enum reset_type method)\n{\n\tint rc, rc2;\n\tbool disabled;\n\n\tnetif_info(efx, drv, efx->net_dev, \"resetting (%s)\\n\",\n\t\t   RESET_TYPE(method));\n\n\tnetif_device_detach(efx->net_dev);\n\tefx_reset_down(efx, method);\n\n\trc = efx->type->reset(efx, method);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev, \"failed to reset hardware\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Clear flags for the scopes we covered.  We assume the NIC and\n\t * driver are now quiescent so that there is no race here.\n\t */\n\tefx->reset_pending &= -(1 << (method + 1));\n\n\t/* Reinitialise bus-mastering, which may have been turned off before\n\t * the reset was scheduled. This is still appropriate, even in the\n\t * RESET_TYPE_DISABLE since this driver generally assumes the hardware\n\t * can respond to requests. */\n\tpci_set_master(efx->pci_dev);\n\nout:\n\t/* Leave device stopped if necessary */\n\tdisabled = rc || method == RESET_TYPE_DISABLE;\n\trc2 = efx_reset_up(efx, method, !disabled);\n\tif (rc2) {\n\t\tdisabled = true;\n\t\tif (!rc)\n\t\t\trc = rc2;\n\t}\n\n\tif (disabled) {\n\t\tdev_close(efx->net_dev);\n\t\tnetif_err(efx, drv, efx->net_dev, \"has been disabled\\n\");\n\t\tefx->state = STATE_DISABLED;\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"reset complete\\n\");\n\t\tnetif_device_attach(efx->net_dev);\n\t}\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "vul_func_with_fix": "int efx_reset(struct efx_nic *efx, enum reset_type method)\n{\n\tint rc, rc2;\n\tbool disabled;\n\n\tnetif_info(efx, drv, efx->net_dev, \"resetting (%s)\\n\",\n\t\t   RESET_TYPE(method));\n\n\tnetif_device_detach(efx->net_dev);\n\tefx_reset_down(efx, method);\n\n\trc = efx->type->reset(efx, method);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev, \"failed to reset hardware\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Clear flags for the scopes we covered.  We assume the NIC and\n\t * driver are now quiescent so that there is no race here.\n\t */\n\tefx->reset_pending &= -(1 << (method + 1));\n\n\t/* Reinitialise bus-mastering, which may have been turned off before\n\t * the reset was scheduled. This is still appropriate, even in the\n\t * RESET_TYPE_DISABLE since this driver generally assumes the hardware\n\t * can respond to requests. */\n\tpci_set_master(efx->pci_dev);\n\nout:\n\t/* Leave device stopped if necessary */\n\tdisabled = rc || method == RESET_TYPE_DISABLE;\n\trc2 = efx_reset_up(efx, method, !disabled);\n\tif (rc2) {\n\t\tdisabled = true;\n\t\tif (!rc)\n\t\t\trc = rc2;\n\t}\n\n\tif (disabled) {\n\t\tdev_close(efx->net_dev);\n\t\tnetif_err(efx, drv, efx->net_dev, \"has been disabled\\n\");\n\t\tefx->state = STATE_DISABLED;\n\t} else {\n\t\tnetif_dbg(efx, drv, efx->net_dev, \"reset complete\\n\");\n\t\tnetif_device_attach(efx->net_dev);\n\t}\n\treturn rc;\n}\n",
        "linevul": 4.845152216148563e-05,
        "sysevr": 0.1915195882320404,
        "devign": 6.11950334749098e-16
    },
    {
        "code": "static int shmem_setxattr(struct dentry *dentry, const char *name,\n\t\t\t  const void *value, size_t size, int flags)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(dentry->d_inode);\n\tint err;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, size, flags);\n\n\terr = shmem_xattr_validate(name);\n\tif (err)\n\t\treturn err;\n\n\treturn simple_xattr_set(&info->xattrs, name, value, size, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "static int shmem_setxattr(struct dentry *dentry, const char *name,\n\t\t\t  const void *value, size_t size, int flags)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(dentry->d_inode);\n\tint err;\n\n\t/*\n\t * If this is a request for a synthetic attribute in the system.*\n\t * namespace use the generic infrastructure to resolve a handler\n\t * for it via sb->s_xattr.\n\t */\n\tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn generic_setxattr(dentry, name, value, size, flags);\n\n\terr = shmem_xattr_validate(name);\n\tif (err)\n\t\treturn err;\n\n\treturn simple_xattr_set(&info->xattrs, name, value, size, flags);\n}\n",
        "linevul": 5.963512376183644e-05,
        "sysevr": 0.14097943902015686,
        "devign": 1.9240570014804345e-19
    },
    {
        "code": "static int job_control(struct tty_struct *tty, struct file *file)\n{\n\t/* Job control check -- must be done at start and after\n\t   every sleep (POSIX.1 7.1.1.4). */\n\t/* NOTE: not yet done after every sleep pending a thorough\n\t   check of the logic of this change. -- jlc */\n\t/* don't stop on /dev/console */\n\tif (file->f_op->write == redirected_tty_write ||\n\t    current->signal->tty != tty)\n\t\treturn 0;\n\n\tspin_lock_irq(&tty->ctrl_lock);\n\tif (!tty->pgrp)\n\t\tprintk(KERN_ERR \"n_tty_read: no tty->pgrp!\\n\");\n\telse if (task_pgrp(current) != tty->pgrp) {\n\t\tspin_unlock_irq(&tty->ctrl_lock);\n\t\tif (is_ignored(SIGTTIN) || is_current_pgrp_orphaned())\n\t\t\treturn -EIO;\n\t\tkill_pgrp(task_pgrp(current), SIGTTIN, 1);\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\treturn -ERESTARTSYS;\n\t}\n\tspin_unlock_irq(&tty->ctrl_lock);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4291086b1f081b869c6d79e5b7441633dc3ace00",
        "vul_func_with_fix": "static int job_control(struct tty_struct *tty, struct file *file)\n{\n\t/* Job control check -- must be done at start and after\n\t   every sleep (POSIX.1 7.1.1.4). */\n\t/* NOTE: not yet done after every sleep pending a thorough\n\t   check of the logic of this change. -- jlc */\n\t/* don't stop on /dev/console */\n\tif (file->f_op->write == redirected_tty_write ||\n\t    current->signal->tty != tty)\n\t\treturn 0;\n\n\tspin_lock_irq(&tty->ctrl_lock);\n\tif (!tty->pgrp)\n\t\tprintk(KERN_ERR \"n_tty_read: no tty->pgrp!\\n\");\n\telse if (task_pgrp(current) != tty->pgrp) {\n\t\tspin_unlock_irq(&tty->ctrl_lock);\n\t\tif (is_ignored(SIGTTIN) || is_current_pgrp_orphaned())\n\t\t\treturn -EIO;\n\t\tkill_pgrp(task_pgrp(current), SIGTTIN, 1);\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\treturn -ERESTARTSYS;\n\t}\n\tspin_unlock_irq(&tty->ctrl_lock);\n\treturn 0;\n}\n",
        "linevul": 0.0047962479293346405,
        "sysevr": 0.15764595568180084,
        "devign": 6.152799159053757e-09
    },
    {
        "code": " static void perf_event_exit_cpu(int cpu)\n {\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n \tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "vul_func_with_fix": " static void perf_event_exit_cpu(int cpu)\n {\n//flaw_line_below:\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n//flaw_line_below:\n\n \tperf_event_exit_cpu_context(cpu);\n//flaw_line_below:\n\n//flaw_line_below:\n\tmutex_lock(&swhash->hlist_mutex);\n//flaw_line_below:\n\tswhash->online = false;\n//flaw_line_below:\n\tswevent_hlist_release(swhash);\n//flaw_line_below:\n\tmutex_unlock(&swhash->hlist_mutex);\n }\n",
        "linevul": 7.127395656425506e-05,
        "sysevr": 0.12860669195652008,
        "devign": 0.9836711883544922
    },
    {
        "code": "static bool arcmsr_hbaC_get_config(struct AdapterControlBlock *pACB)\n{\n\tuint32_t intmask_org, Index, firmware_state = 0;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tchar *acb_firm_model = pACB->firm_model;\n\tchar *acb_firm_version = pACB->firm_version;\n\tchar __iomem *iop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);    /*firm_model,15,60-67*/\n\tchar __iomem *iop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);  /*firm_version,17,68-83*/\n\tint count;\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tdo {\n\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t/* wait message ready */\n\tfor (Index = 0; Index < 2000; Index++) {\n\t\tif (readl(&reg->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);/*clear interrupt*/\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t} /*max 1 seconds*/\n\tif (Index >= 2000) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count) {\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tpACB->host->host_no,\n\t\tpACB->firm_model,\n\t\tpACB->firm_version);\n\tpACB->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);   /*firm_request_len,1,04-07*/\n\tpACB->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]); /*firm_numbers_queue,2,08-11*/\n\tpACB->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);    /*firm_sdram_size,3,12-15*/\n\tpACB->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);  /*firm_ide_channels,4,16-19*/\n\tpACB->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\t/*all interrupt service will be enable at arcmsr_iop_init*/\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7bc2b55a5c030685b399bb65b6baa9ccc3d1f167",
        "vul_func_with_fix": "static bool arcmsr_hbaC_get_config(struct AdapterControlBlock *pACB)\n{\n\tuint32_t intmask_org, Index, firmware_state = 0;\n\tstruct MessageUnit_C __iomem *reg = pACB->pmuC;\n\tchar *acb_firm_model = pACB->firm_model;\n\tchar *acb_firm_version = pACB->firm_version;\n\tchar __iomem *iop_firm_model = (char __iomem *)(&reg->msgcode_rwbuffer[15]);    /*firm_model,15,60-67*/\n\tchar __iomem *iop_firm_version = (char __iomem *)(&reg->msgcode_rwbuffer[17]);  /*firm_version,17,68-83*/\n\tint count;\n\t/* disable all outbound interrupt */\n\tintmask_org = readl(&reg->host_int_mask); /* disable outbound message0 int */\n\twritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\n\t/* wait firmware ready */\n\tdo {\n\t\tfirmware_state = readl(&reg->outbound_msgaddr1);\n\t} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\n\t/* post \"get config\" instruction */\n\twritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\n\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t/* wait message ready */\n\tfor (Index = 0; Index < 2000; Index++) {\n\t\tif (readl(&reg->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\n\t\t\twritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);/*clear interrupt*/\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t} /*max 1 seconds*/\n\tif (Index >= 2000) {\n\t\tprintk(KERN_NOTICE \"arcmsr%d: wait 'get adapter firmware \\\n\t\t\tmiscellaneous data' timeout \\n\", pACB->host->host_no);\n\t\treturn false;\n\t}\n\tcount = 8;\n\twhile (count) {\n\t\t*acb_firm_model = readb(iop_firm_model);\n\t\tacb_firm_model++;\n\t\tiop_firm_model++;\n\t\tcount--;\n\t}\n\tcount = 16;\n\twhile (count) {\n\t\t*acb_firm_version = readb(iop_firm_version);\n\t\tacb_firm_version++;\n\t\tiop_firm_version++;\n\t\tcount--;\n\t}\n\tpr_notice(\"Areca RAID Controller%d: Model %s, F/W %s\\n\",\n\t\tpACB->host->host_no,\n\t\tpACB->firm_model,\n\t\tpACB->firm_version);\n\tpACB->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);   /*firm_request_len,1,04-07*/\n\tpACB->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]); /*firm_numbers_queue,2,08-11*/\n\tpACB->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);    /*firm_sdram_size,3,12-15*/\n\tpACB->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);  /*firm_ide_channels,4,16-19*/\n\tpACB->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);  /*firm_cfg_version,25,100-103*/\n\t/*all interrupt service will be enable at arcmsr_iop_init*/\n\treturn true;\n}\n",
        "linevul": 9.097955626202747e-05,
        "sysevr": 0.1420351266860962,
        "devign": 0.00045155914267525077
    },
    {
        "code": "int ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tu32 mtu;\n\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\t/*\n\t *\tWe DO NOT make any processing on\n\t *\tRA packets, pushing them to user level AS IS\n\t *\twithout ane WARRANTY that application will be able\n\t *\tto interpret them. The reason is that we\n\t *\tcannot make anything clever here.\n\t *\n\t *\tWe are not end-node, so that if packet contains\n\t *\tAH/ESP, we cannot make anything.\n\t *\tDefragmentation also would be mistake, RA packets\n\t *\tcannot be fragmented, because there is no warranty\n\t *\tthat different fragments will go along one path. --ANK\n\t */\n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t *\tcheck and decrement ttl\n\t */\n\tif (hdr->hop_limit <= 1) {\n\t\t/* Force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* XXX: idev->cnf.proxy_ndp? */\n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0)\n\t\t\treturn ip6_input(skb);\n\t\telse if (proxied < 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t      IPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t/* IPv6 specs say nothing about it, but it is clear that we cannot\n\t   send redirects to source routed frames.\n\t   We don't send redirects to frames decapsulated from IPsec.\n\t */\n\tif (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t/*\n\t\t *\tincoming and outgoing devices are the same\n\t\t *\tsend a redirect.\n\t\t */\n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\n\n\t\t/* Limit redirects both by destination (here)\n\t\t   and by source (inside ndisc_send_redirect)\n\t\t */\n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t/* This check is security critical. */\n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif ((!skb->local_df && skb->len > mtu && !skb_is_gso(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)) {\n\t\t/* Again, force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INTOOBIGERRORS);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t/* Mangling hops number delayed to point after skb COW */\n\n\thdr->hop_limit--;\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\tIP6_ADD_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2811ebac2521ceac84f2bdae402455baa6a7fb47",
        "vul_func_with_fix": "int ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tu32 mtu;\n\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\t/*\n\t *\tWe DO NOT make any processing on\n\t *\tRA packets, pushing them to user level AS IS\n\t *\twithout ane WARRANTY that application will be able\n\t *\tto interpret them. The reason is that we\n\t *\tcannot make anything clever here.\n\t *\n\t *\tWe are not end-node, so that if packet contains\n\t *\tAH/ESP, we cannot make anything.\n\t *\tDefragmentation also would be mistake, RA packets\n\t *\tcannot be fragmented, because there is no warranty\n\t *\tthat different fragments will go along one path. --ANK\n\t */\n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t *\tcheck and decrement ttl\n\t */\n\tif (hdr->hop_limit <= 1) {\n\t\t/* Force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* XXX: idev->cnf.proxy_ndp? */\n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0)\n\t\t\treturn ip6_input(skb);\n\t\telse if (proxied < 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t      IPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t/* IPv6 specs say nothing about it, but it is clear that we cannot\n\t   send redirects to source routed frames.\n\t   We don't send redirects to frames decapsulated from IPsec.\n\t */\n\tif (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t/*\n\t\t *\tincoming and outgoing devices are the same\n\t\t *\tsend a redirect.\n\t\t */\n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\n\n\t\t/* Limit redirects both by destination (here)\n\t\t   and by source (inside ndisc_send_redirect)\n\t\t */\n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t/* This check is security critical. */\n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif ((!skb->local_df && skb->len > mtu && !skb_is_gso(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)) {\n\t\t/* Again, force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INTOOBIGERRORS);\n\t\tIP6_INC_STATS_BH(net,\n\t\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t/* Mangling hops number delayed to point after skb COW */\n\n\thdr->hop_limit--;\n\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\tIP6_ADD_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n",
        "linevul": 5.794934986624867e-05,
        "sysevr": 0.21370820701122284,
        "devign": 9.872607939498401e-12
    },
    {
        "code": "void __init dma_contiguous_remap(void)\n{\n\tint i;\n\tfor (i = 0; i < dma_mmu_remap_num; i++) {\n\t\tphys_addr_t start = dma_mmu_remap[i].base;\n\t\tphys_addr_t end = start + dma_mmu_remap[i].size;\n\t\tstruct map_desc map;\n\t\tunsigned long addr;\n\n\t\tif (end > arm_lowmem_limit)\n\t\t\tend = arm_lowmem_limit;\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\tmap.pfn = __phys_to_pfn(start);\n\t\tmap.virtual = __phys_to_virt(start);\n\t\tmap.length = end - start;\n\t\tmap.type = MT_MEMORY_DMA_READY;\n\n\t\t/*\n\t\t * Clear previous low-memory mapping\n\t\t */\n\t\tfor (addr = __phys_to_virt(start); addr < __phys_to_virt(end);\n\t\t     addr += PMD_SIZE)\n\t\t\tpmd_clear(pmd_off_k(addr));\n\n\t\tiotable_init(&map, 1);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826",
        "vul_func_with_fix": "void __init dma_contiguous_remap(void)\n{\n\tint i;\n\tfor (i = 0; i < dma_mmu_remap_num; i++) {\n\t\tphys_addr_t start = dma_mmu_remap[i].base;\n\t\tphys_addr_t end = start + dma_mmu_remap[i].size;\n\t\tstruct map_desc map;\n\t\tunsigned long addr;\n\n\t\tif (end > arm_lowmem_limit)\n\t\t\tend = arm_lowmem_limit;\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\tmap.pfn = __phys_to_pfn(start);\n\t\tmap.virtual = __phys_to_virt(start);\n\t\tmap.length = end - start;\n\t\tmap.type = MT_MEMORY_DMA_READY;\n\n\t\t/*\n\t\t * Clear previous low-memory mapping\n\t\t */\n\t\tfor (addr = __phys_to_virt(start); addr < __phys_to_virt(end);\n\t\t     addr += PMD_SIZE)\n\t\t\tpmd_clear(pmd_off_k(addr));\n\n\t\tiotable_init(&map, 1);\n\t}\n}\n",
        "linevul": 6.652587035205215e-05,
        "sysevr": 0.17232182621955872,
        "devign": 0.6235443353652954
    },
    {
        "code": "static inline cputime_t virt_ticks(struct task_struct *p)\n{\n\treturn p->utime;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static inline cputime_t virt_ticks(struct task_struct *p)\n{\n\treturn p->utime;\n}\n",
        "linevul": 4.7336732677649707e-05,
        "sysevr": 0.12719856202602386,
        "devign": 1.5385746010565526e-08
    },
    {
        "code": "static int em_fxsave(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tsize_t size;\n\tint rc;\n\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->ops->get_fpu(ctxt);\n\n\trc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));\n\n\tctxt->ops->put_fpu(ctxt);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n \telse\n \t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n \n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/129a72a0d3c8e139a04512325384fe5ac119e74d",
        "vul_func_with_fix": "static int em_fxsave(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tsize_t size;\n\tint rc;\n\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tctxt->ops->get_fpu(ctxt);\n\n\trc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));\n\n\tctxt->ops->put_fpu(ctxt);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n \telse\n \t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n \n//flaw_line_below:\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n//fix_flaw_line_below:\n//\treturn segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n }\n",
        "linevul": 0.9941645264625549,
        "sysevr": 0.12901678681373596,
        "devign": 2.2939051699810697e-11
    },
    {
        "code": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88",
        "vul_func_with_fix": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}\n",
        "linevul": 7.190660835476592e-05,
        "sysevr": 0.1655757576227188,
        "devign": 1.9195560696516623e-07
    },
    {
        "code": "static void parse_hid_report_descriptor(struct gtco *device, char * report,\n\t\t\t\t\tint length)\n{\n\tstruct device *ddev = &device->intf->dev;\n\tint   x, i = 0;\n\n\t/* Tag primitive vars */\n\t__u8   prefix;\n\t__u8   size;\n\t__u8   tag;\n\t__u8   type;\n\t__u8   data   = 0;\n\t__u16  data16 = 0;\n\t__u32  data32 = 0;\n\n\t/* For parsing logic */\n\tint   inputnum = 0;\n\t__u32 usage = 0;\n\n\t/* Global Values, indexed by TAG */\n\t__u32 globalval[TAG_GLOB_MAX];\n\t__u32 oldval[TAG_GLOB_MAX];\n\n\t/* Debug stuff */\n\tchar  maintype = 'x';\n\tchar  globtype[12];\n\tint   indent = 0;\n\tchar  indentstr[10] = \"\";\n\n\n\tdev_dbg(ddev, \"======>>>>>>PARSE<<<<<<======\\n\");\n\n\t/* Walk  this report and pull out the info we need */\n\twhile (i < length) {\n\t\tprefix = report[i];\n\n\t\t/* Skip over prefix */\n\t\ti++;\n\n\t\t/* Determine data size and save the data in the proper variable */\n\t\tsize = PREF_SIZE(prefix);\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tdata = report[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata16 = get_unaligned_le16(&report[i]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsize = 4;\n\t\t\tdata32 = get_unaligned_le32(&report[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip size of data */\n\t\ti += size;\n\n\t\t/* What we do depends on the tag type */\n\t\ttag  = PREF_TAG(prefix);\n\t\ttype = PREF_TYPE(prefix);\n\t\tswitch (type) {\n\t\tcase TYPE_MAIN:\n\t\t\tstrcpy(globtype, \"\");\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_MAIN_INPUT:\n\t\t\t\t/*\n\t\t\t\t * The INPUT MAIN tag signifies this is\n\t\t\t\t * information from a report.  We need to\n\t\t\t\t * figure out what it is and store the\n\t\t\t\t * min/max values\n\t\t\t\t */\n\n\t\t\t\tmaintype = 'I';\n\t\t\t\tif (data == 2)\n\t\t\t\t\tstrcpy(globtype, \"Variable\");\n\t\t\t\telse if (data == 3)\n\t\t\t\t\tstrcpy(globtype, \"Var|Const\");\n\n\t\t\t\tdev_dbg(ddev, \"::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\\n\",\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_ID], inputnum,\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\n\n\n\t\t\t\t/*\n\t\t\t\t  We can assume that the first two input items\n\t\t\t\t  are always the X and Y coordinates.  After\n\t\t\t\t  that, we look for everything else by\n\t\t\t\t  local usage value\n\t\t\t\t */\n\t\t\t\tswitch (inputnum) {\n\t\t\t\tcase 0:  /* X coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: X Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_X == 0) {\n\t\t\t\t\t\tdevice->max_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  /* Y coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: Y Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_Y == 0) {\n\t\t\t\t\t\tdevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* Tilt X */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_X) {\n\t\t\t\t\t\tif (device->maxtilt_X == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Tilt Y */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_Y) {\n\t\t\t\t\t\tif (device->maxtilt_Y == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Pressure */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\n\t\t\t\t\t\tif (device->maxpressure == 0) {\n\t\t\t\t\t\t\tdevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputnum++;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_OUTPUT:\n\t\t\t\tmaintype = 'O';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_FEATURE:\n\t\t\t\tmaintype = 'F';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_START:\n\t\t\t\tmaintype = 'S';\n\n\t\t\t\tif (data == 0) {\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>> Physical\\n\");\n\t\t\t\t\tstrcpy(globtype, \"Physical\");\n\t\t\t\t} else\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>>\\n\");\n\n\t\t\t\t/* Indent the debug output */\n\t\t\t\tindent++;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Save global tags */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\toldval[x] = globalval[x];\n\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_END:\n\t\t\t\tdev_dbg(ddev, \"<<<<<<======\\n\");\n\t\t\t\tmaintype = 'E';\n\t\t\t\tindent--;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Copy global tags back */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\tglobalval[x] = oldval[x];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_GLOBAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\t/*\n\t\t\t\t * First time we hit the global usage tag,\n\t\t\t\t * it should tell us the type of device\n\t\t\t\t */\n\t\t\t\tif (device->usage == 0)\n\t\t\t\t\tdevice->usage = data;\n\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"LOG_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"LOG_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MIN:\n\t\t\t\tstrcpy(globtype, \"PHYS_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MAX:\n\t\t\t\tstrcpy(globtype, \"PHYS_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT_EXP:\n\t\t\t\tstrcpy(globtype, \"EXP\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT:\n\t\t\t\tstrcpy(globtype, \"UNIT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_SZ:\n\t\t\t\tstrcpy(globtype, \"REPORT_SZ\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_ID:\n\t\t\t\tstrcpy(globtype, \"REPORT_ID\");\n\t\t\t\t/* New report, restart numbering */\n\t\t\t\tinputnum = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_CNT:\n\t\t\t\tstrcpy(globtype, \"REPORT_CNT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PUSH:\n\t\t\t\tstrcpy(globtype, \"PUSH\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_POP:\n\t\t\t\tstrcpy(globtype, \"POP\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check to make sure we have a good tag number\n\t\t\t   so we don't overflow array */\n\t\t\tif (tag < TAG_GLOB_MAX) {\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 1:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data);\n\t\t\t\t\tglobalval[tag] = data;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data16);\n\t\t\t\t\tglobalval[tag] = data16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data32);\n\t\t\t\t\tglobalval[tag] = data32;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\\n\",\n\t\t\t\t\tindentstr, tag, size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_LOCAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\t/* Always 1 byte */\n\t\t\t\tusage = data;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"MAX\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrcpy(globtype, \"UNKNOWN\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d",
        "vul_func_with_fix": "static void parse_hid_report_descriptor(struct gtco *device, char * report,\n\t\t\t\t\tint length)\n{\n\tstruct device *ddev = &device->intf->dev;\n\tint   x, i = 0;\n\n\t/* Tag primitive vars */\n\t__u8   prefix;\n\t__u8   size;\n\t__u8   tag;\n\t__u8   type;\n\t__u8   data   = 0;\n\t__u16  data16 = 0;\n\t__u32  data32 = 0;\n\n\t/* For parsing logic */\n\tint   inputnum = 0;\n\t__u32 usage = 0;\n\n\t/* Global Values, indexed by TAG */\n\t__u32 globalval[TAG_GLOB_MAX];\n\t__u32 oldval[TAG_GLOB_MAX];\n\n\t/* Debug stuff */\n\tchar  maintype = 'x';\n\tchar  globtype[12];\n\tint   indent = 0;\n\tchar  indentstr[10] = \"\";\n\n\n\tdev_dbg(ddev, \"======>>>>>>PARSE<<<<<<======\\n\");\n\n\t/* Walk  this report and pull out the info we need */\n\twhile (i < length) {\n\t\tprefix = report[i];\n\n\t\t/* Skip over prefix */\n\t\ti++;\n\n\t\t/* Determine data size and save the data in the proper variable */\n\t\tsize = PREF_SIZE(prefix);\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tdata = report[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata16 = get_unaligned_le16(&report[i]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsize = 4;\n\t\t\tdata32 = get_unaligned_le32(&report[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip size of data */\n\t\ti += size;\n\n\t\t/* What we do depends on the tag type */\n\t\ttag  = PREF_TAG(prefix);\n\t\ttype = PREF_TYPE(prefix);\n\t\tswitch (type) {\n\t\tcase TYPE_MAIN:\n\t\t\tstrcpy(globtype, \"\");\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_MAIN_INPUT:\n\t\t\t\t/*\n\t\t\t\t * The INPUT MAIN tag signifies this is\n\t\t\t\t * information from a report.  We need to\n\t\t\t\t * figure out what it is and store the\n\t\t\t\t * min/max values\n\t\t\t\t */\n\n\t\t\t\tmaintype = 'I';\n\t\t\t\tif (data == 2)\n\t\t\t\t\tstrcpy(globtype, \"Variable\");\n\t\t\t\telse if (data == 3)\n\t\t\t\t\tstrcpy(globtype, \"Var|Const\");\n\n\t\t\t\tdev_dbg(ddev, \"::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\\n\",\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_ID], inputnum,\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\n\n\n\t\t\t\t/*\n\t\t\t\t  We can assume that the first two input items\n\t\t\t\t  are always the X and Y coordinates.  After\n\t\t\t\t  that, we look for everything else by\n\t\t\t\t  local usage value\n\t\t\t\t */\n\t\t\t\tswitch (inputnum) {\n\t\t\t\tcase 0:  /* X coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: X Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_X == 0) {\n\t\t\t\t\t\tdevice->max_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  /* Y coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: Y Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_Y == 0) {\n\t\t\t\t\t\tdevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* Tilt X */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_X) {\n\t\t\t\t\t\tif (device->maxtilt_X == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Tilt Y */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_Y) {\n\t\t\t\t\t\tif (device->maxtilt_Y == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Pressure */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\n\t\t\t\t\t\tif (device->maxpressure == 0) {\n\t\t\t\t\t\t\tdevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputnum++;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_OUTPUT:\n\t\t\t\tmaintype = 'O';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_FEATURE:\n\t\t\t\tmaintype = 'F';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_START:\n\t\t\t\tmaintype = 'S';\n\n\t\t\t\tif (data == 0) {\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>> Physical\\n\");\n\t\t\t\t\tstrcpy(globtype, \"Physical\");\n\t\t\t\t} else\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>>\\n\");\n\n\t\t\t\t/* Indent the debug output */\n\t\t\t\tindent++;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Save global tags */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\toldval[x] = globalval[x];\n\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_END:\n\t\t\t\tdev_dbg(ddev, \"<<<<<<======\\n\");\n\t\t\t\tmaintype = 'E';\n\t\t\t\tindent--;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Copy global tags back */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\tglobalval[x] = oldval[x];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_GLOBAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\t/*\n\t\t\t\t * First time we hit the global usage tag,\n\t\t\t\t * it should tell us the type of device\n\t\t\t\t */\n\t\t\t\tif (device->usage == 0)\n\t\t\t\t\tdevice->usage = data;\n\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"LOG_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"LOG_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MIN:\n\t\t\t\tstrcpy(globtype, \"PHYS_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MAX:\n\t\t\t\tstrcpy(globtype, \"PHYS_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT_EXP:\n\t\t\t\tstrcpy(globtype, \"EXP\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT:\n\t\t\t\tstrcpy(globtype, \"UNIT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_SZ:\n\t\t\t\tstrcpy(globtype, \"REPORT_SZ\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_ID:\n\t\t\t\tstrcpy(globtype, \"REPORT_ID\");\n\t\t\t\t/* New report, restart numbering */\n\t\t\t\tinputnum = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_CNT:\n\t\t\t\tstrcpy(globtype, \"REPORT_CNT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PUSH:\n\t\t\t\tstrcpy(globtype, \"PUSH\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_POP:\n\t\t\t\tstrcpy(globtype, \"POP\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check to make sure we have a good tag number\n\t\t\t   so we don't overflow array */\n\t\t\tif (tag < TAG_GLOB_MAX) {\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 1:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data);\n\t\t\t\t\tglobalval[tag] = data;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data16);\n\t\t\t\t\tglobalval[tag] = data16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data32);\n\t\t\t\t\tglobalval[tag] = data32;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\\n\",\n\t\t\t\t\tindentstr, tag, size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_LOCAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\t/* Always 1 byte */\n\t\t\t\tusage = data;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"MAX\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrcpy(globtype, \"UNKNOWN\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
        "linevul": 0.000776495726313442,
        "sysevr": 0.26746487617492676,
        "devign": 0.00043346534948796034
    },
    {
        "code": " static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n {\n \tstruct bpf_verifier_state *cur = env->cur_state;\n \tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n \terr = copy_verifier_state(&elem->st, cur);\n \tif (err)\n \t\tgoto err;\n \tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n \t\tverbose(env, \"BPF program is too complex\\n\");\n \t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "vul_func_with_fix": " static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n//flaw_line_below:\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n//fix_flaw_line_below:\n//\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n//fix_flaw_line_below:\n//\t\t\t\t\t     bool speculative)\n {\n \tstruct bpf_verifier_state *cur = env->cur_state;\n \tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n \terr = copy_verifier_state(&elem->st, cur);\n \tif (err)\n \t\tgoto err;\n//fix_flaw_line_below:\n//\telem->st.speculative |= speculative;\n \tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n \t\tverbose(env, \"BPF program is too complex\\n\");\n \t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}\n",
        "linevul": 0.999592125415802,
        "sysevr": 0.15655332803726196,
        "devign": 0.9536736607551575
    },
    {
        "code": "static int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t\t ext4_lblk_t end)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\text4_fsblk_t partial_cluster = 0;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\text_debug(\"truncate since %u to %u\\n\", start, end);\n\n\t/* probably first extent we're gonna free will be last in block */\n\thandle = ext4_journal_start(inode, depth + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\text4_ext_invalidate_cache(inode);\n\n\ttrace_ext4_ext_remove_space(inode, start, depth);\n\n\t/*\n\t * Check if we are removing extents inside the extent tree. If that\n\t * is the case, we are going to punch a hole inside the extent tree\n\t * so we have to check whether we need to split the extent covering\n\t * the last block to remove so we can easily remove the part of it\n\t * in ext4_ext_rm_leaf().\n\t */\n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block;\n\n\t\t/* find extent for this block */\n\t\tpath = ext4_ext_find_extent(inode, end, NULL);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t/* Leaf not may not exist only if inode has no blocks at all */\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\n\t\t/*\n\t\t * See if the last block is inside the extent, if so split\n\t\t * the extent at 'end' block so we can easily remove the\n\t\t * tail of the first part of the split extent in\n\t\t * ext4_ext_rm_leaf().\n\t\t */\n\t\tif (end >= ee_block &&\n\t\t    end < ee_block + ext4_ext_get_actual_len(ex) - 1) {\n\t\t\tint split_flag = 0;\n\n\t\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\t\tsplit_flag = EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t\t     EXT4_EXT_MARK_UNINIT2;\n\n\t\t\t/*\n\t\t\t * Split the extent in two so that 'end' is the last\n\t\t\t * block in the first new extent\n\t\t\t */\n\t\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\t\t\tend + 1, split_flag,\n\t\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO |\n\t\t\t\t\t\tEXT4_GET_BLOCKS_PUNCH_OUT_EXT);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * We start scanning from right side, freeing all the blocks\n\t * after i_size and walking into the tree depth-wise.\n\t */\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 1),\n\t\t\t       GFP_NOFS);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t/* this is leaf block */\n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,\n\t\t\t\t\t       &partial_cluster, start,\n\t\t\t\t\t       end);\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* this is index block */\n\t\tif (!path[i].p_hdr) {\n\t\t\text_debug(\"initialize header\\n\");\n\t\t\tpath[i].p_hdr = ext_block_hdr(path[i].p_bh);\n\t\t}\n\n\t\tif (!path[i].p_idx) {\n\t\t\t/* this level hasn't been touched yet */\n\t\t\tpath[i].p_idx = EXT_LAST_INDEX(path[i].p_hdr);\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries)+1;\n\t\t\text_debug(\"init index ptr: hdr 0x%p, num %d\\n\",\n\t\t\t\t  path[i].p_hdr,\n\t\t\t\t  le16_to_cpu(path[i].p_hdr->eh_entries));\n\t\t} else {\n\t\t\t/* we were already here, see at next index */\n\t\t\tpath[i].p_idx--;\n\t\t}\n\n\t\text_debug(\"level %d - index, first 0x%p, cur 0x%p\\n\",\n\t\t\t\ti, EXT_FIRST_INDEX(path[i].p_hdr),\n\t\t\t\tpath[i].p_idx);\n\t\tif (ext4_ext_more_to_rm(path + i)) {\n\t\t\tstruct buffer_head *bh;\n\t\t\t/* go to the next level */\n\t\t\text_debug(\"move to level %d (block %llu)\\n\",\n\t\t\t\t  i + 1, ext4_idx_pblock(path[i].p_idx));\n\t\t\tmemset(path + i + 1, 0, sizeof(*path));\n\t\t\tbh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));\n\t\t\tif (!bh) {\n\t\t\t\t/* should we reset i_size? */\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (WARN_ON(i + 1 > depth)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_ext_check_block(inode, ext_block_hdr(bh),\n\t\t\t\t\t\t\tdepth - i - 1, bh)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath[i + 1].p_bh = bh;\n\n\t\t\t/* save actual number of indexes since this\n\t\t\t * number is changed at the next iteration */\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries);\n\t\t\ti++;\n\t\t} else {\n\t\t\t/* we finished processing this index, go up */\n\t\t\tif (path[i].p_hdr->eh_entries == 0 && i > 0) {\n\t\t\t\t/* index is empty, remove it;\n\t\t\t\t * handle must be already prepared by the\n\t\t\t\t * truncatei_leaf() */\n\t\t\t\terr = ext4_ext_rm_idx(handle, inode, path + i);\n\t\t\t}\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\text_debug(\"return to level %d\\n\", i);\n\t\t}\n\t}\n\n\ttrace_ext4_ext_remove_space_done(inode, start, depth, partial_cluster,\n\t\t\tpath->p_hdr->eh_entries);\n\n\t/* If we still have something in the partial cluster and we have removed\n\t * even the first extent, then we should free the blocks in the partial\n\t * cluster as well. */\n\tif (partial_cluster && path->p_hdr->eh_entries == 0) {\n\t\tint flags = EXT4_FREE_BLOCKS_FORGET;\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t EXT4_C2B(EXT4_SB(sb), partial_cluster),\n\t\t\t\t EXT4_SB(sb)->s_cluster_ratio, flags);\n\t\tpartial_cluster = 0;\n\t}\n\n\t/* TODO: flexible tree reduction should be here */\n\tif (path->p_hdr->eh_entries == 0) {\n\t\t/*\n\t\t * truncate to zero freed all the tree,\n\t\t * so we need to correct eh_depth\n\t\t */\n\t\terr = ext4_ext_get_access(handle, inode, path);\n\t\tif (err == 0) {\n\t\t\text_inode_hdr(inode)->eh_depth = 0;\n\t\t\text_inode_hdr(inode)->eh_max =\n\t\t\t\tcpu_to_le16(ext4_ext_space_root(inode, 0));\n\t\t\terr = ext4_ext_dirty(handle, inode, path);\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (err == -EAGAIN) {\n\t\tpath = NULL;\n\t\tgoto again;\n\t}\n\text4_journal_stop(handle);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "vul_func_with_fix": "static int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t\t ext4_lblk_t end)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\text4_fsblk_t partial_cluster = 0;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\text_debug(\"truncate since %u to %u\\n\", start, end);\n\n\t/* probably first extent we're gonna free will be last in block */\n\thandle = ext4_journal_start(inode, depth + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\text4_ext_invalidate_cache(inode);\n\n\ttrace_ext4_ext_remove_space(inode, start, depth);\n\n\t/*\n\t * Check if we are removing extents inside the extent tree. If that\n\t * is the case, we are going to punch a hole inside the extent tree\n\t * so we have to check whether we need to split the extent covering\n\t * the last block to remove so we can easily remove the part of it\n\t * in ext4_ext_rm_leaf().\n\t */\n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block;\n\n\t\t/* find extent for this block */\n\t\tpath = ext4_ext_find_extent(inode, end, NULL);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t/* Leaf not may not exist only if inode has no blocks at all */\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\n\t\t/*\n\t\t * See if the last block is inside the extent, if so split\n\t\t * the extent at 'end' block so we can easily remove the\n\t\t * tail of the first part of the split extent in\n\t\t * ext4_ext_rm_leaf().\n\t\t */\n\t\tif (end >= ee_block &&\n\t\t    end < ee_block + ext4_ext_get_actual_len(ex) - 1) {\n\t\t\tint split_flag = 0;\n\n\t\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\t\tsplit_flag = EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t\t     EXT4_EXT_MARK_UNINIT2;\n\n\t\t\t/*\n\t\t\t * Split the extent in two so that 'end' is the last\n\t\t\t * block in the first new extent\n\t\t\t */\n\t\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\t\t\tend + 1, split_flag,\n\t\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO |\n\t\t\t\t\t\tEXT4_GET_BLOCKS_PUNCH_OUT_EXT);\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * We start scanning from right side, freeing all the blocks\n\t * after i_size and walking into the tree depth-wise.\n\t */\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 1),\n\t\t\t       GFP_NOFS);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t/* this is leaf block */\n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,\n\t\t\t\t\t       &partial_cluster, start,\n\t\t\t\t\t       end);\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* this is index block */\n\t\tif (!path[i].p_hdr) {\n\t\t\text_debug(\"initialize header\\n\");\n\t\t\tpath[i].p_hdr = ext_block_hdr(path[i].p_bh);\n\t\t}\n\n\t\tif (!path[i].p_idx) {\n\t\t\t/* this level hasn't been touched yet */\n\t\t\tpath[i].p_idx = EXT_LAST_INDEX(path[i].p_hdr);\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries)+1;\n\t\t\text_debug(\"init index ptr: hdr 0x%p, num %d\\n\",\n\t\t\t\t  path[i].p_hdr,\n\t\t\t\t  le16_to_cpu(path[i].p_hdr->eh_entries));\n\t\t} else {\n\t\t\t/* we were already here, see at next index */\n\t\t\tpath[i].p_idx--;\n\t\t}\n\n\t\text_debug(\"level %d - index, first 0x%p, cur 0x%p\\n\",\n\t\t\t\ti, EXT_FIRST_INDEX(path[i].p_hdr),\n\t\t\t\tpath[i].p_idx);\n\t\tif (ext4_ext_more_to_rm(path + i)) {\n\t\t\tstruct buffer_head *bh;\n\t\t\t/* go to the next level */\n\t\t\text_debug(\"move to level %d (block %llu)\\n\",\n\t\t\t\t  i + 1, ext4_idx_pblock(path[i].p_idx));\n\t\t\tmemset(path + i + 1, 0, sizeof(*path));\n\t\t\tbh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));\n\t\t\tif (!bh) {\n\t\t\t\t/* should we reset i_size? */\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (WARN_ON(i + 1 > depth)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ext4_ext_check_block(inode, ext_block_hdr(bh),\n\t\t\t\t\t\t\tdepth - i - 1, bh)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath[i + 1].p_bh = bh;\n\n\t\t\t/* save actual number of indexes since this\n\t\t\t * number is changed at the next iteration */\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries);\n\t\t\ti++;\n\t\t} else {\n\t\t\t/* we finished processing this index, go up */\n\t\t\tif (path[i].p_hdr->eh_entries == 0 && i > 0) {\n\t\t\t\t/* index is empty, remove it;\n\t\t\t\t * handle must be already prepared by the\n\t\t\t\t * truncatei_leaf() */\n\t\t\t\terr = ext4_ext_rm_idx(handle, inode, path + i);\n\t\t\t}\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\text_debug(\"return to level %d\\n\", i);\n\t\t}\n\t}\n\n\ttrace_ext4_ext_remove_space_done(inode, start, depth, partial_cluster,\n\t\t\tpath->p_hdr->eh_entries);\n\n\t/* If we still have something in the partial cluster and we have removed\n\t * even the first extent, then we should free the blocks in the partial\n\t * cluster as well. */\n\tif (partial_cluster && path->p_hdr->eh_entries == 0) {\n\t\tint flags = EXT4_FREE_BLOCKS_FORGET;\n\n\t\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t EXT4_C2B(EXT4_SB(sb), partial_cluster),\n\t\t\t\t EXT4_SB(sb)->s_cluster_ratio, flags);\n\t\tpartial_cluster = 0;\n\t}\n\n\t/* TODO: flexible tree reduction should be here */\n\tif (path->p_hdr->eh_entries == 0) {\n\t\t/*\n\t\t * truncate to zero freed all the tree,\n\t\t * so we need to correct eh_depth\n\t\t */\n\t\terr = ext4_ext_get_access(handle, inode, path);\n\t\tif (err == 0) {\n\t\t\text_inode_hdr(inode)->eh_depth = 0;\n\t\t\text_inode_hdr(inode)->eh_max =\n\t\t\t\tcpu_to_le16(ext4_ext_space_root(inode, 0));\n\t\t\terr = ext4_ext_dirty(handle, inode, path);\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tif (err == -EAGAIN) {\n\t\tpath = NULL;\n\t\tgoto again;\n\t}\n\text4_journal_stop(handle);\n\n\treturn err;\n}\n",
        "linevul": 9.865438914857805e-05,
        "sysevr": 0.33223220705986023,
        "devign": 8.742972166554674e-13
    },
    {
        "code": "static int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tinet_free_ifa(ifa);\n\t\treturn -ENOBUFS;\n\t}\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tif (ifa->ifa_dev != in_dev) {\n\t\tWARN_ON(ifa->ifa_dev);\n\t\tin_dev_hold(in_dev);\n\t\tifa->ifa_dev = in_dev;\n\t}\n\tif (ipv4_is_loopback(ifa->ifa_local))\n\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\treturn inet_insert_ifa(ifa);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2",
        "vul_func_with_fix": "static int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tinet_free_ifa(ifa);\n\t\treturn -ENOBUFS;\n\t}\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tif (ifa->ifa_dev != in_dev) {\n\t\tWARN_ON(ifa->ifa_dev);\n\t\tin_dev_hold(in_dev);\n\t\tifa->ifa_dev = in_dev;\n\t}\n\tif (ipv4_is_loopback(ifa->ifa_local))\n\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\treturn inet_insert_ifa(ifa);\n}\n",
        "linevul": 6.203357042977586e-05,
        "sysevr": 0.12806066870689392,
        "devign": 9.677638058329732e-14
    },
    {
        "code": "void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl, u32 pm1b_ctrl))\n{\n\t__acpi_os_prepare_sleep = func;\n}\n",
        "label": "0",
        "addr": "https://github.com/mjg59/linux/commit/a4a5ed2835e8ea042868b7401dced3f517cafa76",
        "vul_func_with_fix": "void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl, u32 pm1b_ctrl))\n{\n\t__acpi_os_prepare_sleep = func;\n}\n",
        "linevul": 6.009554272168316e-05,
        "sysevr": 0.1646568328142166,
        "devign": 2.552368641772773e-05
    },
    {
        "code": "static unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tint err;\n\n\t/*\n\t * We'd prefer to avoid failure later on in do_munmap:\n\t * which may split one vma into three before unmapping.\n\t */\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Advise KSM to break any KSM pages in the area to be moved:\n\t * it would be confusing if they were to turn up at the new\n\t * location, where they happen to coincide with different KSM\n\t * pages recently unmapped.  But leave vma->vm_flags as it was,\n\t * so KSM can come around to merge on vma and new_vma afterwards.\n\t */\n\terr = ksm_madvise(vma, old_addr, old_addr + old_len,\n\t\t\t\t\t\tMADV_UNMERGEABLE, &vm_flags);\n\tif (err)\n\t\treturn err;\n\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len);\n\tif (moved_len < old_len) {\n\t\t/*\n\t\t * On error, move entries back from new area to old,\n\t\t * which will succeed since page tables still there,\n\t\t * and then proceed to unmap new area instead of old.\n\t\t */\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = -ENOMEM;\n\t}\n\n\t/* Conceal VM_ACCOUNT so old reservation is not undone */\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\n\t/*\n\t * If we failed to move page tables we still do total_vm increment\n\t * since do_munmap() will decrement it by old_len == new_len.\n\t *\n\t * Since total_vm is about to be raised artificially high for a\n\t * moment, we need to restore high watermark afterwards: if stats\n\t * are taken meanwhile, total_vm and hiwater_vm appear too high.\n\t * If this were a serious issue, we'd add a flag to do_munmap().\n\t */\n\thiwater_vm = mm->hiwater_vm;\n\tmm->total_vm += new_len >> PAGE_SHIFT;\n\tvm_stat_account(mm, vma->vm_flags, vma->vm_file, new_len>>PAGE_SHIFT);\n\n\tif (do_munmap(mm, old_addr, old_len) < 0) {\n\t\t/* OOM: unable to split vma, just get accounts right */\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\n\t/* Restore VM_ACCOUNT if one or two pieces of vma left */\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\tif (new_len > old_len)\n\t\t\tmlock_vma_pages_range(new_vma, new_addr + old_len,\n\t\t\t\t\t\t       new_addr + new_len);\n\t}\n\n\treturn new_addr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/982134ba62618c2d69fbbbd166d0a11ee3b7e3d8",
        "vul_func_with_fix": "static unsigned long move_vma(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, unsigned long old_len,\n\t\tunsigned long new_len, unsigned long new_addr)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *new_vma;\n\tunsigned long vm_flags = vma->vm_flags;\n\tunsigned long new_pgoff;\n\tunsigned long moved_len;\n\tunsigned long excess = 0;\n\tunsigned long hiwater_vm;\n\tint split = 0;\n\tint err;\n\n\t/*\n\t * We'd prefer to avoid failure later on in do_munmap:\n\t * which may split one vma into three before unmapping.\n\t */\n\tif (mm->map_count >= sysctl_max_map_count - 3)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Advise KSM to break any KSM pages in the area to be moved:\n\t * it would be confusing if they were to turn up at the new\n\t * location, where they happen to coincide with different KSM\n\t * pages recently unmapped.  But leave vma->vm_flags as it was,\n\t * so KSM can come around to merge on vma and new_vma afterwards.\n\t */\n\terr = ksm_madvise(vma, old_addr, old_addr + old_len,\n\t\t\t\t\t\tMADV_UNMERGEABLE, &vm_flags);\n\tif (err)\n\t\treturn err;\n\n\tnew_pgoff = vma->vm_pgoff + ((old_addr - vma->vm_start) >> PAGE_SHIFT);\n\tnew_vma = copy_vma(&vma, new_addr, new_len, new_pgoff);\n\tif (!new_vma)\n\t\treturn -ENOMEM;\n\n\tmoved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len);\n\tif (moved_len < old_len) {\n\t\t/*\n\t\t * On error, move entries back from new area to old,\n\t\t * which will succeed since page tables still there,\n\t\t * and then proceed to unmap new area instead of old.\n\t\t */\n\t\tmove_page_tables(new_vma, new_addr, vma, old_addr, moved_len);\n\t\tvma = new_vma;\n\t\told_len = new_len;\n\t\told_addr = new_addr;\n\t\tnew_addr = -ENOMEM;\n\t}\n\n\t/* Conceal VM_ACCOUNT so old reservation is not undone */\n\tif (vm_flags & VM_ACCOUNT) {\n\t\tvma->vm_flags &= ~VM_ACCOUNT;\n\t\texcess = vma->vm_end - vma->vm_start - old_len;\n\t\tif (old_addr > vma->vm_start &&\n\t\t    old_addr + old_len < vma->vm_end)\n\t\t\tsplit = 1;\n\t}\n\n\t/*\n\t * If we failed to move page tables we still do total_vm increment\n\t * since do_munmap() will decrement it by old_len == new_len.\n\t *\n\t * Since total_vm is about to be raised artificially high for a\n\t * moment, we need to restore high watermark afterwards: if stats\n\t * are taken meanwhile, total_vm and hiwater_vm appear too high.\n\t * If this were a serious issue, we'd add a flag to do_munmap().\n\t */\n\thiwater_vm = mm->hiwater_vm;\n\tmm->total_vm += new_len >> PAGE_SHIFT;\n\tvm_stat_account(mm, vma->vm_flags, vma->vm_file, new_len>>PAGE_SHIFT);\n\n\tif (do_munmap(mm, old_addr, old_len) < 0) {\n\t\t/* OOM: unable to split vma, just get accounts right */\n\t\tvm_unacct_memory(excess >> PAGE_SHIFT);\n\t\texcess = 0;\n\t}\n\tmm->hiwater_vm = hiwater_vm;\n\n\t/* Restore VM_ACCOUNT if one or two pieces of vma left */\n\tif (excess) {\n\t\tvma->vm_flags |= VM_ACCOUNT;\n\t\tif (split)\n\t\t\tvma->vm_next->vm_flags |= VM_ACCOUNT;\n\t}\n\n\tif (vm_flags & VM_LOCKED) {\n\t\tmm->locked_vm += new_len >> PAGE_SHIFT;\n\t\tif (new_len > old_len)\n\t\t\tmlock_vma_pages_range(new_vma, new_addr + old_len,\n\t\t\t\t\t\t       new_addr + new_len);\n\t}\n\n\treturn new_addr;\n}\n",
        "linevul": 0.0031377009581774473,
        "sysevr": 0.22452323138713837,
        "devign": 2.3825490469420174e-09
    },
    {
        "code": "static __net_exit void ipv4_mib_exit_net(struct net *net)\n{\n\tkfree(net->mib.icmpmsg_statistics);\n\tfree_percpu(net->mib.icmp_statistics);\n\tfree_percpu(net->mib.udplite_statistics);\n\tfree_percpu(net->mib.udp_statistics);\n\tfree_percpu(net->mib.net_statistics);\n\tfree_percpu(net->mib.ip_statistics);\n\tfree_percpu(net->mib.tcp_statistics);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9",
        "vul_func_with_fix": "static __net_exit void ipv4_mib_exit_net(struct net *net)\n{\n\tkfree(net->mib.icmpmsg_statistics);\n\tfree_percpu(net->mib.icmp_statistics);\n\tfree_percpu(net->mib.udplite_statistics);\n\tfree_percpu(net->mib.udp_statistics);\n\tfree_percpu(net->mib.net_statistics);\n\tfree_percpu(net->mib.ip_statistics);\n\tfree_percpu(net->mib.tcp_statistics);\n}\n",
        "linevul": 6.0325099184410647e-05,
        "sysevr": 0.12350974231958389,
        "devign": 0.4823053777217865
    },
    {
        "code": "void exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4ea77014af0d6205b05503d1c7aac6eace11d473",
        "vul_func_with_fix": "void exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n",
        "linevul": 5.4638130677631125e-05,
        "sysevr": 0.17706556618213654,
        "devign": 0.1377653330564499
    },
    {
        "code": "static void *irias_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tspin_lock_irq(&irias_objects->hb_spinlock);\n\n\treturn *pos ? irias_seq_idx(*pos - 1) : SEQ_START_TOKEN;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846",
        "vul_func_with_fix": "static void *irias_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tspin_lock_irq(&irias_objects->hb_spinlock);\n\n\treturn *pos ? irias_seq_idx(*pos - 1) : SEQ_START_TOKEN;\n}\n",
        "linevul": 4.9049656809074804e-05,
        "sysevr": 0.13255371153354645,
        "devign": 0.0022210227325558662
    },
    {
        "code": "static bool exclusive_event_match(struct perf_event *e1, struct perf_event *e2)\n{\n\tif ((e1->pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE) &&\n\t    (e1->cpu == e2->cpu ||\n\t     e1->cpu == -1 ||\n\t     e2->cpu == -1))\n\t\treturn true;\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "vul_func_with_fix": "static bool exclusive_event_match(struct perf_event *e1, struct perf_event *e2)\n{\n\tif ((e1->pmu->capabilities & PERF_PMU_CAP_EXCLUSIVE) &&\n\t    (e1->cpu == e2->cpu ||\n\t     e1->cpu == -1 ||\n\t     e2->cpu == -1))\n\t\treturn true;\n\treturn false;\n}\n",
        "linevul": 5.0507256673881784e-05,
        "sysevr": 0.12794160842895508,
        "devign": 3.089395338740108e-15
    },
    {
        "code": "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b799207e1e1816b09e7a5920fbb2d5fcf6edd681",
        "vul_func_with_fix": "__printf(2, 3) void bpf_verifier_log_write(struct bpf_verifier_env *env,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}\n",
        "linevul": 4.872024874202907e-05,
        "sysevr": 0.16074511408805847,
        "devign": 0.33321595191955566
    },
    {
        "code": "void tcp_init_buffer_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint maxwin;\n\n\tif (!(sk->sk_userlocks & SOCK_RCVBUF_LOCK))\n\t\ttcp_fixup_rcvbuf(sk);\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\n\t\ttcp_sndbuf_expand(sk);\n\n\ttp->rcvq_space.space = tp->rcv_wnd;\n\ttp->rcvq_space.time = tcp_time_stamp;\n\ttp->rcvq_space.seq = tp->copied_seq;\n\n\tmaxwin = tcp_full_space(sk);\n\n\tif (tp->window_clamp >= maxwin) {\n\t\ttp->window_clamp = maxwin;\n\n\t\tif (sysctl_tcp_app_win && maxwin > 4 * tp->advmss)\n\t\t\ttp->window_clamp = max(maxwin -\n\t\t\t\t\t       (maxwin >> sysctl_tcp_app_win),\n\t\t\t\t\t       4 * tp->advmss);\n\t}\n\n\t/* Force reservation of one segment. */\n\tif (sysctl_tcp_app_win &&\n\t    tp->window_clamp > 2 * tp->advmss &&\n\t    tp->window_clamp + tp->advmss > maxwin)\n\t\ttp->window_clamp = max(2 * tp->advmss, maxwin - tp->advmss);\n\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758",
        "vul_func_with_fix": "void tcp_init_buffer_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint maxwin;\n\n\tif (!(sk->sk_userlocks & SOCK_RCVBUF_LOCK))\n\t\ttcp_fixup_rcvbuf(sk);\n\tif (!(sk->sk_userlocks & SOCK_SNDBUF_LOCK))\n\t\ttcp_sndbuf_expand(sk);\n\n\ttp->rcvq_space.space = tp->rcv_wnd;\n\ttp->rcvq_space.time = tcp_time_stamp;\n\ttp->rcvq_space.seq = tp->copied_seq;\n\n\tmaxwin = tcp_full_space(sk);\n\n\tif (tp->window_clamp >= maxwin) {\n\t\ttp->window_clamp = maxwin;\n\n\t\tif (sysctl_tcp_app_win && maxwin > 4 * tp->advmss)\n\t\t\ttp->window_clamp = max(maxwin -\n\t\t\t\t\t       (maxwin >> sysctl_tcp_app_win),\n\t\t\t\t\t       4 * tp->advmss);\n\t}\n\n\t/* Force reservation of one segment. */\n\tif (sysctl_tcp_app_win &&\n\t    tp->window_clamp > 2 * tp->advmss &&\n\t    tp->window_clamp + tp->advmss > maxwin)\n\t\ttp->window_clamp = max(2 * tp->advmss, maxwin - tp->advmss);\n\n\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, tp->window_clamp);\n\ttp->snd_cwnd_stamp = tcp_time_stamp;\n}\n",
        "linevul": 0.001562652993015945,
        "sysevr": 0.2632203996181488,
        "devign": 9.95717375218419e-09
    },
    {
        "code": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563",
        "vul_func_with_fix": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n",
        "linevul": 0.00028332986403256655,
        "sysevr": 0.1373966932296753,
        "devign": 6.555218899715323e-28
    },
    {
        "code": "void rtnl_register(int protocol, int msgtype,\n\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t   rtnl_calcit_func calcit)\n{\n\tif (__rtnl_register(protocol, msgtype, doit, dumpit, calcit) < 0)\n\t\tpanic(\"Unable to register rtnetlink message handler, \"\n\t\t      \"protocol = %d, message type = %d\\n\",\n\t\t      protocol, msgtype);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/84d73cd3fb142bf1298a8c13fd4ca50fd2432372",
        "vul_func_with_fix": "void rtnl_register(int protocol, int msgtype,\n\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t   rtnl_calcit_func calcit)\n{\n\tif (__rtnl_register(protocol, msgtype, doit, dumpit, calcit) < 0)\n\t\tpanic(\"Unable to register rtnetlink message handler, \"\n\t\t      \"protocol = %d, message type = %d\\n\",\n\t\t      protocol, msgtype);\n}\n",
        "linevul": 8.221522148232907e-05,
        "sysevr": 0.16103415191173553,
        "devign": 0.00014377373736351728
    },
    {
        "code": "static void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\n\t/* FOLL_DUMP will return -EFAULT on huge zero page */\n\tpage = follow_trans_huge_pmd(vma, addr, pmd, FOLL_DUMP);\n\tif (IS_ERR_OR_NULL(page))\n\t\treturn;\n\tmss->anonymous_thp += HPAGE_PMD_SIZE;\n\tsmaps_account(mss, page, HPAGE_PMD_SIZE,\n\t\t\tpmd_young(*pmd), pmd_dirty(*pmd));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce",
        "vul_func_with_fix": "static void smaps_pmd_entry(pmd_t *pmd, unsigned long addr,\n\t\tstruct mm_walk *walk)\n{\n\tstruct mem_size_stats *mss = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\n\t/* FOLL_DUMP will return -EFAULT on huge zero page */\n\tpage = follow_trans_huge_pmd(vma, addr, pmd, FOLL_DUMP);\n\tif (IS_ERR_OR_NULL(page))\n\t\treturn;\n\tmss->anonymous_thp += HPAGE_PMD_SIZE;\n\tsmaps_account(mss, page, HPAGE_PMD_SIZE,\n\t\t\tpmd_young(*pmd), pmd_dirty(*pmd));\n}\n",
        "linevul": 5.5883963796077296e-05,
        "sysevr": 0.11843029409646988,
        "devign": 1.1382086739786246e-07
    },
    {
        "code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n \n \tkey = key_ref_to_ptr(key_ref);\n \n \t/* see if we can read it directly */\n \tret = key_permission(key_ref, KEY_NEED_READ);\n \tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678",
        "vul_func_with_fix": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n \n \tkey = key_ref_to_ptr(key_ref);\n \n//fix_flaw_line_below:\n//\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n//fix_flaw_line_below:\n//\t\tret = -ENOKEY;\n//fix_flaw_line_below:\n//\t\tgoto error2;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \t/* see if we can read it directly */\n \tret = key_permission(key_ref, KEY_NEED_READ);\n \tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n",
        "linevul": 0.9995459914207458,
        "sysevr": 0.26383137702941895,
        "devign": 0.6767660975456238
    },
    {
        "code": "static int _nfs4_do_open(struct inode *dir,\n\t\t\tstruct nfs_open_context *ctx,\n\t\t\tint flags,\n\t\t\tstruct iattr *sattr,\n\t\t\tstruct nfs4_label *label,\n\t\t\tint *opened)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tstruct dentry *dentry = ctx->dentry;\n\tstruct rpc_cred *cred = ctx->cred;\n\tstruct nfs4_threshold **ctx_th = &ctx->mdsthreshold;\n\tfmode_t fmode = ctx->mode & (FMODE_READ|FMODE_WRITE|FMODE_EXEC);\n\tenum open_claim_type4 claim = NFS4_OPEN_CLAIM_NULL;\n\tstruct nfs4_label *olabel = NULL;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tsp = nfs4_get_state_owner(server, cred, GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (d_really_is_positive(dentry))\n\t\tnfs4_return_incompatible_delegation(d_inode(dentry), fmode);\n\tstatus = -ENOMEM;\n\tif (d_really_is_positive(dentry))\n\t\tclaim = NFS4_OPEN_CLAIM_FH;\n\topendata = nfs4_opendata_alloc(dentry, sp, fmode, flags, sattr,\n\t\t\tlabel, claim, GFP_KERNEL);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (label) {\n\t\tolabel = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(olabel)) {\n\t\t\tstatus = PTR_ERR(olabel);\n\t\t\tgoto err_opendata_put;\n\t\t}\n\t}\n\n\tif (server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\tif (!opendata->f_attr.mdsthreshold) {\n\t\t\topendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();\n\t\t\tif (!opendata->f_attr.mdsthreshold)\n\t\t\t\tgoto err_free_label;\n\t\t}\n\t\topendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];\n\t}\n\tif (d_really_is_positive(dentry))\n\t\topendata->state = nfs4_get_open_state(d_inode(dentry), sp);\n\n\tstatus = _nfs4_open_and_get_state(opendata, fmode, flags, ctx);\n\tif (status != 0)\n\t\tgoto err_free_label;\n\tstate = ctx->state;\n\n\tif ((opendata->o_arg.open_flags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) &&\n\t    (opendata->o_arg.createmode != NFS4_CREATE_GUARDED)) {\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\n\t\tnfs_fattr_init(opendata->o_res.f_attr);\n\t\tstatus = nfs4_do_setattr(state->inode, cred,\n\t\t\t\topendata->o_res.f_attr, sattr,\n\t\t\t\tstate, label, olabel);\n\t\tif (status == 0) {\n\t\t\tnfs_setattr_update_inode(state->inode, sattr,\n\t\t\t\t\topendata->o_res.f_attr);\n\t\t\tnfs_setsecurity(state->inode, opendata->o_res.f_attr, olabel);\n\t\t}\n\t}\n\tif (opendata->file_created)\n\t\t*opened |= FILE_CREATED;\n\n\tif (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server)) {\n\t\t*ctx_th = opendata->f_attr.mdsthreshold;\n\t\topendata->f_attr.mdsthreshold = NULL;\n\t}\n\n\tnfs4_label_free(olabel);\n\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\treturn 0;\nerr_free_label:\n\tnfs4_label_free(olabel);\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static int _nfs4_do_open(struct inode *dir,\n\t\t\tstruct nfs_open_context *ctx,\n\t\t\tint flags,\n\t\t\tstruct iattr *sattr,\n\t\t\tstruct nfs4_label *label,\n\t\t\tint *opened)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tstruct dentry *dentry = ctx->dentry;\n\tstruct rpc_cred *cred = ctx->cred;\n\tstruct nfs4_threshold **ctx_th = &ctx->mdsthreshold;\n\tfmode_t fmode = ctx->mode & (FMODE_READ|FMODE_WRITE|FMODE_EXEC);\n\tenum open_claim_type4 claim = NFS4_OPEN_CLAIM_NULL;\n\tstruct nfs4_label *olabel = NULL;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tsp = nfs4_get_state_owner(server, cred, GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (d_really_is_positive(dentry))\n\t\tnfs4_return_incompatible_delegation(d_inode(dentry), fmode);\n\tstatus = -ENOMEM;\n\tif (d_really_is_positive(dentry))\n\t\tclaim = NFS4_OPEN_CLAIM_FH;\n\topendata = nfs4_opendata_alloc(dentry, sp, fmode, flags, sattr,\n\t\t\tlabel, claim, GFP_KERNEL);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (label) {\n\t\tolabel = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(olabel)) {\n\t\t\tstatus = PTR_ERR(olabel);\n\t\t\tgoto err_opendata_put;\n\t\t}\n\t}\n\n\tif (server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\tif (!opendata->f_attr.mdsthreshold) {\n\t\t\topendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();\n\t\t\tif (!opendata->f_attr.mdsthreshold)\n\t\t\t\tgoto err_free_label;\n\t\t}\n\t\topendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];\n\t}\n\tif (d_really_is_positive(dentry))\n\t\topendata->state = nfs4_get_open_state(d_inode(dentry), sp);\n\n\tstatus = _nfs4_open_and_get_state(opendata, fmode, flags, ctx);\n\tif (status != 0)\n\t\tgoto err_free_label;\n\tstate = ctx->state;\n\n\tif ((opendata->o_arg.open_flags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) &&\n\t    (opendata->o_arg.createmode != NFS4_CREATE_GUARDED)) {\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\n\t\tnfs_fattr_init(opendata->o_res.f_attr);\n\t\tstatus = nfs4_do_setattr(state->inode, cred,\n\t\t\t\topendata->o_res.f_attr, sattr,\n\t\t\t\tstate, label, olabel);\n\t\tif (status == 0) {\n\t\t\tnfs_setattr_update_inode(state->inode, sattr,\n\t\t\t\t\topendata->o_res.f_attr);\n\t\t\tnfs_setsecurity(state->inode, opendata->o_res.f_attr, olabel);\n\t\t}\n\t}\n\tif (opendata->file_created)\n\t\t*opened |= FILE_CREATED;\n\n\tif (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server)) {\n\t\t*ctx_th = opendata->f_attr.mdsthreshold;\n\t\topendata->f_attr.mdsthreshold = NULL;\n\t}\n\n\tnfs4_label_free(olabel);\n\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\treturn 0;\nerr_free_label:\n\tnfs4_label_free(olabel);\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\treturn status;\n}\n",
        "linevul": 0.0004115904157515615,
        "sysevr": 0.15002037584781647,
        "devign": 5.518499391572817e-17
    },
    {
        "code": "static struct usb_function_instance *f_midi_alloc_inst(void)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_midi_free_inst;\n\topts->index = SNDRV_DEFAULT_IDX1;\n\topts->id = SNDRV_DEFAULT_STR1;\n\topts->buflen = 512;\n\topts->qlen = 32;\n\topts->in_ports = 1;\n\topts->out_ports = 1;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &midi_func_type);\n\n\treturn &opts->func_inst;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f",
        "vul_func_with_fix": "static struct usb_function_instance *f_midi_alloc_inst(void)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_midi_free_inst;\n\topts->index = SNDRV_DEFAULT_IDX1;\n\topts->id = SNDRV_DEFAULT_STR1;\n\topts->buflen = 512;\n\topts->qlen = 32;\n\topts->in_ports = 1;\n\topts->out_ports = 1;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &midi_func_type);\n\n\treturn &opts->func_inst;\n}\n",
        "linevul": 8.85907793417573e-05,
        "sysevr": 0.17137311398983002,
        "devign": 7.964792020365152e-12
    },
    {
        "code": "static void __perf_event_mark_enabled(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= PERF_EVENT_STATE_INACTIVE)\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void __perf_event_mark_enabled(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= PERF_EVENT_STATE_INACTIVE)\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t}\n}\n",
        "linevul": 4.884758163825609e-05,
        "sysevr": 0.1403161734342575,
        "devign": 3.3952517880520006e-11
    },
    {
        "code": "static inline void maybe_flush_windows(unsigned int rs1, unsigned int rs2,\n\t\t\t\t       unsigned int rd)\n{\n\tif(rs2 >= 16 || rs1 >= 16 || rd >= 16) {\n\t\t/* Wheee... */\n\t\t__asm__ __volatile__(\"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"restore; restore; restore; restore;\\n\\t\"\n\t\t\t\t     \"restore; restore; restore;\\n\\t\");\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline void maybe_flush_windows(unsigned int rs1, unsigned int rs2,\n\t\t\t\t       unsigned int rd)\n{\n\tif(rs2 >= 16 || rs1 >= 16 || rd >= 16) {\n\t\t/* Wheee... */\n\t\t__asm__ __volatile__(\"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"save %sp, -0x40, %sp\\n\\t\"\n\t\t\t\t     \"restore; restore; restore; restore;\\n\\t\"\n\t\t\t\t     \"restore; restore; restore;\\n\\t\");\n\t}\n}\n",
        "linevul": 5.493414937518537e-05,
        "sysevr": 0.11871132999658585,
        "devign": 0.0057958816178143024
    },
    {
        "code": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\t--sp->unsync_children;\n\t\tWARN_ON((int)sp->unsync_children < 0);\n\t\t__clear_bit(idx, sp->unsync_child_bitmap);\n\t\tlevel++;\n\t} while (level < PT64_ROOT_LEVEL-1 && !sp->unsync_children);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\t--sp->unsync_children;\n\t\tWARN_ON((int)sp->unsync_children < 0);\n\t\t__clear_bit(idx, sp->unsync_child_bitmap);\n\t\tlevel++;\n\t} while (level < PT64_ROOT_LEVEL-1 && !sp->unsync_children);\n}\n",
        "linevul": 5.762285218224861e-05,
        "sysevr": 0.12766818702220917,
        "devign": 4.471123915550379e-09
    },
    {
        "code": "int nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = lrp->clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "int nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = lrp->clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n",
        "linevul": 6.680444494122639e-05,
        "sysevr": 0.24105161428451538,
        "devign": 4.6377309322786054e-23
    },
    {
        "code": "void update_cr_regs(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tstruct thread_struct *thread = &task->thread;\n\tstruct per_regs old, new;\n\n#ifdef CONFIG_64BIT\n\t/* Take care of the enable/disable of transactional execution. */\n\tif (MACHINE_HAS_TE) {\n\t\tunsigned long cr, cr_new;\n\n\t\t__ctl_store(cr, 0, 0);\n\t\t/* Set or clear transaction execution TXC bit 8. */\n\t\tcr_new = cr | (1UL << 55);\n\t\tif (task->thread.per_flags & PER_FLAG_NO_TE)\n\t\t\tcr_new &= ~(1UL << 55);\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 0, 0);\n\t\t/* Set or clear transaction execution TDC bits 62 and 63. */\n\t\t__ctl_store(cr, 2, 2);\n\t\tcr_new = cr & ~3UL;\n\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND) {\n\t\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND_TEND)\n\t\t\t\tcr_new |= 1UL;\n\t\t\telse\n\t\t\t\tcr_new |= 2UL;\n\t\t}\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 2, 2);\n\t}\n#endif\n\t/* Copy user specified PER registers */\n\tnew.control = thread->per_user.control;\n\tnew.start = thread->per_user.start;\n\tnew.end = thread->per_user.end;\n\n\t/* merge TIF_SINGLE_STEP into user specified PER registers. */\n\tif (test_tsk_thread_flag(task, TIF_SINGLE_STEP)) {\n\t\tif (test_tsk_thread_flag(task, TIF_BLOCK_STEP))\n\t\t\tnew.control |= PER_EVENT_BRANCH;\n\t\telse\n\t\t\tnew.control |= PER_EVENT_IFETCH;\n#ifdef CONFIG_64BIT\n\t\tnew.control |= PER_CONTROL_SUSPENSION;\n\t\tnew.control |= PER_EVENT_TRANSACTION_END;\n#endif\n\t\tnew.start = 0;\n\t\tnew.end = PSW_ADDR_INSN;\n\t}\n\n\t/* Take care of the PER enablement bit in the PSW. */\n\tif (!(new.control & PER_EVENT_MASK)) {\n\t\tregs->psw.mask &= ~PSW_MASK_PER;\n\t\treturn;\n\t}\n\tregs->psw.mask |= PSW_MASK_PER;\n\t__ctl_store(old, 9, 11);\n\tif (memcmp(&new, &old, sizeof(struct per_regs)) != 0)\n\t\t__ctl_load(new, 9, 11);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dab6cf55f81a6e16b8147aed9a843e1691dcd318",
        "vul_func_with_fix": "void update_cr_regs(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tstruct thread_struct *thread = &task->thread;\n\tstruct per_regs old, new;\n\n#ifdef CONFIG_64BIT\n\t/* Take care of the enable/disable of transactional execution. */\n\tif (MACHINE_HAS_TE) {\n\t\tunsigned long cr, cr_new;\n\n\t\t__ctl_store(cr, 0, 0);\n\t\t/* Set or clear transaction execution TXC bit 8. */\n\t\tcr_new = cr | (1UL << 55);\n\t\tif (task->thread.per_flags & PER_FLAG_NO_TE)\n\t\t\tcr_new &= ~(1UL << 55);\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 0, 0);\n\t\t/* Set or clear transaction execution TDC bits 62 and 63. */\n\t\t__ctl_store(cr, 2, 2);\n\t\tcr_new = cr & ~3UL;\n\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND) {\n\t\t\tif (task->thread.per_flags & PER_FLAG_TE_ABORT_RAND_TEND)\n\t\t\t\tcr_new |= 1UL;\n\t\t\telse\n\t\t\t\tcr_new |= 2UL;\n\t\t}\n\t\tif (cr_new != cr)\n\t\t\t__ctl_load(cr_new, 2, 2);\n\t}\n#endif\n\t/* Copy user specified PER registers */\n\tnew.control = thread->per_user.control;\n\tnew.start = thread->per_user.start;\n\tnew.end = thread->per_user.end;\n\n\t/* merge TIF_SINGLE_STEP into user specified PER registers. */\n\tif (test_tsk_thread_flag(task, TIF_SINGLE_STEP)) {\n\t\tif (test_tsk_thread_flag(task, TIF_BLOCK_STEP))\n\t\t\tnew.control |= PER_EVENT_BRANCH;\n\t\telse\n\t\t\tnew.control |= PER_EVENT_IFETCH;\n#ifdef CONFIG_64BIT\n\t\tnew.control |= PER_CONTROL_SUSPENSION;\n\t\tnew.control |= PER_EVENT_TRANSACTION_END;\n#endif\n\t\tnew.start = 0;\n\t\tnew.end = PSW_ADDR_INSN;\n\t}\n\n\t/* Take care of the PER enablement bit in the PSW. */\n\tif (!(new.control & PER_EVENT_MASK)) {\n\t\tregs->psw.mask &= ~PSW_MASK_PER;\n\t\treturn;\n\t}\n\tregs->psw.mask |= PSW_MASK_PER;\n\t__ctl_store(old, 9, 11);\n\tif (memcmp(&new, &old, sizeof(struct per_regs)) != 0)\n\t\t__ctl_load(new, 9, 11);\n}\n",
        "linevul": 8.095319935819134e-05,
        "sysevr": 0.2497854232788086,
        "devign": 2.727290171478103e-09
    },
    {
        "code": "static int nfs4_xattr_set_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   const void *buf, size_t buflen,\n\t\t\t\t   int flags, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_set_acl(d_inode(dentry), buf, buflen);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static int nfs4_xattr_set_nfs4_acl(struct dentry *dentry, const char *key,\n\t\t\t\t   const void *buf, size_t buflen,\n\t\t\t\t   int flags, int type)\n{\n\tif (strcmp(key, \"\") != 0)\n\t\treturn -EINVAL;\n\n\treturn nfs4_proc_set_acl(d_inode(dentry), buf, buflen);\n}\n",
        "linevul": 8.112127397907898e-05,
        "sysevr": 0.1314249485731125,
        "devign": 4.1794385730042904e-09
    },
    {
        "code": "static ssize_t ocfs2_file_write_iter(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from)\n{\n\tint direct_io, rw_level;\n\tssize_t written = 0;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(from);\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\t\t       OCFS2_MOUNT_COHERENCY_BUFFERED);\n\tvoid *saved_ki_complete = NULL;\n\tint append_write = ((iocb->ki_pos + count) >=\n\t\t\ti_size_read(inode) ? 1 : 0);\n\n\ttrace_ocfs2_file_aio_write(inode, file, file->f_path.dentry,\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tfile->f_path.dentry->d_name.len,\n\t\tfile->f_path.dentry->d_name.name,\n\t\t(unsigned int)from->nr_segs);\t/* GRRRRR */\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tdirect_io = iocb->ki_flags & IOCB_DIRECT ? 1 : 0;\n\n\tinode_lock(inode);\n\n\t/*\n\t * Concurrent O_DIRECT writes are allowed with\n\t * mount_option \"coherency=buffered\".\n\t * For append write, we must take rw EX.\n\t */\n\trw_level = (!direct_io || full_coherency || append_write);\n\n\tret = ocfs2_rw_lock(inode, rw_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\t/*\n\t * O_DIRECT writes with \"coherency=full\" need to take EX cluster\n\t * inode_lock to guarantee coherency.\n\t */\n\tif (direct_io && full_coherency) {\n\t\t/*\n\t\t * We need to take and drop the inode lock to force\n\t\t * other nodes to drop their caches.  Buffered I/O\n\t\t * already does this in write_begin().\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_inode_unlock(inode, 1);\n\t}\n\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0) {\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tcount = ret;\n\n\tret = ocfs2_prepare_inode_for_write(file, iocb->ki_pos, count);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (direct_io && !is_sync_kiocb(iocb) &&\n\t    ocfs2_is_io_unaligned(inode, count, iocb->ki_pos)) {\n\t\t/*\n\t\t * Make it a sync io if it's an unaligned aio.\n\t\t */\n\t\tsaved_ki_complete = xchg(&iocb->ki_complete, NULL);\n\t}\n\n\t/* communicate with ocfs2_dio_end_io */\n\tocfs2_iocb_set_rw_locked(iocb, rw_level);\n\n\twritten = __generic_file_write_iter(iocb, from);\n\t/* buffered aio wouldn't have proper lock coverage today */\n\tBUG_ON(written == -EIOCBQUEUED && !(iocb->ki_flags & IOCB_DIRECT));\n\n\t/*\n\t * deep in g_f_a_w_n()->ocfs2_direct_IO we pass in a ocfs2_dio_end_io\n\t * function pointer which is called when o_direct io completes so that\n\t * it can unlock our rw lock.\n\t * Unfortunately there are error cases which call end_io and others\n\t * that don't.  so we don't have to unlock the rw_lock if either an\n\t * async dio is going to do it in the future or an end_io after an\n\t * error has already done it.\n\t */\n\tif ((written == -EIOCBQUEUED) || (!ocfs2_iocb_is_rw_locked(iocb))) {\n\t\trw_level = -1;\n\t}\n\n\tif (unlikely(written <= 0))\n\t\tgoto out;\n\n\tif (((file->f_flags & O_DSYNC) && !direct_io) ||\n\t    IS_SYNC(inode)) {\n\t\tret = filemap_fdatawrite_range(file->f_mapping,\n\t\t\t\t\t       iocb->ki_pos - written,\n\t\t\t\t\t       iocb->ki_pos - 1);\n\t\tif (ret < 0)\n\t\t\twritten = ret;\n\n\t\tif (!ret) {\n\t\t\tret = jbd2_journal_force_commit(osb->journal->j_journal);\n\t\t\tif (ret < 0)\n\t\t\t\twritten = ret;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = filemap_fdatawait_range(file->f_mapping,\n\t\t\t\t\t\t      iocb->ki_pos - written,\n\t\t\t\t\t\t      iocb->ki_pos - 1);\n\t}\n\nout:\n\tif (saved_ki_complete)\n\t\txchg(&iocb->ki_complete, saved_ki_complete);\n\n\tif (rw_level != -1)\n\t\tocfs2_rw_unlock(inode, rw_level);\n\nout_mutex:\n\tinode_unlock(inode);\n\n\tif (written)\n\t\tret = written;\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/28f5a8a7c033cbf3e32277f4cc9c6afd74f05300",
        "vul_func_with_fix": "static ssize_t ocfs2_file_write_iter(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from)\n{\n\tint direct_io, rw_level;\n\tssize_t written = 0;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(from);\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\t\t       OCFS2_MOUNT_COHERENCY_BUFFERED);\n\tvoid *saved_ki_complete = NULL;\n\tint append_write = ((iocb->ki_pos + count) >=\n\t\t\ti_size_read(inode) ? 1 : 0);\n\n\ttrace_ocfs2_file_aio_write(inode, file, file->f_path.dentry,\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tfile->f_path.dentry->d_name.len,\n\t\tfile->f_path.dentry->d_name.name,\n\t\t(unsigned int)from->nr_segs);\t/* GRRRRR */\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tdirect_io = iocb->ki_flags & IOCB_DIRECT ? 1 : 0;\n\n\tinode_lock(inode);\n\n\t/*\n\t * Concurrent O_DIRECT writes are allowed with\n\t * mount_option \"coherency=buffered\".\n\t * For append write, we must take rw EX.\n\t */\n\trw_level = (!direct_io || full_coherency || append_write);\n\n\tret = ocfs2_rw_lock(inode, rw_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\t/*\n\t * O_DIRECT writes with \"coherency=full\" need to take EX cluster\n\t * inode_lock to guarantee coherency.\n\t */\n\tif (direct_io && full_coherency) {\n\t\t/*\n\t\t * We need to take and drop the inode lock to force\n\t\t * other nodes to drop their caches.  Buffered I/O\n\t\t * already does this in write_begin().\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_inode_unlock(inode, 1);\n\t}\n\n\tret = generic_write_checks(iocb, from);\n\tif (ret <= 0) {\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tcount = ret;\n\n\tret = ocfs2_prepare_inode_for_write(file, iocb->ki_pos, count);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (direct_io && !is_sync_kiocb(iocb) &&\n\t    ocfs2_is_io_unaligned(inode, count, iocb->ki_pos)) {\n\t\t/*\n\t\t * Make it a sync io if it's an unaligned aio.\n\t\t */\n\t\tsaved_ki_complete = xchg(&iocb->ki_complete, NULL);\n\t}\n\n\t/* communicate with ocfs2_dio_end_io */\n\tocfs2_iocb_set_rw_locked(iocb, rw_level);\n\n\twritten = __generic_file_write_iter(iocb, from);\n\t/* buffered aio wouldn't have proper lock coverage today */\n\tBUG_ON(written == -EIOCBQUEUED && !(iocb->ki_flags & IOCB_DIRECT));\n\n\t/*\n\t * deep in g_f_a_w_n()->ocfs2_direct_IO we pass in a ocfs2_dio_end_io\n\t * function pointer which is called when o_direct io completes so that\n\t * it can unlock our rw lock.\n\t * Unfortunately there are error cases which call end_io and others\n\t * that don't.  so we don't have to unlock the rw_lock if either an\n\t * async dio is going to do it in the future or an end_io after an\n\t * error has already done it.\n\t */\n\tif ((written == -EIOCBQUEUED) || (!ocfs2_iocb_is_rw_locked(iocb))) {\n\t\trw_level = -1;\n\t}\n\n\tif (unlikely(written <= 0))\n\t\tgoto out;\n\n\tif (((file->f_flags & O_DSYNC) && !direct_io) ||\n\t    IS_SYNC(inode)) {\n\t\tret = filemap_fdatawrite_range(file->f_mapping,\n\t\t\t\t\t       iocb->ki_pos - written,\n\t\t\t\t\t       iocb->ki_pos - 1);\n\t\tif (ret < 0)\n\t\t\twritten = ret;\n\n\t\tif (!ret) {\n\t\t\tret = jbd2_journal_force_commit(osb->journal->j_journal);\n\t\t\tif (ret < 0)\n\t\t\t\twritten = ret;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = filemap_fdatawait_range(file->f_mapping,\n\t\t\t\t\t\t      iocb->ki_pos - written,\n\t\t\t\t\t\t      iocb->ki_pos - 1);\n\t}\n\nout:\n\tif (saved_ki_complete)\n\t\txchg(&iocb->ki_complete, saved_ki_complete);\n\n\tif (rw_level != -1)\n\t\tocfs2_rw_unlock(inode, rw_level);\n\nout_mutex:\n\tinode_unlock(inode);\n\n\tif (written)\n\t\tret = written;\n\treturn ret;\n}\n",
        "linevul": 0.000739433104172349,
        "sysevr": 0.18493783473968506,
        "devign": 0.0005887091974727809
    },
    {
        "code": "static ssize_t clear_refs_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tenum clear_refs_types type;\n\tstruct mmu_gather tlb;\n\tint itype;\n\tint rv;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 10, &itype);\n\tif (rv < 0)\n\t\treturn rv;\n\ttype = (enum clear_refs_types)itype;\n\tif (type < CLEAR_REFS_ALL || type >= CLEAR_REFS_LAST)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tstruct mmu_notifier_range range;\n\t\tstruct clear_refs_private cp = {\n\t\t\t.type = type,\n\t\t};\n\t\tstruct mm_walk clear_refs_walk = {\n\t\t\t.pmd_entry = clear_refs_pte_range,\n\t\t\t.test_walk = clear_refs_test_walk,\n\t\t\t.mm = mm,\n\t\t\t.private = &cp,\n\t\t};\n\n\t\tif (type == CLEAR_REFS_MM_HIWATER_RSS) {\n\t\t\tif (down_write_killable(&mm->mmap_sem)) {\n\t\t\t\tcount = -EINTR;\n\t\t\t\tgoto out_mm;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Writing 5 to /proc/pid/clear_refs resets the peak\n\t\t\t * resident set size to this mm's current rss value.\n\t\t\t */\n\t\t\treset_mm_hiwater_rss(mm);\n\t\t\tup_write(&mm->mmap_sem);\n\t\t\tgoto out_mm;\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\t\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\tif (!(vma->vm_flags & VM_SOFTDIRTY))\n\t\t\t\t\tcontinue;\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tif (down_write_killable(&mm->mmap_sem)) {\n \t\t\t\t\tcount = -EINTR;\n \t\t\t\t\tgoto out_mm;\n \t\t\t\t}\n \t\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n \t\t\t\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n \t\t\t\t\tvma_set_page_prot(vma);\n\t\t\t\t}\n\t\t\t\tdowngrade_write(&mm->mmap_sem);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmmu_notifier_range_init(&range, mm, 0, -1UL);\n\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t}\n\t\twalk_page_range(0, mm->highest_vm_end, &clear_refs_walk);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY)\n\t\t\tmmu_notifier_invalidate_range_end(&range);\n\t\ttlb_finish_mmu(&tlb, 0, -1);\n\t\tup_read(&mm->mmap_sem);\nout_mm:\n\t\tmmput(mm);\n\t}\n\tput_task_struct(task);\n\n\treturn count;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a",
        "vul_func_with_fix": "static ssize_t clear_refs_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tenum clear_refs_types type;\n\tstruct mmu_gather tlb;\n\tint itype;\n\tint rv;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 10, &itype);\n\tif (rv < 0)\n\t\treturn rv;\n\ttype = (enum clear_refs_types)itype;\n\tif (type < CLEAR_REFS_ALL || type >= CLEAR_REFS_LAST)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tstruct mmu_notifier_range range;\n\t\tstruct clear_refs_private cp = {\n\t\t\t.type = type,\n\t\t};\n\t\tstruct mm_walk clear_refs_walk = {\n\t\t\t.pmd_entry = clear_refs_pte_range,\n\t\t\t.test_walk = clear_refs_test_walk,\n\t\t\t.mm = mm,\n\t\t\t.private = &cp,\n\t\t};\n\n\t\tif (type == CLEAR_REFS_MM_HIWATER_RSS) {\n\t\t\tif (down_write_killable(&mm->mmap_sem)) {\n\t\t\t\tcount = -EINTR;\n\t\t\t\tgoto out_mm;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Writing 5 to /proc/pid/clear_refs resets the peak\n\t\t\t * resident set size to this mm's current rss value.\n\t\t\t */\n\t\t\treset_mm_hiwater_rss(mm);\n\t\t\tup_write(&mm->mmap_sem);\n\t\t\tgoto out_mm;\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\t\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\tif (!(vma->vm_flags & VM_SOFTDIRTY))\n\t\t\t\t\tcontinue;\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tif (down_write_killable(&mm->mmap_sem)) {\n \t\t\t\t\tcount = -EINTR;\n \t\t\t\t\tgoto out_mm;\n \t\t\t\t}\n//fix_flaw_line_below:\n//\t\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t\t * Avoid to modify vma->vm_flags\n//fix_flaw_line_below:\n//\t\t\t\t * without locked ops while the\n//fix_flaw_line_below:\n//\t\t\t\t * coredump reads the vm_flags.\n//fix_flaw_line_below:\n//\t\t\t\t */\n//fix_flaw_line_below:\n//\t\t\t\tif (!mmget_still_valid(mm)) {\n//fix_flaw_line_below:\n//\t\t\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t\t\t * Silently return \"count\"\n//fix_flaw_line_below:\n//\t\t\t\t\t * like if get_task_mm()\n//fix_flaw_line_below:\n//\t\t\t\t\t * failed. FIXME: should this\n//fix_flaw_line_below:\n//\t\t\t\t\t * function have returned\n//fix_flaw_line_below:\n//\t\t\t\t\t * -ESRCH if get_task_mm()\n//fix_flaw_line_below:\n//\t\t\t\t\t * failed like if\n//fix_flaw_line_below:\n//\t\t\t\t\t * get_proc_task() fails?\n//fix_flaw_line_below:\n//\t\t\t\t\t */\n//fix_flaw_line_below:\n//\t\t\t\t\tup_write(&mm->mmap_sem);\n//fix_flaw_line_below:\n//\t\t\t\t\tgoto out_mm;\n//fix_flaw_line_below:\n//\t\t\t\t}\n \t\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n \t\t\t\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n \t\t\t\t\tvma_set_page_prot(vma);\n\t\t\t\t}\n\t\t\t\tdowngrade_write(&mm->mmap_sem);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmmu_notifier_range_init(&range, mm, 0, -1UL);\n\t\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t}\n\t\twalk_page_range(0, mm->highest_vm_end, &clear_refs_walk);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY)\n\t\t\tmmu_notifier_invalidate_range_end(&range);\n\t\ttlb_finish_mmu(&tlb, 0, -1);\n\t\tup_read(&mm->mmap_sem);\nout_mm:\n\t\tmmput(mm);\n\t}\n\tput_task_struct(task);\n\n\treturn count;\n}\n",
        "linevul": 0.14574702084064484,
        "sysevr": 0.17853382229804993,
        "devign": 0.6245700716972351
    },
    {
        "code": "int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1d1221f375c94ef961ba8574ac4f85c8870ddd51",
        "vul_func_with_fix": "int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr;\n\tstruct task_struct *reaper;\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\tgoto out_no_task;\n\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\n\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}\n",
        "linevul": 0.0002600775915198028,
        "sysevr": 0.17489568889141083,
        "devign": 2.225212678471608e-26
    },
    {
        "code": "static ssize_t ucma_accept(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_accept cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (cmd.conn_param.valid) {\n\t\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\t\tmutex_lock(&file->mut);\n\t\tret = rdma_accept(ctx->cm_id, &conn_param);\n\t\tif (!ret)\n\t\t\tctx->uid = cmd.uid;\n\t\tmutex_unlock(&file->mut);\n\t} else\n\t\tret = rdma_accept(ctx->cm_id, NULL);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static ssize_t ucma_accept(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_accept cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (cmd.conn_param.valid) {\n\t\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\t\tmutex_lock(&file->mut);\n\t\tret = rdma_accept(ctx->cm_id, &conn_param);\n\t\tif (!ret)\n\t\t\tctx->uid = cmd.uid;\n\t\tmutex_unlock(&file->mut);\n\t} else\n\t\tret = rdma_accept(ctx->cm_id, NULL);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n",
        "linevul": 0.0003199344500899315,
        "sysevr": 0.12692788243293762,
        "devign": 0.5928832292556763
    },
    {
        "code": " static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n {\n \tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n \n\treturn X86EMUL_CONTINUE;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601",
        "vul_func_with_fix": " static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n {\n//fix_flaw_line_below:\n//\tint rc = X86EMUL_CONTINUE;\n//fix_flaw_line_below:\n//\n \tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n//flaw_line_below:\n\t\tjmp_rel(ctxt, ctxt->src.val);\n//fix_flaw_line_below:\n//\t\trc = jmp_rel(ctxt, ctxt->src.val);\n \n//flaw_line_below:\n\treturn X86EMUL_CONTINUE;\n//fix_flaw_line_below:\n//\treturn rc;\n }\n",
        "linevul": 0.023164793848991394,
        "sysevr": 0.13021333515644073,
        "devign": 0.9990158081054688
    },
    {
        "code": "static void handle_new_recv_msgs(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_msg  *smi_msg;\n\tunsigned long        flags = 0;\n\tint                  rv;\n\tint                  run_to_completion = intf->run_to_completion;\n\n\t/* See if any waiting messages need to be processed. */\n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\twhile (!list_empty(&intf->waiting_rcv_msgs)) {\n\t\tsmi_msg = list_entry(intf->waiting_rcv_msgs.next,\n\t\t\t\t     struct ipmi_smi_msg, link);\n\t\tlist_del(&smi_msg->link);\n\t\tif (!run_to_completion)\n\t\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock,\n\t\t\t\t\t       flags);\n\t\trv = handle_one_recv_msg(intf, smi_msg);\n\t\tif (!run_to_completion)\n\t\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\t\tif (rv > 0) {\n\t\t\t/*\n\t\t\t * To preserve message order, quit if we\n\t\t\t * can't handle a message.  Add the message\n\t\t\t * back at the head, this is safe because this\n\t\t\t * tasklet is the only thing that pulls the\n\t\t\t * messages.\n\t\t\t */\n\t\t\tlist_add(&smi_msg->link, &intf->waiting_rcv_msgs);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (rv == 0)\n\t\t\t\t/* Message handled */\n\t\t\t\tipmi_free_smi_msg(smi_msg);\n\t\t\t/* If rv < 0, fatal error, del but don't free. */\n\t\t}\n\t}\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock, flags);\n\n\t/*\n\t * If the pretimout count is non-zero, decrement one from it and\n\t * deliver pretimeouts to all the users.\n\t */\n\tif (atomic_add_unless(&intf->watchdog_pretimeouts_to_deliver, -1, 0)) {\n\t\tstruct ipmi_user *user;\n\t\tint index;\n\n\t\tindex = srcu_read_lock(&intf->users_srcu);\n\t\tlist_for_each_entry_rcu(user, &intf->users, link) {\n\t\t\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\t\t\tuser->handler->ipmi_watchdog_pretimeout(\n\t\t\t\t\tuser->handler_data);\n\t\t}\n\t\tsrcu_read_unlock(&intf->users_srcu, index);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8",
        "vul_func_with_fix": "static void handle_new_recv_msgs(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_msg  *smi_msg;\n\tunsigned long        flags = 0;\n\tint                  rv;\n\tint                  run_to_completion = intf->run_to_completion;\n\n\t/* See if any waiting messages need to be processed. */\n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\twhile (!list_empty(&intf->waiting_rcv_msgs)) {\n\t\tsmi_msg = list_entry(intf->waiting_rcv_msgs.next,\n\t\t\t\t     struct ipmi_smi_msg, link);\n\t\tlist_del(&smi_msg->link);\n\t\tif (!run_to_completion)\n\t\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock,\n\t\t\t\t\t       flags);\n\t\trv = handle_one_recv_msg(intf, smi_msg);\n\t\tif (!run_to_completion)\n\t\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\t\tif (rv > 0) {\n\t\t\t/*\n\t\t\t * To preserve message order, quit if we\n\t\t\t * can't handle a message.  Add the message\n\t\t\t * back at the head, this is safe because this\n\t\t\t * tasklet is the only thing that pulls the\n\t\t\t * messages.\n\t\t\t */\n\t\t\tlist_add(&smi_msg->link, &intf->waiting_rcv_msgs);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (rv == 0)\n\t\t\t\t/* Message handled */\n\t\t\t\tipmi_free_smi_msg(smi_msg);\n\t\t\t/* If rv < 0, fatal error, del but don't free. */\n\t\t}\n\t}\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock, flags);\n\n\t/*\n\t * If the pretimout count is non-zero, decrement one from it and\n\t * deliver pretimeouts to all the users.\n\t */\n\tif (atomic_add_unless(&intf->watchdog_pretimeouts_to_deliver, -1, 0)) {\n\t\tstruct ipmi_user *user;\n\t\tint index;\n\n\t\tindex = srcu_read_lock(&intf->users_srcu);\n\t\tlist_for_each_entry_rcu(user, &intf->users, link) {\n\t\t\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\t\t\tuser->handler->ipmi_watchdog_pretimeout(\n\t\t\t\t\tuser->handler_data);\n\t\t}\n\t\tsrcu_read_unlock(&intf->users_srcu, index);\n\t}\n}\n",
        "linevul": 0.00012115934077883139,
        "sysevr": 0.15057098865509033,
        "devign": 1.4178104910583515e-22
    },
    {
        "code": "static void dump_vmcs(void)\n{\n\tu32 vmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tu32 vmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tu32 cpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tu32 pin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tu32 secondary_exec_control = 0;\n\tunsigned long cr4 = vmcs_readl(GUEST_CR4);\n\tu64 efer = vmcs_readl(GUEST_IA32_EFER);\n\tint i, n;\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016lx  PDPTR1 = 0x%016lx\\n\",\n\t\t       vmcs_readl(GUEST_PDPTR0), vmcs_readl(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016lx  PDPTR3 = 0x%016lx\\n\",\n\t\t       vmcs_readl(GUEST_PDPTR2), vmcs_readl(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016lx\\n\",\n\t\t       efer, vmcs_readl(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016lx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016lx\\n\",\n\t\t       vmcs_readl(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016lx\\n\", vmcs_readl(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016lx  PAT = 0x%016lx\\n\",\n\t\t       vmcs_readl(HOST_IA32_EFER), vmcs_readl(HOST_IA32_PAT));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016lx\\n\",\n\t\t       vmcs_readl(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016lx\\n\", vmcs_readl(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016lx\\n\",\n\t\t       vmcs_readl(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW)\n\t\tpr_err(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016lx\\n\", vmcs_readl(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed",
        "vul_func_with_fix": "static void dump_vmcs(void)\n{\n\tu32 vmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tu32 vmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tu32 cpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tu32 pin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tu32 secondary_exec_control = 0;\n\tunsigned long cr4 = vmcs_readl(GUEST_CR4);\n\tu64 efer = vmcs_readl(GUEST_IA32_EFER);\n\tint i, n;\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016lx  PDPTR1 = 0x%016lx\\n\",\n\t\t       vmcs_readl(GUEST_PDPTR0), vmcs_readl(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016lx  PDPTR3 = 0x%016lx\\n\",\n\t\t       vmcs_readl(GUEST_PDPTR2), vmcs_readl(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016lx\\n\",\n\t\t       efer, vmcs_readl(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016lx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016lx\\n\",\n\t\t       vmcs_readl(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016lx\\n\", vmcs_readl(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016lx  PAT = 0x%016lx\\n\",\n\t\t       vmcs_readl(HOST_IA32_EFER), vmcs_readl(HOST_IA32_PAT));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016lx\\n\",\n\t\t       vmcs_readl(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016lx\\n\", vmcs_readl(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016lx\\n\",\n\t\t       vmcs_readl(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW)\n\t\tpr_err(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016lx\\n\", vmcs_readl(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}\n",
        "linevul": 5.2341838454594836e-05,
        "sysevr": 0.25437501072883606,
        "devign": 0.004425582941621542
    },
    {
        "code": "static int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/263b4509ec4d47e0da3e753f85a39ea12d1eff24",
        "vul_func_with_fix": "static int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}\n",
        "linevul": 4.773879118147306e-05,
        "sysevr": 0.13108034431934357,
        "devign": 0.003929495811462402
    },
    {
        "code": "static int snd_seq_ioctl_get_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct snd_seq_queue_timer timer;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tif (copy_from_user(&timer, arg, sizeof(timer)))\n\t\treturn -EFAULT;\n\n\tqueue = queueptr(timer.queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&queue->timer_mutex)) {\n\t\tqueuefree(queue);\n\t\treturn -ERESTARTSYS;\n\t}\n\ttmr = queue->timer;\n\tmemset(&timer, 0, sizeof(timer));\n\ttimer.queue = queue->queue;\n\n\ttimer.type = tmr->type;\n\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\ttimer.u.alsa.id = tmr->alsa_id;\n\t\ttimer.u.alsa.resolution = tmr->preferred_resolution;\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\t\n\tif (copy_to_user(arg, &timer, sizeof(timer)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/030e2c78d3a91dd0d27fef37e91950dde333eba1",
        "vul_func_with_fix": "static int snd_seq_ioctl_get_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct snd_seq_queue_timer timer;\n\tstruct snd_seq_queue *queue;\n\tstruct snd_seq_timer *tmr;\n\n\tif (copy_from_user(&timer, arg, sizeof(timer)))\n\t\treturn -EFAULT;\n\n\tqueue = queueptr(timer.queue);\n\tif (queue == NULL)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&queue->timer_mutex)) {\n\t\tqueuefree(queue);\n\t\treturn -ERESTARTSYS;\n\t}\n\ttmr = queue->timer;\n\tmemset(&timer, 0, sizeof(timer));\n\ttimer.queue = queue->queue;\n\n\ttimer.type = tmr->type;\n\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\ttimer.u.alsa.id = tmr->alsa_id;\n\t\ttimer.u.alsa.resolution = tmr->preferred_resolution;\n\t}\n\tmutex_unlock(&queue->timer_mutex);\n\tqueuefree(queue);\n\t\n\tif (copy_to_user(arg, &timer, sizeof(timer)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "linevul": 7.308835483854637e-05,
        "sysevr": 0.13181576132774353,
        "devign": 0.6783948540687561
    },
    {
        "code": "static int decode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tREAD_BUF(8);\n\tREAD32(hdr->status);\n\tREAD32(hdr->taglen);\n\t\n\tREAD_BUF(hdr->taglen + 4);\n\thdr->tag = (char *)p;\n\tp += XDR_QUADLEN(hdr->taglen);\n\tREAD32(hdr->nops);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int decode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tREAD_BUF(8);\n\tREAD32(hdr->status);\n\tREAD32(hdr->taglen);\n\t\n\tREAD_BUF(hdr->taglen + 4);\n\thdr->tag = (char *)p;\n\tp += XDR_QUADLEN(hdr->taglen);\n\tREAD32(hdr->nops);\n\treturn 0;\n}\n",
        "linevul": 5.919764225836843e-05,
        "sysevr": 0.12826654314994812,
        "devign": 1.0712859072059544e-10
    },
    {
        "code": "static inline void *flow_keys_hash_start(struct flow_keys *flow)\n{\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\n\treturn (void *)flow + FLOW_KEYS_HASH_OFFSET;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
        "vul_func_with_fix": "static inline void *flow_keys_hash_start(struct flow_keys *flow)\n{\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\n\treturn (void *)flow + FLOW_KEYS_HASH_OFFSET;\n}\n",
        "linevul": 7.50735416659154e-05,
        "sysevr": 0.12529613077640533,
        "devign": 0.22158855199813843
    },
    {
        "code": "vc4_job_handle_completed(struct vc4_dev *vc4)\n{\n\tunsigned long irqflags;\n\tstruct vc4_seqno_cb *cb, *cb_temp;\n\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\twhile (!list_empty(&vc4->job_done_list)) {\n\t\tstruct vc4_exec_info *exec =\n\t\t\tlist_first_entry(&vc4->job_done_list,\n\t\t\t\t\t struct vc4_exec_info, head);\n\t\tlist_del(&exec->head);\n\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t\tvc4_complete_exec(vc4->dev, exec);\n\t\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\t}\n\n\tlist_for_each_entry_safe(cb, cb_temp, &vc4->seqno_cb_list, work.entry) {\n\t\tif (cb->seqno <= vc4->finished_seqno) {\n\t\t\tlist_del_init(&cb->work.entry);\n\t\t\tschedule_work(&cb->work);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b8ac63847bc2f958dd93c09edc941a0118992d9",
        "vul_func_with_fix": "vc4_job_handle_completed(struct vc4_dev *vc4)\n{\n\tunsigned long irqflags;\n\tstruct vc4_seqno_cb *cb, *cb_temp;\n\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\twhile (!list_empty(&vc4->job_done_list)) {\n\t\tstruct vc4_exec_info *exec =\n\t\t\tlist_first_entry(&vc4->job_done_list,\n\t\t\t\t\t struct vc4_exec_info, head);\n\t\tlist_del(&exec->head);\n\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t\tvc4_complete_exec(vc4->dev, exec);\n\t\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\t}\n\n\tlist_for_each_entry_safe(cb, cb_temp, &vc4->seqno_cb_list, work.entry) {\n\t\tif (cb->seqno <= vc4->finished_seqno) {\n\t\t\tlist_del_init(&cb->work.entry);\n\t\t\tschedule_work(&cb->work);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n}\n",
        "linevul": 5.6040651543298736e-05,
        "sysevr": 0.17011511325836182,
        "devign": 0.00040561595233157277
    },
    {
        "code": "static void dm_blk_close(struct gendisk *disk, fmode_t mode)\n{\n\tstruct mapped_device *md;\n\n\tspin_lock(&_minor_lock);\n\n\tmd = disk->private_data;\n\tif (WARN_ON(!md))\n\t\tgoto out;\n\n\tif (atomic_dec_and_test(&md->open_count) &&\n\t    (test_bit(DMF_DEFERRED_REMOVE, &md->flags)))\n\t\tqueue_work(deferred_remove_workqueue, &deferred_remove_work);\n\n\tdm_put(md);\nout:\n\tspin_unlock(&_minor_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9a41d21dceadf8104812626ef85dc56ee8a60ed",
        "vul_func_with_fix": "static void dm_blk_close(struct gendisk *disk, fmode_t mode)\n{\n\tstruct mapped_device *md;\n\n\tspin_lock(&_minor_lock);\n\n\tmd = disk->private_data;\n\tif (WARN_ON(!md))\n\t\tgoto out;\n\n\tif (atomic_dec_and_test(&md->open_count) &&\n\t    (test_bit(DMF_DEFERRED_REMOVE, &md->flags)))\n\t\tqueue_work(deferred_remove_workqueue, &deferred_remove_work);\n\n\tdm_put(md);\nout:\n\tspin_unlock(&_minor_lock);\n}\n",
        "linevul": 6.012730227666907e-05,
        "sysevr": 0.1262199878692627,
        "devign": 9.974268937232056e-19
    },
    {
        "code": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\t\t\t\tint rw)\n{\n\t__f2fs_submit_merged_bio(sbi, NULL, NULL, 0, type, rw);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b86e33075ed1909d8002745b56ecf73b833db143",
        "vul_func_with_fix": "void f2fs_submit_merged_bio(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\t\t\t\tint rw)\n{\n\t__f2fs_submit_merged_bio(sbi, NULL, NULL, 0, type, rw);\n}\n",
        "linevul": 0.0003656879416666925,
        "sysevr": 0.1718209981918335,
        "devign": 1.5589921575909216e-09
    },
    {
        "code": "static long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct vop_vdev *vdev = f->private_data;\n\tstruct vop_info *vi = vdev->vi;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase MIC_VIRTIO_ADD_DEVICE:\n\t{\n\t\tstruct mic_device_desc dd, *dd_config;\n\n\t\tif (copy_from_user(&dd, argp, sizeof(dd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\n\t\t    dd.num_vq > MIC_MAX_VRINGS)\n\t\t\treturn -EINVAL;\n\n\t\tdd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\n\t\tif (!dd_config)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\n \t\t\tret = -EFAULT;\n \t\t\tgoto free_ret;\n \t\t}\n \t\tmutex_lock(&vdev->vdev_mutex);\n \t\tmutex_lock(&vi->vop_mutex);\n \t\tret = vop_virtio_add_device(vdev, dd_config);\n\t\tif (ret)\n\t\t\tgoto unlock_ret;\n\t\tlist_add_tail(&vdev->list, &vi->vdev_list);\nunlock_ret:\n\t\tmutex_unlock(&vi->vop_mutex);\n\t\tmutex_unlock(&vdev->vdev_mutex);\nfree_ret:\n\t\tkfree(dd_config);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_COPY_DESC:\n\t{\n\t\tstruct mic_copy_desc copy;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto _unlock_ret;\n\n\t\tif (copy_from_user(&copy, argp, sizeof(copy))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto _unlock_ret;\n\t\t}\n\n\t\tret = vop_virtio_copy_desc(vdev, &copy);\n\t\tif (ret < 0)\n\t\t\tgoto _unlock_ret;\n\t\tif (copy_to_user(\n\t\t\t&((struct mic_copy_desc __user *)argp)->out_len,\n\t\t\t&copy.out_len, sizeof(copy.out_len)))\n\t\t\tret = -EFAULT;\n_unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_CONFIG_CHANGE:\n\t{\n\t\tvoid *buf;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto __unlock_ret;\n\t\tbuf = kzalloc(vdev->dd->config_len, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto __unlock_ret;\n\t\t}\n\t\tif (copy_from_user(buf, argp, vdev->dd->config_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tret = vop_virtio_config_change(vdev, buf);\ndone:\n\t\tkfree(buf);\n__unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t};\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9bf292bfca94694a721449e3fd752493856710f6",
        "vul_func_with_fix": "static long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tstruct vop_vdev *vdev = f->private_data;\n\tstruct vop_info *vi = vdev->vi;\n\tvoid __user *argp = (void __user *)arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase MIC_VIRTIO_ADD_DEVICE:\n\t{\n\t\tstruct mic_device_desc dd, *dd_config;\n\n\t\tif (copy_from_user(&dd, argp, sizeof(dd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (mic_aligned_desc_size(&dd) > MIC_MAX_DESC_BLK_SIZE ||\n\t\t    dd.num_vq > MIC_MAX_VRINGS)\n\t\t\treturn -EINVAL;\n\n\t\tdd_config = kzalloc(mic_desc_size(&dd), GFP_KERNEL);\n\t\tif (!dd_config)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dd_config, argp, mic_desc_size(&dd))) {\n \t\t\tret = -EFAULT;\n \t\t\tgoto free_ret;\n \t\t}\n//fix_flaw_line_below:\n//\t\t/* Ensure desc has not changed between the two reads */\n//fix_flaw_line_below:\n//\t\tif (memcmp(&dd, dd_config, sizeof(dd))) {\n//fix_flaw_line_below:\n//\t\t\tret = -EINVAL;\n//fix_flaw_line_below:\n//\t\t\tgoto free_ret;\n//fix_flaw_line_below:\n//\t\t}\n \t\tmutex_lock(&vdev->vdev_mutex);\n \t\tmutex_lock(&vi->vop_mutex);\n \t\tret = vop_virtio_add_device(vdev, dd_config);\n\t\tif (ret)\n\t\t\tgoto unlock_ret;\n\t\tlist_add_tail(&vdev->list, &vi->vdev_list);\nunlock_ret:\n\t\tmutex_unlock(&vi->vop_mutex);\n\t\tmutex_unlock(&vdev->vdev_mutex);\nfree_ret:\n\t\tkfree(dd_config);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_COPY_DESC:\n\t{\n\t\tstruct mic_copy_desc copy;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto _unlock_ret;\n\n\t\tif (copy_from_user(&copy, argp, sizeof(copy))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto _unlock_ret;\n\t\t}\n\n\t\tret = vop_virtio_copy_desc(vdev, &copy);\n\t\tif (ret < 0)\n\t\t\tgoto _unlock_ret;\n\t\tif (copy_to_user(\n\t\t\t&((struct mic_copy_desc __user *)argp)->out_len,\n\t\t\t&copy.out_len, sizeof(copy.out_len)))\n\t\t\tret = -EFAULT;\n_unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tcase MIC_VIRTIO_CONFIG_CHANGE:\n\t{\n\t\tvoid *buf;\n\n\t\tmutex_lock(&vdev->vdev_mutex);\n\t\tret = vop_vdev_inited(vdev);\n\t\tif (ret)\n\t\t\tgoto __unlock_ret;\n\t\tbuf = kzalloc(vdev->dd->config_len, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto __unlock_ret;\n\t\t}\n\t\tif (copy_from_user(buf, argp, vdev->dd->config_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tret = vop_virtio_config_change(vdev, buf);\ndone:\n\t\tkfree(buf);\n__unlock_ret:\n\t\tmutex_unlock(&vdev->vdev_mutex);\n\t\treturn ret;\n\t}\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t};\n\treturn 0;\n}\n",
        "linevul": 0.00014258486044127494,
        "sysevr": 0.1506229192018509,
        "devign": 0.9995860457420349
    },
    {
        "code": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n \t}\n \n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n//fix_flaw_line_below:\n//\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n//flaw_line_below:\n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n//flaw_line_below:\n\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n",
        "linevul": 0.0011352570727467537,
        "sysevr": 0.17812108993530273,
        "devign": 1.0
    },
    {
        "code": "static int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,\n\t\t\t     struct sg_io_hdr *hdr, fmode_t mode)\n{\n\tif (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))\n\t\treturn -EFAULT;\n\tif (blk_verify_command(rq->cmd, mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\n\t/*\n\t * fill in request structure\n\t */\n\trq->cmd_len = hdr->cmd_len;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\trq->timeout = msecs_to_jiffies(hdr->timeout);\n\tif (!rq->timeout)\n\t\trq->timeout = q->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\tif (rq->timeout < BLK_MIN_SG_TIMEOUT)\n\t\trq->timeout = BLK_MIN_SG_TIMEOUT;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e",
        "vul_func_with_fix": "static int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,\n\t\t\t     struct sg_io_hdr *hdr, fmode_t mode)\n{\n\tif (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))\n\t\treturn -EFAULT;\n\tif (blk_verify_command(rq->cmd, mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\n\t/*\n\t * fill in request structure\n\t */\n\trq->cmd_len = hdr->cmd_len;\n\trq->cmd_type = REQ_TYPE_BLOCK_PC;\n\n\trq->timeout = msecs_to_jiffies(hdr->timeout);\n\tif (!rq->timeout)\n\t\trq->timeout = q->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\tif (rq->timeout < BLK_MIN_SG_TIMEOUT)\n\t\trq->timeout = BLK_MIN_SG_TIMEOUT;\n\n\treturn 0;\n}\n",
        "linevul": 0.00011626096966210753,
        "sysevr": 0.13934309780597687,
        "devign": 4.901872500571655e-14
    },
    {
        "code": "static int tty_fasync(int fd, struct file *filp, int on)\n{\n\tstruct tty_struct *tty = file_tty(filp);\n\tint retval;\n\n\ttty_lock(tty);\n\tretval = __tty_fasync(fd, filp, on);\n\ttty_unlock(tty);\n\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5c17c861a357e9458001f021a7afa7aab9937439",
        "vul_func_with_fix": "static int tty_fasync(int fd, struct file *filp, int on)\n{\n\tstruct tty_struct *tty = file_tty(filp);\n\tint retval;\n\n\ttty_lock(tty);\n\tretval = __tty_fasync(fd, filp, on);\n\ttty_unlock(tty);\n\n\treturn retval;\n}\n",
        "linevul": 4.7297344281105325e-05,
        "sysevr": 0.12771359086036682,
        "devign": 1.2640824024856556e-05
    },
    {
        "code": "static int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret = 0;\n\tint batch_count = PRECHARGE_COUNT_AT_ONCE;\n\tstruct mem_cgroup *memcg = mc.to;\n\n\tif (mem_cgroup_is_root(memcg)) {\n\t\tmc.precharge += count;\n\t\t/* we don't need css_get for root */\n\t\treturn ret;\n\t}\n\t/* try to charge at once */\n\tif (count > 1) {\n\t\tstruct res_counter *dummy;\n\t\t/*\n\t\t * \"memcg\" cannot be under rmdir() because we've already checked\n\t\t * by cgroup_lock_live_cgroup() that it is not removed and we\n\t\t * are still under the same cgroup_mutex. So we can postpone\n\t\t * css_get().\n\t\t */\n\t\tif (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))\n\t\t\tgoto one_by_one;\n\t\tif (do_swap_account && res_counter_charge(&memcg->memsw,\n\t\t\t\t\t\tPAGE_SIZE * count, &dummy)) {\n\t\t\tres_counter_uncharge(&memcg->res, PAGE_SIZE * count);\n\t\t\tgoto one_by_one;\n\t\t}\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\none_by_one:\n\t/* fall back to one by one charge */\n\twhile (count--) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (!batch_count--) {\n\t\t\tbatch_count = PRECHARGE_COUNT_AT_ONCE;\n\t\t\tcond_resched();\n\t\t}\n\t\tret = __mem_cgroup_try_charge(NULL,\n\t\t\t\t\tGFP_KERNEL, 1, &memcg, false);\n\t\tif (ret)\n\t\t\t/* mem_cgroup_clear_mc() will do uncharge later */\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t}\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static int mem_cgroup_do_precharge(unsigned long count)\n{\n\tint ret = 0;\n\tint batch_count = PRECHARGE_COUNT_AT_ONCE;\n\tstruct mem_cgroup *memcg = mc.to;\n\n\tif (mem_cgroup_is_root(memcg)) {\n\t\tmc.precharge += count;\n\t\t/* we don't need css_get for root */\n\t\treturn ret;\n\t}\n\t/* try to charge at once */\n\tif (count > 1) {\n\t\tstruct res_counter *dummy;\n\t\t/*\n\t\t * \"memcg\" cannot be under rmdir() because we've already checked\n\t\t * by cgroup_lock_live_cgroup() that it is not removed and we\n\t\t * are still under the same cgroup_mutex. So we can postpone\n\t\t * css_get().\n\t\t */\n\t\tif (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))\n\t\t\tgoto one_by_one;\n\t\tif (do_swap_account && res_counter_charge(&memcg->memsw,\n\t\t\t\t\t\tPAGE_SIZE * count, &dummy)) {\n\t\t\tres_counter_uncharge(&memcg->res, PAGE_SIZE * count);\n\t\t\tgoto one_by_one;\n\t\t}\n\t\tmc.precharge += count;\n\t\treturn ret;\n\t}\none_by_one:\n\t/* fall back to one by one charge */\n\twhile (count--) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tif (!batch_count--) {\n\t\t\tbatch_count = PRECHARGE_COUNT_AT_ONCE;\n\t\t\tcond_resched();\n\t\t}\n\t\tret = __mem_cgroup_try_charge(NULL,\n\t\t\t\t\tGFP_KERNEL, 1, &memcg, false);\n\t\tif (ret)\n\t\t\t/* mem_cgroup_clear_mc() will do uncharge later */\n\t\t\treturn ret;\n\t\tmc.precharge++;\n\t}\n\treturn ret;\n}\n",
        "linevul": 0.00012340799730736762,
        "sysevr": 0.1618877649307251,
        "devign": 1.110214123471102e-23
    },
    {
        "code": "int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fc3a9157d3148ab91039c75423da8ef97be3e105",
        "vul_func_with_fix": "int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n",
        "linevul": 5.309548578225076e-05,
        "sysevr": 0.2531450092792511,
        "devign": 1.2970901640435984e-24
    },
    {
        "code": "int pid_delete_dentry(const struct dentry *dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn proc_inode_is_dead(d_inode(dentry));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8148a73c9901a8794a50f950083c00ccf97d43b3",
        "vul_func_with_fix": "int pid_delete_dentry(const struct dentry *dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn proc_inode_is_dead(d_inode(dentry));\n}\n",
        "linevul": 6.943544576643035e-05,
        "sysevr": 0.15815593302249908,
        "devign": 0.0009586588712409139
    },
    {
        "code": " static int netbk_count_requests(struct xenvif *vif,\n \t\t\t\tstruct xen_netif_tx_request *first,\n \t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n \n \tdo {\n \t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n \t\t\treturn -frags;\n \t\t}\n \n \t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n \t\t\treturn -frags;\n \t\t}\n \n \t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n \t\t       sizeof(*txp));\n \t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n \t\t\treturn -frags;\n \t\t}\n \n \t\tfirst->size -= txp->size;\n \t\tfrags++;\n \n \t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n \t\t\t\t txp->offset, txp->size);\n \t\t\treturn -frags;\n \t\t}\n \t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664",
        "vul_func_with_fix": " static int netbk_count_requests(struct xenvif *vif,\n \t\t\t\tstruct xen_netif_tx_request *first,\n \t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n \n \tdo {\n \t\tif (frags >= work_to_do) {\n//flaw_line_below:\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n//fix_flaw_line_below:\n//\t\t\tnetdev_err(vif->dev, \"Need more frags\\n\");\n//fix_flaw_line_below:\n//\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \n \t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n//flaw_line_below:\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n//fix_flaw_line_below:\n//\t\t\tnetdev_err(vif->dev, \"Too many frags\\n\");\n//fix_flaw_line_below:\n//\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \n \t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n \t\t       sizeof(*txp));\n \t\tif (txp->size > first->size) {\n//flaw_line_below:\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n//fix_flaw_line_below:\n//\t\t\tnetdev_err(vif->dev, \"Frag is bigger than frame.\\n\");\n//fix_flaw_line_below:\n//\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \n \t\tfirst->size -= txp->size;\n \t\tfrags++;\n \n \t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n//flaw_line_below:\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n//fix_flaw_line_below:\n//\t\t\tnetdev_err(vif->dev, \"txp->offset: %x, size: %u\\n\",\n \t\t\t\t txp->offset, txp->size);\n//fix_flaw_line_below:\n//\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}\n",
        "linevul": 0.9995900988578796,
        "sysevr": 0.13731510937213898,
        "devign": 1.5261149548945196e-12
    },
    {
        "code": "void kvm_arch_check_processor_compat(void *rtn)\n{\n\t*(int *)rtn = kvmppc_core_check_processor_compat();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac64115a66c18c01745bbd3c47a36b124e5fd8c0",
        "vul_func_with_fix": "void kvm_arch_check_processor_compat(void *rtn)\n{\n\t*(int *)rtn = kvmppc_core_check_processor_compat();\n}\n",
        "linevul": 5.027107908972539e-05,
        "sysevr": 0.15760311484336853,
        "devign": 0.0033968479838222265
    },
    {
        "code": "static sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4",
        "vul_func_with_fix": "static sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n",
        "linevul": 5.685996075044386e-05,
        "sysevr": 0.20124074816703796,
        "devign": 0.028004581108689308
    },
    {
        "code": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n {\n \tchar *p;\n \tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n \tchar *cipher_key_bytes_src;\n \tchar *fn_cipher_key_bytes_src;\n \n \tif (!options) {\n \t\trc = -EINVAL;\n \t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n \t\t\tmount_crypt_stat->flags |=\n \t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n \t\t\tbreak;\n \t\tcase ecryptfs_opt_err:\n \t\tdefault:\n \t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97",
        "vul_func_with_fix": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n//fix_flaw_line_below:\n//static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n//fix_flaw_line_below:\n//\t\t\t\t  uid_t *check_ruid)\n {\n \tchar *p;\n \tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n \tchar *cipher_key_bytes_src;\n \tchar *fn_cipher_key_bytes_src;\n \n//fix_flaw_line_below:\n//\t*check_ruid = 0;\n//fix_flaw_line_below:\n//\n \tif (!options) {\n \t\trc = -EINVAL;\n \t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n \t\t\tmount_crypt_stat->flags |=\n \t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n \t\t\tbreak;\n//fix_flaw_line_below:\n//\t\tcase ecryptfs_opt_check_dev_ruid:\n//fix_flaw_line_below:\n//\t\t\t*check_ruid = 1;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n \t\tcase ecryptfs_opt_err:\n \t\tdefault:\n \t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}\n",
        "linevul": 0.9984095692634583,
        "sysevr": 0.17996299266815186,
        "devign": 0.9995284080505371
    },
    {
        "code": "static void set_intr_gate(unsigned int n, const void *addr)\n{\n\tstruct idt_data data;\n\n\tBUG_ON(n > 0xFF);\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.vector\t= n;\n\tdata.addr\t= addr;\n\tdata.segment\t= __KERNEL_CS;\n\tdata.bits.type\t= GATE_INTERRUPT;\n\tdata.bits.p\t= 1;\n\n\tidt_setup_from_table(idt_table, &data, 1, false);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9",
        "vul_func_with_fix": "static void set_intr_gate(unsigned int n, const void *addr)\n{\n\tstruct idt_data data;\n\n\tBUG_ON(n > 0xFF);\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.vector\t= n;\n\tdata.addr\t= addr;\n\tdata.segment\t= __KERNEL_CS;\n\tdata.bits.type\t= GATE_INTERRUPT;\n\tdata.bits.p\t= 1;\n\n\tidt_setup_from_table(idt_table, &data, 1, false);\n}\n",
        "linevul": 5.0799451855709776e-05,
        "sysevr": 0.12249521911144257,
        "devign": 1.1922685949329328e-22
    },
    {
        "code": "static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nft_set *set;\n\tstruct nft_set_dump_args args;\n\tstruct nft_ctx ctx;\n\tstruct nlattr *nla[NFTA_SET_ELEM_LIST_MAX + 1];\n\tstruct nfgenmsg *nfmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tu32 portid, seq;\n\tint event, err;\n\n\terr = nlmsg_parse(cb->nlh, sizeof(struct nfgenmsg), nla,\n\t\t\t  NFTA_SET_ELEM_LIST_MAX, nft_set_elem_list_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_ctx_init_from_elemattr(&ctx, cb->skb, cb->nlh, (void *)nla,\n\t\t\t\t\t false);\n\tif (err < 0)\n\t\treturn err;\n\n\tset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\tif (set->flags & NFT_SET_INACTIVE)\n\t\treturn -ENOENT;\n\n\tevent  = NFT_MSG_NEWSETELEM;\n\tevent |= NFNL_SUBSYS_NFTABLES << 8;\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq    = cb->nlh->nlmsg_seq;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),\n\t\t\tNLM_F_MULTI);\n\tif (nlh == NULL)\n\t\tgoto nla_put_failure;\n\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family = ctx.afi->family;\n\tnfmsg->version      = NFNETLINK_V0;\n\tnfmsg->res_id\t    = htons(ctx.net->nft.base_seq & 0xffff);\n\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, ctx.table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\targs.cb\t\t= cb;\n\targs.skb\t= skb;\n\targs.iter.skip\t= cb->args[0];\n\targs.iter.count\t= 0;\n\targs.iter.err   = 0;\n\targs.iter.fn\t= nf_tables_dump_setelem;\n\tset->ops->walk(&ctx, set, &args.iter);\n\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\n\tif (args.iter.err && args.iter.err != -EMSGSIZE)\n\t\treturn args.iter.err;\n\tif (args.iter.count == cb->args[0])\n\t\treturn 0;\n\n\tcb->args[0] = args.iter.count;\n\treturn skb->len;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a2f18db0c68fec96631c10cad9384c196e9008ac",
        "vul_func_with_fix": "static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nft_set *set;\n\tstruct nft_set_dump_args args;\n\tstruct nft_ctx ctx;\n\tstruct nlattr *nla[NFTA_SET_ELEM_LIST_MAX + 1];\n\tstruct nfgenmsg *nfmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tu32 portid, seq;\n\tint event, err;\n\n\terr = nlmsg_parse(cb->nlh, sizeof(struct nfgenmsg), nla,\n\t\t\t  NFTA_SET_ELEM_LIST_MAX, nft_set_elem_list_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nft_ctx_init_from_elemattr(&ctx, cb->skb, cb->nlh, (void *)nla,\n\t\t\t\t\t false);\n\tif (err < 0)\n\t\treturn err;\n\n\tset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\n\tif (IS_ERR(set))\n\t\treturn PTR_ERR(set);\n\tif (set->flags & NFT_SET_INACTIVE)\n\t\treturn -ENOENT;\n\n\tevent  = NFT_MSG_NEWSETELEM;\n\tevent |= NFNL_SUBSYS_NFTABLES << 8;\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq    = cb->nlh->nlmsg_seq;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),\n\t\t\tNLM_F_MULTI);\n\tif (nlh == NULL)\n\t\tgoto nla_put_failure;\n\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family = ctx.afi->family;\n\tnfmsg->version      = NFNETLINK_V0;\n\tnfmsg->res_id\t    = htons(ctx.net->nft.base_seq & 0xffff);\n\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, ctx.table->name))\n\t\tgoto nla_put_failure;\n\tif (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, NFTA_SET_ELEM_LIST_ELEMENTS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\targs.cb\t\t= cb;\n\targs.skb\t= skb;\n\targs.iter.skip\t= cb->args[0];\n\targs.iter.count\t= 0;\n\targs.iter.err   = 0;\n\targs.iter.fn\t= nf_tables_dump_setelem;\n\tset->ops->walk(&ctx, set, &args.iter);\n\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\n\tif (args.iter.err && args.iter.err != -EMSGSIZE)\n\t\treturn args.iter.err;\n\tif (args.iter.count == cb->args[0])\n\t\treturn 0;\n\n\tcb->args[0] = args.iter.count;\n\treturn skb->len;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n",
        "linevul": 0.00033615322900004685,
        "sysevr": 0.17267157137393951,
        "devign": 4.1589671730736913e-29
    },
    {
        "code": "static int __netlink_insert(struct netlink_table *table, struct sock *sk)\n{\n\tstruct netlink_compare_arg arg;\n\n\tnetlink_compare_arg_init(&arg, sock_net(sk), nlk_sk(sk)->portid);\n\treturn rhashtable_lookup_insert_key(&table->hash, &arg,\n\t\t\t\t\t    &nlk_sk(sk)->node,\n\t\t\t\t\t    netlink_rhashtable_params);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92964c79b357efd980812c4de5c1fd2ec8bb5520",
        "vul_func_with_fix": "static int __netlink_insert(struct netlink_table *table, struct sock *sk)\n{\n\tstruct netlink_compare_arg arg;\n\n\tnetlink_compare_arg_init(&arg, sock_net(sk), nlk_sk(sk)->portid);\n\treturn rhashtable_lookup_insert_key(&table->hash, &arg,\n\t\t\t\t\t    &nlk_sk(sk)->node,\n\t\t\t\t\t    netlink_rhashtable_params);\n}\n",
        "linevul": 6.376933743013069e-05,
        "sysevr": 0.12246978282928467,
        "devign": 8.484404679620638e-05
    },
    {
        "code": "static int megasas_io_attach(struct megasas_instance *instance)\n{\n\tstruct Scsi_Host *host = instance->host;\n\n\t/*\n\t * Export parameters required by SCSI mid-layer\n\t */\n\thost->unique_id = instance->unique_id;\n\thost->can_queue = instance->max_scsi_cmds;\n\thost->this_id = instance->init_id;\n\thost->sg_tablesize = instance->max_num_sge;\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\n\n\t/*\n\t * Check if the module parameter value for max_sectors can be used\n\t */\n\tif (max_sectors && max_sectors < instance->max_sectors_per_req)\n\t\tinstance->max_sectors_per_req = max_sectors;\n\telse {\n\t\tif (max_sectors) {\n\t\t\tif (((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\n\t\t\t\t(max_sectors <= MEGASAS_MAX_SECTORS)) {\n\t\t\t\tinstance->max_sectors_per_req = max_sectors;\n\t\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"max_sectors should be > 0\"\n\t\t\t\t\"and <= %d (or < 1MB for GEN2 controller)\\n\",\n\t\t\t\tinstance->max_sectors_per_req);\n\t\t\t}\n\t\t}\n\t}\n\n\thost->max_sectors = instance->max_sectors_per_req;\n\thost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\n\thost->max_channel = MEGASAS_MAX_CHANNELS - 1;\n\thost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\n\thost->max_lun = MEGASAS_MAX_LUN;\n\thost->max_cmd_len = 16;\n\n\t/*\n\t * Notify the mid-layer about the new controller\n\t */\n\tif (scsi_add_host(host, &instance->pdev->dev)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to add host from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "vul_func_with_fix": "static int megasas_io_attach(struct megasas_instance *instance)\n{\n\tstruct Scsi_Host *host = instance->host;\n\n\t/*\n\t * Export parameters required by SCSI mid-layer\n\t */\n\thost->unique_id = instance->unique_id;\n\thost->can_queue = instance->max_scsi_cmds;\n\thost->this_id = instance->init_id;\n\thost->sg_tablesize = instance->max_num_sge;\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\n\n\t/*\n\t * Check if the module parameter value for max_sectors can be used\n\t */\n\tif (max_sectors && max_sectors < instance->max_sectors_per_req)\n\t\tinstance->max_sectors_per_req = max_sectors;\n\telse {\n\t\tif (max_sectors) {\n\t\t\tif (((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\n\t\t\t\t(max_sectors <= MEGASAS_MAX_SECTORS)) {\n\t\t\t\tinstance->max_sectors_per_req = max_sectors;\n\t\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"max_sectors should be > 0\"\n\t\t\t\t\"and <= %d (or < 1MB for GEN2 controller)\\n\",\n\t\t\t\tinstance->max_sectors_per_req);\n\t\t\t}\n\t\t}\n\t}\n\n\thost->max_sectors = instance->max_sectors_per_req;\n\thost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\n\thost->max_channel = MEGASAS_MAX_CHANNELS - 1;\n\thost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\n\thost->max_lun = MEGASAS_MAX_LUN;\n\thost->max_cmd_len = 16;\n\n\t/*\n\t * Notify the mid-layer about the new controller\n\t */\n\tif (scsi_add_host(host, &instance->pdev->dev)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to add host from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 8.078023529378697e-05,
        "sysevr": 0.15050992369651794,
        "devign": 1.8243819788210658e-09
    },
    {
        "code": "int register_netdev(struct net_device *dev)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = register_netdevice(dev);\n\trtnl_unlock();\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
        "vul_func_with_fix": "int register_netdev(struct net_device *dev)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = register_netdevice(dev);\n\trtnl_unlock();\n\treturn err;\n}\n",
        "linevul": 5.267974847811274e-05,
        "sysevr": 0.14933472871780396,
        "devign": 0.002267466625198722
    },
    {
        "code": "static void reset_controllers(int dev, unsigned char *controller, int update_dev)\n{\n\tint i;\n\tfor (i = 0; i < 128; i++)\n\t\tcontroller[i] = ctrl_def_values[i];\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9",
        "vul_func_with_fix": "static void reset_controllers(int dev, unsigned char *controller, int update_dev)\n{\n\tint i;\n\tfor (i = 0; i < 128; i++)\n\t\tcontroller[i] = ctrl_def_values[i];\n}\n",
        "linevul": 5.2490497182589024e-05,
        "sysevr": 0.11468680948019028,
        "devign": 9.360164199279097e-09
    },
    {
        "code": "static unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77",
        "vul_func_with_fix": "static unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n",
        "linevul": 0.0001427873212378472,
        "sysevr": 0.20174595713615417,
        "devign": 3.941289662275108e-33
    },
    {
        "code": "ftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "ftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}\n",
        "linevul": 4.8227575462078676e-05,
        "sysevr": 0.19033916294574738,
        "devign": 2.4657872927491553e-05
    },
    {
        "code": "static inline struct pppoe_net *pppoe_pernet(struct net *net)\n{\n\tBUG_ON(!net);\n\n\treturn net_generic(net, pppoe_net_id);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static inline struct pppoe_net *pppoe_pernet(struct net *net)\n{\n\tBUG_ON(!net);\n\n\treturn net_generic(net, pppoe_net_id);\n}\n",
        "linevul": 5.338085247785784e-05,
        "sysevr": 0.1261880248785019,
        "devign": 0.00022413367696572095
    },
    {
        "code": "static int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).pid,\n\t\t\t   cb_arg->seq, &netlbl_cipsov4_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_CIPSOV4_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\tret_val = nla_put_u32(cb_arg->skb,\n\t\t\t      NLBL_CIPSOV4_A_MTYPE,\n\t\t\t      doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\treturn genlmsg_end(cb_arg->skb, data);\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4",
        "vul_func_with_fix": "static int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).pid,\n\t\t\t   cb_arg->seq, &netlbl_cipsov4_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_CIPSOV4_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\tret_val = nla_put_u32(cb_arg->skb,\n\t\t\t      NLBL_CIPSOV4_A_MTYPE,\n\t\t\t      doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\treturn genlmsg_end(cb_arg->skb, data);\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n",
        "linevul": 5.06925061927177e-05,
        "sysevr": 0.13645778596401215,
        "devign": 3.846284835207876e-21
    },
    {
        "code": "static void register_prot_hook(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tif (!po->running) {\n\t\tif (po->fanout)\n\t\t\t__fanout_link(sk, po);\n\t\telse\n\t\t\tdev_add_pack(&po->prot_hook);\n\t\tsock_hold(sk);\n\t\tpo->running = 1;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static void register_prot_hook(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tif (!po->running) {\n\t\tif (po->fanout)\n\t\t\t__fanout_link(sk, po);\n\t\telse\n\t\t\tdev_add_pack(&po->prot_hook);\n\t\tsock_hold(sk);\n\t\tpo->running = 1;\n\t}\n}\n",
        "linevul": 0.0001517163182143122,
        "sysevr": 0.12386266887187958,
        "devign": 1.091203375835903e-05
    },
    {
        "code": "SYSCALL_DEFINE1(old_adjtimex, struct timex32 __user *, txc_p)\n{\n        struct timex txc;\n\tint ret;\n\n\t/* copy relevant bits of struct timex. */\n\tif (copy_from_user(&txc, txc_p, offsetof(struct timex32, time)) ||\n\t    copy_from_user(&txc.tick, &txc_p->tick, sizeof(struct timex32) - \n\t\t\t   offsetof(struct timex32, time)))\n\t  return -EFAULT;\n\n\tret = do_adjtimex(&txc);\t\n\tif (ret < 0)\n\t  return ret;\n\t\n\t/* copy back to timex32 */\n\tif (copy_to_user(txc_p, &txc, offsetof(struct timex32, time)) ||\n\t    (copy_to_user(&txc_p->tick, &txc.tick, sizeof(struct timex32) - \n\t\t\t  offsetof(struct timex32, tick))) ||\n\t    (put_tv32(&txc_p->time, &txc.time)))\n\t  return -EFAULT;\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f",
        "vul_func_with_fix": "SYSCALL_DEFINE1(old_adjtimex, struct timex32 __user *, txc_p)\n{\n        struct timex txc;\n\tint ret;\n\n\t/* copy relevant bits of struct timex. */\n\tif (copy_from_user(&txc, txc_p, offsetof(struct timex32, time)) ||\n\t    copy_from_user(&txc.tick, &txc_p->tick, sizeof(struct timex32) - \n\t\t\t   offsetof(struct timex32, time)))\n\t  return -EFAULT;\n\n\tret = do_adjtimex(&txc);\t\n\tif (ret < 0)\n\t  return ret;\n\t\n\t/* copy back to timex32 */\n\tif (copy_to_user(txc_p, &txc, offsetof(struct timex32, time)) ||\n\t    (copy_to_user(&txc_p->tick, &txc.tick, sizeof(struct timex32) - \n\t\t\t  offsetof(struct timex32, tick))) ||\n\t    (put_tv32(&txc_p->time, &txc.time)))\n\t  return -EFAULT;\n\n\treturn ret;\n}\n",
        "linevul": 4.773059845319949e-05,
        "sysevr": 0.180673286318779,
        "devign": 0.6226896643638611
    },
    {
        "code": "static irqreturn_t dwc3_check_event_buf(struct dwc3_event_buffer *evt)\n{\n\tstruct dwc3 *dwc = evt->dwc;\n\tu32 amount;\n\tu32 count;\n\tu32 reg;\n\n\tif (pm_runtime_suspended(dwc->dev)) {\n\t\tpm_runtime_get(dwc->dev);\n\t\tdisable_irq_nosync(dwc->irq_gadget);\n\t\tdwc->pending_events = true;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/*\n\t * With PCIe legacy interrupt, test shows that top-half irq handler can\n\t * be called again after HW interrupt deassertion. Check if bottom-half\n\t * irq event handler completes before caching new event to prevent\n\t * losing events.\n\t */\n\tif (evt->flags & DWC3_EVENT_PENDING)\n\t\treturn IRQ_HANDLED;\n\n\tcount = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(0));\n\tcount &= DWC3_GEVNTCOUNT_MASK;\n\tif (!count)\n\t\treturn IRQ_NONE;\n\n\tevt->count = count;\n\tevt->flags |= DWC3_EVENT_PENDING;\n\n\t/* Mask interrupt */\n\treg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));\n\treg |= DWC3_GEVNTSIZ_INTMASK;\n\tdwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), reg);\n\n\tamount = min(count, evt->length - evt->lpos);\n\tmemcpy(evt->cache + evt->lpos, evt->buf + evt->lpos, amount);\n\n\tif (amount < count)\n\t\tmemcpy(evt->cache, evt->buf, count - amount);\n\n\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), count);\n\n\treturn IRQ_WAKE_THREAD;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e",
        "vul_func_with_fix": "static irqreturn_t dwc3_check_event_buf(struct dwc3_event_buffer *evt)\n{\n\tstruct dwc3 *dwc = evt->dwc;\n\tu32 amount;\n\tu32 count;\n\tu32 reg;\n\n\tif (pm_runtime_suspended(dwc->dev)) {\n\t\tpm_runtime_get(dwc->dev);\n\t\tdisable_irq_nosync(dwc->irq_gadget);\n\t\tdwc->pending_events = true;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/*\n\t * With PCIe legacy interrupt, test shows that top-half irq handler can\n\t * be called again after HW interrupt deassertion. Check if bottom-half\n\t * irq event handler completes before caching new event to prevent\n\t * losing events.\n\t */\n\tif (evt->flags & DWC3_EVENT_PENDING)\n\t\treturn IRQ_HANDLED;\n\n\tcount = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(0));\n\tcount &= DWC3_GEVNTCOUNT_MASK;\n\tif (!count)\n\t\treturn IRQ_NONE;\n\n\tevt->count = count;\n\tevt->flags |= DWC3_EVENT_PENDING;\n\n\t/* Mask interrupt */\n\treg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));\n\treg |= DWC3_GEVNTSIZ_INTMASK;\n\tdwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), reg);\n\n\tamount = min(count, evt->length - evt->lpos);\n\tmemcpy(evt->cache + evt->lpos, evt->buf + evt->lpos, amount);\n\n\tif (amount < count)\n\t\tmemcpy(evt->cache, evt->buf, count - amount);\n\n\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), count);\n\n\treturn IRQ_WAKE_THREAD;\n}\n",
        "linevul": 5.641109964926727e-05,
        "sysevr": 0.1412898600101471,
        "devign": 2.0372461914638904e-27
    },
    {
        "code": "void recompute_msgmni(struct ipc_namespace *ns)\n{\n\tstruct sysinfo i;\n\tunsigned long allowed;\n\tint nb_ns;\n\n\tsi_meminfo(&i);\n\tallowed = (((i.totalram - i.totalhigh) / MSG_MEM_SCALE) * i.mem_unit)\n\t\t/ MSGMNB;\n\tnb_ns = atomic_read(&nr_ipc_ns);\n\tallowed /= nb_ns;\n\n\tif (allowed < MSGMNI) {\n\t\tns->msg_ctlmni = MSGMNI;\n\t\treturn;\n\t}\n\n\tif (allowed > IPCMNI / nb_ns) {\n\t\tns->msg_ctlmni = IPCMNI / nb_ns;\n\t\treturn;\n\t}\n\n\tns->msg_ctlmni = allowed;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": "void recompute_msgmni(struct ipc_namespace *ns)\n{\n\tstruct sysinfo i;\n\tunsigned long allowed;\n\tint nb_ns;\n\n\tsi_meminfo(&i);\n\tallowed = (((i.totalram - i.totalhigh) / MSG_MEM_SCALE) * i.mem_unit)\n\t\t/ MSGMNB;\n\tnb_ns = atomic_read(&nr_ipc_ns);\n\tallowed /= nb_ns;\n\n\tif (allowed < MSGMNI) {\n\t\tns->msg_ctlmni = MSGMNI;\n\t\treturn;\n\t}\n\n\tif (allowed > IPCMNI / nb_ns) {\n\t\tns->msg_ctlmni = IPCMNI / nb_ns;\n\t\treturn;\n\t}\n\n\tns->msg_ctlmni = allowed;\n}\n",
        "linevul": 7.510340219596401e-05,
        "sysevr": 0.1868302971124649,
        "devign": 2.972443124971136e-11
    },
    {
        "code": "nfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}\n",
        "linevul": 0.00011601886944845319,
        "sysevr": 0.15895313024520874,
        "devign": 5.810441279066871e-27
    },
    {
        "code": "static void wdm_out_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc;\n\tdesc = urb->context;\n\tspin_lock(&desc->iuspin);\n\tdesc->werr = urb->status;\n\tspin_unlock(&desc->iuspin);\n\tkfree(desc->outbuf);\n\tdesc->outbuf = NULL;\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\twake_up(&desc->wait);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa",
        "vul_func_with_fix": "static void wdm_out_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc;\n\tdesc = urb->context;\n\tspin_lock(&desc->iuspin);\n\tdesc->werr = urb->status;\n\tspin_unlock(&desc->iuspin);\n\tkfree(desc->outbuf);\n\tdesc->outbuf = NULL;\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\twake_up(&desc->wait);\n}\n",
        "linevul": 5.9419809986138716e-05,
        "sysevr": 0.1291763037443161,
        "devign": 1.1096480495072899e-21
    },
    {
        "code": "static int nfs_size_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\treturn nfs_size_to_loff_t(fattr->size) > i_size_read(inode);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int nfs_size_need_update(const struct inode *inode, const struct nfs_fattr *fattr)\n{\n\treturn nfs_size_to_loff_t(fattr->size) > i_size_read(inode);\n}\n",
        "linevul": 0.00012712592433672398,
        "sysevr": 0.12946471571922302,
        "devign": 0.0011794576421380043
    },
    {
        "code": "static int __init init(void)\n{\n\tint err;\n\n\tpdrvdata.class = class_create(THIS_MODULE, \"virtio-ports\");\n\tif (IS_ERR(pdrvdata.class)) {\n\t\terr = PTR_ERR(pdrvdata.class);\n\t\tpr_err(\"Error %d creating virtio-ports class\\n\", err);\n\t\treturn err;\n\t}\n\n\tpdrvdata.debugfs_dir = debugfs_create_dir(\"virtio-ports\", NULL);\n\tif (!pdrvdata.debugfs_dir)\n\t\tpr_warning(\"Error creating debugfs dir for virtio-ports\\n\");\n\tINIT_LIST_HEAD(&pdrvdata.consoles);\n\tINIT_LIST_HEAD(&pdrvdata.portdevs);\n\n\terr = register_virtio_driver(&virtio_console);\n\tif (err < 0) {\n\t\tpr_err(\"Error %d registering virtio driver\\n\", err);\n\t\tgoto free;\n\t}\n\terr = register_virtio_driver(&virtio_rproc_serial);\n\tif (err < 0) {\n\t\tpr_err(\"Error %d registering virtio rproc serial driver\\n\",\n\t\t       err);\n\t\tgoto unregister;\n\t}\n\treturn 0;\nunregister:\n\tunregister_virtio_driver(&virtio_console);\nfree:\n\tdebugfs_remove_recursive(pdrvdata.debugfs_dir);\n\tclass_destroy(pdrvdata.class);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4baad50297d84bde1a7ad45e50c73adae4a2192",
        "vul_func_with_fix": "static int __init init(void)\n{\n\tint err;\n\n\tpdrvdata.class = class_create(THIS_MODULE, \"virtio-ports\");\n\tif (IS_ERR(pdrvdata.class)) {\n\t\terr = PTR_ERR(pdrvdata.class);\n\t\tpr_err(\"Error %d creating virtio-ports class\\n\", err);\n\t\treturn err;\n\t}\n\n\tpdrvdata.debugfs_dir = debugfs_create_dir(\"virtio-ports\", NULL);\n\tif (!pdrvdata.debugfs_dir)\n\t\tpr_warning(\"Error creating debugfs dir for virtio-ports\\n\");\n\tINIT_LIST_HEAD(&pdrvdata.consoles);\n\tINIT_LIST_HEAD(&pdrvdata.portdevs);\n\n\terr = register_virtio_driver(&virtio_console);\n\tif (err < 0) {\n\t\tpr_err(\"Error %d registering virtio driver\\n\", err);\n\t\tgoto free;\n\t}\n\terr = register_virtio_driver(&virtio_rproc_serial);\n\tif (err < 0) {\n\t\tpr_err(\"Error %d registering virtio rproc serial driver\\n\",\n\t\t       err);\n\t\tgoto unregister;\n\t}\n\treturn 0;\nunregister:\n\tunregister_virtio_driver(&virtio_console);\nfree:\n\tdebugfs_remove_recursive(pdrvdata.debugfs_dir);\n\tclass_destroy(pdrvdata.class);\n\treturn err;\n}\n",
        "linevul": 9.755797509569675e-05,
        "sysevr": 0.1387919783592224,
        "devign": 0.6205015778541565
    },
    {
        "code": "static int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_protmode(vcpu))\n\t\treturn 0;\n\n\tif (!is_long_mode(vcpu)\n\t    && (kvm_get_rflags(vcpu) & X86_EFLAGS_VM)) /* if virtual 8086 */\n\t\treturn 3;\n\n\tif (!test_bit(VCPU_EXREG_CPL, (ulong *)&vcpu->arch.regs_avail)) {\n\t\t__set_bit(VCPU_EXREG_CPL, (ulong *)&vcpu->arch.regs_avail);\n\t\tvmx->cpl = vmx_read_guest_seg_selector(vmx, VCPU_SREG_CS) & 3;\n\t}\n\n\treturn vmx->cpl;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_protmode(vcpu))\n\t\treturn 0;\n\n\tif (!is_long_mode(vcpu)\n\t    && (kvm_get_rflags(vcpu) & X86_EFLAGS_VM)) /* if virtual 8086 */\n\t\treturn 3;\n\n\tif (!test_bit(VCPU_EXREG_CPL, (ulong *)&vcpu->arch.regs_avail)) {\n\t\t__set_bit(VCPU_EXREG_CPL, (ulong *)&vcpu->arch.regs_avail);\n\t\tvmx->cpl = vmx_read_guest_seg_selector(vmx, VCPU_SREG_CS) & 3;\n\t}\n\n\treturn vmx->cpl;\n}\n",
        "linevul": 4.668183100875467e-05,
        "sysevr": 0.12186673283576965,
        "devign": 1.442359957599254e-13
    },
    {
        "code": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a430c9166312e1aa3d80bce32374233bdbfeba32",
        "vul_func_with_fix": "static int emulate_exception(struct x86_emulate_ctxt *ctxt, int vec,\n\t\t\t     u32 error, bool valid)\n{\n\tWARN_ON(vec > 0x1f);\n\tctxt->exception.vector = vec;\n\tctxt->exception.error_code = error;\n\tctxt->exception.error_code_valid = valid;\n\treturn X86EMUL_PROPAGATE_FAULT;\n}\n",
        "linevul": 5.198879080126062e-05,
        "sysevr": 0.13402634859085083,
        "devign": 1.5268688002834097e-05
    },
    {
        "code": "static int ovl_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185",
        "vul_func_with_fix": "static int ovl_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *link)\n{\n\treturn ovl_create_object(dentry, S_IFLNK, 0, link);\n}\n",
        "linevul": 5.460666579892859e-05,
        "sysevr": 0.11870485544204712,
        "devign": 1.6212491071865287e-10
    },
    {
        "code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n \tWRITE32(OP_OPEN_DOWNGRADE);\n \tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n \tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n \treturn 0;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n \tWRITE32(OP_OPEN_DOWNGRADE);\n \tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n \tWRITE32(arg->seqid->sequence->counter);\n//flaw_line_below:\n\tencode_share_access(xdr, arg->open_flags);\n//fix_flaw_line_below:\n//\tencode_share_access(xdr, arg->fmode);\n \treturn 0;\n }\n",
        "linevul": 0.9874746203422546,
        "sysevr": 0.12521852552890778,
        "devign": 1.661867149969909e-12
    },
    {
        "code": "static int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/blockdev/floppy.txt\\n\");\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f",
        "vul_func_with_fix": "static int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/blockdev/floppy.txt\\n\");\n\treturn 0;\n}\n",
        "linevul": 0.0005954882362857461,
        "sysevr": 0.13431166112422943,
        "devign": 0.3174135088920593
    },
    {
        "code": "static int __net_init dev_proc_net_init(struct net *net)\n{\n\tint rc = -ENOMEM;\n\n\tif (!proc_net_fops_create(net, \"dev\", S_IRUGO, &dev_seq_fops))\n\t\tgoto out;\n\tif (!proc_net_fops_create(net, \"softnet_stat\", S_IRUGO, &softnet_seq_fops))\n\t\tgoto out_dev;\n\tif (!proc_net_fops_create(net, \"ptype\", S_IRUGO, &ptype_seq_fops))\n\t\tgoto out_softnet;\n\n\tif (wext_proc_init(net))\n\t\tgoto out_ptype;\n\trc = 0;\nout:\n\treturn rc;\nout_ptype:\n\tproc_net_remove(net, \"ptype\");\nout_softnet:\n\tproc_net_remove(net, \"softnet_stat\");\nout_dev:\n\tproc_net_remove(net, \"dev\");\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867",
        "vul_func_with_fix": "static int __net_init dev_proc_net_init(struct net *net)\n{\n\tint rc = -ENOMEM;\n\n\tif (!proc_net_fops_create(net, \"dev\", S_IRUGO, &dev_seq_fops))\n\t\tgoto out;\n\tif (!proc_net_fops_create(net, \"softnet_stat\", S_IRUGO, &softnet_seq_fops))\n\t\tgoto out_dev;\n\tif (!proc_net_fops_create(net, \"ptype\", S_IRUGO, &ptype_seq_fops))\n\t\tgoto out_softnet;\n\n\tif (wext_proc_init(net))\n\t\tgoto out_ptype;\n\trc = 0;\nout:\n\treturn rc;\nout_ptype:\n\tproc_net_remove(net, \"ptype\");\nout_softnet:\n\tproc_net_remove(net, \"softnet_stat\");\nout_dev:\n\tproc_net_remove(net, \"dev\");\n\tgoto out;\n}\n",
        "linevul": 5.4493888455908746e-05,
        "sysevr": 0.12466593086719513,
        "devign": 0.5428643226623535
    },
    {
        "code": "static struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c8e252586f8d5de906385d8cf6385fee289a825e",
        "vul_func_with_fix": "static struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}\n",
        "linevul": 9.851676441030577e-05,
        "sysevr": 0.12564727663993835,
        "devign": 7.283740721675258e-09
    },
    {
        "code": "static int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive, interruptible))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tFDCS->reset = 1;\n\tif (FDCS->reset) {\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f",
        "vul_func_with_fix": "static int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive, interruptible))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tFDCS->reset = 1;\n\tif (FDCS->reset) {\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n",
        "linevul": 7.367173384409398e-05,
        "sysevr": 0.12940329313278198,
        "devign": 4.990832131911739e-27
    },
    {
        "code": "static inline void evmcs_touch_msr_bitmap(void)\n{\n\tif (unlikely(!current_evmcs))\n\t\treturn;\n\n\tif (current_evmcs->hv_enlightenments_control.msr_bitmap)\n\t\tcurrent_evmcs->hv_clean_fields &=\n\t\t\t~HV_VMX_ENLIGHTENED_CLEAN_FIELD_MSR_BITMAP;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static inline void evmcs_touch_msr_bitmap(void)\n{\n\tif (unlikely(!current_evmcs))\n\t\treturn;\n\n\tif (current_evmcs->hv_enlightenments_control.msr_bitmap)\n\t\tcurrent_evmcs->hv_clean_fields &=\n\t\t\t~HV_VMX_ENLIGHTENED_CLEAN_FIELD_MSR_BITMAP;\n}\n",
        "linevul": 4.836473453906365e-05,
        "sysevr": 0.12558448314666748,
        "devign": 0.6494994759559631
    },
    {
        "code": "struct iscsi_param *iscsi_find_param_from_key(\n\tchar *key,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (!key || !param_list) {\n\t\tpr_err(\"Key or parameter list pointer is NULL.\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(key, param->name))\n\t\t\treturn param;\n\t}\n\n\tpr_err(\"Unable to locate key \\\"%s\\\".\\n\", key);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456",
        "vul_func_with_fix": "struct iscsi_param *iscsi_find_param_from_key(\n\tchar *key,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (!key || !param_list) {\n\t\tpr_err(\"Key or parameter list pointer is NULL.\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(key, param->name))\n\t\t\treturn param;\n\t}\n\n\tpr_err(\"Unable to locate key \\\"%s\\\".\\n\", key);\n\treturn NULL;\n}\n",
        "linevul": 4.948155037709512e-05,
        "sysevr": 0.1409807950258255,
        "devign": 6.2226127740393645e-15
    },
    {
        "code": "int __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "vul_func_with_fix": "int __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n",
        "linevul": 4.8330250137951225e-05,
        "sysevr": 0.15413184463977814,
        "devign": 0.6716830730438232
    },
    {
        "code": "static void convert_pseudo_ld_imm64(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++)\n\t\tif (insn->code == (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tinsn->src_reg = 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e",
        "vul_func_with_fix": "static void convert_pseudo_ld_imm64(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++)\n\t\tif (insn->code == (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tinsn->src_reg = 0;\n}\n",
        "linevul": 5.96521349507384e-05,
        "sysevr": 0.128753200173378,
        "devign": 9.255678734338612e-18
    },
    {
        "code": "struct crypto_attr_type *crypto_get_attr_type(struct rtattr **tb)\n{\n\tstruct rtattr *rta = tb[0];\n\tstruct crypto_attr_type *algt;\n\n\tif (!rta)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (RTA_PAYLOAD(rta) < sizeof(*algt))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (rta->rta_type != CRYPTOA_TYPE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\talgt = RTA_DATA(rta);\n\n\treturn algt;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "struct crypto_attr_type *crypto_get_attr_type(struct rtattr **tb)\n{\n\tstruct rtattr *rta = tb[0];\n\tstruct crypto_attr_type *algt;\n\n\tif (!rta)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (RTA_PAYLOAD(rta) < sizeof(*algt))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (rta->rta_type != CRYPTOA_TYPE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\talgt = RTA_DATA(rta);\n\n\treturn algt;\n}\n",
        "linevul": 5.065399454906583e-05,
        "sysevr": 0.14060203731060028,
        "devign": 3.023701428128689e-11
    },
    {
        "code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\n\tval = 0;\n \tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n \t\tif (val > SG_MAX_QUEUE)\n \t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n \t\trinfo[val].req_state = srp->done + 1;\n \t\trinfo[val].problem =\n \t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9",
        "vul_func_with_fix": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\n\tval = 0;\n \tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n \t\tif (val > SG_MAX_QUEUE)\n \t\t\tbreak;\n//flaw_line_below:\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n \t\trinfo[val].req_state = srp->done + 1;\n \t\trinfo[val].problem =\n \t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}\n",
        "linevul": 0.9989553689956665,
        "sysevr": 0.22972606122493744,
        "devign": 0.9989251494407654
    },
    {
        "code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/eda98796aff0d9bf41094b06811f5def3b4c333c",
        "vul_func_with_fix": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \n//fix_flaw_line_below:\n//\t\tmemset(&vblank, 0, sizeof(vblank));\n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
        "linevul": 0.9990242719650269,
        "sysevr": 0.11965609341859818,
        "devign": 0.999991774559021
    },
    {
        "code": "static u16 llcp_tlv_miux(u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5",
        "vul_func_with_fix": "static u16 llcp_tlv_miux(u8 *tlv)\n{\n\treturn llcp_tlv16(tlv, LLCP_TLV_MIUX) & 0x7ff;\n}\n",
        "linevul": 4.854499638895504e-05,
        "sysevr": 0.13259756565093994,
        "devign": 2.9136796001694165e-05
    },
    {
        "code": "xfs_buf_init(void)\n{\n\txfs_buf_zone = kmem_zone_init_flags(sizeof(xfs_buf_t), \"xfs_buf\",\n\t\t\t\t\t\tKM_ZONE_HWALIGN, NULL);\n\tif (!xfs_buf_zone)\n\t\tgoto out;\n\n\txfslogd_workqueue = alloc_workqueue(\"xfslogd\",\n\t\t\t\t\tWQ_MEM_RECLAIM | WQ_HIGHPRI, 1);\n\tif (!xfslogd_workqueue)\n\t\tgoto out_free_buf_zone;\n\n\treturn 0;\n\n out_free_buf_zone:\n\tkmem_zone_destroy(xfs_buf_zone);\n out:\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/eb178619f930fa2ba2348de332a1ff1c66a31424",
        "vul_func_with_fix": "xfs_buf_init(void)\n{\n\txfs_buf_zone = kmem_zone_init_flags(sizeof(xfs_buf_t), \"xfs_buf\",\n\t\t\t\t\t\tKM_ZONE_HWALIGN, NULL);\n\tif (!xfs_buf_zone)\n\t\tgoto out;\n\n\txfslogd_workqueue = alloc_workqueue(\"xfslogd\",\n\t\t\t\t\tWQ_MEM_RECLAIM | WQ_HIGHPRI, 1);\n\tif (!xfslogd_workqueue)\n\t\tgoto out_free_buf_zone;\n\n\treturn 0;\n\n out_free_buf_zone:\n\tkmem_zone_destroy(xfs_buf_zone);\n out:\n\treturn -ENOMEM;\n}\n",
        "linevul": 5.8358673413749784e-05,
        "sysevr": 0.15582741796970367,
        "devign": 2.750670463023139e-15
    },
    {
        "code": "static unsigned shmem_find_get_pages_and_swap(struct address_space *mapping,\n\t\t\t\t\tpgoff_t start, unsigned int nr_pages,\n\t\t\t\t\tstruct page **pages, pgoff_t *indices)\n{\n\tvoid **slot;\n\tunsigned int ret = 0;\n\tstruct radix_tree_iter iter;\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\trcu_read_lock();\nrestart:\n\tradix_tree_for_each_slot(slot, &mapping->page_tree, &iter, start) {\n\t\tstruct page *page;\nrepeat:\n\t\tpage = radix_tree_deref_slot(slot);\n\t\tif (unlikely(!page))\n\t\t\tcontinue;\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page))\n\t\t\t\tgoto restart;\n\t\t\t/*\n\t\t\t * Otherwise, we must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it\n\t\t\t * without attempting to raise page count.\n\t\t\t */\n\t\t\tgoto export;\n\t\t}\n\t\tif (!page_cache_get_speculative(page))\n\t\t\tgoto repeat;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != *slot)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\nexport:\n\t\tindices[ret] = iter.index;\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "static unsigned shmem_find_get_pages_and_swap(struct address_space *mapping,\n\t\t\t\t\tpgoff_t start, unsigned int nr_pages,\n\t\t\t\t\tstruct page **pages, pgoff_t *indices)\n{\n\tvoid **slot;\n\tunsigned int ret = 0;\n\tstruct radix_tree_iter iter;\n\n\tif (!nr_pages)\n\t\treturn 0;\n\n\trcu_read_lock();\nrestart:\n\tradix_tree_for_each_slot(slot, &mapping->page_tree, &iter, start) {\n\t\tstruct page *page;\nrepeat:\n\t\tpage = radix_tree_deref_slot(slot);\n\t\tif (unlikely(!page))\n\t\t\tcontinue;\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page))\n\t\t\t\tgoto restart;\n\t\t\t/*\n\t\t\t * Otherwise, we must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it\n\t\t\t * without attempting to raise page count.\n\t\t\t */\n\t\t\tgoto export;\n\t\t}\n\t\tif (!page_cache_get_speculative(page))\n\t\t\tgoto repeat;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != *slot)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\nexport:\n\t\tindices[ret] = iter.index;\n\t\tpages[ret] = page;\n\t\tif (++ret == nr_pages)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n",
        "linevul": 0.00022390938829630613,
        "sysevr": 0.1165274903178215,
        "devign": 2.7811678520289863e-19
    },
    {
        "code": "int add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, NULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ce0030c00f95cf9110d9cdcd41e901e1fb814417",
        "vul_func_with_fix": "int add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, NULL);\n}\n",
        "linevul": 6.336699880193919e-05,
        "sysevr": 0.14874780178070068,
        "devign": 1.1308928793418715e-10
    },
    {
        "code": "static void dccp_v4_ctl_send_reset(struct sock *sk, struct sk_buff *rxskb)\n{\n\tint err;\n\tconst struct iphdr *rxiph;\n\tstruct sk_buff *skb;\n\tstruct dst_entry *dst;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct sock *ctl_sk = net->dccp.v4_ctl_sk;\n\n\t/* Never send a reset in response to a reset. */\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (skb_rtable(rxskb)->rt_type != RTN_LOCAL)\n\t\treturn;\n\n\tdst = dccp_v4_route_skb(net, ctl_sk, rxskb);\n\tif (dst == NULL)\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\trxiph = ip_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v4_csum_finish(skb, rxiph->saddr,\n\t\t\t\t\t\t\t\t rxiph->daddr);\n\tskb_dst_set(skb, dst_clone(dst));\n\n\tbh_lock_sock(ctl_sk);\n\terr = ip_build_and_send_pkt(skb, ctl_sk,\n\t\t\t\t    rxiph->daddr, rxiph->saddr, NULL);\n\tbh_unlock_sock(ctl_sk);\n\n\tif (net_xmit_eval(err) == 0) {\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);\n\t}\nout:\n\t dst_release(dst);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static void dccp_v4_ctl_send_reset(struct sock *sk, struct sk_buff *rxskb)\n{\n\tint err;\n\tconst struct iphdr *rxiph;\n\tstruct sk_buff *skb;\n\tstruct dst_entry *dst;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct sock *ctl_sk = net->dccp.v4_ctl_sk;\n\n\t/* Never send a reset in response to a reset. */\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (skb_rtable(rxskb)->rt_type != RTN_LOCAL)\n\t\treturn;\n\n\tdst = dccp_v4_route_skb(net, ctl_sk, rxskb);\n\tif (dst == NULL)\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\trxiph = ip_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v4_csum_finish(skb, rxiph->saddr,\n\t\t\t\t\t\t\t\t rxiph->daddr);\n\tskb_dst_set(skb, dst_clone(dst));\n\n\tbh_lock_sock(ctl_sk);\n\terr = ip_build_and_send_pkt(skb, ctl_sk,\n\t\t\t\t    rxiph->daddr, rxiph->saddr, NULL);\n\tbh_unlock_sock(ctl_sk);\n\n\tif (net_xmit_eval(err) == 0) {\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);\n\t}\nout:\n\t dst_release(dst);\n}\n",
        "linevul": 5.0143004045821726e-05,
        "sysevr": 0.14725901186466217,
        "devign": 3.243040692544612e-27
    },
    {
        "code": "xfs_find_get_desired_pgoff(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*map,\n\tunsigned int\t\ttype,\n\tloff_t\t\t\t*offset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct pagevec\t\tpvec;\n\tpgoff_t\t\t\tindex;\n\tpgoff_t\t\t\tend;\n\tloff_t\t\t\tendoff;\n\tloff_t\t\t\tstartoff = *offset;\n\tloff_t\t\t\tlastoff = startoff;\n\tbool\t\t\tfound = false;\n\n\tpagevec_init(&pvec, 0);\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tendoff = XFS_FSB_TO_B(mp, map->br_startoff + map->br_blockcount);\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tint\t\twant;\n\t\tunsigned\tnr_pages;\n\t\tunsigned int\ti;\n\n\t\twant = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  want);\n\t\t/*\n\t\t * No page mapped into given range.  If we are searching holes\n\t\t * and if this is the first time we got into the loop, it means\n\t\t * that the given offset is landed in a hole, return it.\n\t\t *\n\t\t * If we have already stepped through some block buffers to find\n\t\t * holes but they all contains data.  In this case, the last\n\t\t * offset is already updated and pointed to the end of the last\n\t\t * mapped page, if it does not reach the endpoint to search,\n\t\t * that means there should be a hole between them.\n\t\t */\n\t\tif (nr_pages == 0) {\n\t\t\t/* Data search found nothing */\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(type == HOLE_OFF);\n\t\t\tif (lastoff == startoff || lastoff < endoff) {\n\t\t\t\tfound = true;\n\t\t\t\t*offset = lastoff;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * At lease we found one page.  If this is the first time we\n\t\t * step into the loop, and if the first page index offset is\n\t\t * greater than the given search offset, a hole was found.\n\t\t */\n\t\tif (type == HOLE_OFF && lastoff == startoff &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page\t*page = pvec.pages[i];\n\t\t\tloff_t\t\tb_offset;\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL),\n\t\t\t * or even swizzled back from swapper_space to tmpfs\n\t\t\t * file mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t *\n\t\t\t * Searching done if the page index is out of range.\n\t\t\t * If the current offset is not reaches the end of\n\t\t\t * the specified search range, there should be a hole\n\t\t\t * between them.\n\t\t\t */\n\t\t\tif (page->index > end) {\n\t\t\t\tif (type == HOLE_OFF && lastoff < endoff) {\n\t\t\t\t\t*offset = lastoff;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * Page truncated or invalidated(page->mapping == NULL).\n\t\t\t * We can freely skip it and proceed to check the next\n\t\t\t * page.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = xfs_lookup_buffer_offset(page, &b_offset, type);\n\t\t\tif (found) {\n\t\t\t\t/*\n\t\t\t\t * The found offset may be less than the start\n\t\t\t\t * point to search if this is the first time to\n\t\t\t\t * come here.\n\t\t\t\t */\n\t\t\t\t*offset = max_t(loff_t, startoff, b_offset);\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We either searching data but nothing was found, or\n\t\t\t * searching hole but found a data buffer.  In either\n\t\t\t * case, probably the next page contains the desired\n\t\t\t * things, update the last offset to it so.\n\t\t\t */\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The number of returned pages less than our desired, search\n\t\t * done.  In this case, nothing was found for searching data,\n\t\t * but we found a hole behind the last offset.\n\t\t */\n\t\tif (nr_pages < want) {\n\t\t\tif (type == HOLE_OFF) {\n\t\t\t\t*offset = lastoff;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958",
        "vul_func_with_fix": "xfs_find_get_desired_pgoff(\n\tstruct inode\t\t*inode,\n\tstruct xfs_bmbt_irec\t*map,\n\tunsigned int\t\ttype,\n\tloff_t\t\t\t*offset)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct pagevec\t\tpvec;\n\tpgoff_t\t\t\tindex;\n\tpgoff_t\t\t\tend;\n\tloff_t\t\t\tendoff;\n\tloff_t\t\t\tstartoff = *offset;\n\tloff_t\t\t\tlastoff = startoff;\n\tbool\t\t\tfound = false;\n\n\tpagevec_init(&pvec, 0);\n\n\tindex = startoff >> PAGE_CACHE_SHIFT;\n\tendoff = XFS_FSB_TO_B(mp, map->br_startoff + map->br_blockcount);\n\tend = endoff >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\tint\t\twant;\n\t\tunsigned\tnr_pages;\n\t\tunsigned int\ti;\n\n\t\twant = min_t(pgoff_t, end - index, PAGEVEC_SIZE);\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, index,\n\t\t\t\t\t  want);\n\t\t/*\n\t\t * No page mapped into given range.  If we are searching holes\n\t\t * and if this is the first time we got into the loop, it means\n\t\t * that the given offset is landed in a hole, return it.\n\t\t *\n\t\t * If we have already stepped through some block buffers to find\n\t\t * holes but they all contains data.  In this case, the last\n\t\t * offset is already updated and pointed to the end of the last\n\t\t * mapped page, if it does not reach the endpoint to search,\n\t\t * that means there should be a hole between them.\n\t\t */\n\t\tif (nr_pages == 0) {\n\t\t\t/* Data search found nothing */\n\t\t\tif (type == DATA_OFF)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(type == HOLE_OFF);\n\t\t\tif (lastoff == startoff || lastoff < endoff) {\n\t\t\t\tfound = true;\n\t\t\t\t*offset = lastoff;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * At lease we found one page.  If this is the first time we\n\t\t * step into the loop, and if the first page index offset is\n\t\t * greater than the given search offset, a hole was found.\n\t\t */\n\t\tif (type == HOLE_OFF && lastoff == startoff &&\n\t\t    lastoff < page_offset(pvec.pages[0])) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page\t*page = pvec.pages[i];\n\t\t\tloff_t\t\tb_offset;\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL),\n\t\t\t * or even swizzled back from swapper_space to tmpfs\n\t\t\t * file mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t *\n\t\t\t * Searching done if the page index is out of range.\n\t\t\t * If the current offset is not reaches the end of\n\t\t\t * the specified search range, there should be a hole\n\t\t\t * between them.\n\t\t\t */\n\t\t\tif (page->index > end) {\n\t\t\t\tif (type == HOLE_OFF && lastoff < endoff) {\n\t\t\t\t\t*offset = lastoff;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * Page truncated or invalidated(page->mapping == NULL).\n\t\t\t * We can freely skip it and proceed to check the next\n\t\t\t * page.\n\t\t\t */\n\t\t\tif (unlikely(page->mapping != inode->i_mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!page_has_buffers(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfound = xfs_lookup_buffer_offset(page, &b_offset, type);\n\t\t\tif (found) {\n\t\t\t\t/*\n\t\t\t\t * The found offset may be less than the start\n\t\t\t\t * point to search if this is the first time to\n\t\t\t\t * come here.\n\t\t\t\t */\n\t\t\t\t*offset = max_t(loff_t, startoff, b_offset);\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We either searching data but nothing was found, or\n\t\t\t * searching hole but found a data buffer.  In either\n\t\t\t * case, probably the next page contains the desired\n\t\t\t * things, update the last offset to it so.\n\t\t\t */\n\t\t\tlastoff = page_offset(page) + PAGE_SIZE;\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\t/*\n\t\t * The number of returned pages less than our desired, search\n\t\t * done.  In this case, nothing was found for searching data,\n\t\t * but we found a hole behind the last offset.\n\t\t */\n\t\tif (nr_pages < want) {\n\t\t\tif (type == HOLE_OFF) {\n\t\t\t\t*offset = lastoff;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tindex = pvec.pages[i - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t} while (index <= end);\n\nout:\n\tpagevec_release(&pvec);\n\treturn found;\n}\n",
        "linevul": 9.153029532171786e-05,
        "sysevr": 0.2760710120201111,
        "devign": 1.9618395100534435e-28
    },
    {
        "code": "static int nfs4_xdr_enc_delegreturn(struct rpc_rqst *req, __be32 *p, const struct nfs4_delegreturnargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fhandle);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_delegreturn(&xdr, args->stateid);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int nfs4_xdr_enc_delegreturn(struct rpc_rqst *req, __be32 *p, const struct nfs4_delegreturnargs *args)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr = {\n\t\t.nops = 3,\n\t};\n\tint status;\n\n\txdr_init_encode(&xdr, &req->rq_snd_buf, p);\n\tencode_compound_hdr(&xdr, &hdr);\n\tstatus = encode_putfh(&xdr, args->fhandle);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_delegreturn(&xdr, args->stateid);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = encode_getfattr(&xdr, args->bitmask);\nout:\n\treturn status;\n}\n",
        "linevul": 5.366525147110224e-05,
        "sysevr": 0.13735459744930267,
        "devign": 2.97677625550121e-27
    },
    {
        "code": "static void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tstruct inet6_timewait_sock *tw6 = inet6_twsk((struct sock *)tw);\n\tint ttd = tw->tw_ttd - jiffies;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tdest = &tw6->tw_v6_daddr;\n\tsrc  = &tw6->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tstruct inet6_timewait_sock *tw6 = inet6_twsk((struct sock *)tw);\n\tint ttd = tw->tw_ttd - jiffies;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tdest = &tw6->tw_v6_daddr;\n\tsrc  = &tw6->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n",
        "linevul": 8.880053064785898e-05,
        "sysevr": 0.16200430691242218,
        "devign": 2.929024346199141e-14
    },
    {
        "code": "int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tint ret;\n\n\tret = gfs2_rsqa_alloc(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tneed_unlock = true;\n\t}\n\tret = __gfs2_set_acl(inode, acl, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef",
        "vul_func_with_fix": "int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tbool need_unlock = false;\n\tint ret;\n\n\tret = gfs2_rsqa_alloc(ip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!gfs2_glock_is_locked_by_me(ip->i_gl)) {\n\t\tret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tneed_unlock = true;\n\t}\n\tret = __gfs2_set_acl(inode, acl, type);\n\tif (need_unlock)\n\t\tgfs2_glock_dq_uninit(&gh);\n\treturn ret;\n}\n",
        "linevul": 6.227647099876776e-05,
        "sysevr": 0.16873908042907715,
        "devign": 0.00027675912133418024
    },
    {
        "code": "static int __register_pernet_operations(struct list_head *list,\n\t\t\t\t\tstruct pernet_operations *ops)\n{\n\tif (!init_net_initialized) {\n\t\tlist_add_tail(&ops->list, list);\n\t\treturn 0;\n\t}\n\n\treturn ops_init(ops, &init_net);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0",
        "vul_func_with_fix": "static int __register_pernet_operations(struct list_head *list,\n\t\t\t\t\tstruct pernet_operations *ops)\n{\n\tif (!init_net_initialized) {\n\t\tlist_add_tail(&ops->list, list);\n\t\treturn 0;\n\t}\n\n\treturn ops_init(ops, &init_net);\n}\n",
        "linevul": 6.98291405569762e-05,
        "sysevr": 0.12969672679901123,
        "devign": 0.0003260643861722201
    },
    {
        "code": "struct bio *bio_copy_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t  gfp_t gfp_mask, int reading)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tstruct bio *bio;\n\tvoid *p = data;\n\tint nr_pages = 0;\n\n\t/*\n\t * Overflow, abort\n\t */\n\tif (end < start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = end - start;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (len) {\n\t\tstruct page *page;\n\t\tunsigned int bytes = PAGE_SIZE;\n\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tpage = alloc_page(q->bounce_gfp | gfp_mask);\n\t\tif (!page)\n\t\t\tgoto cleanup;\n\n\t\tif (!reading)\n\t\t\tmemcpy(page_address(page), p, bytes);\n\n\t\tif (bio_add_pc_page(q, bio, page, bytes, 0) < bytes)\n\t\t\tbreak;\n\n\t\tlen -= bytes;\n\t\tp += bytes;\n\t}\n\n\tif (reading) {\n\t\tbio->bi_end_io = bio_copy_kern_endio_read;\n\t\tbio->bi_private = data;\n\t} else {\n\t\tbio->bi_end_io = bio_copy_kern_endio;\n\t}\n\n\treturn bio;\n\ncleanup:\n\tbio_free_pages(bio);\n\tbio_put(bio);\n\treturn ERR_PTR(-ENOMEM);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467",
        "vul_func_with_fix": "struct bio *bio_copy_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t  gfp_t gfp_mask, int reading)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tstruct bio *bio;\n\tvoid *p = data;\n\tint nr_pages = 0;\n\n\t/*\n\t * Overflow, abort\n\t */\n\tif (end < start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = end - start;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (len) {\n\t\tstruct page *page;\n\t\tunsigned int bytes = PAGE_SIZE;\n\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tpage = alloc_page(q->bounce_gfp | gfp_mask);\n\t\tif (!page)\n\t\t\tgoto cleanup;\n\n\t\tif (!reading)\n\t\t\tmemcpy(page_address(page), p, bytes);\n\n\t\tif (bio_add_pc_page(q, bio, page, bytes, 0) < bytes)\n\t\t\tbreak;\n\n\t\tlen -= bytes;\n\t\tp += bytes;\n\t}\n\n\tif (reading) {\n\t\tbio->bi_end_io = bio_copy_kern_endio_read;\n\t\tbio->bi_private = data;\n\t} else {\n\t\tbio->bi_end_io = bio_copy_kern_endio;\n\t}\n\n\treturn bio;\n\ncleanup:\n\tbio_free_pages(bio);\n\tbio_put(bio);\n\treturn ERR_PTR(-ENOMEM);\n}\n",
        "linevul": 0.002410547574982047,
        "sysevr": 0.15581531822681427,
        "devign": 7.722620884838039e-25
    },
    {
        "code": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271",
        "vul_func_with_fix": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n",
        "linevul": 4.915585304843262e-05,
        "sysevr": 0.16980530321598053,
        "devign": 1.223994153869192e-27
    },
    {
        "code": "void blkcg_exit_queue(struct request_queue *q)\n{\n\tspin_lock_irq(q->queue_lock);\n\tblkg_destroy_all(q);\n\tspin_unlock_irq(q->queue_lock);\n\n\tblk_throtl_exit(q);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258",
        "vul_func_with_fix": "void blkcg_exit_queue(struct request_queue *q)\n{\n\tspin_lock_irq(q->queue_lock);\n\tblkg_destroy_all(q);\n\tspin_unlock_irq(q->queue_lock);\n\n\tblk_throtl_exit(q);\n}\n",
        "linevul": 7.659719994990155e-05,
        "sysevr": 0.15661542117595673,
        "devign": 9.789362957235426e-05
    },
    {
        "code": "int __init early_platform_driver_probe(char *class_str,\n\t\t\t\t       int nr_probe,\n\t\t\t\t       int user_only)\n{\n\tint k, n, i;\n\n\tn = 0;\n\tfor (i = -2; n < nr_probe; i++) {\n\t\tk = early_platform_driver_probe_id(class_str, i, nr_probe - n);\n\n\t\tif (k < 0)\n\t\t\tbreak;\n\n\t\tn += k;\n\n\t\tif (user_only)\n\t\t\tbreak;\n\t}\n\n\treturn n;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154",
        "vul_func_with_fix": "int __init early_platform_driver_probe(char *class_str,\n\t\t\t\t       int nr_probe,\n\t\t\t\t       int user_only)\n{\n\tint k, n, i;\n\n\tn = 0;\n\tfor (i = -2; n < nr_probe; i++) {\n\t\tk = early_platform_driver_probe_id(class_str, i, nr_probe - n);\n\n\t\tif (k < 0)\n\t\t\tbreak;\n\n\t\tn += k;\n\n\t\tif (user_only)\n\t\t\tbreak;\n\t}\n\n\treturn n;\n}\n",
        "linevul": 4.823429117095657e-05,
        "sysevr": 0.1488749235868454,
        "devign": 0.5690847635269165
    },
    {
        "code": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n {\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n \n\tif (d->fe_adap[0].fe == NULL)\n \t\treturn -EIO;\n \n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n \t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n \t\tinfo(\"Attached RS2000/TS2020!\");\n \t\treturn 0;\n \t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125",
        "vul_func_with_fix": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n//fix_flaw_line_below:\n//static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)\n {\n//flaw_line_below:\n\tu8 obuf[] = { 0x51 };\n//flaw_line_below:\n\tu8 ibuf[] = { 0 };\n//fix_flaw_line_below:\n//\tstruct dvb_usb_device *d = adap->dev;\n//fix_flaw_line_below:\n//\tstruct dw2102_state *state = d->priv;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tmutex_lock(&d->data_mutex);\n \n//flaw_line_below:\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n//fix_flaw_line_below:\n//\tstate->data[0] = 0x51;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n//flaw_line_below:\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n//flaw_line_below:\n\t\t\t\t\t&d->dev->i2c_adap);\n//fix_flaw_line_below:\n//\tmutex_unlock(&d->data_mutex);\n \n//flaw_line_below:\n\tif (d->fe_adap[0].fe == NULL)\n//fix_flaw_line_below:\n//\tadap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,\n//fix_flaw_line_below:\n//\t\t\t\t\t&s421_m88rs2000_config,\n//fix_flaw_line_below:\n//\t\t\t\t\t&d->i2c_adap);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (adap->fe_adap[0].fe == NULL)\n \t\treturn -EIO;\n \n//flaw_line_below:\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n//fix_flaw_line_below:\n//\tif (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,\n \t\t\t\t&dw2104_ts2020_config,\n//flaw_line_below:\n\t\t\t\t&d->dev->i2c_adap)) {\n//fix_flaw_line_below:\n//\t\t\t\t&d->i2c_adap)) {\n \t\tinfo(\"Attached RS2000/TS2020!\");\n \t\treturn 0;\n \t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}\n",
        "linevul": 0.9986501336097717,
        "sysevr": 0.13376542925834656,
        "devign": 6.8074293082956774e-15
    },
    {
        "code": "static void packet_increment_head(struct packet_ring_buffer *buff)\n{\n\tbuff->head = buff->head != buff->frame_max ? buff->head+1 : 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static void packet_increment_head(struct packet_ring_buffer *buff)\n{\n\tbuff->head = buff->head != buff->frame_max ? buff->head+1 : 0;\n}\n",
        "linevul": 7.517956692026928e-05,
        "sysevr": 0.13082462549209595,
        "devign": 7.396137874241329e-14
    },
    {
        "code": "static bool is_simm32(s64 value)\n{\n\treturn value == (s64) (s32) value;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3f7352bf21f8fd7ba3e2fcef9488756f188e12be",
        "vul_func_with_fix": "static bool is_simm32(s64 value)\n{\n\treturn value == (s64) (s32) value;\n}\n",
        "linevul": 5.052725100540556e-05,
        "sysevr": 0.1314678192138672,
        "devign": 0.0015719120856374502
    },
    {
        "code": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n {\n \tstruct br_mdb_entry entry;\n \n \tentry.ifindex = port->dev->ifindex;\n \tentry.addr.proto = group->proto;\n \tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc",
        "vul_func_with_fix": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n {\n \tstruct br_mdb_entry entry;\n \n//fix_flaw_line_below:\n//\tmemset(&entry, 0, sizeof(entry));\n \tentry.ifindex = port->dev->ifindex;\n \tentry.addr.proto = group->proto;\n \tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n",
        "linevul": 0.9996367692947388,
        "sysevr": 0.1853395253419876,
        "devign": 0.22523799538612366
    },
    {
        "code": "static int tipc_nl_compat_bearer_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t      struct nlattr **attrs)\n{\n\tstruct nlattr *bearer[TIPC_NLA_BEARER_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(bearer, TIPC_NLA_BEARER_MAX,\n\t\t\t       attrs[TIPC_NLA_BEARER], NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_BEARER_NAME,\n\t\t\t    nla_data(bearer[TIPC_NLA_BEARER_NAME]),\n\t\t\t    nla_len(bearer[TIPC_NLA_BEARER_NAME]));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2",
        "vul_func_with_fix": "static int tipc_nl_compat_bearer_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t      struct nlattr **attrs)\n{\n\tstruct nlattr *bearer[TIPC_NLA_BEARER_MAX + 1];\n\tint err;\n\n\tif (!attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(bearer, TIPC_NLA_BEARER_MAX,\n\t\t\t       attrs[TIPC_NLA_BEARER], NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_BEARER_NAME,\n\t\t\t    nla_data(bearer[TIPC_NLA_BEARER_NAME]),\n\t\t\t    nla_len(bearer[TIPC_NLA_BEARER_NAME]));\n}\n",
        "linevul": 5.453350240713917e-05,
        "sysevr": 0.125959113240242,
        "devign": 2.0475013351450855e-10
    },
    {
        "code": "static unsigned int fuse_req_hash(u64 unique)\n{\n\treturn hash_long(unique & ~FUSE_INT_REQ_BIT, FUSE_PQ_HASH_BITS);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "vul_func_with_fix": "static unsigned int fuse_req_hash(u64 unique)\n{\n\treturn hash_long(unique & ~FUSE_INT_REQ_BIT, FUSE_PQ_HASH_BITS);\n}\n",
        "linevul": 5.9199901443207636e-05,
        "sysevr": 0.12699437141418457,
        "devign": 0.01769043505191803
    },
    {
        "code": "static int sctp_setsockopt_enable_strreset(struct sock *sk,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(params))\n\t\tgoto out;\n\n\tif (copy_from_user(&params, optval, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (params.assoc_value & (~SCTP_ENABLE_STRRESET_MASK))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tasoc->strreset_enable = params.assoc_value;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tsp->ep->strreset_enable = params.assoc_value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "vul_func_with_fix": "static int sctp_setsockopt_enable_strreset(struct sock *sk,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(params))\n\t\tgoto out;\n\n\tif (copy_from_user(&params, optval, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (params.assoc_value & (~SCTP_ENABLE_STRRESET_MASK))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (asoc) {\n\t\tasoc->strreset_enable = params.assoc_value;\n\t} else if (!params.assoc_id) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tsp->ep->strreset_enable = params.assoc_value;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n",
        "linevul": 5.1002498366869986e-05,
        "sysevr": 0.12236876785755157,
        "devign": 0.6535395383834839
    },
    {
        "code": "static int do_insnlist_ioctl(struct comedi_device *dev,\n\t\t\t     struct comedi_insnlist __user *arg, void *file)\n{\n\tstruct comedi_insnlist insnlist;\n\tstruct comedi_insn *insns = NULL;\n\tunsigned int *data = NULL;\n\tint i = 0;\n\tint ret = 0;\n\n\tif (copy_from_user(&insnlist, arg, sizeof(struct comedi_insnlist)))\n\t\treturn -EFAULT;\n\n\tdata = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);\n\tif (!data) {\n\t\tDPRINTK(\"kmalloc failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinsns =\n\t    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);\n\tif (!insns) {\n\t\tDPRINTK(\"kmalloc failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(insns, insnlist.insns,\n\t\t\t   sizeof(struct comedi_insn) * insnlist.n_insns)) {\n\t\tDPRINTK(\"copy_from_user failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < insnlist.n_insns; i++) {\n\t\tif (insns[i].n > MAX_SAMPLES) {\n\t\t\tDPRINTK(\"number of samples too large\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tif (insns[i].insn & INSN_MASK_WRITE) {\n\t\t\tif (copy_from_user(data, insns[i].data,\n\t\t\t\t\t   insns[i].n * sizeof(unsigned int))) {\n\t\t\t\tDPRINTK(\"copy_from_user failed\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tret = parse_insn(dev, insns + i, data, file);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (insns[i].insn & INSN_MASK_READ) {\n\t\t\tif (copy_to_user(insns[i].data, data,\n\t\t\t\t\t insns[i].n * sizeof(unsigned int))) {\n\t\t\t\tDPRINTK(\"copy_to_user failed\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nerror:\n\tkfree(insns);\n\tkfree(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn i;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/819cbb120eaec7e014e5abd029260db1ca8c5735",
        "vul_func_with_fix": "static int do_insnlist_ioctl(struct comedi_device *dev,\n\t\t\t     struct comedi_insnlist __user *arg, void *file)\n{\n\tstruct comedi_insnlist insnlist;\n\tstruct comedi_insn *insns = NULL;\n\tunsigned int *data = NULL;\n\tint i = 0;\n\tint ret = 0;\n\n\tif (copy_from_user(&insnlist, arg, sizeof(struct comedi_insnlist)))\n\t\treturn -EFAULT;\n\n\tdata = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);\n\tif (!data) {\n\t\tDPRINTK(\"kmalloc failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinsns =\n\t    kmalloc(sizeof(struct comedi_insn) * insnlist.n_insns, GFP_KERNEL);\n\tif (!insns) {\n\t\tDPRINTK(\"kmalloc failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(insns, insnlist.insns,\n\t\t\t   sizeof(struct comedi_insn) * insnlist.n_insns)) {\n\t\tDPRINTK(\"copy_from_user failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < insnlist.n_insns; i++) {\n\t\tif (insns[i].n > MAX_SAMPLES) {\n\t\t\tDPRINTK(\"number of samples too large\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tif (insns[i].insn & INSN_MASK_WRITE) {\n\t\t\tif (copy_from_user(data, insns[i].data,\n\t\t\t\t\t   insns[i].n * sizeof(unsigned int))) {\n\t\t\t\tDPRINTK(\"copy_from_user failed\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tret = parse_insn(dev, insns + i, data, file);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (insns[i].insn & INSN_MASK_READ) {\n\t\t\tif (copy_to_user(insns[i].data, data,\n\t\t\t\t\t insns[i].n * sizeof(unsigned int))) {\n\t\t\t\tDPRINTK(\"copy_to_user failed\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nerror:\n\tkfree(insns);\n\tkfree(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn i;\n}\n",
        "linevul": 7.688948971917853e-05,
        "sysevr": 0.13253480195999146,
        "devign": 0.6464301943778992
    },
    {
        "code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f2e323ec96077642d397bb1c355def536d489d16",
        "vul_func_with_fix": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \n//fix_flaw_line_below:\n//\tif (cmd->msg_len > sizeof(b) - 4)\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}\n",
        "linevul": 0.9997112154960632,
        "sysevr": 0.12975400686264038,
        "devign": 2.42671299721664e-11
    },
    {
        "code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6",
        "vul_func_with_fix": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n//flaw_line_below:\n\t\t    u8 *dst, unsigned int dlen)\n//flaw_line_below:\n{\n//flaw_line_below:\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n//flaw_line_below:\n}\n",
        "linevul": 0.07722704112529755,
        "sysevr": 0.12752242386341095,
        "devign": 0.9899150133132935
    },
    {
        "code": "static int __init wanxl_init_module(void)\n{\n#ifdef MODULE\n\tpr_info(\"%s\\n\", version);\n#endif\n\treturn pci_register_driver(&wanxl_pci_driver);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2b13d06c9584b4eb773f1e80bbaedab9a1c344e1",
        "vul_func_with_fix": "static int __init wanxl_init_module(void)\n{\n#ifdef MODULE\n\tpr_info(\"%s\\n\", version);\n#endif\n\treturn pci_register_driver(&wanxl_pci_driver);\n}\n",
        "linevul": 8.909877942642197e-05,
        "sysevr": 0.12619057297706604,
        "devign": 0.4991692900657654
    },
    {
        "code": "static void kmem_rcu_free(struct rcu_head *head)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\tpage = container_of(head, struct page, rcu_head);\n\tcachep = page->slab_cache;\n\n\tkmem_freepages(cachep, page);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
        "vul_func_with_fix": "static void kmem_rcu_free(struct rcu_head *head)\n{\n\tstruct kmem_cache *cachep;\n\tstruct page *page;\n\n\tpage = container_of(head, struct page, rcu_head);\n\tcachep = page->slab_cache;\n\n\tkmem_freepages(cachep, page);\n}\n",
        "linevul": 8.655394049128518e-05,
        "sysevr": 0.11327263712882996,
        "devign": 1.1963431461481377e-05
    },
    {
        "code": "static ssize_t write_iter_null(struct kiocb *iocb, struct iov_iter *from)\n{\n\tsize_t count = iov_iter_count(from);\n\tiov_iter_advance(from, count);\n\treturn count;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
        "vul_func_with_fix": "static ssize_t write_iter_null(struct kiocb *iocb, struct iov_iter *from)\n{\n\tsize_t count = iov_iter_count(from);\n\tiov_iter_advance(from, count);\n\treturn count;\n}\n",
        "linevul": 0.00010066598042612895,
        "sysevr": 0.1286090463399887,
        "devign": 1.856653000231745e-07
    },
    {
        "code": "static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ca_ops->cong_avoid(sk, ack, acked);\n\ttcp_sk(sk)->snd_cwnd_stamp = tcp_time_stamp;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758",
        "vul_func_with_fix": "static void tcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\ticsk->icsk_ca_ops->cong_avoid(sk, ack, acked);\n\ttcp_sk(sk)->snd_cwnd_stamp = tcp_time_stamp;\n}\n",
        "linevul": 4.852421261603013e-05,
        "sysevr": 0.12627211213111877,
        "devign": 1.1164523759698078e-13
    },
    {
        "code": "static bool check_underflow(const struct arpt_entry *e)\n{\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n\tif (!unconditional(&e->arp))\n \t\treturn false;\n \tt = arpt_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309",
        "vul_func_with_fix": "static bool check_underflow(const struct arpt_entry *e)\n{\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n//flaw_line_below:\n\tif (!unconditional(&e->arp))\n//fix_flaw_line_below:\n//\tif (!unconditional(e))\n \t\treturn false;\n \tt = arpt_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}\n",
        "linevul": 0.9988841414451599,
        "sysevr": 0.13520608842372894,
        "devign": 0.9979158043861389
    },
    {
        "code": "static int _nfs41_proc_fsid_present(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct nfs4_fsid_present_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t};\n\tstruct nfs4_fsid_present_res res = {\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FSID_PRESENT],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint status;\n\n\tres.fh = nfs_alloc_fhandle();\n\tif (res.fh == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tnfs4_set_sequence_privileged(&args.seq_args);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tnfs_free_fhandle(res.fh);\n\tif (status == NFS4_OK &&\n\t    res.seq_res.sr_status_flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tstatus = -NFS4ERR_LEASE_MOVED;\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static int _nfs41_proc_fsid_present(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct nfs4_fsid_present_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t};\n\tstruct nfs4_fsid_present_res res = {\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FSID_PRESENT],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint status;\n\n\tres.fh = nfs_alloc_fhandle();\n\tif (res.fh == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tnfs4_set_sequence_privileged(&args.seq_args);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tnfs_free_fhandle(res.fh);\n\tif (status == NFS4_OK &&\n\t    res.seq_res.sr_status_flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tstatus = -NFS4ERR_LEASE_MOVED;\n\treturn status;\n}\n",
        "linevul": 9.539991151541471e-05,
        "sysevr": 0.1439104676246643,
        "devign": 1.017613906992787e-21
    },
    {
        "code": "int br_multicast_toggle(struct net_bridge *br, unsigned long val)\n{\n\tstruct net_bridge_port *port;\n\tint err = 0;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled == !val)\n\t\tgoto unlock;\n\n\tbr->multicast_disabled = !val;\n\tif (br->multicast_disabled)\n\t\tgoto unlock;\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->multicast_disabled = !!val;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, mdb->max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tbr_multicast_open(br);\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->state == BR_STATE_DISABLED ||\n\t\t    port->state == BR_STATE_BLOCKING)\n\t\t\tcontinue;\n\n\t\t__br_multicast_enable_port(port);\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287",
        "vul_func_with_fix": "int br_multicast_toggle(struct net_bridge *br, unsigned long val)\n{\n\tstruct net_bridge_port *port;\n\tint err = 0;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (br->multicast_disabled == !val)\n\t\tgoto unlock;\n\n\tbr->multicast_disabled = !val;\n\tif (br->multicast_disabled)\n\t\tgoto unlock;\n\n\tif (!netif_running(br->dev))\n\t\tgoto unlock;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (mdb) {\n\t\tif (mdb->old) {\n\t\t\terr = -EEXIST;\nrollback:\n\t\t\tbr->multicast_disabled = !!val;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = br_mdb_rehash(&br->mdb, mdb->max,\n\t\t\t\t    br->hash_elasticity);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tbr_multicast_open(br);\n\tlist_for_each_entry(port, &br->port_list, list) {\n\t\tif (port->state == BR_STATE_DISABLED ||\n\t\t    port->state == BR_STATE_BLOCKING)\n\t\t\tcontinue;\n\n\t\t__br_multicast_enable_port(port);\n\t}\n\nunlock:\n\tspin_unlock(&br->multicast_lock);\n\n\treturn err;\n}\n",
        "linevul": 6.625123205594718e-05,
        "sysevr": 0.17168855667114258,
        "devign": 8.43798340186973e-16
    },
    {
        "code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
        "vul_func_with_fix": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n//flaw_line_below:\n\t\t\t       __be16 dport)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tstruct keydata *keyptr = get_keyptr();\n//flaw_line_below:\n\tu32 hash[12];\n//flaw_line_below:\n\n//flaw_line_below:\n\tmemcpy(hash, saddr, 16);\n//flaw_line_below:\n\thash[4] = (__force u32)dport;\n//flaw_line_below:\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n//flaw_line_below:\n\n//flaw_line_below:\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n//flaw_line_below:\n}\n",
        "linevul": 0.018013974651694298,
        "sysevr": 0.16994811594486237,
        "devign": 0.999058187007904
    },
    {
        "code": "static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t\tstruct ath_txq *txq, struct list_head *bf_q,\n\t\t\t\tstruct ath_tx_status *ts, int txok)\n{\n\tstruct sk_buff *skb = bf->bf_mpdu;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tunsigned long flags;\n\tint tx_flags = 0;\n\n\tif (!txok)\n\t\ttx_flags |= ATH_TX_ERROR;\n\n\tif (ts->ts_status & ATH9K_TXERR_FILT)\n\t\ttx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\n\tdma_unmap_single(sc->dev, bf->bf_buf_addr, skb->len, DMA_TO_DEVICE);\n\tbf->bf_buf_addr = 0;\n\tif (sc->tx99_state)\n\t\tgoto skip_tx_complete;\n\n\tif (bf->bf_state.bfs_paprd) {\n\t\tif (time_after(jiffies,\n\t\t\t\tbf->bf_state.bfs_paprd_timestamp +\n\t\t\t\tmsecs_to_jiffies(ATH_PAPRD_TIMEOUT)))\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tcomplete(&sc->paprd_complete);\n\t} else {\n\t\tath_debug_stat_tx(sc, bf, ts, txq, tx_flags);\n\t\tath_tx_complete(sc, skb, tx_flags, txq);\n\t}\nskip_tx_complete:\n\t/* At this point, skb (bf->bf_mpdu) is consumed...make sure we don't\n\t * accidentally reference it later.\n\t */\n\tbf->bf_mpdu = NULL;\n\n\t/*\n\t * Return the list of ath_buf of this mpdu to free queue\n\t */\n\tspin_lock_irqsave(&sc->tx.txbuflock, flags);\n\tlist_splice_tail_init(bf_q, &sc->tx.txbuf);\n\tspin_unlock_irqrestore(&sc->tx.txbuflock, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/21f8aaee0c62708654988ce092838aa7df4d25d8",
        "vul_func_with_fix": "static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,\n\t\t\t\tstruct ath_txq *txq, struct list_head *bf_q,\n\t\t\t\tstruct ath_tx_status *ts, int txok)\n{\n\tstruct sk_buff *skb = bf->bf_mpdu;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tunsigned long flags;\n\tint tx_flags = 0;\n\n\tif (!txok)\n\t\ttx_flags |= ATH_TX_ERROR;\n\n\tif (ts->ts_status & ATH9K_TXERR_FILT)\n\t\ttx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\n\tdma_unmap_single(sc->dev, bf->bf_buf_addr, skb->len, DMA_TO_DEVICE);\n\tbf->bf_buf_addr = 0;\n\tif (sc->tx99_state)\n\t\tgoto skip_tx_complete;\n\n\tif (bf->bf_state.bfs_paprd) {\n\t\tif (time_after(jiffies,\n\t\t\t\tbf->bf_state.bfs_paprd_timestamp +\n\t\t\t\tmsecs_to_jiffies(ATH_PAPRD_TIMEOUT)))\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tcomplete(&sc->paprd_complete);\n\t} else {\n\t\tath_debug_stat_tx(sc, bf, ts, txq, tx_flags);\n\t\tath_tx_complete(sc, skb, tx_flags, txq);\n\t}\nskip_tx_complete:\n\t/* At this point, skb (bf->bf_mpdu) is consumed...make sure we don't\n\t * accidentally reference it later.\n\t */\n\tbf->bf_mpdu = NULL;\n\n\t/*\n\t * Return the list of ath_buf of this mpdu to free queue\n\t */\n\tspin_lock_irqsave(&sc->tx.txbuflock, flags);\n\tlist_splice_tail_init(bf_q, &sc->tx.txbuf);\n\tspin_unlock_irqrestore(&sc->tx.txbuflock, flags);\n}\n",
        "linevul": 6.29175701760687e-05,
        "sysevr": 0.15451326966285706,
        "devign": 2.4061020537091693e-11
    },
    {
        "code": "static void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\n\tunsigned int len;\n\n\ticsk->icsk_ack.last_seg_size = 0;\n\n\t/* skb->len may jitter because of SACKs, even if peer\n\t * sends good full-sized frames.\n\t */\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\n\tif (len >= icsk->icsk_ack.rcv_mss) {\n\t\ticsk->icsk_ack.rcv_mss = len;\n\t} else {\n\t\t/* Otherwise, we make more careful check taking into account,\n\t\t * that SACKs block is variable.\n\t\t *\n\t\t * \"len\" is invariant segment length, including TCP header.\n\t\t */\n\t\tlen += skb->data - skb_transport_header(skb);\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\n\t\t    /* If PSH is not set, packet should be\n\t\t     * full sized, provided peer TCP is not badly broken.\n\t\t     * This observation (if it is correct 8)) allows\n\t\t     * to handle super-low mtu links fairly.\n\t\t     */\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\n\t\t\t * tcp header plus fixed timestamp option length.\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\n\t\t\t */\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\n\t\t\ticsk->icsk_ack.last_seg_size = len;\n\t\t\tif (len == lss) {\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fdf5af0daf8019cec2396cdef8fb042d80fe71fa",
        "vul_func_with_fix": "static void tcp_measure_rcv_mss(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst unsigned int lss = icsk->icsk_ack.last_seg_size;\n\tunsigned int len;\n\n\ticsk->icsk_ack.last_seg_size = 0;\n\n\t/* skb->len may jitter because of SACKs, even if peer\n\t * sends good full-sized frames.\n\t */\n\tlen = skb_shinfo(skb)->gso_size ? : skb->len;\n\tif (len >= icsk->icsk_ack.rcv_mss) {\n\t\ticsk->icsk_ack.rcv_mss = len;\n\t} else {\n\t\t/* Otherwise, we make more careful check taking into account,\n\t\t * that SACKs block is variable.\n\t\t *\n\t\t * \"len\" is invariant segment length, including TCP header.\n\t\t */\n\t\tlen += skb->data - skb_transport_header(skb);\n\t\tif (len >= TCP_MSS_DEFAULT + sizeof(struct tcphdr) ||\n\t\t    /* If PSH is not set, packet should be\n\t\t     * full sized, provided peer TCP is not badly broken.\n\t\t     * This observation (if it is correct 8)) allows\n\t\t     * to handle super-low mtu links fairly.\n\t\t     */\n\t\t    (len >= TCP_MIN_MSS + sizeof(struct tcphdr) &&\n\t\t     !(tcp_flag_word(tcp_hdr(skb)) & TCP_REMNANT))) {\n\t\t\t/* Subtract also invariant (if peer is RFC compliant),\n\t\t\t * tcp header plus fixed timestamp option length.\n\t\t\t * Resulting \"len\" is MSS free of SACK jitter.\n\t\t\t */\n\t\t\tlen -= tcp_sk(sk)->tcp_header_len;\n\t\t\ticsk->icsk_ack.last_seg_size = len;\n\t\t\tif (len == lss) {\n\t\t\t\ticsk->icsk_ack.rcv_mss = len;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (icsk->icsk_ack.pending & ICSK_ACK_PUSHED)\n\t\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED2;\n\t\ticsk->icsk_ack.pending |= ICSK_ACK_PUSHED;\n\t}\n}\n",
        "linevul": 8.236573921749368e-05,
        "sysevr": 0.1355210840702057,
        "devign": 2.3008965843729356e-09
    },
    {
        "code": "ieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tid;\n\tu8 *qc;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t/*\n\t * If this flag is set to true anywhere, and we get here,\n\t * we are doing the needed processing, so remove the flag\n\t * now.\n\t */\n\tinfo->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)\n\t\t\treturn TX_DROP;\n\t} else if (info->flags & (IEEE80211_TX_CTL_INJECTED |\n\t\t\t\t  IEEE80211_TX_INTFL_NL80211_FRAME_TX) ||\n\t\t   tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t}\n\tif (!tx->sta)\n\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) &&\n\t    !(local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/338f977f4eb441e69bb9a46eaa0ac715c931a67f",
        "vul_func_with_fix": "ieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tid;\n\tu8 *qc;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t/*\n\t * If this flag is set to true anywhere, and we get here,\n\t * we are doing the needed processing, so remove the flag\n\t * now.\n\t */\n\tinfo->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)\n\t\t\treturn TX_DROP;\n\t} else if (info->flags & (IEEE80211_TX_CTL_INJECTED |\n\t\t\t\t  IEEE80211_TX_INTFL_NL80211_FRAME_TX) ||\n\t\t   tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t}\n\tif (!tx->sta)\n\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    (local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) &&\n\t    !(local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n",
        "linevul": 0.00029802662902511656,
        "sysevr": 0.2544746398925781,
        "devign": 1.6686638649633912e-24
    },
    {
        "code": "static void skb_drop_list(struct sk_buff **listp)\n{\n\tkfree_skb_list(*listp);\n\t*listp = NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "vul_func_with_fix": "static void skb_drop_list(struct sk_buff **listp)\n{\n\tkfree_skb_list(*listp);\n\t*listp = NULL;\n}\n",
        "linevul": 6.240469519980252e-05,
        "sysevr": 0.12602517008781433,
        "devign": 0.18705253303050995
    },
    {
        "code": "int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d049f74f2dbe71354d43d393ac3a188947811348",
        "vul_func_with_fix": "int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}\n",
        "linevul": 5.112184589961544e-05,
        "sysevr": 0.15287095308303833,
        "devign": 3.289546768314722e-08
    },
    {
        "code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n {\n \tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n \tconst struct user_desc *info;\n \n \tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n \t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n \telse\n \t\tinfo = infobuf;\n \n \tset_tls_desc(target,\n \t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n \t\t     info, count / sizeof(struct user_desc));\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/41bdc78544b8a93a9c6814b8bbbfef966272abbe",
        "vul_func_with_fix": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n {\n \tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n \tconst struct user_desc *info;\n//fix_flaw_line_below:\n//\tint i;\n \n \tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n \t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n \telse\n \t\tinfo = infobuf;\n \n//fix_flaw_line_below:\n//\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n//fix_flaw_line_below:\n//\t\tif (!tls_desc_okay(info + i))\n//fix_flaw_line_below:\n//\t\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n \tset_tls_desc(target,\n \t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n \t\t     info, count / sizeof(struct user_desc));\n\n\treturn 0;\n}\n",
        "linevul": 0.9996578693389893,
        "sysevr": 0.1869906485080719,
        "devign": 0.44034668803215027
    },
    {
        "code": " void ipc_rcu_putref(void *ptr)\n {\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": " void ipc_rcu_putref(void *ptr)\n {\n//flaw_line_below:\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n//fix_flaw_line_below:\n//\tif (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}\n",
        "linevul": 0.9997290968894958,
        "sysevr": 0.18480758368968964,
        "devign": 0.9885446429252625
    },
    {
        "code": "cifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b",
        "vul_func_with_fix": "cifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}\n",
        "linevul": 5.135839819558896e-05,
        "sysevr": 0.15732122957706451,
        "devign": 4.504051798193132e-09
    },
    {
        "code": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\tf->f_path = *path;\n\t\terror = do_dentry_open(f, NULL, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87",
        "vul_func_with_fix": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\tf->f_path = *path;\n\t\terror = do_dentry_open(f, NULL, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\n",
        "linevul": 9.660371870268136e-05,
        "sysevr": 0.16603687405586243,
        "devign": 0.0015192920109257102
    },
    {
        "code": "sg_res_in_use(Sg_fd * sfp)\n{\n\tconst Sg_request *srp;\n\tunsigned long iflags;\n\n\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\tfor (srp = sfp->headrp; srp; srp = srp->nextrp)\n\t\tif (srp->res_used)\n\t\t\tbreak;\n\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\treturn srp ? 1 : 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/451a2886b6bf90e2fb378f7c46c655450fb96e81",
        "vul_func_with_fix": "sg_res_in_use(Sg_fd * sfp)\n{\n\tconst Sg_request *srp;\n\tunsigned long iflags;\n\n\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\tfor (srp = sfp->headrp; srp; srp = srp->nextrp)\n\t\tif (srp->res_used)\n\t\t\tbreak;\n\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\treturn srp ? 1 : 0;\n}\n",
        "linevul": 4.8036086809588596e-05,
        "sysevr": 0.1650194525718689,
        "devign": 2.7104995581339608e-08
    },
    {
        "code": "mem_cgroup_get_reclaim_stat_from_page(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\tstruct mem_cgroup_per_zone *mz;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tpc = lookup_page_cgroup(page);\n\tif (!PageCgroupUsed(pc))\n\t\treturn NULL;\n\t/* Ensure pc->mem_cgroup is visible after reading PCG_USED. */\n\tsmp_rmb();\n\tmz = page_cgroup_zoneinfo(pc->mem_cgroup, page);\n\treturn &mz->reclaim_stat;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "mem_cgroup_get_reclaim_stat_from_page(struct page *page)\n{\n\tstruct page_cgroup *pc;\n\tstruct mem_cgroup_per_zone *mz;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tpc = lookup_page_cgroup(page);\n\tif (!PageCgroupUsed(pc))\n\t\treturn NULL;\n\t/* Ensure pc->mem_cgroup is visible after reading PCG_USED. */\n\tsmp_rmb();\n\tmz = page_cgroup_zoneinfo(pc->mem_cgroup, page);\n\treturn &mz->reclaim_stat;\n}\n",
        "linevul": 6.985344225540757e-05,
        "sysevr": 0.1524638831615448,
        "devign": 5.061163619278497e-13
    },
    {
        "code": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n \t\tgoto out;\n \t}\n \n \tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n \t\tgoto out;\n \t}\n \n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n \t\tpte_t pte = *ptep;\n \n \t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n \t\telse if (pte_present(pte))\n \t\t\t*vec = 1;\n \t\telse { /* pte is a swap entry */\n \t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n \n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t/*\n\t\t\t\t * migration or hwpoison entries are always\n\t\t\t\t * uptodate\n\t\t\t\t */\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n \t\t}\n \t\tvec++;\n \t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e",
        "vul_func_with_fix": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n \t\tgoto out;\n \t}\n \n//fix_flaw_line_below:\n//\t/* We'll consider a THP page under construction to be there */\n \tif (pmd_trans_unstable(pmd)) {\n//flaw_line_below:\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n//fix_flaw_line_below:\n//\t\tmemset(vec, 1, nr);\n \t\tgoto out;\n \t}\n \n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n \t\tpte_t pte = *ptep;\n \n \t\tif (pte_none(pte))\n//flaw_line_below:\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n//flaw_line_below:\n\t\t\t\t\t\t vma, vec);\n//fix_flaw_line_below:\n//\t\t\t*vec = 0;\n \t\telse if (pte_present(pte))\n \t\t\t*vec = 1;\n \t\telse { /* pte is a swap entry */\n \t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n \n//flaw_line_below:\n\t\t\tif (non_swap_entry(entry)) {\n//flaw_line_below:\n\t\t\t\t/*\n//flaw_line_below:\n\t\t\t\t * migration or hwpoison entries are always\n//flaw_line_below:\n\t\t\t\t * uptodate\n//flaw_line_below:\n\t\t\t\t */\n//flaw_line_below:\n\t\t\t\t*vec = 1;\n//flaw_line_below:\n\t\t\t} else {\n//flaw_line_below:\n#ifdef CONFIG_SWAP\n//flaw_line_below:\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n//flaw_line_below:\n\t\t\t\t\t\t    swp_offset(entry));\n//flaw_line_below:\n#else\n//flaw_line_below:\n\t\t\t\tWARN_ON(1);\n//flaw_line_below:\n\t\t\t\t*vec = 1;\n//flaw_line_below:\n#endif\n//flaw_line_below:\n\t\t\t}\n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * migration or hwpoison entries are always\n//fix_flaw_line_below:\n//\t\t\t * uptodate\n//fix_flaw_line_below:\n//\t\t\t */\n//fix_flaw_line_below:\n//\t\t\t*vec = !!non_swap_entry(entry);\n \t\t}\n \t\tvec++;\n \t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}\n",
        "linevul": 0.9995296001434326,
        "sysevr": 0.12521721422672272,
        "devign": 0.9984446167945862
    },
    {
        "code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\n\tsrp->data.cmd_opcode = cmnd[0];\t/* hold opcode of command */\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n \t\treturn k;\t/* probably out of space --> ENOMEM */\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}\n\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t/* v3 (or later) interface */\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */\n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3951a3709ff50990bf3e188c27d346792103432",
        "vul_func_with_fix": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\n\tsrp->data.cmd_opcode = cmnd[0];\t/* hold opcode of command */\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n \t\treturn k;\t/* probably out of space --> ENOMEM */\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n//flaw_line_below:\n\t\tif (srp->bio)\n//fix_flaw_line_below:\n//\t\tif (srp->bio) {\n//fix_flaw_line_below:\n//\t\t\tif (srp->rq->cmd != srp->rq->__cmd)\n//fix_flaw_line_below:\n//\t\t\t\tkfree(srp->rq->cmd);\n//fix_flaw_line_below:\n//\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n//fix_flaw_line_below:\n//\t\t\tsrp->rq = NULL;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}\n\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t/* v3 (or later) interface */\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */\n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}\n",
        "linevul": 0.00016718085680622607,
        "sysevr": 0.20413213968276978,
        "devign": 0.9817062020301819
    },
    {
        "code": " static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t     u16 selector, int seg, u8 cpl,\n \t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n \n \trpl = selector & 3;\n \n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n \t/* TR should be in GDT only */\n \tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n \t\tgoto exception;\n \n\tif (null_selector) /* for NULL selector skip all following checks */\n \t\tgoto load;\n \n \tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n \tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/33ab91103b3415e12457e3104f0e4517ce12d0f3",
        "vul_func_with_fix": " static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t     u16 selector, int seg, u8 cpl,\n \t\t\t\t     enum x86_transfer_type transfer,\n\t\t\t\t     struct desc_struct *desc)\n{\n\tstruct desc_struct seg_desc, old_desc;\n\tu8 dpl, rpl;\n\tunsigned err_vec = GP_VECTOR;\n\tu32 err_code = 0;\n\tbool null_selector = !(selector & ~0x3); /* 0000-0003 are null */\n\tulong desc_addr;\n\tint ret;\n\tu16 dummy;\n\tu32 base3 = 0;\n\n\tmemset(&seg_desc, 0, sizeof seg_desc);\n\n\tif (ctxt->mode == X86EMUL_MODE_REAL) {\n\t\t/* set real mode segment descriptor (keep limit etc. for\n\t\t * unreal mode) */\n\t\tctxt->ops->get_segment(ctxt, &dummy, &seg_desc, NULL, seg);\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tgoto load;\n\t} else if (seg <= VCPU_SREG_GS && ctxt->mode == X86EMUL_MODE_VM86) {\n\t\t/* VM86 needs a clean new segment descriptor */\n\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n \n \trpl = selector & 3;\n \n//flaw_line_below:\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n//flaw_line_below:\n\tif ((seg == VCPU_SREG_CS\n//flaw_line_below:\n\t     || (seg == VCPU_SREG_SS\n//flaw_line_below:\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n//flaw_line_below:\n\t     || seg == VCPU_SREG_TR)\n//flaw_line_below:\n\t    && null_selector)\n//flaw_line_below:\n\t\tgoto exception;\n//flaw_line_below:\n\n \t/* TR should be in GDT only */\n \tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n \t\tgoto exception;\n \n//flaw_line_below:\n\tif (null_selector) /* for NULL selector skip all following checks */\n//fix_flaw_line_below:\n//\t/* NULL selector is not valid for TR, CS and (except for long mode) SS */\n//fix_flaw_line_below:\n//\tif (null_selector) {\n//fix_flaw_line_below:\n//\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)\n//fix_flaw_line_below:\n//\t\t\tgoto exception;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (seg == VCPU_SREG_SS) {\n//fix_flaw_line_below:\n//\t\t\tif (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)\n//fix_flaw_line_below:\n//\t\t\t\tgoto exception;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * ctxt->ops->set_segment expects the CPL to be in\n//fix_flaw_line_below:\n//\t\t\t * SS.DPL, so fake an expand-up 32-bit data segment.\n//fix_flaw_line_below:\n//\t\t\t */\n//fix_flaw_line_below:\n//\t\t\tseg_desc.type = 3;\n//fix_flaw_line_below:\n//\t\t\tseg_desc.p = 1;\n//fix_flaw_line_below:\n//\t\t\tseg_desc.s = 1;\n//fix_flaw_line_below:\n//\t\t\tseg_desc.dpl = cpl;\n//fix_flaw_line_below:\n//\t\t\tseg_desc.d = 1;\n//fix_flaw_line_below:\n//\t\t\tseg_desc.g = 1;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* Skip all following checks */\n \t\tgoto load;\n//fix_flaw_line_below:\n//\t}\n \n \tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n \tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */\n\tif (seg <= VCPU_SREG_GS && !seg_desc.s) {\n\t\tif (transfer == X86_TRANSFER_CALL_JMP)\n\t\t\treturn X86EMUL_UNHANDLEABLE;\n\t\tgoto exception;\n\t}\n\n\tif (!seg_desc.p) {\n\t\terr_vec = (seg == VCPU_SREG_SS) ? SS_VECTOR : NP_VECTOR;\n\t\tgoto exception;\n\t}\n\n\tdpl = seg_desc.dpl;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * segment is not a writable data segment or segment\n\t\t * selector's RPL != CPL or segment selector's RPL != CPL\n\t\t */\n\t\tif (rpl != cpl || (seg_desc.type & 0xa) != 0x2 || dpl != cpl)\n\t\t\tgoto exception;\n\t\tbreak;\n\tcase VCPU_SREG_CS:\n\t\tif (!(seg_desc.type & 8))\n\t\t\tgoto exception;\n\n\t\tif (seg_desc.type & 4) {\n\t\t\t/* conforming */\n\t\t\tif (dpl > cpl)\n\t\t\t\tgoto exception;\n\t\t} else {\n\t\t\t/* nonconforming */\n\t\t\tif (rpl > cpl || dpl != cpl)\n\t\t\t\tgoto exception;\n\t\t}\n\t\t/* in long-mode d/b must be clear if l is set */\n\t\tif (seg_desc.d && seg_desc.l) {\n\t\t\tu64 efer = 0;\n\n\t\t\tctxt->ops->get_msr(ctxt, MSR_EFER, &efer);\n\t\t\tif (efer & EFER_LMA)\n\t\t\t\tgoto exception;\n\t\t}\n\n\t\t/* CS(RPL) <- CPL */\n\t\tselector = (selector & 0xfffc) | cpl;\n\t\tbreak;\n\tcase VCPU_SREG_TR:\n\t\tif (seg_desc.s || (seg_desc.type != 1 && seg_desc.type != 9))\n\t\t\tgoto exception;\n\t\told_desc = seg_desc;\n\t\tseg_desc.type |= 2; /* busy */\n\t\tret = ctxt->ops->cmpxchg_emulated(ctxt, desc_addr, &old_desc, &seg_desc,\n\t\t\t\t\t\t  sizeof(seg_desc), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VCPU_SREG_LDTR:\n\t\tif (seg_desc.s || seg_desc.type != 2)\n\t\t\tgoto exception;\n\t\tbreak;\n\tdefault: /*  DS, ES, FS, or GS */\n\t\t/*\n\t\t * segment is not a data or readable code segment or\n\t\t * ((segment is a data or nonconforming code segment)\n\t\t * and (both RPL and CPL > DPL))\n\t\t */\n\t\tif ((seg_desc.type & 0xa) == 0x8 ||\n\t\t    (((seg_desc.type & 0xc) != 0xc) &&\n\t\t     (rpl > dpl && cpl > dpl)))\n\t\t\tgoto exception;\n\t\tbreak;\n\t}\n\n\tif (seg_desc.s) {\n\t\t/* mark segment as accessed */\n\t\tif (!(seg_desc.type & 1)) {\n\t\t\tseg_desc.type |= 1;\n\t\t\tret = write_segment_descriptor(ctxt, selector,\n\t\t\t\t\t\t       &seg_desc);\n\t\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\t\treturn ret;\n\t\t}\n\t} else if (ctxt->mode == X86EMUL_MODE_PROT64) {\n\t\tret = ctxt->ops->read_std(ctxt, desc_addr+8, &base3,\n\t\t\t\tsizeof(base3), &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t\tif (is_noncanonical_address(get_desc_base(&seg_desc) |\n\t\t\t\t\t     ((u64)base3 << 32)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t}\nload:\n\tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n\tif (desc)\n\t\t*desc = seg_desc;\n\treturn X86EMUL_CONTINUE;\nexception:\n\treturn emulate_exception(ctxt, err_vec, err_code, true);\n}\n",
        "linevul": 0.00026747441734187305,
        "sysevr": 0.1737518459558487,
        "devign": 4.1182960330843343e-07
    },
    {
        "code": "static int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv6_is_local_multicast(group))\n\t\treturn 0;\n\n\tipv6_addr_copy(&br_group.u.ip6, group);\n\tbr_group.proto = htons(ETH_P_IP);\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287",
        "vul_func_with_fix": "static int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group)\n{\n\tstruct br_ip br_group;\n\n\tif (ipv6_is_local_multicast(group))\n\t\treturn 0;\n\n\tipv6_addr_copy(&br_group.u.ip6, group);\n\tbr_group.proto = htons(ETH_P_IP);\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n",
        "linevul": 5.134042294230312e-05,
        "sysevr": 0.12904931604862213,
        "devign": 2.0579238480422646e-05
    },
    {
        "code": "static inline bool nested_cpu_has_nmi_exiting(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_NMI_EXITING;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static inline bool nested_cpu_has_nmi_exiting(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_NMI_EXITING;\n}\n",
        "linevul": 5.76173588342499e-05,
        "sysevr": 0.11938603222370148,
        "devign": 3.941730483347783e-06
    },
    {
        "code": "static int proc_BSSList_open( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tBSSListRid BSSList_rid;\n\tint rc;\n\t/* If doLoseSync is not 1, we won't do a Lose Sync */\n\tint doLoseSync = -1;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 1024, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 0;\n\tdata->wbuffer = NULL;\n\tdata->on_close = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (!(file->f_mode & FMODE_READ)) {\n\t\t\tCmd cmd;\n\t\t\tResp rsp;\n\n\t\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tcmd.cmd=CMD_LISTBSS;\n\t\t\tif (down_interruptible(&ai->sem))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tissuecommand(ai, &cmd, &rsp);\n\t\t\tup(&ai->sem);\n\t\t\tdata->readlen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tdoLoseSync = 1;\n\t}\n\tptr = data->rbuffer;\n\t/* There is a race condition here if there are concurrent opens.\n           Since it is a rare condition, we'll just live with it, otherwise\n           we have to add a spin lock... */\n\trc = readBSSListRid(ai, doLoseSync, &BSSList_rid);\n\twhile(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {\n\t\tptr += sprintf(ptr, \"%pM %*s rssi = %d\",\n\t\t\t       BSSList_rid.bssid,\n\t\t\t\t(int)BSSList_rid.ssidLen,\n\t\t\t\tBSSList_rid.ssid,\n\t\t\t\tle16_to_cpu(BSSList_rid.dBm));\n\t\tptr += sprintf(ptr, \" channel = %d %s %s %s %s\\n\",\n\t\t\t\tle16_to_cpu(BSSList_rid.dsChannel),\n\t\t\t\tBSSList_rid.cap & CAP_ESS ? \"ESS\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_IBSS ? \"adhoc\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_PRIVACY ? \"wep\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_SHORTHDR ? \"shorthdr\" : \"\");\n\t\trc = readBSSListRid(ai, 0, &BSSList_rid);\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static int proc_BSSList_open( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tBSSListRid BSSList_rid;\n\tint rc;\n\t/* If doLoseSync is not 1, we won't do a Lose Sync */\n\tint doLoseSync = -1;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 1024, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 0;\n\tdata->wbuffer = NULL;\n\tdata->on_close = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (!(file->f_mode & FMODE_READ)) {\n\t\t\tCmd cmd;\n\t\t\tResp rsp;\n\n\t\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tcmd.cmd=CMD_LISTBSS;\n\t\t\tif (down_interruptible(&ai->sem))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tissuecommand(ai, &cmd, &rsp);\n\t\t\tup(&ai->sem);\n\t\t\tdata->readlen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tdoLoseSync = 1;\n\t}\n\tptr = data->rbuffer;\n\t/* There is a race condition here if there are concurrent opens.\n           Since it is a rare condition, we'll just live with it, otherwise\n           we have to add a spin lock... */\n\trc = readBSSListRid(ai, doLoseSync, &BSSList_rid);\n\twhile(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {\n\t\tptr += sprintf(ptr, \"%pM %*s rssi = %d\",\n\t\t\t       BSSList_rid.bssid,\n\t\t\t\t(int)BSSList_rid.ssidLen,\n\t\t\t\tBSSList_rid.ssid,\n\t\t\t\tle16_to_cpu(BSSList_rid.dBm));\n\t\tptr += sprintf(ptr, \" channel = %d %s %s %s %s\\n\",\n\t\t\t\tle16_to_cpu(BSSList_rid.dsChannel),\n\t\t\t\tBSSList_rid.cap & CAP_ESS ? \"ESS\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_IBSS ? \"adhoc\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_PRIVACY ? \"wep\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_SHORTHDR ? \"shorthdr\" : \"\");\n\t\trc = readBSSListRid(ai, 0, &BSSList_rid);\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n",
        "linevul": 8.381897350773215e-05,
        "sysevr": 0.24536186456680298,
        "devign": 3.4571397912335163e-35
    },
    {
        "code": "int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "int vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n",
        "linevul": 5.367129415390082e-05,
        "sysevr": 0.1719362735748291,
        "devign": 1.9264413690654368e-29
    },
    {
        "code": "static void nfs41_free_stateid_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\tnfs41_setup_sequence(nfs4_get_session(data->server),\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static void nfs41_free_stateid_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\tnfs41_setup_sequence(nfs4_get_session(data->server),\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n",
        "linevul": 6.454553658841178e-05,
        "sysevr": 0.12540526688098907,
        "devign": 4.110661117051606e-11
    },
    {
        "code": "static inline unsigned long fetch_reg(unsigned int reg, struct pt_regs *regs)\n{\n\tstruct reg_window32 *win;\n\n\tif(reg < 16)\n\t\treturn (!reg ? 0 : regs->u_regs[reg]);\n\n\t/* Ho hum, the slightly complicated case. */\n\twin = (struct reg_window32 *) regs->u_regs[UREG_FP];\n\treturn win->locals[reg - 16]; /* yes, I know what this does... */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline unsigned long fetch_reg(unsigned int reg, struct pt_regs *regs)\n{\n\tstruct reg_window32 *win;\n\n\tif(reg < 16)\n\t\treturn (!reg ? 0 : regs->u_regs[reg]);\n\n\t/* Ho hum, the slightly complicated case. */\n\twin = (struct reg_window32 *) regs->u_regs[UREG_FP];\n\treturn win->locals[reg - 16]; /* yes, I know what this does... */\n}\n",
        "linevul": 5.0666356401052326e-05,
        "sysevr": 0.13094471395015717,
        "devign": 1.5225906091487218e-09
    },
    {
        "code": "struct vfsmount *collect_mounts(struct path *path)\n {\n \tstruct mount *tree;\n \tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n \tnamespace_unlock();\n \tif (IS_ERR(tree))\n \t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cd4a40174b71acd021877341684d8bb1dc8ea4ae",
        "vul_func_with_fix": "struct vfsmount *collect_mounts(struct path *path)\n {\n \tstruct mount *tree;\n \tnamespace_lock();\n//flaw_line_below:\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n//flaw_line_below:\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n//fix_flaw_line_below:\n//\tif (!check_mnt(real_mount(path->mnt)))\n//fix_flaw_line_below:\n//\t\ttree = ERR_PTR(-EINVAL);\n//fix_flaw_line_below:\n//\telse\n//fix_flaw_line_below:\n//\t\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n//fix_flaw_line_below:\n//\t\t\t\t CL_COPY_ALL | CL_PRIVATE);\n \tnamespace_unlock();\n \tif (IS_ERR(tree))\n \t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}\n",
        "linevul": 0.9995487332344055,
        "sysevr": 0.14013046026229858,
        "devign": 0.9827314019203186
    },
    {
        "code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n \tunsigned char *buf = NULL;\n \tu32 buf_len;\n \tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n \tstruct inet_request_sock *req_inet;\n \n \t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n \t\tret_val = -ENOMEM;\n \t\tgoto req_setattr_failure;\n \t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n \tkfree(buf);\n \tbuf = NULL;\n \n \treq_inet = inet_rsk(req);\n \topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n \n \treturn 0;\n \nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n \tunsigned char *buf = NULL;\n \tu32 buf_len;\n \tu32 opt_len;\n//flaw_line_below:\n\tstruct ip_options *opt = NULL;\n//fix_flaw_line_below:\n//\tstruct ip_options_rcu *opt = NULL;\n \tstruct inet_request_sock *req_inet;\n \n \t/* We allocate the maximum CIPSO option size here so we are probably\n\t * being a little wasteful, but it makes our life _much_ easier later\n\t * on and after all we are only talking about 40 bytes. */\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t/* We can't use ip_options_get() directly because it makes a call to\n\t * ip_options_get_alloc() which allocates memory with GFP_KERNEL and\n\t * we won't always have CAP_NET_RAW even though we _always_ want to\n\t * set the IPOPT_CIPSO option. */\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n \t\tret_val = -ENOMEM;\n \t\tgoto req_setattr_failure;\n \t}\n//flaw_line_below:\n\tmemcpy(opt->__data, buf, buf_len);\n//flaw_line_below:\n\topt->optlen = opt_len;\n//flaw_line_below:\n\topt->cipso = sizeof(struct iphdr);\n//fix_flaw_line_below:\n//\tmemcpy(opt->opt.__data, buf, buf_len);\n//fix_flaw_line_below:\n//\topt->opt.optlen = opt_len;\n//fix_flaw_line_below:\n//\topt->opt.cipso = sizeof(struct iphdr);\n \tkfree(buf);\n \tbuf = NULL;\n \n \treq_inet = inet_rsk(req);\n \topt = xchg(&req_inet->opt, opt);\n//flaw_line_below:\n\tkfree(opt);\n//fix_flaw_line_below:\n//\tif (opt)\n//fix_flaw_line_below:\n//\t\tcall_rcu(&opt->rcu, opt_kfree_rcu);\n \n \treturn 0;\n \nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n",
        "linevul": 0.9995855689048767,
        "sysevr": 0.22276350855827332,
        "devign": 0.9985425472259521
    },
    {
        "code": "static long vmsplice_to_pipe(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tspd.nr_pages = get_iovec_page_array(iov, nr_segs, spd.pages,\n\t\t\t\t\t    spd.partial, false,\n\t\t\t\t\t    spd.nr_pages_max);\n\tif (spd.nr_pages <= 0)\n\t\tret = spd.nr_pages;\n\telse\n\t\tret = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958",
        "vul_func_with_fix": "static long vmsplice_to_pipe(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tspd.nr_pages = get_iovec_page_array(iov, nr_segs, spd.pages,\n\t\t\t\t\t    spd.partial, false,\n\t\t\t\t\t    spd.nr_pages_max);\n\tif (spd.nr_pages <= 0)\n\t\tret = spd.nr_pages;\n\telse\n\t\tret = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}\n",
        "linevul": 0.0001289017527597025,
        "sysevr": 0.13774624466896057,
        "devign": 0.6319426894187927
    },
    {
        "code": "nfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t/* In nfsv4, \".\" and \"..\" never make it onto the wire.. */\n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                             /* mark entry present */\n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */\n\tp = xdr_encode_array(p, name, namlen);      /* name length & name */\n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tdefault:\n\t\t/*\n\t\t * If the client requested the RDATTR_ERROR attribute,\n\t\t * we stuff the error code into this attribute\n\t\t * and continue.  If this attribute was not requested,\n\t\t * then in accordance with the spec, we fail the\n\t\t * entire READDIR operation(!)\n\t\t */\n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t/*\n\t * RFC 3530 14.2.24 describes rd_dircount as only a \"hint\", so\n\t * let's always let through the first entry, at least:\n\t */\n\tif (!cd->rd_dircount)\n\t\tgoto fail;\n\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\tgoto fail;\n\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t/* In nfsv4, \".\" and \"..\" never make it onto the wire.. */\n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                             /* mark entry present */\n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */\n\tp = xdr_encode_array(p, name, namlen);      /* name length & name */\n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tdefault:\n\t\t/*\n\t\t * If the client requested the RDATTR_ERROR attribute,\n\t\t * we stuff the error code into this attribute\n\t\t * and continue.  If this attribute was not requested,\n\t\t * then in accordance with the spec, we fail the\n\t\t * entire READDIR operation(!)\n\t\t */\n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t/*\n\t * RFC 3530 14.2.24 describes rd_dircount as only a \"hint\", so\n\t * let's always let through the first entry, at least:\n\t */\n\tif (!cd->rd_dircount)\n\t\tgoto fail;\n\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\tgoto fail;\n\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}\n",
        "linevul": 0.0002937456301879138,
        "sysevr": 0.2663053572177887,
        "devign": 0.00026430387515574694
    },
    {
        "code": "void __init printk_all_partitions(void)\n{\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct disk_part_iter piter;\n\t\tstruct hd_struct *part;\n\t\tchar name_buf[BDEVNAME_SIZE];\n\t\tchar devt_buf[BDEVT_SIZE];\n\n\t\t/*\n\t\t * Don't show empty devices or things that have been\n\t\t * suppressed\n\t\t */\n\t\tif (get_capacity(disk) == 0 ||\n\t\t    (disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note, unlike /proc/partitions, I am showing the\n\t\t * numbers in hex - the same format as the root=\n\t\t * option takes.\n\t\t */\n\t\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\n\t\twhile ((part = disk_part_iter_next(&piter))) {\n\t\t\tbool is_part0 = part == &disk->part0;\n\n\t\t\tprintk(\"%s%s %10llu %s %s\", is_part0 ? \"\" : \"  \",\n\t\t\t       bdevt_str(part_devt(part), devt_buf),\n\t\t\t       (unsigned long long)part_nr_sects_read(part) >> 1\n\t\t\t       , disk_name(disk, part->partno, name_buf),\n\t\t\t       part->info ? part->info->uuid : \"\");\n\t\t\tif (is_part0) {\n\t\t\t\tif (dev->parent && dev->parent->driver)\n\t\t\t\t\tprintk(\" driver: %s\\n\",\n\t\t\t\t\t      dev->parent->driver->name);\n\t\t\t\telse\n\t\t\t\t\tprintk(\" (driver?)\\n\");\n\t\t\t} else\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tdisk_part_iter_exit(&piter);\n\t}\n\tclass_dev_iter_exit(&iter);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "vul_func_with_fix": "void __init printk_all_partitions(void)\n{\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct disk_part_iter piter;\n\t\tstruct hd_struct *part;\n\t\tchar name_buf[BDEVNAME_SIZE];\n\t\tchar devt_buf[BDEVT_SIZE];\n\n\t\t/*\n\t\t * Don't show empty devices or things that have been\n\t\t * suppressed\n\t\t */\n\t\tif (get_capacity(disk) == 0 ||\n\t\t    (disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note, unlike /proc/partitions, I am showing the\n\t\t * numbers in hex - the same format as the root=\n\t\t * option takes.\n\t\t */\n\t\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_PART0);\n\t\twhile ((part = disk_part_iter_next(&piter))) {\n\t\t\tbool is_part0 = part == &disk->part0;\n\n\t\t\tprintk(\"%s%s %10llu %s %s\", is_part0 ? \"\" : \"  \",\n\t\t\t       bdevt_str(part_devt(part), devt_buf),\n\t\t\t       (unsigned long long)part_nr_sects_read(part) >> 1\n\t\t\t       , disk_name(disk, part->partno, name_buf),\n\t\t\t       part->info ? part->info->uuid : \"\");\n\t\t\tif (is_part0) {\n\t\t\t\tif (dev->parent && dev->parent->driver)\n\t\t\t\t\tprintk(\" driver: %s\\n\",\n\t\t\t\t\t      dev->parent->driver->name);\n\t\t\t\telse\n\t\t\t\t\tprintk(\" (driver?)\\n\");\n\t\t\t} else\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tdisk_part_iter_exit(&piter);\n\t}\n\tclass_dev_iter_exit(&iter);\n}\n",
        "linevul": 0.00015501547022722661,
        "sysevr": 0.2062084674835205,
        "devign": 0.6474040150642395
    },
    {
        "code": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n \n \treturn new_port;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
        "vul_func_with_fix": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\t\n\t/* sanity check */\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\n\t/* create a new port */\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t/* failure, out of memory */\n\t/* init port data */\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n//fix_flaw_line_below:\n//\tsnd_use_lock_use(&new_port->use_lock);\n \n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) /* auto-probe mode */\n\t\t\tnum = p->addr.port + 1;\n\t}\n\t/* insert the new port */\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t/* store the port number in the port */\n//fix_flaw_line_below:\n//\tsprintf(new_port->name, \"port-%d\", num);\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n//flaw_line_below:\n\tsprintf(new_port->name, \"port-%d\", num);\n \n \treturn new_port;\n }\n",
        "linevul": 0.0001349832455161959,
        "sysevr": 0.19261084496974945,
        "devign": 1.7467278958423917e-20
    },
    {
        "code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n {\n \t__be32 *p;\n \n \tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n \t\tcase FMODE_READ:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n \t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n \t\t\tbreak;\n \t\tdefault:\n\t\t\tBUG();\n \t}\n \tWRITE32(0);\t\t/* for linux, share_deny = 0 always */\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n//fix_flaw_line_below:\n//static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)\n {\n \t__be32 *p;\n \n \tRESERVE_SPACE(8);\n//flaw_line_below:\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n//fix_flaw_line_below:\n//\tswitch (fmode & (FMODE_READ|FMODE_WRITE)) {\n \t\tcase FMODE_READ:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n \t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n \t\t\tbreak;\n \t\tdefault:\n//flaw_line_below:\n\t\t\tBUG();\n//fix_flaw_line_below:\n//\t\t\tWRITE32(0);\n \t}\n \tWRITE32(0);\t\t/* for linux, share_deny = 0 always */\n }\n",
        "linevul": 0.9990541338920593,
        "sysevr": 0.12041091173887253,
        "devign": 0.9975520968437195
    },
    {
        "code": "static int adf_add_key_value_data(struct adf_accel_dev *accel_dev,\n\t\t\t\t  const char *section,\n\t\t\t\t  const struct adf_user_cfg_key_val *key_val)\n{\n\tif (key_val->type == ADF_HEX) {\n\t\tlong *ptr = (long *)key_val->val;\n\t\tlong val = *ptr;\n\n\t\tif (adf_cfg_add_key_value_param(accel_dev, section,\n\t\t\t\t\t\tkey_val->key, (void *)val,\n\t\t\t\t\t\tkey_val->type)) {\n\t\t\tpr_err(\"QAT: failed to add keyvalue.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tif (adf_cfg_add_key_value_param(accel_dev, section,\n\t\t\t\t\t\tkey_val->key, key_val->val,\n\t\t\t\t\t\tkey_val->type)) {\n\t\t\tpr_err(\"QAT: failed to add keyvalue.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int adf_add_key_value_data(struct adf_accel_dev *accel_dev,\n\t\t\t\t  const char *section,\n\t\t\t\t  const struct adf_user_cfg_key_val *key_val)\n{\n\tif (key_val->type == ADF_HEX) {\n\t\tlong *ptr = (long *)key_val->val;\n\t\tlong val = *ptr;\n\n\t\tif (adf_cfg_add_key_value_param(accel_dev, section,\n\t\t\t\t\t\tkey_val->key, (void *)val,\n\t\t\t\t\t\tkey_val->type)) {\n\t\t\tpr_err(\"QAT: failed to add keyvalue.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tif (adf_cfg_add_key_value_param(accel_dev, section,\n\t\t\t\t\t\tkey_val->key, key_val->val,\n\t\t\t\t\t\tkey_val->type)) {\n\t\t\tpr_err(\"QAT: failed to add keyvalue.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "linevul": 5.066809899290092e-05,
        "sysevr": 0.11463996767997742,
        "devign": 1.8231338747703996e-12
    },
    {
        "code": "static int check_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\tu64 rcx = ctxt->regs[VCPU_REGS_RCX];\n\n\tif ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||\n\t    (rcx > 3))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84",
        "vul_func_with_fix": "static int check_rdpmc(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 cr4 = ctxt->ops->get_cr(ctxt, 4);\n\tu64 rcx = ctxt->regs[VCPU_REGS_RCX];\n\n\tif ((!(cr4 & X86_CR4_PCE) && ctxt->ops->cpl(ctxt)) ||\n\t    (rcx > 3))\n\t\treturn emulate_gp(ctxt, 0);\n\n\treturn X86EMUL_CONTINUE;\n}\n",
        "linevul": 4.851028643315658e-05,
        "sysevr": 0.12610940635204315,
        "devign": 2.0979904660804617e-19
    },
    {
        "code": "tvsub(register struct timeval *out, register struct timeval *in)\n{\n    if((out->tv_usec -= in->tv_usec) < 0) {\n        out->tv_sec--;\n        out->tv_usec += 1000000;\n    }\n    out->tv_sec -= in->tv_sec;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "tvsub(register struct timeval *out, register struct timeval *in)\n{\n    if((out->tv_usec -= in->tv_usec) < 0) {\n        out->tv_sec--;\n        out->tv_usec += 1000000;\n    }\n    out->tv_sec -= in->tv_sec;\n}\n",
        "linevul": 5.337906986824237e-05,
        "sysevr": 0.14570114016532898,
        "devign": 2.665571319226956e-09
    },
    {
        "code": "static void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n",
        "linevul": 0.0001486549444962293,
        "sysevr": 0.13096266984939575,
        "devign": 6.327088613033993e-06
    },
    {
        "code": "find_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "find_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}\n",
        "linevul": 5.042150223744102e-05,
        "sysevr": 0.1538102775812149,
        "devign": 3.992973506683484e-05
    },
    {
        "code": "static int nfs4_xdr_dec_pathconf(struct rpc_rqst *req, __be32 *p, struct nfs_pathconf *pathconf)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_pathconf(&xdr, pathconf);\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int nfs4_xdr_dec_pathconf(struct rpc_rqst *req, __be32 *p, struct nfs_pathconf *pathconf)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_putfh(&xdr);\n\tif (!status)\n\t\tstatus = decode_pathconf(&xdr, pathconf);\n\treturn status;\n}\n",
        "linevul": 5.225276981946081e-05,
        "sysevr": 0.12516246736049652,
        "devign": 9.670635822268673e-27
    },
    {
        "code": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/637b58c2887e5e57850865839cc75f59184b23d1",
        "vul_func_with_fix": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n//flaw_line_below:\n\t\t      int atomic)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tunsigned long copy;\n//flaw_line_below:\n\n//flaw_line_below:\n\twhile (len > 0) {\n//flaw_line_below:\n\t\twhile (!iov->iov_len)\n//flaw_line_below:\n\t\t\tiov++;\n//flaw_line_below:\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tif (atomic) {\n//flaw_line_below:\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n//flaw_line_below:\n\t\t\t\treturn -EFAULT;\n//flaw_line_below:\n\t\t} else {\n//flaw_line_below:\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n//flaw_line_below:\n\t\t\t\treturn -EFAULT;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t\tfrom += copy;\n//flaw_line_below:\n\t\tlen -= copy;\n//flaw_line_below:\n\t\tiov->iov_base += copy;\n//flaw_line_below:\n\t\tiov->iov_len -= copy;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\treturn 0;\n//flaw_line_below:\n}\n",
        "linevul": 0.9823033213615417,
        "sysevr": 0.188589945435524,
        "devign": 0.0014839351642876863
    },
    {
        "code": "int iwch_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\n{\n\tstruct iwch_dev *h = to_iwch_dev(cm_id->device);\n\tstruct iwch_ep *ep;\n\tstruct rtable *rt;\n\tint err = 0;\n\tstruct sockaddr_in *laddr = (struct sockaddr_in *)&cm_id->local_addr;\n\tstruct sockaddr_in *raddr = (struct sockaddr_in *)&cm_id->remote_addr;\n\n\tif (cm_id->remote_addr.ss_family != PF_INET) {\n\t\terr = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tif (is_loopback_dst(cm_id)) {\n\t\terr = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tep = alloc_ep(sizeof(*ep), GFP_KERNEL);\n\tif (!ep) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot alloc ep.\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tinit_timer(&ep->timer);\n\tep->plen = conn_param->private_data_len;\n\tif (ep->plen)\n\t\tmemcpy(ep->mpa_pkt + sizeof(struct mpa_message),\n\t\t       conn_param->private_data, ep->plen);\n\tep->ird = conn_param->ird;\n\tep->ord = conn_param->ord;\n\n\tif (peer2peer && ep->ord == 0)\n\t\tep->ord = 1;\n\n\tep->com.tdev = h->rdev.t3cdev_p;\n\n\tcm_id->add_ref(cm_id);\n\tep->com.cm_id = cm_id;\n\tep->com.qp = get_qhp(h, conn_param->qpn);\n\tBUG_ON(!ep->com.qp);\n\tPDBG(\"%s qpn 0x%x qp %p cm_id %p\\n\", __func__, conn_param->qpn,\n\t     ep->com.qp, cm_id);\n\n\t/*\n\t * Allocate an active TID to initiate a TCP connection.\n\t */\n\tep->atid = cxgb3_alloc_atid(h->rdev.t3cdev_p, &t3c_client, ep);\n\tif (ep->atid == -1) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot alloc atid.\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\t/* find a route */\n\trt = find_route(h->rdev.t3cdev_p, laddr->sin_addr.s_addr,\n\t\t\traddr->sin_addr.s_addr, laddr->sin_port,\n\t\t\traddr->sin_port, IPTOS_LOWDELAY);\n\tif (!rt) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot find route.\\n\", __func__);\n\t\terr = -EHOSTUNREACH;\n\t\tgoto fail3;\n\t}\n\tep->dst = &rt->dst;\n\tep->l2t = t3_l2t_get(ep->com.tdev, ep->dst, NULL,\n\t\t\t     &raddr->sin_addr.s_addr);\n\tif (!ep->l2t) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot alloc l2e.\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto fail4;\n\t}\n\n\tstate_set(&ep->com, CONNECTING);\n\tep->tos = IPTOS_LOWDELAY;\n\tmemcpy(&ep->com.local_addr, &cm_id->local_addr,\n\t       sizeof(ep->com.local_addr));\n\tmemcpy(&ep->com.remote_addr, &cm_id->remote_addr,\n\t       sizeof(ep->com.remote_addr));\n\n\t/* send connect request to rnic */\n\terr = send_connect(ep);\n\tif (!err)\n\t\tgoto out;\n\n\tl2t_release(h->rdev.t3cdev_p, ep->l2t);\nfail4:\n\tdst_release(ep->dst);\nfail3:\n\tcxgb3_free_atid(ep->com.tdev, ep->atid);\nfail2:\n\tcm_id->rem_ref(cm_id);\n\tput_ep(&ep->com);\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3",
        "vul_func_with_fix": "int iwch_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\n{\n\tstruct iwch_dev *h = to_iwch_dev(cm_id->device);\n\tstruct iwch_ep *ep;\n\tstruct rtable *rt;\n\tint err = 0;\n\tstruct sockaddr_in *laddr = (struct sockaddr_in *)&cm_id->local_addr;\n\tstruct sockaddr_in *raddr = (struct sockaddr_in *)&cm_id->remote_addr;\n\n\tif (cm_id->remote_addr.ss_family != PF_INET) {\n\t\terr = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tif (is_loopback_dst(cm_id)) {\n\t\terr = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tep = alloc_ep(sizeof(*ep), GFP_KERNEL);\n\tif (!ep) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot alloc ep.\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tinit_timer(&ep->timer);\n\tep->plen = conn_param->private_data_len;\n\tif (ep->plen)\n\t\tmemcpy(ep->mpa_pkt + sizeof(struct mpa_message),\n\t\t       conn_param->private_data, ep->plen);\n\tep->ird = conn_param->ird;\n\tep->ord = conn_param->ord;\n\n\tif (peer2peer && ep->ord == 0)\n\t\tep->ord = 1;\n\n\tep->com.tdev = h->rdev.t3cdev_p;\n\n\tcm_id->add_ref(cm_id);\n\tep->com.cm_id = cm_id;\n\tep->com.qp = get_qhp(h, conn_param->qpn);\n\tBUG_ON(!ep->com.qp);\n\tPDBG(\"%s qpn 0x%x qp %p cm_id %p\\n\", __func__, conn_param->qpn,\n\t     ep->com.qp, cm_id);\n\n\t/*\n\t * Allocate an active TID to initiate a TCP connection.\n\t */\n\tep->atid = cxgb3_alloc_atid(h->rdev.t3cdev_p, &t3c_client, ep);\n\tif (ep->atid == -1) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot alloc atid.\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\t/* find a route */\n\trt = find_route(h->rdev.t3cdev_p, laddr->sin_addr.s_addr,\n\t\t\traddr->sin_addr.s_addr, laddr->sin_port,\n\t\t\traddr->sin_port, IPTOS_LOWDELAY);\n\tif (!rt) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot find route.\\n\", __func__);\n\t\terr = -EHOSTUNREACH;\n\t\tgoto fail3;\n\t}\n\tep->dst = &rt->dst;\n\tep->l2t = t3_l2t_get(ep->com.tdev, ep->dst, NULL,\n\t\t\t     &raddr->sin_addr.s_addr);\n\tif (!ep->l2t) {\n\t\tprintk(KERN_ERR MOD \"%s - cannot alloc l2e.\\n\", __func__);\n\t\terr = -ENOMEM;\n\t\tgoto fail4;\n\t}\n\n\tstate_set(&ep->com, CONNECTING);\n\tep->tos = IPTOS_LOWDELAY;\n\tmemcpy(&ep->com.local_addr, &cm_id->local_addr,\n\t       sizeof(ep->com.local_addr));\n\tmemcpy(&ep->com.remote_addr, &cm_id->remote_addr,\n\t       sizeof(ep->com.remote_addr));\n\n\t/* send connect request to rnic */\n\terr = send_connect(ep);\n\tif (!err)\n\t\tgoto out;\n\n\tl2t_release(h->rdev.t3cdev_p, ep->l2t);\nfail4:\n\tdst_release(ep->dst);\nfail3:\n\tcxgb3_free_atid(ep->com.tdev, ep->atid);\nfail2:\n\tcm_id->rem_ref(cm_id);\n\tput_ep(&ep->com);\nout:\n\treturn err;\n}\n",
        "linevul": 0.00018024681776296347,
        "sysevr": 0.2244988977909088,
        "devign": 9.175916543232057e-32
    },
    {
        "code": "sync_min_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%d (%s)\\n\", speed_min(mddev),\n\t\t       mddev->sync_speed_min ? \"local\": \"system\");\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "sync_min_show(struct mddev *mddev, char *page)\n{\n\treturn sprintf(page, \"%d (%s)\\n\", speed_min(mddev),\n\t\t       mddev->sync_speed_min ? \"local\": \"system\");\n}\n",
        "linevul": 5.472949123941362e-05,
        "sysevr": 0.14959503710269928,
        "devign": 6.784167116968831e-10
    },
    {
        "code": "__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC);\n\t\tbp->b_flags |= XBF_WRITE;\n\n\t\tif (!wait) {\n\t\t\tbp->b_flags |= XBF_ASYNC;\n\t\t\tlist_del_init(&bp->b_list);\n\t\t}\n\t\txfs_bdstrat_cb(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/eb178619f930fa2ba2348de332a1ff1c66a31424",
        "vul_func_with_fix": "__xfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list,\n\tstruct list_head\t*io_list,\n\tbool\t\t\twait)\n{\n\tstruct blk_plug\t\tplug;\n\tstruct xfs_buf\t\t*bp, *n;\n\tint\t\t\tpinned = 0;\n\n\tlist_for_each_entry_safe(bp, n, buffer_list, b_list) {\n\t\tif (!wait) {\n\t\t\tif (xfs_buf_ispinned(bp)) {\n\t\t\t\tpinned++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!xfs_buf_trylock(bp))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\txfs_buf_lock(bp);\n\t\t}\n\n\t\t/*\n\t\t * Someone else might have written the buffer synchronously or\n\t\t * marked it stale in the meantime.  In that case only the\n\t\t * _XBF_DELWRI_Q flag got cleared, and we have to drop the\n\t\t * reference and remove it from the list here.\n\t\t */\n\t\tif (!(bp->b_flags & _XBF_DELWRI_Q)) {\n\t\t\tlist_del_init(&bp->b_list);\n\t\t\txfs_buf_relse(bp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&bp->b_list, io_list);\n\t\ttrace_xfs_buf_delwri_split(bp, _RET_IP_);\n\t}\n\n\tlist_sort(NULL, io_list, xfs_buf_cmp);\n\n\tblk_start_plug(&plug);\n\tlist_for_each_entry_safe(bp, n, io_list, b_list) {\n\t\tbp->b_flags &= ~(_XBF_DELWRI_Q | XBF_ASYNC);\n\t\tbp->b_flags |= XBF_WRITE;\n\n\t\tif (!wait) {\n\t\t\tbp->b_flags |= XBF_ASYNC;\n\t\t\tlist_del_init(&bp->b_list);\n\t\t}\n\t\txfs_bdstrat_cb(bp);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn pinned;\n}\n",
        "linevul": 9.490214142715558e-05,
        "sysevr": 0.19091670215129852,
        "devign": 3.1530228867268986e-14
    },
    {
        "code": "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_x86_ops->tlb_flush(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse if (vcpu->arch.nmi_pending)\n\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tint i;\n\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a2b9e6c1a35afcc0973acb72e591c714e78885ff",
        "vul_func_with_fix": "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_x86_ops->tlb_flush(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse if (vcpu->arch.nmi_pending)\n\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tint i;\n\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n",
        "linevul": 5.178883293410763e-05,
        "sysevr": 0.20238031446933746,
        "devign": 0.0032306245993822813
    },
    {
        "code": "static void hid_io_error(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\t/* Stop when disconnected */\n\tif (test_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\tgoto done;\n\n\t/* If it has been a while since the last error, we'll assume\n\t * this a brand new error and reset the retry timeout. */\n\tif (time_after(jiffies, usbhid->stop_retry + HZ/2))\n\t\tusbhid->retry_delay = 0;\n\n\t/* When an error occurs, retry at increasing intervals */\n\tif (usbhid->retry_delay == 0) {\n\t\tusbhid->retry_delay = 13;\t/* Then 26, 52, 104, 104, ... */\n\t\tusbhid->stop_retry = jiffies + msecs_to_jiffies(1000);\n\t} else if (usbhid->retry_delay < 100)\n\t\tusbhid->retry_delay *= 2;\n\n\tif (time_after(jiffies, usbhid->stop_retry)) {\n\n\t\t/* Retries failed, so do a port reset unless we lack bandwidth*/\n\t\tif (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)\n\t\t     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\n\t\t\tschedule_work(&usbhid->reset_work);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmod_timer(&usbhid->io_retry,\n\t\t\tjiffies + msecs_to_jiffies(usbhid->retry_delay));\ndone:\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b",
        "vul_func_with_fix": "static void hid_io_error(struct hid_device *hid)\n{\n\tunsigned long flags;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\n\tspin_lock_irqsave(&usbhid->lock, flags);\n\n\t/* Stop when disconnected */\n\tif (test_bit(HID_DISCONNECTED, &usbhid->iofl))\n\t\tgoto done;\n\n\t/* If it has been a while since the last error, we'll assume\n\t * this a brand new error and reset the retry timeout. */\n\tif (time_after(jiffies, usbhid->stop_retry + HZ/2))\n\t\tusbhid->retry_delay = 0;\n\n\t/* When an error occurs, retry at increasing intervals */\n\tif (usbhid->retry_delay == 0) {\n\t\tusbhid->retry_delay = 13;\t/* Then 26, 52, 104, 104, ... */\n\t\tusbhid->stop_retry = jiffies + msecs_to_jiffies(1000);\n\t} else if (usbhid->retry_delay < 100)\n\t\tusbhid->retry_delay *= 2;\n\n\tif (time_after(jiffies, usbhid->stop_retry)) {\n\n\t\t/* Retries failed, so do a port reset unless we lack bandwidth*/\n\t\tif (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)\n\t\t     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {\n\n\t\t\tschedule_work(&usbhid->reset_work);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmod_timer(&usbhid->io_retry,\n\t\t\tjiffies + msecs_to_jiffies(usbhid->retry_delay));\ndone:\n\tspin_unlock_irqrestore(&usbhid->lock, flags);\n}\n",
        "linevul": 0.00016318874259013683,
        "sysevr": 0.1552179455757141,
        "devign": 3.868110345917053e-11
    },
    {
        "code": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n \tstruct page *page;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n \tstruct page *page;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n//fix_flaw_line_below:\n//\tif (pmd_trans_unstable(pmd))\n//fix_flaw_line_below:\n//\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\n\t\t/* Clear accessed and referenced bits. */\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}\n",
        "linevul": 0.9996744394302368,
        "sysevr": 0.11903929710388184,
        "devign": 0.9975067973136902
    },
    {
        "code": "static u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
        "vul_func_with_fix": "static u32 fsflags_cvt(const u32 *table, u32 val)\n{\n\tu32 res = 0;\n\twhile(val) {\n\t\tif (val & 1)\n\t\t\tres |= *table;\n\t\ttable++;\n\t\tval >>= 1;\n\t}\n\treturn res;\n}\n",
        "linevul": 0.00010718120029196143,
        "sysevr": 0.12827536463737488,
        "devign": 3.0022831443154985e-11
    },
    {
        "code": "int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t   void *data, unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint r;\n\n\tBUG_ON(len > ghc->len);\n\n\tif (slots->generation != ghc->generation)\n\t\t__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len);\n\n\tif (unlikely(!ghc->memslot))\n\t\treturn kvm_read_guest(kvm, ghc->gpa, data, len);\n\n\tif (kvm_is_error_hva(ghc->hva))\n\t\treturn -EFAULT;\n\n\tr = __copy_from_user(data, (void __user *)ghc->hva, len);\n\tif (r)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9",
        "vul_func_with_fix": "int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t   void *data, unsigned long len)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint r;\n\n\tBUG_ON(len > ghc->len);\n\n\tif (slots->generation != ghc->generation)\n\t\t__kvm_gfn_to_hva_cache_init(slots, ghc, ghc->gpa, ghc->len);\n\n\tif (unlikely(!ghc->memslot))\n\t\treturn kvm_read_guest(kvm, ghc->gpa, data, len);\n\n\tif (kvm_is_error_hva(ghc->hva))\n\t\treturn -EFAULT;\n\n\tr = __copy_from_user(data, (void __user *)ghc->hva, len);\n\tif (r)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "linevul": 4.886500755674206e-05,
        "sysevr": 0.15296052396297455,
        "devign": 8.351543855038551e-18
    },
    {
        "code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n \n\t\tsock->sk->sk_uid = iattr->ia_uid;\n \t}\n \n \treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6d8c50dcb029872b298eea68cc6209c866fd3e14",
        "vul_func_with_fix": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n \n//flaw_line_below:\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n//fix_flaw_line_below:\n//\t\tif (sock->sk)\n//fix_flaw_line_below:\n//\t\t\tsock->sk->sk_uid = iattr->ia_uid;\n//fix_flaw_line_below:\n//\t\telse\n//fix_flaw_line_below:\n//\t\t\terr = -ENOENT;\n \t}\n \n \treturn err;\n}\n",
        "linevul": 0.99894779920578,
        "sysevr": 0.1258241832256317,
        "devign": 0.9996247291564941
    },
    {
        "code": "static void oz_acquire_port(struct oz_port *port, void *hpd)\n{\n\tINIT_LIST_HEAD(&port->isoc_out_ep);\n\tINIT_LIST_HEAD(&port->isoc_in_ep);\n\tport->flags |= OZ_PORT_F_PRESENT | OZ_PORT_F_CHANGED;\n\tport->status |= USB_PORT_STAT_CONNECTION |\n\t\t\t(USB_PORT_STAT_C_CONNECTION << 16);\n\toz_usb_get(hpd);\n\tport->hpd = hpd;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c",
        "vul_func_with_fix": "static void oz_acquire_port(struct oz_port *port, void *hpd)\n{\n\tINIT_LIST_HEAD(&port->isoc_out_ep);\n\tINIT_LIST_HEAD(&port->isoc_in_ep);\n\tport->flags |= OZ_PORT_F_PRESENT | OZ_PORT_F_CHANGED;\n\tport->status |= USB_PORT_STAT_CONNECTION |\n\t\t\t(USB_PORT_STAT_C_CONNECTION << 16);\n\toz_usb_get(hpd);\n\tport->hpd = hpd;\n}\n",
        "linevul": 0.0001395559374941513,
        "sysevr": 0.12605597078800201,
        "devign": 2.9216422485921557e-18
    },
    {
        "code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n \tint ret;\n \tuint8_t value;\n \n \tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655",
        "vul_func_with_fix": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n \tint ret;\n//fix_flaw_line_below:\n//\tuint8_t *buffer;\n \tuint8_t value;\n \n//fix_flaw_line_below:\n//\tbuffer = kmalloc(1, GFP_KERNEL);\n//fix_flaw_line_below:\n//\tif (!buffer)\n//fix_flaw_line_below:\n//\t\treturn -ENOMEM;\n//fix_flaw_line_below:\n//\n \tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n//flaw_line_below:\n\t\t\t\t0, reg, &value, 1, 1000);\n//flaw_line_below:\n\treturn ret >= 0 ? value : ret;\n//fix_flaw_line_below:\n//\t\t\t\t0, reg, buffer, 1, 1000);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (ret >= 0) {\n//fix_flaw_line_below:\n//\t\tvalue = buffer[0];\n//fix_flaw_line_below:\n//\t\tkfree(buffer);\n//fix_flaw_line_below:\n//\t\treturn value;\n//fix_flaw_line_below:\n//\t} else {\n//fix_flaw_line_below:\n//\t\tkfree(buffer);\n//fix_flaw_line_below:\n//\t\treturn ret;\n//fix_flaw_line_below:\n//\t}\n }\n",
        "linevul": 0.9994997978210449,
        "sysevr": 0.12605611979961395,
        "devign": 0.5678903460502625
    },
    {
        "code": "static int key_wait_bit_intr(void *flags)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static int key_wait_bit_intr(void *flags)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n",
        "linevul": 6.536563887493685e-05,
        "sysevr": 0.1356336772441864,
        "devign": 2.0855202365055447e-06
    },
    {
        "code": "static int ccm_init_mac(struct aead_request *req, u8 maciv[], u32 msglen)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\t__be32 *n = (__be32 *)&maciv[AES_BLOCK_SIZE - 8];\n\tu32 l = req->iv[0] + 1;\n\n\t/* verify that CCM dimension 'L' is set correctly in the IV */\n\tif (l < 2 || l > 8)\n\t\treturn -EINVAL;\n\n\t/* verify that msglen can in fact be represented in L bytes */\n\tif (l < 4 && msglen >> (8 * l))\n\t\treturn -EOVERFLOW;\n\n\t/*\n\t * Even if the CCM spec allows L values of up to 8, the Linux cryptoapi\n\t * uses a u32 type to represent msglen so the top 4 bytes are always 0.\n\t */\n\tn[0] = 0;\n\tn[1] = cpu_to_be32(msglen);\n\n\tmemcpy(maciv, req->iv, AES_BLOCK_SIZE - l);\n\n\t/*\n\t * Meaning of byte 0 according to CCM spec (RFC 3610/NIST 800-38C)\n\t * - bits 0..2\t: max # of bytes required to represent msglen, minus 1\n\t *                (already set by caller)\n\t * - bits 3..5\t: size of auth tag (1 => 4 bytes, 2 => 6 bytes, etc)\n\t * - bit 6\t: indicates presence of authenticate-only data\n\t */\n\tmaciv[0] |= (crypto_aead_authsize(aead) - 2) << 2;\n\tif (req->assoclen)\n\t\tmaciv[0] |= 0x40;\n\n\tmemset(&req->iv[AES_BLOCK_SIZE - l], 0, l);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int ccm_init_mac(struct aead_request *req, u8 maciv[], u32 msglen)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\t__be32 *n = (__be32 *)&maciv[AES_BLOCK_SIZE - 8];\n\tu32 l = req->iv[0] + 1;\n\n\t/* verify that CCM dimension 'L' is set correctly in the IV */\n\tif (l < 2 || l > 8)\n\t\treturn -EINVAL;\n\n\t/* verify that msglen can in fact be represented in L bytes */\n\tif (l < 4 && msglen >> (8 * l))\n\t\treturn -EOVERFLOW;\n\n\t/*\n\t * Even if the CCM spec allows L values of up to 8, the Linux cryptoapi\n\t * uses a u32 type to represent msglen so the top 4 bytes are always 0.\n\t */\n\tn[0] = 0;\n\tn[1] = cpu_to_be32(msglen);\n\n\tmemcpy(maciv, req->iv, AES_BLOCK_SIZE - l);\n\n\t/*\n\t * Meaning of byte 0 according to CCM spec (RFC 3610/NIST 800-38C)\n\t * - bits 0..2\t: max # of bytes required to represent msglen, minus 1\n\t *                (already set by caller)\n\t * - bits 3..5\t: size of auth tag (1 => 4 bytes, 2 => 6 bytes, etc)\n\t * - bit 6\t: indicates presence of authenticate-only data\n\t */\n\tmaciv[0] |= (crypto_aead_authsize(aead) - 2) << 2;\n\tif (req->assoclen)\n\t\tmaciv[0] |= 0x40;\n\n\tmemset(&req->iv[AES_BLOCK_SIZE - l], 0, l);\n\treturn 0;\n}\n",
        "linevul": 6.818225665483624e-05,
        "sysevr": 0.20825456082820892,
        "devign": 0.16055023670196533
    },
    {
        "code": "static void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,\n\t\t\t    unsigned long caller)\n{\n\tint size = cachep->object_size;\n\n\taddr = (unsigned long *)&((char *)addr)[obj_offset(cachep)];\n\n\tif (size < 5 * sizeof(unsigned long))\n\t\treturn;\n\n\t*addr++ = 0x12345678;\n\t*addr++ = caller;\n\t*addr++ = smp_processor_id();\n\tsize -= 3 * sizeof(unsigned long);\n\t{\n\t\tunsigned long *sptr = &caller;\n\t\tunsigned long svalue;\n\n\t\twhile (!kstack_end(sptr)) {\n\t\t\tsvalue = *sptr++;\n\t\t\tif (kernel_text_address(svalue)) {\n\t\t\t\t*addr++ = svalue;\n\t\t\t\tsize -= sizeof(unsigned long);\n\t\t\t\tif (size <= sizeof(unsigned long))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\t*addr++ = 0x87654321;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
        "vul_func_with_fix": "static void store_stackinfo(struct kmem_cache *cachep, unsigned long *addr,\n\t\t\t    unsigned long caller)\n{\n\tint size = cachep->object_size;\n\n\taddr = (unsigned long *)&((char *)addr)[obj_offset(cachep)];\n\n\tif (size < 5 * sizeof(unsigned long))\n\t\treturn;\n\n\t*addr++ = 0x12345678;\n\t*addr++ = caller;\n\t*addr++ = smp_processor_id();\n\tsize -= 3 * sizeof(unsigned long);\n\t{\n\t\tunsigned long *sptr = &caller;\n\t\tunsigned long svalue;\n\n\t\twhile (!kstack_end(sptr)) {\n\t\t\tsvalue = *sptr++;\n\t\t\tif (kernel_text_address(svalue)) {\n\t\t\t\t*addr++ = svalue;\n\t\t\t\tsize -= sizeof(unsigned long);\n\t\t\t\tif (size <= sizeof(unsigned long))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\t*addr++ = 0x87654321;\n}\n",
        "linevul": 0.00014019588707014918,
        "sysevr": 0.12840987741947174,
        "devign": 2.463488136113973e-20
    },
    {
        "code": "static int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t/* conflicts.. */\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e4ec8cc8039a7063e24204299b462bd1383184a5",
        "vul_func_with_fix": "static int snd_timer_dev_register(struct snd_device *dev)\n{\n\tstruct snd_timer *timer = dev->device_data;\n\tstruct snd_timer *timer1;\n\n\tif (snd_BUG_ON(!timer || !timer->hw.start || !timer->hw.stop))\n\t\treturn -ENXIO;\n\tif (!(timer->hw.flags & SNDRV_TIMER_HW_SLAVE) &&\n\t    !timer->hw.resolution && timer->hw.c_resolution == NULL)\n\t    \treturn -EINVAL;\n\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer1, &snd_timer_list, device_list) {\n\t\tif (timer1->tmr_class > timer->tmr_class)\n\t\t\tbreak;\n\t\tif (timer1->tmr_class < timer->tmr_class)\n\t\t\tcontinue;\n\t\tif (timer1->card && timer->card) {\n\t\t\tif (timer1->card->number > timer->card->number)\n\t\t\t\tbreak;\n\t\t\tif (timer1->card->number < timer->card->number)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (timer1->tmr_device > timer->tmr_device)\n\t\t\tbreak;\n\t\tif (timer1->tmr_device < timer->tmr_device)\n\t\t\tcontinue;\n\t\tif (timer1->tmr_subdevice > timer->tmr_subdevice)\n\t\t\tbreak;\n\t\tif (timer1->tmr_subdevice < timer->tmr_subdevice)\n\t\t\tcontinue;\n\t\t/* conflicts.. */\n\t\tmutex_unlock(&register_mutex);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&timer->device_list, &timer1->device_list);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n",
        "linevul": 7.113190804375336e-05,
        "sysevr": 0.1440717726945877,
        "devign": 9.598073373682115e-15
    },
    {
        "code": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}\n",
        "linevul": 4.893481309409253e-05,
        "sysevr": 0.15061059594154358,
        "devign": 4.228401656591885e-11
    },
    {
        "code": "struct xt_table *xt_find_table_lock(struct net *net, u_int8_t af,\n\t\t\t\t    const char *name)\n{\n\tstruct xt_table *t, *found = NULL;\n\n\tmutex_lock(&xt[af].mutex);\n\tlist_for_each_entry(t, &net->xt.tables[af], list)\n\t\tif (strcmp(t->name, name) == 0 && try_module_get(t->me))\n\t\t\treturn t;\n\n\tif (net == &init_net)\n\t\tgoto out;\n\n\t/* Table doesn't exist in this netns, re-try init */\n\tlist_for_each_entry(t, &init_net.xt.tables[af], list) {\n\t\tif (strcmp(t->name, name))\n\t\t\tcontinue;\n\t\tif (!try_module_get(t->me))\n\t\t\treturn NULL;\n\n\t\tmutex_unlock(&xt[af].mutex);\n\t\tif (t->table_init(net) != 0) {\n\t\t\tmodule_put(t->me);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfound = t;\n\n\t\tmutex_lock(&xt[af].mutex);\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tgoto out;\n\n\t/* and once again: */\n\tlist_for_each_entry(t, &net->xt.tables[af], list)\n\t\tif (strcmp(t->name, name) == 0)\n\t\t\treturn t;\n\n\tmodule_put(found->me);\n out:\n\tmutex_unlock(&xt[af].mutex);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c",
        "vul_func_with_fix": "struct xt_table *xt_find_table_lock(struct net *net, u_int8_t af,\n\t\t\t\t    const char *name)\n{\n\tstruct xt_table *t, *found = NULL;\n\n\tmutex_lock(&xt[af].mutex);\n\tlist_for_each_entry(t, &net->xt.tables[af], list)\n\t\tif (strcmp(t->name, name) == 0 && try_module_get(t->me))\n\t\t\treturn t;\n\n\tif (net == &init_net)\n\t\tgoto out;\n\n\t/* Table doesn't exist in this netns, re-try init */\n\tlist_for_each_entry(t, &init_net.xt.tables[af], list) {\n\t\tif (strcmp(t->name, name))\n\t\t\tcontinue;\n\t\tif (!try_module_get(t->me))\n\t\t\treturn NULL;\n\n\t\tmutex_unlock(&xt[af].mutex);\n\t\tif (t->table_init(net) != 0) {\n\t\t\tmodule_put(t->me);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfound = t;\n\n\t\tmutex_lock(&xt[af].mutex);\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tgoto out;\n\n\t/* and once again: */\n\tlist_for_each_entry(t, &net->xt.tables[af], list)\n\t\tif (strcmp(t->name, name) == 0)\n\t\t\treturn t;\n\n\tmodule_put(found->me);\n out:\n\tmutex_unlock(&xt[af].mutex);\n\treturn NULL;\n}\n",
        "linevul": 0.00010763431782834232,
        "sysevr": 0.1363265961408615,
        "devign": 1.1614721415753593e-06
    },
    {
        "code": "struct super_block *get_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87",
        "vul_func_with_fix": "struct super_block *get_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}\n",
        "linevul": 0.0001692331425147131,
        "sysevr": 0.14907991886138916,
        "devign": 0.0
    },
    {
        "code": "vsock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct sockaddr_vm *vm_addr;\n\n\tsk = sock->sk;\n\n\tif (vsock_addr_cast(addr, addr_len, &vm_addr) != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\terr = __vsock_bind(sk, vm_addr);\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d5e0d0f607a7a029c6563a0470d88255c89a8d11",
        "vul_func_with_fix": "vsock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct sockaddr_vm *vm_addr;\n\n\tsk = sock->sk;\n\n\tif (vsock_addr_cast(addr, addr_len, &vm_addr) != 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\terr = __vsock_bind(sk, vm_addr);\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "linevul": 4.883193105342798e-05,
        "sysevr": 0.15569289028644562,
        "devign": 4.130123488721438e-05
    },
    {
        "code": "static void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97",
        "vul_func_with_fix": "static void __exit ecryptfs_exit(void)\n{\n\tint rc;\n\n\trc = ecryptfs_destroy_crypto();\n\tif (rc)\n\t\tprintk(KERN_ERR \"Failure whilst attempting to destroy crypto; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\tecryptfs_release_messaging();\n\tecryptfs_destroy_kthread();\n\tdo_sysfs_unregistration();\n\tunregister_filesystem(&ecryptfs_fs_type);\n\tecryptfs_free_kmem_caches();\n}\n",
        "linevul": 7.466124225175008e-05,
        "sysevr": 0.1255057156085968,
        "devign": 0.4751233160495758
    },
    {
        "code": "static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tif (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) {\n\t\tif (!set_nr_if_polling(rq->idle))\n\t\t\tsmp_send_reschedule(cpu);\n\t\telse\n\t\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tif (llist_add(&p->wake_entry, &cpu_rq(cpu)->wake_list)) {\n\t\tif (!set_nr_if_polling(rq->idle))\n\t\t\tsmp_send_reschedule(cpu);\n\t\telse\n\t\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t}\n}\n",
        "linevul": 5.006288120057434e-05,
        "sysevr": 0.11942550539970398,
        "devign": 1.6204495993182394e-16
    },
    {
        "code": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n \tunsigned int ee_len, depth;\n \tint err = 0;\n \n \text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n \t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n \n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n \n \terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n \tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n \t\tif (err)\n \t\t\tgoto fix_extent_len;\n \t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dee1f973ca341c266229faa5a1a5bb268bed3531",
        "vul_func_with_fix": "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path *path,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags)\n{\n\text4_fsblk_t newblock;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex, newex, orig_ex;\n\tstruct ext4_extent *ex2 = NULL;\n \tunsigned int ee_len, depth;\n \tint err = 0;\n \n//fix_flaw_line_below:\n//\tBUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==\n//fix_flaw_line_below:\n//\t       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));\n//fix_flaw_line_below:\n//\n \text_debug(\"ext4_split_extents_at: inode %lu, logical\"\n \t\t\"block %llu\\n\", inode->i_ino, (unsigned long long)split);\n \n\text4_ext_show_leaf(inode, path);\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tnewblock = split - ee_block + ext4_ext_pblock(ex);\n\n\tBUG_ON(split < ee_block || split >= (ee_block + ee_len));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\n\tif (split == ee_block) {\n\t\t/*\n\t\t * case b: block @split is the block that the extent begins with\n\t\t * then we just change the state of the extent, and splitting\n\t\t * is not needed.\n\t\t */\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\telse\n\t\t\text4_ext_mark_initialized(ex);\n\n\t\tif (!(flags & EXT4_GET_BLOCKS_PRE_IO))\n\t\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t}\n\n\t/* case a */\n\tmemcpy(&orig_ex, ex, sizeof(orig_ex));\n\tex->ee_len = cpu_to_le16(split - ee_block);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT1)\n\t\text4_ext_mark_uninitialized(ex);\n\n\t/*\n\t * path may lead to new leaf, not to original leaf any more\n\t * after ext4_ext_insert_extent() returns,\n\t */\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\tif (err)\n\t\tgoto fix_extent_len;\n\n\tex2 = &newex;\n\tex2->ee_block = cpu_to_le32(split);\n\tex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));\n\text4_ext_store_pblock(ex2, newblock);\n\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\text4_ext_mark_uninitialized(ex2);\n \n \terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n \tif (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {\n//flaw_line_below:\n\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n//fix_flaw_line_below:\n//\t\tif (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {\n//fix_flaw_line_below:\n//\t\t\tif (split_flag & EXT4_EXT_DATA_VALID1)\n//fix_flaw_line_below:\n//\t\t\t\terr = ext4_ext_zeroout(inode, ex2);\n//fix_flaw_line_below:\n//\t\t\telse\n//fix_flaw_line_below:\n//\t\t\t\terr = ext4_ext_zeroout(inode, ex);\n//fix_flaw_line_below:\n//\t\t} else\n//fix_flaw_line_below:\n//\t\t\terr = ext4_ext_zeroout(inode, &orig_ex);\n//fix_flaw_line_below:\n//\n \t\tif (err)\n \t\t\tgoto fix_extent_len;\n \t\t/* update the extent length and mark as initialized */\n\t\tex->ee_len = cpu_to_le16(ee_len);\n\t\text4_ext_try_to_merge(handle, inode, path, ex);\n\t\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\n\t\tgoto out;\n\t} else if (err)\n\t\tgoto fix_extent_len;\n\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n\nfix_extent_len:\n\tex->ee_len = orig_ex.ee_len;\n\text4_ext_dirty(handle, inode, path + depth);\n\treturn err;\n}\n",
        "linevul": 0.9995573163032532,
        "sysevr": 0.24142318964004517,
        "devign": 1.0185911003546266e-09
    },
    {
        "code": "static void ebt_standard_compat_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v >= 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d846f71195d57b0bbb143382647c2c6638b04c5a",
        "vul_func_with_fix": "static void ebt_standard_compat_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v >= 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_BRIDGE, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n",
        "linevul": 4.7565248678438365e-05,
        "sysevr": 0.12650053203105927,
        "devign": 1.4759488742299709e-08
    },
    {
        "code": "static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/17d68b763f09a9ce824ae23eb62c9efc57b69271",
        "vul_func_with_fix": "static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}\n",
        "linevul": 4.859552063862793e-05,
        "sysevr": 0.12765416502952576,
        "devign": 0.020941970869898796
    },
    {
        "code": "static int __init hugetlb_nrpages_setup(char *s)\n{\n\tunsigned long *mhp;\n\tstatic unsigned long *last_mhp;\n\n\tif (!parsed_valid_hugepagesz) {\n\t\tpr_warn(\"hugepages = %s preceded by \"\n\t\t\t\"an unsupported hugepagesz, ignoring\\n\", s);\n\t\tparsed_valid_hugepagesz = true;\n\t\treturn 1;\n\t}\n\t/*\n\t * !hugetlb_max_hstate means we haven't parsed a hugepagesz= parameter yet,\n\t * so this hugepages= parameter goes to the \"default hstate\".\n\t */\n\telse if (!hugetlb_max_hstate)\n\t\tmhp = &default_hstate_max_huge_pages;\n\telse\n\t\tmhp = &parsed_hstate->max_huge_pages;\n\n\tif (mhp == last_mhp) {\n\t\tpr_warn(\"hugepages= specified twice without interleaving hugepagesz=, ignoring\\n\");\n\t\treturn 1;\n\t}\n\n\tif (sscanf(s, \"%lu\", mhp) <= 0)\n\t\t*mhp = 0;\n\n\t/*\n\t * Global state is always initialized later in hugetlb_init.\n\t * But we need to allocate >= MAX_ORDER hstates here early to still\n\t * use the bootmem allocator.\n\t */\n\tif (hugetlb_max_hstate && parsed_hstate->order >= MAX_ORDER)\n\t\thugetlb_hstate_alloc_pages(parsed_hstate);\n\n\tlast_mhp = mhp;\n\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1e3921471354244f70fe268586ff94a97a6dd4df",
        "vul_func_with_fix": "static int __init hugetlb_nrpages_setup(char *s)\n{\n\tunsigned long *mhp;\n\tstatic unsigned long *last_mhp;\n\n\tif (!parsed_valid_hugepagesz) {\n\t\tpr_warn(\"hugepages = %s preceded by \"\n\t\t\t\"an unsupported hugepagesz, ignoring\\n\", s);\n\t\tparsed_valid_hugepagesz = true;\n\t\treturn 1;\n\t}\n\t/*\n\t * !hugetlb_max_hstate means we haven't parsed a hugepagesz= parameter yet,\n\t * so this hugepages= parameter goes to the \"default hstate\".\n\t */\n\telse if (!hugetlb_max_hstate)\n\t\tmhp = &default_hstate_max_huge_pages;\n\telse\n\t\tmhp = &parsed_hstate->max_huge_pages;\n\n\tif (mhp == last_mhp) {\n\t\tpr_warn(\"hugepages= specified twice without interleaving hugepagesz=, ignoring\\n\");\n\t\treturn 1;\n\t}\n\n\tif (sscanf(s, \"%lu\", mhp) <= 0)\n\t\t*mhp = 0;\n\n\t/*\n\t * Global state is always initialized later in hugetlb_init.\n\t * But we need to allocate >= MAX_ORDER hstates here early to still\n\t * use the bootmem allocator.\n\t */\n\tif (hugetlb_max_hstate && parsed_hstate->order >= MAX_ORDER)\n\t\thugetlb_hstate_alloc_pages(parsed_hstate);\n\n\tlast_mhp = mhp;\n\n\treturn 1;\n}\n",
        "linevul": 5.522830178961158e-05,
        "sysevr": 0.1329810917377472,
        "devign": 0.6975529193878174
    },
    {
        "code": "static struct ib_qp *mlx5_ib_create_dct(struct ib_pd *pd,\n\t\t\t\t\tstruct ib_qp_init_attr *attr,\n\t\t\t\t\tstruct mlx5_ib_create_qp *ucmd)\n{\n\tstruct mlx5_ib_qp *qp;\n\tint err = 0;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tvoid *dctc;\n\n\tif (!attr->srq || !attr->recv_cq)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\tucmd, sizeof(*ucmd), &uidx);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);\n\tif (!qp->dct.in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tqp->qp_sub_type = MLX5_IB_QPT_DCT;\n\tMLX5_SET(dctc, dctc, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(dctc, dctc, srqn_xrqn, to_msrq(attr->srq)->msrq.srqn);\n\tMLX5_SET(dctc, dctc, cqn, to_mcq(attr->recv_cq)->mcq.cqn);\n\tMLX5_SET64(dctc, dctc, dc_access_key, ucmd->access_key);\n\tMLX5_SET(dctc, dctc, user_index, uidx);\n\n\tqp->state = IB_QPS_RESET;\n\n\treturn &qp->ibqp;\nerr_free:\n\tkfree(qp);\n\treturn ERR_PTR(err);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00",
        "vul_func_with_fix": "static struct ib_qp *mlx5_ib_create_dct(struct ib_pd *pd,\n\t\t\t\t\tstruct ib_qp_init_attr *attr,\n\t\t\t\t\tstruct mlx5_ib_create_qp *ucmd)\n{\n\tstruct mlx5_ib_qp *qp;\n\tint err = 0;\n\tu32 uidx = MLX5_IB_DEFAULT_UIDX;\n\tvoid *dctc;\n\n\tif (!attr->srq || !attr->recv_cq)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terr = get_qp_user_index(to_mucontext(pd->uobject->context),\n\t\t\t\tucmd, sizeof(*ucmd), &uidx);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);\n\tif (!qp->dct.in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tqp->qp_sub_type = MLX5_IB_QPT_DCT;\n\tMLX5_SET(dctc, dctc, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(dctc, dctc, srqn_xrqn, to_msrq(attr->srq)->msrq.srqn);\n\tMLX5_SET(dctc, dctc, cqn, to_mcq(attr->recv_cq)->mcq.cqn);\n\tMLX5_SET64(dctc, dctc, dc_access_key, ucmd->access_key);\n\tMLX5_SET(dctc, dctc, user_index, uidx);\n\n\tqp->state = IB_QPS_RESET;\n\n\treturn &qp->ibqp;\nerr_free:\n\tkfree(qp);\n\treturn ERR_PTR(err);\n}\n",
        "linevul": 7.654901128262281e-05,
        "sysevr": 0.1617688238620758,
        "devign": 1.5565617683677146e-09
    },
    {
        "code": "static int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct user_namespace *s_user_ns;\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\ts_user_ns = dir->dentry->d_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e",
        "vul_func_with_fix": "static int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct user_namespace *s_user_ns;\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\ts_user_ns = dir->dentry->d_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n",
        "linevul": 7.999489025678486e-05,
        "sysevr": 0.12587842345237732,
        "devign": 2.5561287348553428e-26
    },
    {
        "code": "static bool tcp_try_undo_dsack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && !tp->undo_retrans) {\n\t\tDBGUNDO(sk, \"D-SACK\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390",
        "vul_func_with_fix": "static bool tcp_try_undo_dsack(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tp->undo_marker && !tp->undo_retrans) {\n\t\tDBGUNDO(sk, \"D-SACK\");\n\t\ttcp_undo_cwnd_reduction(sk, false);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "linevul": 4.701377474702895e-05,
        "sysevr": 0.12856930494308472,
        "devign": 4.365364885044934e-37
    },
    {
        "code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n \t/* Linux only supports version 0 radiotap format */\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n \t\t\t */\n \n \t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f5563318ff1bde15b10e736e97ffce13be08bc1a",
        "vul_func_with_fix": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n \tstruct ieee80211_radiotap_header *radiotap_header,\n \tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n {\n//fix_flaw_line_below:\n//\t/* check the radiotap header can actually be present */\n//fix_flaw_line_below:\n//\tif (max_length < sizeof(struct ieee80211_radiotap_header))\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n \t/* Linux only supports version 0 radiotap format */\n \tif (radiotap_header->it_version)\n \t\treturn -EINVAL;\n\n\t/* sanity check for allowed length and radiotap length field */\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\n\t/* find payload start allowing for extended bitmap(s) */\n\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t\t/*\n\t\t\t * check for insanity where the present bitmaps\n\t\t\t * keep claiming to extend up to or even beyond the\n\t\t\t * stated radiotap header length\n \t\t\t */\n \n \t\t\tif ((unsigned long)iterator->_arg -\n//flaw_line_below:\n\t\t\t    (unsigned long)iterator->_rtheader >\n//fix_flaw_line_below:\n//\t\t\t    (unsigned long)iterator->_rtheader +\n//fix_flaw_line_below:\n//\t\t\t    sizeof(uint32_t) >\n \t\t\t    (unsigned long)iterator->_max_length)\n \t\t\t\treturn -EINVAL;\n \t\t}\n\n\t\titerator->_arg += sizeof(uint32_t);\n\n\t\t/*\n\t\t * no need to check again for blowing past stated radiotap\n\t\t * header length, because ieee80211_radiotap_iterator_next\n\t\t * checks it before it is dereferenced\n\t\t */\n\t}\n\n\titerator->this_arg = iterator->_arg;\n\n\t/* we are all initialized happily */\n\n\treturn 0;\n}\n",
        "linevul": 0.9996719360351562,
        "sysevr": 0.2449832260608673,
        "devign": 0.9950822591781616
    },
    {
        "code": "do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tunsigned long address;\n\tstruct mm_struct *mm;\n\tint fault;\n\tint write = error_code & PF_WRITE;\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |\n\t\t\t\t\t(write ? FAULT_FLAG_WRITE : 0);\n\n\ttsk = current;\n\tmm = tsk->mm;\n\n\t/* Get the faulting address: */\n\taddress = read_cr2();\n\n\t/*\n\t * Detect and handle instructions that would cause a page fault for\n\t * both a tracked kernel page and a userspace page.\n\t */\n\tif (kmemcheck_active(regs))\n\t\tkmemcheck_hide(regs);\n\tprefetchw(&mm->mmap_sem);\n\n\tif (unlikely(kmmio_fault(regs, address)))\n\t\treturn;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t *\n\t * This verifies that the fault happens in kernel space\n\t * (error_code & 4) == 0, and that the fault was not a\n\t * protection error (error_code & 9) == 0.\n\t */\n\tif (unlikely(fault_in_kernel_space(address))) {\n\t\tif (!(error_code & (PF_RSVD | PF_USER | PF_PROT))) {\n\t\t\tif (vmalloc_fault(address) >= 0)\n\t\t\t\treturn;\n\n\t\t\tif (kmemcheck_fault(regs, address, error_code))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/* Can handle a stale RO->RW TLB: */\n\t\tif (spurious_fault(error_code, address))\n\t\t\treturn;\n\n\t\t/* kprobes don't want to hook the spurious faults: */\n\t\tif (notify_page_fault(regs))\n\t\t\treturn;\n\t\t/*\n\t\t * Don't take the mm semaphore here. If we fixup a prefetch\n\t\t * fault we could otherwise deadlock:\n\t\t */\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\n\t\treturn;\n\t}\n\n\t/* kprobes don't want to hook the spurious faults: */\n\tif (unlikely(notify_page_fault(regs)))\n\t\treturn;\n\t/*\n\t * It's safe to allow irq's after cr2 has been saved and the\n\t * vmalloc fault has been handled.\n\t *\n\t * User-mode registers count as a user access even for any\n\t * potential system fault or CPU buglet:\n\t */\n\tif (user_mode_vm(regs)) {\n\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else {\n\t\tif (regs->flags & X86_EFLAGS_IF)\n\t\t\tlocal_irq_enable();\n\t}\n\n \tif (unlikely(error_code & PF_RSVD))\n \t\tpgtable_bad(regs, error_code, address);\n \n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n \n \t/*\n \t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t */\n\tif (unlikely(in_atomic() || !mm)) {\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * When running in the kernel we expect faults to occur only to\n\t * addresses in user space.  All other faults represent errors in\n\t * the kernel and should generate an OOPS.  Unfortunately, in the\n\t * case of an erroneous fault occurring in a code path which already\n\t * holds mmap_sem we will deadlock attempting to validate the fault\n\t * against the address space.  Luckily the kernel only validly\n\t * references user space from well defined areas of code, which are\n\t * listed in the exceptions table.\n\t *\n\t * As the vast majority of faults will be valid we will only perform\n\t * the source reference check when there is a possibility of a\n\t * deadlock. Attempt to lock the address space, if we cannot we then\n\t * validate the source. If this is invalid we can skip the address\n\t * space check, thus avoiding the deadlock:\n\t */\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem))) {\n\t\tif ((error_code & PF_USER) == 0 &&\n\t\t    !search_exception_tables(regs->ip)) {\n\t\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\t\treturn;\n\t\t}\nretry:\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in\n\t\t * which case we'll have missed the might_sleep() from\n\t\t * down_read():\n\t\t */\n\t\tmight_sleep();\n\t}\n\n\tvma = find_vma(mm, address);\n\tif (unlikely(!vma)) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\tif (likely(vma->vm_start <= address))\n\t\tgoto good_area;\n\tif (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\tif (error_code & PF_USER) {\n\t\t/*\n\t\t * Accessing the stack below %sp is always a bug.\n\t\t * The large cushion allows instructions like enter\n\t\t * and pusha to work. (\"enter $65535, $31\" pushes\n\t\t * 32 pointers and then decrements %sp by 65535.)\n\t\t */\n\t\tif (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {\n\t\t\tbad_area(regs, error_code, address);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (unlikely(expand_stack(vma, address))) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\ngood_area:\n\tif (unlikely(access_error(error_code, vma))) {\n\t\tbad_area_access_error(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault:\n\t */\n\tfault = handle_mm_fault(mm, vma, address, flags);\n\n\tif (unlikely(fault & (VM_FAULT_RETRY|VM_FAULT_ERROR))) {\n\t\tif (mm_fault_error(regs, error_code, address, fault))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Major/minor page fault accounting is only done on the\n\t * initial attempt. If we go through a retry, it is extremely\n\t * likely that the page will be found in page cache at that point.\n\t */\n \tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n \t\tif (fault & VM_FAULT_MAJOR) {\n \t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n \t\t\t\t      regs, address);\n \t\t} else {\n \t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n \t\t\t\t      regs, address);\n \t\t}\n \t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. */\n\t\t\tflags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tcheck_v8086_mode(regs, address, tsk);\n\n\tup_read(&mm->mmap_sem);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk;\n\tunsigned long address;\n\tstruct mm_struct *mm;\n\tint fault;\n\tint write = error_code & PF_WRITE;\n\tunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |\n\t\t\t\t\t(write ? FAULT_FLAG_WRITE : 0);\n\n\ttsk = current;\n\tmm = tsk->mm;\n\n\t/* Get the faulting address: */\n\taddress = read_cr2();\n\n\t/*\n\t * Detect and handle instructions that would cause a page fault for\n\t * both a tracked kernel page and a userspace page.\n\t */\n\tif (kmemcheck_active(regs))\n\t\tkmemcheck_hide(regs);\n\tprefetchw(&mm->mmap_sem);\n\n\tif (unlikely(kmmio_fault(regs, address)))\n\t\treturn;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t *\n\t * This verifies that the fault happens in kernel space\n\t * (error_code & 4) == 0, and that the fault was not a\n\t * protection error (error_code & 9) == 0.\n\t */\n\tif (unlikely(fault_in_kernel_space(address))) {\n\t\tif (!(error_code & (PF_RSVD | PF_USER | PF_PROT))) {\n\t\t\tif (vmalloc_fault(address) >= 0)\n\t\t\t\treturn;\n\n\t\t\tif (kmemcheck_fault(regs, address, error_code))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/* Can handle a stale RO->RW TLB: */\n\t\tif (spurious_fault(error_code, address))\n\t\t\treturn;\n\n\t\t/* kprobes don't want to hook the spurious faults: */\n\t\tif (notify_page_fault(regs))\n\t\t\treturn;\n\t\t/*\n\t\t * Don't take the mm semaphore here. If we fixup a prefetch\n\t\t * fault we could otherwise deadlock:\n\t\t */\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\n\t\treturn;\n\t}\n\n\t/* kprobes don't want to hook the spurious faults: */\n\tif (unlikely(notify_page_fault(regs)))\n\t\treturn;\n\t/*\n\t * It's safe to allow irq's after cr2 has been saved and the\n\t * vmalloc fault has been handled.\n\t *\n\t * User-mode registers count as a user access even for any\n\t * potential system fault or CPU buglet:\n\t */\n\tif (user_mode_vm(regs)) {\n\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else {\n\t\tif (regs->flags & X86_EFLAGS_IF)\n\t\t\tlocal_irq_enable();\n\t}\n\n \tif (unlikely(error_code & PF_RSVD))\n \t\tpgtable_bad(regs, error_code, address);\n \n//flaw_line_below:\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n//fix_flaw_line_below:\n//\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t/*\n \t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t */\n\tif (unlikely(in_atomic() || !mm)) {\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * When running in the kernel we expect faults to occur only to\n\t * addresses in user space.  All other faults represent errors in\n\t * the kernel and should generate an OOPS.  Unfortunately, in the\n\t * case of an erroneous fault occurring in a code path which already\n\t * holds mmap_sem we will deadlock attempting to validate the fault\n\t * against the address space.  Luckily the kernel only validly\n\t * references user space from well defined areas of code, which are\n\t * listed in the exceptions table.\n\t *\n\t * As the vast majority of faults will be valid we will only perform\n\t * the source reference check when there is a possibility of a\n\t * deadlock. Attempt to lock the address space, if we cannot we then\n\t * validate the source. If this is invalid we can skip the address\n\t * space check, thus avoiding the deadlock:\n\t */\n\tif (unlikely(!down_read_trylock(&mm->mmap_sem))) {\n\t\tif ((error_code & PF_USER) == 0 &&\n\t\t    !search_exception_tables(regs->ip)) {\n\t\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\t\treturn;\n\t\t}\nretry:\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in\n\t\t * which case we'll have missed the might_sleep() from\n\t\t * down_read():\n\t\t */\n\t\tmight_sleep();\n\t}\n\n\tvma = find_vma(mm, address);\n\tif (unlikely(!vma)) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\tif (likely(vma->vm_start <= address))\n\t\tgoto good_area;\n\tif (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\tif (error_code & PF_USER) {\n\t\t/*\n\t\t * Accessing the stack below %sp is always a bug.\n\t\t * The large cushion allows instructions like enter\n\t\t * and pusha to work. (\"enter $65535, $31\" pushes\n\t\t * 32 pointers and then decrements %sp by 65535.)\n\t\t */\n\t\tif (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {\n\t\t\tbad_area(regs, error_code, address);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (unlikely(expand_stack(vma, address))) {\n\t\tbad_area(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\ngood_area:\n\tif (unlikely(access_error(error_code, vma))) {\n\t\tbad_area_access_error(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault:\n\t */\n\tfault = handle_mm_fault(mm, vma, address, flags);\n\n\tif (unlikely(fault & (VM_FAULT_RETRY|VM_FAULT_ERROR))) {\n\t\tif (mm_fault_error(regs, error_code, address, fault))\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Major/minor page fault accounting is only done on the\n\t * initial attempt. If we go through a retry, it is extremely\n\t * likely that the page will be found in page cache at that point.\n\t */\n \tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n \t\tif (fault & VM_FAULT_MAJOR) {\n \t\t\ttsk->maj_flt++;\n//flaw_line_below:\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n//fix_flaw_line_below:\n//\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t      regs, address);\n \t\t} else {\n \t\t\ttsk->min_flt++;\n//flaw_line_below:\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n//fix_flaw_line_below:\n//\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t      regs, address);\n \t\t}\n \t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. */\n\t\t\tflags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tcheck_v8086_mode(regs, address, tsk);\n\n\tup_read(&mm->mmap_sem);\n}\n",
        "linevul": 0.0010718865087255836,
        "sysevr": 0.40664586424827576,
        "devign": 2.1186340442430618e-13
    },
    {
        "code": "static int __init ib_ucm_init(void)\n{\n\tint ret;\n\n\tret = register_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES,\n\t\t\t\t     \"infiniband_cm\");\n\tif (ret) {\n\t\tpr_err(\"ucm: couldn't register device number\\n\");\n\t\tgoto error1;\n\t}\n\n\tret = class_create_file(&cm_class, &class_attr_abi_version.attr);\n\tif (ret) {\n\t\tpr_err(\"ucm: couldn't create abi_version attribute\\n\");\n\t\tgoto error2;\n\t}\n\n\tret = ib_register_client(&ucm_client);\n\tif (ret) {\n\t\tpr_err(\"ucm: couldn't register client\\n\");\n\t\tgoto error3;\n\t}\n\treturn 0;\n\nerror3:\n\tclass_remove_file(&cm_class, &class_attr_abi_version.attr);\nerror2:\n\tunregister_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES);\nerror1:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static int __init ib_ucm_init(void)\n{\n\tint ret;\n\n\tret = register_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES,\n\t\t\t\t     \"infiniband_cm\");\n\tif (ret) {\n\t\tpr_err(\"ucm: couldn't register device number\\n\");\n\t\tgoto error1;\n\t}\n\n\tret = class_create_file(&cm_class, &class_attr_abi_version.attr);\n\tif (ret) {\n\t\tpr_err(\"ucm: couldn't create abi_version attribute\\n\");\n\t\tgoto error2;\n\t}\n\n\tret = ib_register_client(&ucm_client);\n\tif (ret) {\n\t\tpr_err(\"ucm: couldn't register client\\n\");\n\t\tgoto error3;\n\t}\n\treturn 0;\n\nerror3:\n\tclass_remove_file(&cm_class, &class_attr_abi_version.attr);\nerror2:\n\tunregister_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES);\nerror1:\n\treturn ret;\n}\n",
        "linevul": 9.004292951431125e-05,
        "sysevr": 0.12634046375751495,
        "devign": 0.6674666404724121
    },
    {
        "code": "int security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2172fa709ab32ca60e86179dc67d0857be8e2c98",
        "vul_func_with_fix": "int security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}\n",
        "linevul": 5.828948997077532e-05,
        "sysevr": 0.200033500790596,
        "devign": 4.784819192169e-31
    },
    {
        "code": "static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)\n{\n\tdev_dbg(&adap_to_d(adap)->udev->dev, \"%s: adap=%d\\n\", __func__,\n\t\t\tadap->id);\n\n\tif (adap->dvb_adap.priv) {\n\t\tdvb_net_release(&adap->dvb_net);\n\t\tadap->demux.dmx.close(&adap->demux.dmx);\n\t\tdvb_dmxdev_release(&adap->dmxdev);\n\t\tdvb_dmx_release(&adap->demux);\n\t\tdvb_unregister_adapter(&adap->dvb_adap);\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/005145378c9ad7575a01b6ce1ba118fb427f583a",
        "vul_func_with_fix": "static int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)\n{\n\tdev_dbg(&adap_to_d(adap)->udev->dev, \"%s: adap=%d\\n\", __func__,\n\t\t\tadap->id);\n\n\tif (adap->dvb_adap.priv) {\n\t\tdvb_net_release(&adap->dvb_net);\n\t\tadap->demux.dmx.close(&adap->demux.dmx);\n\t\tdvb_dmxdev_release(&adap->dmxdev);\n\t\tdvb_dmx_release(&adap->demux);\n\t\tdvb_unregister_adapter(&adap->dvb_adap);\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 4.667889152187854e-05,
        "sysevr": 0.12990766763687134,
        "devign": 1.7836298030985548e-13
    },
    {
        "code": "static bool __init sparc64_has_md5_opcode(void)\n{\n\tunsigned long cfr;\n\n\tif (!(sparc64_elf_hwcap & HWCAP_SPARC_CRYPTO))\n\t\treturn false;\n\n\t__asm__ __volatile__(\"rd %%asr26, %0\" : \"=r\" (cfr));\n\tif (!(cfr & CFR_MD5))\n\t\treturn false;\n\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static bool __init sparc64_has_md5_opcode(void)\n{\n\tunsigned long cfr;\n\n\tif (!(sparc64_elf_hwcap & HWCAP_SPARC_CRYPTO))\n\t\treturn false;\n\n\t__asm__ __volatile__(\"rd %%asr26, %0\" : \"=r\" (cfr));\n\tif (!(cfr & CFR_MD5))\n\t\treturn false;\n\n\treturn true;\n}\n",
        "linevul": 4.746325794258155e-05,
        "sysevr": 0.1312294751405716,
        "devign": 0.5345906019210815
    },
    {
        "code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n {\n \tstruct vcpu_svm *svm = to_svm(vcpu);\n \n\tclr_exception_intercept(svm, DB_VECTOR);\n \tclr_exception_intercept(svm, BP_VECTOR);\n \n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n \tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n \t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n \t\t\tset_exception_intercept(svm, BP_VECTOR);\n \t} else\n\t\tvcpu->guest_debug = 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d",
        "vul_func_with_fix": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n//fix_flaw_line_below:\n//static void update_bp_intercept(struct kvm_vcpu *vcpu)\n {\n \tstruct vcpu_svm *svm = to_svm(vcpu);\n \n//flaw_line_below:\n\tclr_exception_intercept(svm, DB_VECTOR);\n \tclr_exception_intercept(svm, BP_VECTOR);\n \n//flaw_line_below:\n\tif (svm->nmi_singlestep)\n//flaw_line_below:\n\t\tset_exception_intercept(svm, DB_VECTOR);\n//flaw_line_below:\n\n \tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n//flaw_line_below:\n\t\tif (vcpu->guest_debug &\n//flaw_line_below:\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n//flaw_line_below:\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n \t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n \t\t\tset_exception_intercept(svm, BP_VECTOR);\n \t} else\n\t\tvcpu->guest_debug = 0;\n}\n",
        "linevul": 0.9994767308235168,
        "sysevr": 0.13694483041763306,
        "devign": 0.9988903403282166
    },
    {
        "code": "static void find_good_pkt_pointers(struct bpf_verifier_state *state,\n\t\t\t\t   struct bpf_reg_state *dst_reg)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\t/* LLVM can generate two kind of checks:\n\t *\n\t * Type 1:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (r2 > pkt_end) goto <handle exception>\n\t *   <access okay>\n\t *\n\t *   Where:\n\t *     r2 == dst_reg, pkt_end == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Type 2:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (pkt_end >= r2) goto <access okay>\n\t *   <handle exception>\n\t *\n\t *   Where:\n\t *     pkt_end == dst_reg, r2 == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Find register r3 and mark its range as r3=pkt(id=n,off=0,r=8)\n\t * so that range of bytes [r3, r3 + 8) is safe to access.\n\t */\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)\n\t\t\t/* keep the maximum range already checked */\n\t\t\tregs[i].range = max(regs[i].range, dst_reg->off);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\treg = &state->spilled_regs[i / BPF_REG_SIZE];\n\t\tif (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)\n\t\t\treg->range = max(reg->range, dst_reg->off);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07",
        "vul_func_with_fix": "static void find_good_pkt_pointers(struct bpf_verifier_state *state,\n\t\t\t\t   struct bpf_reg_state *dst_reg)\n{\n\tstruct bpf_reg_state *regs = state->regs, *reg;\n\tint i;\n\n\t/* LLVM can generate two kind of checks:\n\t *\n\t * Type 1:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (r2 > pkt_end) goto <handle exception>\n\t *   <access okay>\n\t *\n\t *   Where:\n\t *     r2 == dst_reg, pkt_end == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Type 2:\n\t *\n\t *   r2 = r3;\n\t *   r2 += 8;\n\t *   if (pkt_end >= r2) goto <access okay>\n\t *   <handle exception>\n\t *\n\t *   Where:\n\t *     pkt_end == dst_reg, r2 == src_reg\n\t *     r2=pkt(id=n,off=8,r=0)\n\t *     r3=pkt(id=n,off=0,r=0)\n\t *\n\t * Find register r3 and mark its range as r3=pkt(id=n,off=0,r=8)\n\t * so that range of bytes [r3, r3 + 8) is safe to access.\n\t */\n\n\tfor (i = 0; i < MAX_BPF_REG; i++)\n\t\tif (regs[i].type == PTR_TO_PACKET && regs[i].id == dst_reg->id)\n\t\t\t/* keep the maximum range already checked */\n\t\t\tregs[i].range = max(regs[i].range, dst_reg->off);\n\n\tfor (i = 0; i < MAX_BPF_STACK; i += BPF_REG_SIZE) {\n\t\tif (state->stack_slot_type[i] != STACK_SPILL)\n\t\t\tcontinue;\n\t\treg = &state->spilled_regs[i / BPF_REG_SIZE];\n\t\tif (reg->type == PTR_TO_PACKET && reg->id == dst_reg->id)\n\t\t\treg->range = max(reg->range, dst_reg->off);\n\t}\n}\n",
        "linevul": 0.9230566024780273,
        "sysevr": 0.17606650292873383,
        "devign": 3.9748818380758166e-05
    },
    {
        "code": "SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)\n{\n\tstruct k_itimer *timer;\n\tunsigned long flags;\n\nretry_delete:\n\ttimer = lock_timer(timer_id, &flags);\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\tlist_del(&timer->list);\n\tspin_unlock(&current->sighand->siglock);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76",
        "vul_func_with_fix": "SYSCALL_DEFINE1(timer_delete, timer_t, timer_id)\n{\n\tstruct k_itimer *timer;\n\tunsigned long flags;\n\nretry_delete:\n\ttimer = lock_timer(timer_id, &flags);\n\tif (!timer)\n\t\treturn -EINVAL;\n\n\tif (timer_delete_hook(timer) == TIMER_RETRY) {\n\t\tunlock_timer(timer, flags);\n\t\tgoto retry_delete;\n\t}\n\n\tspin_lock(&current->sighand->siglock);\n\tlist_del(&timer->list);\n\tspin_unlock(&current->sighand->siglock);\n\t/*\n\t * This keeps any tasks waiting on the spin lock from thinking\n\t * they got something (see the lock code above).\n\t */\n\ttimer->it_signal = NULL;\n\n\tunlock_timer(timer, flags);\n\trelease_posix_timer(timer, IT_ID_SET);\n\treturn 0;\n}\n",
        "linevul": 5.089230398880318e-05,
        "sysevr": 0.17559069395065308,
        "devign": 3.684856437757844e-06
    },
    {
        "code": "static int __init sched_debug_setup(char *str)\n{\n\tsched_debug_enabled = 1;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "static int __init sched_debug_setup(char *str)\n{\n\tsched_debug_enabled = 1;\n\n\treturn 0;\n}\n",
        "linevul": 4.8033612983999774e-05,
        "sysevr": 0.12560829520225525,
        "devign": 0.47208327054977417
    },
    {
        "code": "int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1",
        "vul_func_with_fix": "int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level);\n\treturn 0;\n}\n",
        "linevul": 4.744216857943684e-05,
        "sysevr": 0.1497655063867569,
        "devign": 0.040621109306812286
    },
    {
        "code": "static int edge_create_sysfs_attrs(struct usb_serial_port *port)\n{\n\treturn device_create_file(&port->dev, &dev_attr_uart_mode);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1ee0a224bc9aad1de496c795f96bc6ba2c394811",
        "vul_func_with_fix": "static int edge_create_sysfs_attrs(struct usb_serial_port *port)\n{\n\treturn device_create_file(&port->dev, &dev_attr_uart_mode);\n}\n",
        "linevul": 0.00010265184391755611,
        "sysevr": 0.1296919286251068,
        "devign": 7.4184363256790675e-06
    },
    {
        "code": "static int xen_pcibk_read_device(struct pci_dev *dev, int offset,\n\t\t\t       u16 *value, void *data)\n{\n\t*value = dev->device;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b",
        "vul_func_with_fix": "static int xen_pcibk_read_device(struct pci_dev *dev, int offset,\n\t\t\t       u16 *value, void *data)\n{\n\t*value = dev->device;\n\n\treturn 0;\n}\n",
        "linevul": 5.847889406140894e-05,
        "sysevr": 0.12621037662029266,
        "devign": 1.164595087033149e-09
    },
    {
        "code": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n {\n \tint result;\n \thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n \tbool write = vmf->flags & FAULT_FLAG_WRITE;\n \n \tif (write) {\n \t\tsb_start_pagefault(sb);\n \t\tfile_update_time(vma->vm_file);\n \t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n \t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n \n \tif (IS_ERR(handle))\n \t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n \tif (write) {\n \t\tif (!IS_ERR(handle))\n \t\t\text4_journal_stop(handle);\n \t\tsb_end_pagefault(sb);\n\t}\n \n \treturn result;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n {\n \tint result;\n \thandle_t *handle = NULL;\n//flaw_line_below:\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n//fix_flaw_line_below:\n//\tstruct inode *inode = file_inode(vma->vm_file);\n//fix_flaw_line_below:\n//\tstruct super_block *sb = inode->i_sb;\n \tbool write = vmf->flags & FAULT_FLAG_WRITE;\n \n \tif (write) {\n \t\tsb_start_pagefault(sb);\n \t\tfile_update_time(vma->vm_file);\n//fix_flaw_line_below:\n//\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n \t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n \t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\t} else\n//fix_flaw_line_below:\n//\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n \n \tif (IS_ERR(handle))\n \t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n \tif (write) {\n \t\tif (!IS_ERR(handle))\n \t\t\text4_journal_stop(handle);\n//fix_flaw_line_below:\n//\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n \t\tsb_end_pagefault(sb);\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\t} else\n//fix_flaw_line_below:\n//\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n \n \treturn result;\n }\n",
        "linevul": 0.9996212720870972,
        "sysevr": 0.1318344920873642,
        "devign": 0.9976513981819153
    },
    {
        "code": "void mwifiex_set_vht_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vht_ie;\n\n\tvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (vht_ie) {\n\t\tmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t\tpriv->ap_11ac_enabled = 1;\n\t} else {\n\t\tpriv->ap_11ac_enabled = 0;\n\t}\n\n\treturn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3",
        "vul_func_with_fix": "void mwifiex_set_vht_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vht_ie;\n\n\tvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (vht_ie) {\n\t\tmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t\tpriv->ap_11ac_enabled = 1;\n\t} else {\n\t\tpriv->ap_11ac_enabled = 0;\n\t}\n\n\treturn;\n}\n",
        "linevul": 4.681048449128866e-05,
        "sysevr": 0.2028626650571823,
        "devign": 7.438516287845177e-16
    },
    {
        "code": "static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tLIST_HEAD(list);\n\n\tbatchcount = ac->batchcount;\n\n\tcheck_irq_off();\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tif (n->shared) {\n\t\tstruct array_cache *shared_array = n->shared;\n\t\tint max = shared_array->limit - shared_array->avail;\n\t\tif (max) {\n\t\t\tif (batchcount > max)\n\t\t\t\tbatchcount = max;\n\t\t\tmemcpy(&(shared_array->entry[shared_array->avail]),\n\t\t\t       ac->entry, sizeof(void *) * batchcount);\n\t\t\tshared_array->avail += batchcount;\n\t\t\tgoto free_done;\n\t\t}\n\t}\n\n\tfree_block(cachep, ac->entry, batchcount, node, &list);\nfree_done:\n#if STATS\n\t{\n\t\tint i = 0;\n\t\tstruct page *page;\n\n\t\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\t\tBUG_ON(page->active);\n\n\t\t\ti++;\n\t\t}\n\t\tSTATS_SET_FREEABLE(cachep, i);\n\t}\n#endif\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail -= batchcount;\n\tmemmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
        "vul_func_with_fix": "static void cache_flusharray(struct kmem_cache *cachep, struct array_cache *ac)\n{\n\tint batchcount;\n\tstruct kmem_cache_node *n;\n\tint node = numa_mem_id();\n\tLIST_HEAD(list);\n\n\tbatchcount = ac->batchcount;\n\n\tcheck_irq_off();\n\tn = get_node(cachep, node);\n\tspin_lock(&n->list_lock);\n\tif (n->shared) {\n\t\tstruct array_cache *shared_array = n->shared;\n\t\tint max = shared_array->limit - shared_array->avail;\n\t\tif (max) {\n\t\t\tif (batchcount > max)\n\t\t\t\tbatchcount = max;\n\t\t\tmemcpy(&(shared_array->entry[shared_array->avail]),\n\t\t\t       ac->entry, sizeof(void *) * batchcount);\n\t\t\tshared_array->avail += batchcount;\n\t\t\tgoto free_done;\n\t\t}\n\t}\n\n\tfree_block(cachep, ac->entry, batchcount, node, &list);\nfree_done:\n#if STATS\n\t{\n\t\tint i = 0;\n\t\tstruct page *page;\n\n\t\tlist_for_each_entry(page, &n->slabs_free, lru) {\n\t\t\tBUG_ON(page->active);\n\n\t\t\ti++;\n\t\t}\n\t\tSTATS_SET_FREEABLE(cachep, i);\n\t}\n#endif\n\tspin_unlock(&n->list_lock);\n\tslabs_destroy(cachep, &list);\n\tac->avail -= batchcount;\n\tmemmove(ac->entry, &(ac->entry[batchcount]), sizeof(void *)*ac->avail);\n}\n",
        "linevul": 0.00020419653446879238,
        "sysevr": 0.14051325619220734,
        "devign": 1.543333912079374e-22
    },
    {
        "code": "static void *find_audio_control_unit(struct mixer_build *state,\n\t\t\t\t     unsigned char unit)\n{\n\t/* we just parse the header */\n\tstruct uac_feature_unit_descriptor *hdr = NULL;\n\n\twhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\n\t\t\t\t\tUSB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (hdr->bLength >= 4 &&\n\t\t    hdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\n\t\t    hdr->bDescriptorSubtype <= UAC2_SAMPLE_RATE_CONVERTER &&\n\t\t    hdr->bUnitID == unit)\n\t\t\treturn hdr;\n\t}\n\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4",
        "vul_func_with_fix": "static void *find_audio_control_unit(struct mixer_build *state,\n\t\t\t\t     unsigned char unit)\n{\n\t/* we just parse the header */\n\tstruct uac_feature_unit_descriptor *hdr = NULL;\n\n\twhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\n\t\t\t\t\tUSB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (hdr->bLength >= 4 &&\n\t\t    hdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\n\t\t    hdr->bDescriptorSubtype <= UAC2_SAMPLE_RATE_CONVERTER &&\n\t\t    hdr->bUnitID == unit)\n\t\t\treturn hdr;\n\t}\n\n\treturn NULL;\n}\n",
        "linevul": 7.379154703812674e-05,
        "sysevr": 0.13375097513198853,
        "devign": 7.34060056663266e-13
    },
    {
        "code": "static void fini_debug_store_on_cpu(int cpu)\n{\n\tif (!per_cpu(cpu_hw_events, cpu).ds)\n\t\treturn;\n\n\twrmsr_on_cpu(cpu, MSR_IA32_DS_AREA, 0, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void fini_debug_store_on_cpu(int cpu)\n{\n\tif (!per_cpu(cpu_hw_events, cpu).ds)\n\t\treturn;\n\n\twrmsr_on_cpu(cpu, MSR_IA32_DS_AREA, 0, 0);\n}\n",
        "linevul": 5.237714503891766e-05,
        "sysevr": 0.12844739854335785,
        "devign": 0.18073558807373047
    },
    {
        "code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n {\n \tif (cache)\n\t\tmb_cache_destroy(cache);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
        "vul_func_with_fix": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n//fix_flaw_line_below:\n//void ext4_xattr_destroy_cache(struct mb2_cache *cache)\n {\n \tif (cache)\n//flaw_line_below:\n\t\tmb_cache_destroy(cache);\n//fix_flaw_line_below:\n//\t\tmb2_cache_destroy(cache);\n }\n",
        "linevul": 0.012727991677820683,
        "sysevr": 0.15841329097747803,
        "devign": 0.9663456678390503
    },
    {
        "code": "static const struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\tstruct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry(dynid, &hdrv->dyn_list, list) {\n\t\tif (hid_match_one_id(hdev, &dynid->id)) {\n\t\t\tspin_unlock(&hdrv->dyn_lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n\n\treturn hid_match_id(hdev, hdrv->id_table);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/50220dead1650609206efe91f0cc116132d59b3f",
        "vul_func_with_fix": "static const struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\tstruct hid_driver *hdrv)\n{\n\tstruct hid_dynid *dynid;\n\n\tspin_lock(&hdrv->dyn_lock);\n\tlist_for_each_entry(dynid, &hdrv->dyn_list, list) {\n\t\tif (hid_match_one_id(hdev, &dynid->id)) {\n\t\t\tspin_unlock(&hdrv->dyn_lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&hdrv->dyn_lock);\n\n\treturn hid_match_id(hdev, hdrv->id_table);\n}\n",
        "linevul": 0.00020168568880762905,
        "sysevr": 0.12814214825630188,
        "devign": 1.9054868971579708e-05
    },
    {
        "code": "static void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n",
        "linevul": 4.898888437310234e-05,
        "sysevr": 0.1307472586631775,
        "devign": 3.419964589301827e-10
    },
    {
        "code": "int security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2172fa709ab32ca60e86179dc67d0857be8e2c98",
        "vul_func_with_fix": "int security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n",
        "linevul": 9.394106746185571e-05,
        "sysevr": 0.22141849994659424,
        "devign": 2.6312834289915488e-12
    },
    {
        "code": "static __init int ftrace_init_dyn_debugfs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"available_filter_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_avail_fops);\n\n\ttrace_create_file(\"enabled_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_enabled_fops);\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, d_tracer,\n\t\t\tNULL, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, d_tracer,\n\t\t\t\t    NULL, &ftrace_notrace_fops);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\ttrace_create_file(\"set_graph_function\", 0444, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_fops);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6a76f8c0ab19f215af2a3442870eeb5f0e81998d",
        "vul_func_with_fix": "static __init int ftrace_init_dyn_debugfs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"available_filter_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_avail_fops);\n\n\ttrace_create_file(\"enabled_functions\", 0444,\n\t\t\td_tracer, NULL, &ftrace_enabled_fops);\n\n\ttrace_create_file(\"set_ftrace_filter\", 0644, d_tracer,\n\t\t\tNULL, &ftrace_filter_fops);\n\n\ttrace_create_file(\"set_ftrace_notrace\", 0644, d_tracer,\n\t\t\t\t    NULL, &ftrace_notrace_fops);\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\ttrace_create_file(\"set_graph_function\", 0444, d_tracer,\n\t\t\t\t    NULL,\n\t\t\t\t    &ftrace_graph_fops);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n\n\treturn 0;\n}\n",
        "linevul": 0.00012965567293576896,
        "sysevr": 0.11414668709039688,
        "devign": 0.5612607598304749
    },
    {
        "code": "static void catc_rx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *pkt_start = urb->transfer_buffer;\n\tstruct sk_buff *skb;\n\tint pkt_len, pkt_offset = 0;\n\tint status = urb->status;\n\n\tif (!catc->is_f5u011) {\n\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\tpkt_offset = 2;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"rx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif(!catc->is_f5u011) {\n\t\t\tpkt_len = le16_to_cpup((__le16*)pkt_start);\n\t\t\tif (pkt_len > urb->actual_length) {\n\t\t\t\tcatc->netdev->stats.rx_length_errors++;\n\t\t\t\tcatc->netdev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpkt_len = urb->actual_length;\n\t\t}\n\n\t\tif (!(skb = dev_alloc_skb(pkt_len)))\n\t\t\treturn;\n\n\t\tskb_copy_to_linear_data(skb, pkt_start + pkt_offset, pkt_len);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->protocol = eth_type_trans(skb, catc->netdev);\n\t\tnetif_rx(skb);\n\n\t\tcatc->netdev->stats.rx_packets++;\n\t\tcatc->netdev->stats.rx_bytes += pkt_len;\n\n\t\t/* F5U011 only does one packet per RX */\n\t\tif (catc->is_f5u011)\n\t\t\tbreak;\n\t\tpkt_start += (((pkt_len + 1) >> 6) + 1) << 6;\n\n\t} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);\n\n\tif (catc->is_f5u011) {\n\t\tif (atomic_read(&catc->recq_sz)) {\n\t\t\tint state;\n\t\t\tatomic_dec(&catc->recq_sz);\n\t\t\tnetdev_dbg(catc->netdev, \"getting extra packet\\n\");\n\t\t\turb->dev = catc->usbdev;\n\t\t\tif ((state = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t\t   \"submit(rx_urb) status %d\\n\", state);\n\t\t\t}\n\t\t} else {\n\t\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2d6a0e9de03ee658a9adc3bfb2f0ca55dff1e478",
        "vul_func_with_fix": "static void catc_rx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *pkt_start = urb->transfer_buffer;\n\tstruct sk_buff *skb;\n\tint pkt_len, pkt_offset = 0;\n\tint status = urb->status;\n\n\tif (!catc->is_f5u011) {\n\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\tpkt_offset = 2;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"rx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif(!catc->is_f5u011) {\n\t\t\tpkt_len = le16_to_cpup((__le16*)pkt_start);\n\t\t\tif (pkt_len > urb->actual_length) {\n\t\t\t\tcatc->netdev->stats.rx_length_errors++;\n\t\t\t\tcatc->netdev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpkt_len = urb->actual_length;\n\t\t}\n\n\t\tif (!(skb = dev_alloc_skb(pkt_len)))\n\t\t\treturn;\n\n\t\tskb_copy_to_linear_data(skb, pkt_start + pkt_offset, pkt_len);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->protocol = eth_type_trans(skb, catc->netdev);\n\t\tnetif_rx(skb);\n\n\t\tcatc->netdev->stats.rx_packets++;\n\t\tcatc->netdev->stats.rx_bytes += pkt_len;\n\n\t\t/* F5U011 only does one packet per RX */\n\t\tif (catc->is_f5u011)\n\t\t\tbreak;\n\t\tpkt_start += (((pkt_len + 1) >> 6) + 1) << 6;\n\n\t} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);\n\n\tif (catc->is_f5u011) {\n\t\tif (atomic_read(&catc->recq_sz)) {\n\t\t\tint state;\n\t\t\tatomic_dec(&catc->recq_sz);\n\t\t\tnetdev_dbg(catc->netdev, \"getting extra packet\\n\");\n\t\t\turb->dev = catc->usbdev;\n\t\t\tif ((state = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t\t   \"submit(rx_urb) status %d\\n\", state);\n\t\t\t}\n\t\t} else {\n\t\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\t}\n\t}\n}\n",
        "linevul": 6.545639917021617e-05,
        "sysevr": 0.13348232209682465,
        "devign": 3.7963326321758656e-27
    },
    {
        "code": "_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/eb178619f930fa2ba2348de332a1ff1c66a31424",
        "vul_func_with_fix": "_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n//fix_flaw_line_below:\n//\txfs_daddr_t\t\teofs;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n//fix_flaw_line_below:\n//\t/*\n//fix_flaw_line_below:\n//\t * Corrupted block numbers can get through to here, unfortunately, so we\n//fix_flaw_line_below:\n//\t * have to check that the buffer falls within the filesystem bounds.\n//fix_flaw_line_below:\n//\t */\n//fix_flaw_line_below:\n//\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n//fix_flaw_line_below:\n//\tif (blkno >= eofs) {\n//fix_flaw_line_below:\n//\t\t/*\n//fix_flaw_line_below:\n//\t\t * XXX (dgc): we should really be returning EFSCORRUPTED here,\n//fix_flaw_line_below:\n//\t\t * but none of the higher level infrastructure supports\n//fix_flaw_line_below:\n//\t\t * returning a specific error on buffer lookup failures.\n//fix_flaw_line_below:\n//\t\t */\n//fix_flaw_line_below:\n//\t\txfs_alert(btp->bt_mount,\n//fix_flaw_line_below:\n//\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n//fix_flaw_line_below:\n//\t\t\t  __func__, blkno, eofs);\n//fix_flaw_line_below:\n//\t\treturn NULL;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \t/* get tree root */\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}\n",
        "linevul": 0.9983104467391968,
        "sysevr": 0.2863713502883911,
        "devign": 0.9775218963623047
    },
    {
        "code": "static inline unsigned long kvm_read_tr_base(void)\n{\n\tu16 tr;\n\tasm(\"str %0\" : \"=g\"(tr));\n\treturn segment_base(tr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static inline unsigned long kvm_read_tr_base(void)\n{\n\tu16 tr;\n\tasm(\"str %0\" : \"=g\"(tr));\n\treturn segment_base(tr);\n}\n",
        "linevul": 6.701545498799533e-05,
        "sysevr": 0.12894529104232788,
        "devign": 2.9401388701444375e-07
    },
    {
        "code": "static struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0143fc5e9f6f5aad4764801015bc8d4b4a278200",
        "vul_func_with_fix": "static struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}\n",
        "linevul": 0.0001488498382968828,
        "sysevr": 0.1271362006664276,
        "devign": 1.1140476562088164e-11
    },
    {
        "code": "static int decode_read(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs_readres *res)\n{\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\t__be32 *p;\n\tuint32_t count, eof, recvd, hdrlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READ);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\teof = be32_to_cpup(p++);\n\tcount = be32_to_cpup(p);\n\thdrlen = (u8 *) xdr->p - (u8 *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (count > recvd) {\n\t\tdprintk(\"NFS: server cheating in read reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", count, recvd);\n\t\tcount = recvd;\n\t\teof = 0;\n\t}\n\txdr_read_pages(xdr, count);\n\tres->eof = eof;\n\tres->count = count;\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int decode_read(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs_readres *res)\n{\n\tstruct kvec *iov = req->rq_rcv_buf.head;\n\t__be32 *p;\n\tuint32_t count, eof, recvd, hdrlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_READ);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\teof = be32_to_cpup(p++);\n\tcount = be32_to_cpup(p);\n\thdrlen = (u8 *) xdr->p - (u8 *) iov->iov_base;\n\trecvd = req->rq_rcv_buf.len - hdrlen;\n\tif (count > recvd) {\n\t\tdprintk(\"NFS: server cheating in read reply: \"\n\t\t\t\t\"count %u > recvd %u\\n\", count, recvd);\n\t\tcount = recvd;\n\t\teof = 0;\n\t}\n\txdr_read_pages(xdr, count);\n\tres->eof = eof;\n\tres->count = count;\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n",
        "linevul": 8.086879824986681e-05,
        "sysevr": 0.1779402643442154,
        "devign": 6.660058111561049e-14
    },
    {
        "code": "armpmu_reserve_hardware(struct arm_pmu *armpmu)\n{\n\tint err;\n\tstruct platform_device *pmu_device = armpmu->plat_device;\n\n\tif (!pmu_device)\n\t\treturn -ENODEV;\n\n\tpm_runtime_get_sync(&pmu_device->dev);\n\terr = armpmu->request_irq(armpmu, armpmu_dispatch_irq);\n\tif (err) {\n\t\tarmpmu_release_hardware(armpmu);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c95eb3184ea1a3a2551df57190c81da695e2144b",
        "vul_func_with_fix": "armpmu_reserve_hardware(struct arm_pmu *armpmu)\n{\n\tint err;\n\tstruct platform_device *pmu_device = armpmu->plat_device;\n\n\tif (!pmu_device)\n\t\treturn -ENODEV;\n\n\tpm_runtime_get_sync(&pmu_device->dev);\n\terr = armpmu->request_irq(armpmu, armpmu_dispatch_irq);\n\tif (err) {\n\t\tarmpmu_release_hardware(armpmu);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 4.594980418914929e-05,
        "sysevr": 0.16414158046245575,
        "devign": 2.838979153488557e-17
    },
    {
        "code": "static __be32 *xdr_check_read_list(__be32 *p, __be32 *end)\n{\n\t__be32 *next;\n\n\twhile (*p++ != xdr_zero) {\n\t\tnext = p + rpcrdma_readchunk_maxsz - 1;\n\t\tif (next > end)\n\t\t\treturn NULL;\n\t\tp = next;\n\t}\n\treturn p;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static __be32 *xdr_check_read_list(__be32 *p, __be32 *end)\n{\n\t__be32 *next;\n\n\twhile (*p++ != xdr_zero) {\n\t\tnext = p + rpcrdma_readchunk_maxsz - 1;\n\t\tif (next > end)\n\t\t\treturn NULL;\n\t\tp = next;\n\t}\n\treturn p;\n}\n",
        "linevul": 0.00010131777526112273,
        "sysevr": 0.1308714747428894,
        "devign": 9.339822345426699e-15
    },
    {
        "code": " static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n {\n \tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \n\t/* Assignment of RIP may only fail in 64-bit mode */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n \tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n \n \trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n \trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\t/* assigning eip failed; restore the old cs */\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n \treturn rc;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/2117d5398c81554fbf803f5fd1dc55eb78216c0c",
        "vul_func_with_fix": " static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n {\n \tint rc;\n//flaw_line_below:\n\tunsigned short sel, old_sel;\n//flaw_line_below:\n\tstruct desc_struct old_desc, new_desc;\n//flaw_line_below:\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n//fix_flaw_line_below:\n//\tunsigned short sel;\n//fix_flaw_line_below:\n//\tstruct desc_struct new_desc;\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \n//flaw_line_below:\n\t/* Assignment of RIP may only fail in 64-bit mode */\n//flaw_line_below:\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n//flaw_line_below:\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n//flaw_line_below:\n\t\t\t\t VCPU_SREG_CS);\n//flaw_line_below:\n\n \tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n \n \trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n \trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n//flaw_line_below:\n\tif (rc != X86EMUL_CONTINUE) {\n//flaw_line_below:\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n//flaw_line_below:\n\t\t/* assigning eip failed; restore the old cs */\n//flaw_line_below:\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n//flaw_line_below:\n\t\treturn rc;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\t/* Error handling is not implemented. */\n//fix_flaw_line_below:\n//\tif (rc != X86EMUL_CONTINUE)\n//fix_flaw_line_below:\n//\t\treturn X86EMUL_UNHANDLEABLE;\n//fix_flaw_line_below:\n//\n \treturn rc;\n }\n",
        "linevul": 0.9995111227035522,
        "sysevr": 0.12960931658744812,
        "devign": 0.0
    },
    {
        "code": "static void tty_vhangup_session(struct tty_struct *tty)\n{\n\ttty_debug_hangup(tty, \"session hangup\\n\");\n\t__tty_hangup(tty, 1);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5c17c861a357e9458001f021a7afa7aab9937439",
        "vul_func_with_fix": "static void tty_vhangup_session(struct tty_struct *tty)\n{\n\ttty_debug_hangup(tty, \"session hangup\\n\");\n\t__tty_hangup(tty, 1);\n}\n",
        "linevul": 4.7723864554427564e-05,
        "sysevr": 0.12740196287631989,
        "devign": 2.23050065528696e-07
    },
    {
        "code": "static int set_user_buf_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    struct mlx5_ib_create_qp *ucmd,\n\t\t\t    struct mlx5_ib_qp_base *base,\n\t\t\t    struct ib_qp_init_attr *attr)\n{\n\tint desc_sz = 1 << qp->sq.wqe_shift;\n\n\tif (desc_sz > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_warn(dev, \"desc_sz %d, max_sq_desc_sz %d\\n\",\n\t\t\t     desc_sz, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucmd->sq_wqe_count && ((1 << ilog2(ucmd->sq_wqe_count)) != ucmd->sq_wqe_count)) {\n\t\tmlx5_ib_warn(dev, \"sq_wqe_count %d, sq_wqe_count %d\\n\",\n\t\t\t     ucmd->sq_wqe_count, ucmd->sq_wqe_count);\n\t\treturn -EINVAL;\n\t}\n\n\tqp->sq.wqe_cnt = ucmd->sq_wqe_count;\n\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_warn(dev, \"wqe_cnt %d, max_wqes %d\\n\",\n\t\t\t     qp->sq.wqe_cnt,\n\t\t\t     1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tbase->ubuffer.buf_size = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_size = qp->sq.wqe_cnt << 6;\n\t} else {\n\t\tbase->ubuffer.buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t\t\t\t (qp->sq.wqe_cnt << 6);\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00",
        "vul_func_with_fix": "static int set_user_buf_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    struct mlx5_ib_create_qp *ucmd,\n\t\t\t    struct mlx5_ib_qp_base *base,\n\t\t\t    struct ib_qp_init_attr *attr)\n{\n\tint desc_sz = 1 << qp->sq.wqe_shift;\n\n\tif (desc_sz > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_warn(dev, \"desc_sz %d, max_sq_desc_sz %d\\n\",\n\t\t\t     desc_sz, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucmd->sq_wqe_count && ((1 << ilog2(ucmd->sq_wqe_count)) != ucmd->sq_wqe_count)) {\n\t\tmlx5_ib_warn(dev, \"sq_wqe_count %d, sq_wqe_count %d\\n\",\n\t\t\t     ucmd->sq_wqe_count, ucmd->sq_wqe_count);\n\t\treturn -EINVAL;\n\t}\n\n\tqp->sq.wqe_cnt = ucmd->sq_wqe_count;\n\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_warn(dev, \"wqe_cnt %d, max_wqes %d\\n\",\n\t\t\t     qp->sq.wqe_cnt,\n\t\t\t     1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & MLX5_IB_QP_UNDERLAY) {\n\t\tbase->ubuffer.buf_size = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_size = qp->sq.wqe_cnt << 6;\n\t} else {\n\t\tbase->ubuffer.buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t\t\t\t (qp->sq.wqe_cnt << 6);\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 5.3953011956764385e-05,
        "sysevr": 0.14586327970027924,
        "devign": 1.0588041371639392e-23
    },
    {
        "code": "static inline int cap_inh_is_capped(void)\n{\n\n\t/* they are so limited unless the current task has the CAP_SETPCAP\n\t * capability\n\t */\n\tif (cap_capable(current_cred(), current_cred()->user->user_ns,\n\t\t\tCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\n\t\treturn 0;\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d52fc5dde171f030170a6cb78034d166b13c9445",
        "vul_func_with_fix": "static inline int cap_inh_is_capped(void)\n{\n\n\t/* they are so limited unless the current task has the CAP_SETPCAP\n\t * capability\n\t */\n\tif (cap_capable(current_cred(), current_cred()->user->user_ns,\n\t\t\tCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\n\t\treturn 0;\n\treturn 1;\n}\n",
        "linevul": 5.500219049281441e-05,
        "sysevr": 0.13198161125183105,
        "devign": 4.533035280473996e-06
    },
    {
        "code": "static void sas_probe_devices(struct work_struct *work)\n {\n \tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n \n \t/* devices must be domain members before link recovery and probe */\n \tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d",
        "vul_func_with_fix": "static void sas_probe_devices(struct work_struct *work)\n//fix_flaw_line_below:\n//static void sas_probe_devices(struct asd_sas_port *port)\n {\n \tstruct domain_device *dev, *n;\n//flaw_line_below:\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n//flaw_line_below:\n\tstruct asd_sas_port *port = ev->port;\n//flaw_line_below:\n\n//flaw_line_below:\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n \n \t/* devices must be domain members before link recovery and probe */\n \tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}\n",
        "linevul": 0.9995461106300354,
        "sysevr": 0.12531529366970062,
        "devign": 0.9996886253356934
    },
    {
        "code": "static void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\tint sndmem = SKB_TRUESIZE(max_t(u32,\n\t\t\t\t\t\ttp->rx_opt.mss_clamp,\n\t\t\t\t\t\ttp->mss_cache) +\n\t\t\t\t\t  MAX_TCP_HEADER);\n\t\tint demanded = max_t(unsigned int, tp->snd_cwnd,\n\t\t\t\t     tp->reordering + 1);\n\t\tsndmem *= 2 * demanded;\n\t\tif (sndmem > sk->sk_sndbuf)\n\t\t\tsk->sk_sndbuf = min(sndmem, sysctl_tcp_wmem[2]);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\n\tsk->sk_write_space(sk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fdf5af0daf8019cec2396cdef8fb042d80fe71fa",
        "vul_func_with_fix": "static void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\tint sndmem = SKB_TRUESIZE(max_t(u32,\n\t\t\t\t\t\ttp->rx_opt.mss_clamp,\n\t\t\t\t\t\ttp->mss_cache) +\n\t\t\t\t\t  MAX_TCP_HEADER);\n\t\tint demanded = max_t(unsigned int, tp->snd_cwnd,\n\t\t\t\t     tp->reordering + 1);\n\t\tsndmem *= 2 * demanded;\n\t\tif (sndmem > sk->sk_sndbuf)\n\t\t\tsk->sk_sndbuf = min(sndmem, sysctl_tcp_wmem[2]);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\n\tsk->sk_write_space(sk);\n}\n",
        "linevul": 7.759586878819391e-05,
        "sysevr": 0.14305059611797333,
        "devign": 0.0
    },
    {
        "code": "static int roland_load_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_usb_midi *umidi = kcontrol->private_data;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&umidi->mutex);\n\tchanged = value->value.enumerated.item[0] != kcontrol->private_value;\n\tif (changed)\n\t\tkcontrol->private_value = value->value.enumerated.item[0];\n\tmutex_unlock(&umidi->mutex);\n\treturn changed;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/07d86ca93db7e5cdf4743564d98292042ec21af7",
        "vul_func_with_fix": "static int roland_load_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *value)\n{\n\tstruct snd_usb_midi *umidi = kcontrol->private_data;\n\tint changed;\n\n\tif (value->value.enumerated.item[0] > 1)\n\t\treturn -EINVAL;\n\tmutex_lock(&umidi->mutex);\n\tchanged = value->value.enumerated.item[0] != kcontrol->private_value;\n\tif (changed)\n\t\tkcontrol->private_value = value->value.enumerated.item[0];\n\tmutex_unlock(&umidi->mutex);\n\treturn changed;\n}\n",
        "linevul": 5.6636083172634244e-05,
        "sysevr": 0.13312776386737823,
        "devign": 1.8887277519752388e-07
    },
    {
        "code": "int wvlan_uil(struct uilreq *urq, struct wl_private *lp)\n{\n\tint ioctl_ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\tDBG_FUNC(\"wvlan_uil\");\n\tDBG_ENTER(DbgInfo);\n\n\tswitch (urq->command) {\n\tcase UIL_FUN_CONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_CONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_connect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_DISCONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_DISCONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_disconnect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_ACTION:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\\n\");\n\t\tioctl_ret = wvlan_uil_action(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_SEND_DIAG_MSG:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_SEND_DIAG_MSG\\n\");\n\t\tioctl_ret = wvlan_uil_send_diag_msg(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_GET_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_GET_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_get_info(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_PUT_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_PUT_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_put_info(urq, lp);\n\t\tbreak;\n\tdefault:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X\", urq->command);\n\t\tioctl_ret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tDBG_LEAVE(DbgInfo);\n\treturn ioctl_ret;\n} /* wvlan_uil */\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054",
        "vul_func_with_fix": "int wvlan_uil(struct uilreq *urq, struct wl_private *lp)\n{\n\tint ioctl_ret = 0;\n\t/*------------------------------------------------------------------------*/\n\n\tDBG_FUNC(\"wvlan_uil\");\n\tDBG_ENTER(DbgInfo);\n\n\tswitch (urq->command) {\n\tcase UIL_FUN_CONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_CONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_connect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_DISCONNECT:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_DISCONNECT\\n\");\n\t\tioctl_ret = wvlan_uil_disconnect(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_ACTION:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_ACTION\\n\");\n\t\tioctl_ret = wvlan_uil_action(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_SEND_DIAG_MSG:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_SEND_DIAG_MSG\\n\");\n\t\tioctl_ret = wvlan_uil_send_diag_msg(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_GET_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_GET_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_get_info(urq, lp);\n\t\tbreak;\n\tcase UIL_FUN_PUT_INFO:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- WVLAN2_UIL_PUT_INFO\\n\");\n\t\tioctl_ret = wvlan_uil_put_info(urq, lp);\n\t\tbreak;\n\tdefault:\n\t\tDBG_TRACE(DbgInfo, \"IOCTL: WVLAN2_IOCTL_UIL -- UNSUPPORTED UIL CODE: 0x%X\", urq->command);\n\t\tioctl_ret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tDBG_LEAVE(DbgInfo);\n\treturn ioctl_ret;\n} /* wvlan_uil */\n",
        "linevul": 4.926162728224881e-05,
        "sysevr": 0.2053416520357132,
        "devign": 1.2856310947974002e-18
    },
    {
        "code": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n \n no_journal:\n \tif (ext4_mballoc_ready) {\n\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n \t\tif (!sbi->s_mb_cache) {\n \t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n \t\t\tgoto failed_mount_wq;\n\t\t}\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_CACHE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n \tif (EXT4_SB(sb)->rsv_conversion_wq)\n \t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\n failed_mount_wq:\n \tif (sbi->s_journal) {\n \t\tjbd2_journal_destroy(sbi->s_journal);\n \t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
        "vul_func_with_fix": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n \n no_journal:\n \tif (ext4_mballoc_ready) {\n//flaw_line_below:\n\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n//fix_flaw_line_below:\n//\t\tsbi->s_mb_cache = ext4_xattr_create_cache();\n \t\tif (!sbi->s_mb_cache) {\n \t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n \t\t\tgoto failed_mount_wq;\n\t\t}\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_CACHE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n \tif (EXT4_SB(sb)->rsv_conversion_wq)\n \t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\n failed_mount_wq:\n//fix_flaw_line_below:\n//\tif (sbi->s_mb_cache) {\n//fix_flaw_line_below:\n//\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n//fix_flaw_line_below:\n//\t\tsbi->s_mb_cache = NULL;\n//fix_flaw_line_below:\n//\t}\n \tif (sbi->s_journal) {\n \t\tjbd2_journal_destroy(sbi->s_journal);\n \t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n",
        "linevul": 0.04533287510275841,
        "sysevr": 0.4102763235569,
        "devign": 9.556435711401028e-20
    },
    {
        "code": "static void gcm_encrypt_done(struct crypto_async_request *areq, int err)\n{\n\tstruct aead_request *req = areq->data;\n\tstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\n\n\tif (!err) {\n\t\terr = gcm_hash(req, pctx);\n\t\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\t\treturn;\n\t\telse if (!err) {\n\t\t\tcrypto_xor(pctx->auth_tag, pctx->iauth_tag, 16);\n\t\t\tgcm_enc_copy_hash(req, pctx);\n\t\t}\n\t}\n\n\taead_request_complete(req, err);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "static void gcm_encrypt_done(struct crypto_async_request *areq, int err)\n{\n\tstruct aead_request *req = areq->data;\n\tstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\n\n\tif (!err) {\n\t\terr = gcm_hash(req, pctx);\n\t\tif (err == -EINPROGRESS || err == -EBUSY)\n\t\t\treturn;\n\t\telse if (!err) {\n\t\t\tcrypto_xor(pctx->auth_tag, pctx->iauth_tag, 16);\n\t\t\tgcm_enc_copy_hash(req, pctx);\n\t\t}\n\t}\n\n\taead_request_complete(req, err);\n}\n",
        "linevul": 4.916016769129783e-05,
        "sysevr": 0.12292952090501785,
        "devign": 6.929256812782114e-08
    },
    {
        "code": "struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tstruct hlist_head *head = dev_index_hash(net, ifindex);\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist)\n\t\tif (dev->ifindex == ifindex)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
        "vul_func_with_fix": "struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tstruct hlist_head *head = dev_index_hash(net, ifindex);\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist)\n\t\tif (dev->ifindex == ifindex)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n",
        "linevul": 4.958399949828163e-05,
        "sysevr": 0.13178184628486633,
        "devign": 0.0009561280603520572
    },
    {
        "code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n {\n \tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n \t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n \t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n \t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n \t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n \t}\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4",
        "vul_func_with_fix": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n//fix_flaw_line_below:\n//static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n {\n//flaw_line_below:\n\n//fix_flaw_line_below:\n//\tif (sta_id >= IWLAGN_STATION_COUNT) {\n//fix_flaw_line_below:\n//\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\t}\n \tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n \t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n \t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n \t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n \t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n \t}\n//fix_flaw_line_below:\n//\treturn 0;\n }\n",
        "linevul": 0.9987602233886719,
        "sysevr": 0.1266596019268036,
        "devign": 1.0285872464833182e-16
    },
    {
        "code": "static inline struct msg_queue *msg_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&msg_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn (struct msg_queue *)ipcp;\n\n\treturn container_of(ipcp, struct msg_queue, q_perm);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": "static inline struct msg_queue *msg_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&msg_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn (struct msg_queue *)ipcp;\n\n\treturn container_of(ipcp, struct msg_queue, q_perm);\n}\n",
        "linevul": 0.00010184240090893582,
        "sysevr": 0.12712055444717407,
        "devign": 0.0001374074345221743
    },
    {
        "code": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n \t\t\t\tgoto err;\n \t\t\t}\n \n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "vul_func_with_fix": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n//fix_flaw_line_below:\n//\tstruct sk_buff *frag_skb = head_skb;\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n//fix_flaw_line_below:\n//\t\t\tfrag_skb = list_skb;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n//fix_flaw_line_below:\n//\t\t\t\tfrag_skb = list_skb;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n \t\t\t\tgoto err;\n \t\t\t}\n \n//fix_flaw_line_below:\n//\t\t\tif (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))\n//fix_flaw_line_below:\n//\t\t\t\tgoto err;\n//fix_flaw_line_below:\n//\n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}\n",
        "linevul": 0.9993364214897156,
        "sysevr": 0.36605095863342285,
        "devign": 0.0013402284821495414
    },
    {
        "code": "static void ppp_destroy_channel(struct channel *pch)\n{\n\tatomic_dec(&channel_count);\n\n\tif (!pch->file.dead) {\n\t\t/* \"can't happen\" */\n\t\tpr_err(\"ppp: destroying undead channel %p !\\n\", pch);\n\t\treturn;\n\t}\n\tskb_queue_purge(&pch->file.xq);\n\tskb_queue_purge(&pch->file.rq);\n\tkfree(pch);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "vul_func_with_fix": "static void ppp_destroy_channel(struct channel *pch)\n{\n\tatomic_dec(&channel_count);\n\n\tif (!pch->file.dead) {\n\t\t/* \"can't happen\" */\n\t\tpr_err(\"ppp: destroying undead channel %p !\\n\", pch);\n\t\treturn;\n\t}\n\tskb_queue_purge(&pch->file.xq);\n\tskb_queue_purge(&pch->file.rq);\n\tkfree(pch);\n}\n",
        "linevul": 6.222067167982459e-05,
        "sysevr": 0.12677086889743805,
        "devign": 4.427115527505521e-06
    },
    {
        "code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n \t\t\t\t\t    params->beacon.tail_len);\n \tif (vendor_ie) {\n \t\twmm_ie = vendor_ie;\n \t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n \t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n \t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3",
        "vul_func_with_fix": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n \t\t\t\t\t    params->beacon.tail_len);\n \tif (vendor_ie) {\n \t\twmm_ie = vendor_ie;\n//fix_flaw_line_below:\n//\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n//fix_flaw_line_below:\n//\t\t\treturn;\n \t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n \t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n \t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}\n",
        "linevul": 0.9988454580307007,
        "sysevr": 0.18648551404476166,
        "devign": 0.9866107106208801
    },
    {
        "code": "void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac;\n\tunsigned long flags;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\n\tif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n \n \tskb_queue_head_init(&pending);\n \n \t/* Send all buffered frames to the station */\n \tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n \t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n \t}\n \n \tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n \n \t/* This station just woke up and isn't aware of our SMPS state */\n \tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,\n\t\t\t\t\t   sdata->smps_mode) &&\n\t    sta->known_smps_mode != sdata->bss->req_smps &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sdata,\n\t\t       \"%pM just woke up and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sdata, sdata->bss->req_smps,\n\t\t\t\t\t   sta->sta.addr,\n\t\t\t\t\t   sdata->vif.bss_conf.bssid);\n\t}\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba",
        "vul_func_with_fix": "void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac;\n\tunsigned long flags;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\n\tif (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n \n \tskb_queue_head_init(&pending);\n \n//fix_flaw_line_below:\n//\t/* sync with ieee80211_tx_h_unicast_ps_buf */\n//fix_flaw_line_below:\n//\tspin_lock(&sta->ps_lock);\n \t/* Send all buffered frames to the station */\n \tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n \t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n \t}\n \n \tieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);\n//fix_flaw_line_below:\n//\tspin_unlock(&sta->ps_lock);\n \n \t/* This station just woke up and isn't aware of our SMPS state */\n \tif (!ieee80211_smps_is_restrictive(sta->known_smps_mode,\n\t\t\t\t\t   sdata->smps_mode) &&\n\t    sta->known_smps_mode != sdata->bss->req_smps &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sdata,\n\t\t       \"%pM just woke up and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sdata, sdata->bss->req_smps,\n\t\t\t\t\t   sta->sta.addr,\n\t\t\t\t\t   sdata->vif.bss_conf.bssid);\n\t}\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n}\n",
        "linevul": 0.9996401071548462,
        "sysevr": 0.21488741040229797,
        "devign": 0.9993634819984436
    },
    {
        "code": "int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ab79efab0a0ba01a74df782eb7fa44b044dae8b5",
        "vul_func_with_fix": "int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n{\n\tssize_t list_size, size;\n\tchar *buf, *name, *value;\n\tint error;\n\n\tif (!old->d_inode->i_op->getxattr ||\n\t    !new->d_inode->i_op->getxattr)\n\t\treturn 0;\n\n\tlist_size = vfs_listxattr(old, NULL, 0);\n\tif (list_size <= 0) {\n\t\tif (list_size == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn list_size;\n\t}\n\n\tbuf = kzalloc(list_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = -ENOMEM;\n\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n\tif (!value)\n\t\tgoto out;\n\n\tlist_size = vfs_listxattr(old, buf, list_size);\n\tif (list_size <= 0) {\n\t\terror = list_size;\n\t\tgoto out_free_value;\n\t}\n\n\tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n\t\tif (size <= 0) {\n\t\t\terror = size;\n\t\t\tgoto out_free_value;\n\t\t}\n\t\terror = vfs_setxattr(new, name, value, size, 0);\n\t\tif (error)\n\t\t\tgoto out_free_value;\n\t}\n\nout_free_value:\n\tkfree(value);\nout:\n\tkfree(buf);\n\treturn error;\n}\n",
        "linevul": 0.00010415252472739667,
        "sysevr": 0.1775074303150177,
        "devign": 2.847060377200955e-16
    },
    {
        "code": "static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(connect.auth_type))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tconnect.channel =\n\t\t\tieee80211_get_channel(wiphy,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\t\tif (!connect.channel ||\n\t\t    connect.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
        "vul_func_with_fix": "static int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(connect.auth_type))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tconnect.channel =\n\t\t\tieee80211_get_channel(wiphy,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\t\tif (!connect.channel ||\n\t\t    connect.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n",
        "linevul": 6.444122118409723e-05,
        "sysevr": 0.16715115308761597,
        "devign": 9.283238119517216e-30
    },
    {
        "code": "static int nfs4_proc_lookupfh(struct nfs_server *server, struct nfs_fh *dirfh,\n\t\t\t      struct qstr *name, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookupfh(server, dirfh, name, fhandle, fattr);\n\t\t/* FIXME: !!!! */\n\t\tif (err == -NFS4ERR_MOVED) {\n\t\t\terr = -EREMOTE;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int nfs4_proc_lookupfh(struct nfs_server *server, struct nfs_fh *dirfh,\n\t\t\t      struct qstr *name, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fattr *fattr)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookupfh(server, dirfh, name, fhandle, fattr);\n\t\t/* FIXME: !!!! */\n\t\tif (err == -NFS4ERR_MOVED) {\n\t\t\terr = -EREMOTE;\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "linevul": 5.301144119584933e-05,
        "sysevr": 0.1427442580461502,
        "devign": 1.1559823194159935e-12
    },
    {
        "code": "static int relink_is_mergable(struct extent_buffer *leaf,\n\t\t\t      struct btrfs_file_extent_item *fi,\n\t\t\t      struct new_sa_defrag_extent *new)\n{\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi) != new->bytenr)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_compression(leaf, fi) != new->compress_type)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7",
        "vul_func_with_fix": "static int relink_is_mergable(struct extent_buffer *leaf,\n\t\t\t      struct btrfs_file_extent_item *fi,\n\t\t\t      struct new_sa_defrag_extent *new)\n{\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi) != new->bytenr)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_compression(leaf, fi) != new->compress_type)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\treturn 1;\n}\n",
        "linevul": 6.471279630204663e-05,
        "sysevr": 0.12874916195869446,
        "devign": 1.0751439669109963e-11
    },
    {
        "code": "static int perf_rotate_context(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint rotate = 0, remove = 1;\n\n\tif (cpuctx->ctx.nr_events) {\n\t\tremove = 0;\n\t\tif (cpuctx->ctx.nr_events != cpuctx->ctx.nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tctx = cpuctx->task_ctx;\n\tif (ctx && ctx->nr_events) {\n\t\tremove = 0;\n\t\tif (ctx->nr_events != ctx->nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tif (!rotate)\n\t\tgoto done;\n\n\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tif (ctx)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);\n\n\trotate_ctx(&cpuctx->ctx);\n\tif (ctx)\n\t\trotate_ctx(ctx);\n\n\tperf_event_sched_in(cpuctx, ctx, current);\n\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\ndone:\n\tif (remove)\n\t\tlist_del_init(&cpuctx->rotation_list);\n\n\treturn rotate;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
        "vul_func_with_fix": "static int perf_rotate_context(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_event_context *ctx = NULL;\n\tint rotate = 0, remove = 1;\n\n\tif (cpuctx->ctx.nr_events) {\n\t\tremove = 0;\n\t\tif (cpuctx->ctx.nr_events != cpuctx->ctx.nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tctx = cpuctx->task_ctx;\n\tif (ctx && ctx->nr_events) {\n\t\tremove = 0;\n\t\tif (ctx->nr_events != ctx->nr_active)\n\t\t\trotate = 1;\n\t}\n\n\tif (!rotate)\n\t\tgoto done;\n\n\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\tif (ctx)\n\t\tctx_sched_out(ctx, cpuctx, EVENT_FLEXIBLE);\n\n\trotate_ctx(&cpuctx->ctx);\n\tif (ctx)\n\t\trotate_ctx(ctx);\n\n\tperf_event_sched_in(cpuctx, ctx, current);\n\n\tperf_pmu_enable(cpuctx->ctx.pmu);\n\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\ndone:\n\tif (remove)\n\t\tlist_del_init(&cpuctx->rotation_list);\n\n\treturn rotate;\n}\n",
        "linevul": 4.951936352881603e-05,
        "sysevr": 0.15633773803710938,
        "devign": 2.0473299187116222e-17
    },
    {
        "code": "fst_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tstruct fstioc_write wrthdr;\n\tstruct fstioc_info info;\n\tunsigned long flags;\n\tvoid *buf;\n\n\tdbg(DBG_IOCTL, \"ioctl: %x, %p\\n\", cmd, ifr->ifr_data);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FSTCPURESET:\n\t\tfst_cpureset(card);\n\t\tcard->state = FST_RESET;\n\t\treturn 0;\n\n\tcase FSTCPURELEASE:\n\t\tfst_cpurelease(card);\n\t\tcard->state = FST_STARTING;\n\t\treturn 0;\n\n\tcase FSTWRITE:\t\t/* Code write (download) */\n\n\t\t/* First copy in the header with the length and offset of data\n\t\t * to write\n\t\t */\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&wrthdr, ifr->ifr_data,\n\t\t\t\t   sizeof (struct fstioc_write))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* Sanity check the parameters. We don't support partial writes\n\t\t * when going over the top\n\t\t */\n\t\tif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\n\t\t    wrthdr.size + wrthdr.offset > FST_MEMSIZE) {\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t/* Now copy the data to the card. */\n\n\t\tbuf = memdup_user(ifr->ifr_data + sizeof(struct fstioc_write),\n\t\t\t\t  wrthdr.size);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\n\t\tkfree(buf);\n\n\t\t/* Writes to the memory of a card in the reset state constitute\n\t\t * a download\n\t\t */\n\t\tif (card->state == FST_RESET) {\n\t\t\tcard->state = FST_DOWNLOAD;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTGETCONF:\n\n\t\t/* If card has just been started check the shared memory config\n\t\t * version and marker\n\t\t */\n\t\tif (card->state == FST_STARTING) {\n\t\t\tcheck_started_ok(card);\n\n\t\t\t/* If everything checked out enable card interrupts */\n\t\t\tif (card->state == FST_RUNNING) {\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tfst_enable_intr(card);\n\t\t\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgather_conf_info(card, port, &info);\n\n\t\tif (copy_to_user(ifr->ifr_data, &info, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTSETCONF:\n\n\t\t/*\n\t\t * Most of the settings have been moved to the generic ioctls\n\t\t * this just covers debug and board ident now\n\t\t */\n\n\t\tif (card->state != FST_RUNNING) {\n\t\t\tpr_err(\"Attempt to configure card %d in non-running state (%d)\\n\",\n\t\t\t       card->card_no, card->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_from_user(&info, ifr->ifr_data, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treturn set_conf_from_info(card, port, &info);\n\n\tcase SIOCWANDEV:\n\t\tswitch (ifr->ifr_settings.type) {\n\t\tcase IF_GET_IFACE:\n\t\t\treturn fst_get_iface(card, port, ifr);\n\n\t\tcase IF_IFACE_SYNC_SERIAL:\n\t\tcase IF_IFACE_V35:\n\t\tcase IF_IFACE_V24:\n\t\tcase IF_IFACE_X21:\n\t\tcase IF_IFACE_X21D:\n\t\tcase IF_IFACE_T1:\n\t\tcase IF_IFACE_E1:\n\t\t\treturn fst_set_iface(card, port, ifr);\n\n\t\tcase IF_PROTO_RAW:\n\t\t\tport->mode = FST_RAW;\n\t\t\treturn 0;\n\n\t\tcase IF_GET_PROTO:\n\t\t\tif (port->mode == FST_RAW) {\n\t\t\t\tifr->ifr_settings.type = IF_PROTO_RAW;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\t\tdefault:\n\t\t\tport->mode = FST_GEN_HDLC;\n\t\t\tdbg(DBG_IOCTL, \"Passing this type to hdlc %x\\n\",\n\t\t\t    ifr->ifr_settings.type);\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t\t}\n\n\tdefault:\n\t\t/* Not one of ours. Pass through to HDLC package */\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/96b340406724d87e4621284ebac5e059d67b2194",
        "vul_func_with_fix": "fst_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tstruct fstioc_write wrthdr;\n\tstruct fstioc_info info;\n\tunsigned long flags;\n\tvoid *buf;\n\n\tdbg(DBG_IOCTL, \"ioctl: %x, %p\\n\", cmd, ifr->ifr_data);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FSTCPURESET:\n\t\tfst_cpureset(card);\n\t\tcard->state = FST_RESET;\n\t\treturn 0;\n\n\tcase FSTCPURELEASE:\n\t\tfst_cpurelease(card);\n\t\tcard->state = FST_STARTING;\n\t\treturn 0;\n\n\tcase FSTWRITE:\t\t/* Code write (download) */\n\n\t\t/* First copy in the header with the length and offset of data\n\t\t * to write\n\t\t */\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (copy_from_user(&wrthdr, ifr->ifr_data,\n\t\t\t\t   sizeof (struct fstioc_write))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* Sanity check the parameters. We don't support partial writes\n\t\t * when going over the top\n\t\t */\n\t\tif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\n\t\t    wrthdr.size + wrthdr.offset > FST_MEMSIZE) {\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t/* Now copy the data to the card. */\n\n\t\tbuf = memdup_user(ifr->ifr_data + sizeof(struct fstioc_write),\n\t\t\t\t  wrthdr.size);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\n\t\tkfree(buf);\n\n\t\t/* Writes to the memory of a card in the reset state constitute\n\t\t * a download\n\t\t */\n\t\tif (card->state == FST_RESET) {\n\t\t\tcard->state = FST_DOWNLOAD;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTGETCONF:\n\n\t\t/* If card has just been started check the shared memory config\n\t\t * version and marker\n\t\t */\n\t\tif (card->state == FST_STARTING) {\n\t\t\tcheck_started_ok(card);\n\n\t\t\t/* If everything checked out enable card interrupts */\n\t\t\tif (card->state == FST_RUNNING) {\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tfst_enable_intr(card);\n\t\t\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (ifr->ifr_data == NULL) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgather_conf_info(card, port, &info);\n\n\t\tif (copy_to_user(ifr->ifr_data, &info, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treturn 0;\n\n\tcase FSTSETCONF:\n\n\t\t/*\n\t\t * Most of the settings have been moved to the generic ioctls\n\t\t * this just covers debug and board ident now\n\t\t */\n\n\t\tif (card->state != FST_RUNNING) {\n\t\t\tpr_err(\"Attempt to configure card %d in non-running state (%d)\\n\",\n\t\t\t       card->card_no, card->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_from_user(&info, ifr->ifr_data, sizeof (info))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treturn set_conf_from_info(card, port, &info);\n\n\tcase SIOCWANDEV:\n\t\tswitch (ifr->ifr_settings.type) {\n\t\tcase IF_GET_IFACE:\n\t\t\treturn fst_get_iface(card, port, ifr);\n\n\t\tcase IF_IFACE_SYNC_SERIAL:\n\t\tcase IF_IFACE_V35:\n\t\tcase IF_IFACE_V24:\n\t\tcase IF_IFACE_X21:\n\t\tcase IF_IFACE_X21D:\n\t\tcase IF_IFACE_T1:\n\t\tcase IF_IFACE_E1:\n\t\t\treturn fst_set_iface(card, port, ifr);\n\n\t\tcase IF_PROTO_RAW:\n\t\t\tport->mode = FST_RAW;\n\t\t\treturn 0;\n\n\t\tcase IF_GET_PROTO:\n\t\t\tif (port->mode == FST_RAW) {\n\t\t\t\tifr->ifr_settings.type = IF_PROTO_RAW;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\t\tdefault:\n\t\t\tport->mode = FST_GEN_HDLC;\n\t\t\tdbg(DBG_IOCTL, \"Passing this type to hdlc %x\\n\",\n\t\t\t    ifr->ifr_settings.type);\n\t\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t\t}\n\n\tdefault:\n\t\t/* Not one of ours. Pass through to HDLC package */\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\t}\n}\n",
        "linevul": 5.269009852781892e-05,
        "sysevr": 0.31637948751449585,
        "devign": 0.0
    },
    {
        "code": "static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,\n\t\t\t\t struct buffer_head *exbh)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tint blocks = exbh->b_size >> inode->i_blkbits;\n\tsector_t pblock = exbh->b_blocknr, cur_logical;\n\tstruct buffer_head *head, *bh;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\n\tindex = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tend = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tcur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\t/* XXX: optimize tail */\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tindex = page->index;\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\t\t\tindex++;\n\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tBUG_ON(!page_has_buffers(page));\n\n\t\t\tbh = page_buffers(page);\n\t\t\thead = bh;\n\n\t\t\t/* skip blocks out of the range */\n\t\t\tdo {\n\t\t\t\tif (cur_logical >= logical)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_logical++;\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\t\tdo {\n\t\t\t\tif (cur_logical >= logical + blocks)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (buffer_delay(bh) ||\n\t\t\t\t\t\tbuffer_unwritten(bh)) {\n\n\t\t\t\t\tBUG_ON(bh->b_bdev != inode->i_sb->s_bdev);\n\n\t\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\t\tbh->b_blocknr = pblock;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * unwritten already should have\n\t\t\t\t\t\t * blocknr assigned. Verify that\n\t\t\t\t\t\t */\n\t\t\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n\t\t\t\t\t}\n\n \t\t\t\t} else if (buffer_mapped(bh))\n \t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n \n \t\t\t\tcur_logical++;\n \t\t\t\tpblock++;\n \t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
        "vul_func_with_fix": "static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,\n\t\t\t\t struct buffer_head *exbh)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tint blocks = exbh->b_size >> inode->i_blkbits;\n\tsector_t pblock = exbh->b_blocknr, cur_logical;\n\tstruct buffer_head *head, *bh;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\n\tindex = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tend = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tcur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\t/* XXX: optimize tail */\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tindex = page->index;\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\t\t\tindex++;\n\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tBUG_ON(!page_has_buffers(page));\n\n\t\t\tbh = page_buffers(page);\n\t\t\thead = bh;\n\n\t\t\t/* skip blocks out of the range */\n\t\t\tdo {\n\t\t\t\tif (cur_logical >= logical)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_logical++;\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\t\tdo {\n\t\t\t\tif (cur_logical >= logical + blocks)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (buffer_delay(bh) ||\n\t\t\t\t\t\tbuffer_unwritten(bh)) {\n\n\t\t\t\t\tBUG_ON(bh->b_bdev != inode->i_sb->s_bdev);\n\n\t\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\t\tbh->b_blocknr = pblock;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * unwritten already should have\n\t\t\t\t\t\t * blocknr assigned. Verify that\n\t\t\t\t\t\t */\n\t\t\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n\t\t\t\t\t}\n\n \t\t\t\t} else if (buffer_mapped(bh))\n \t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n \n//fix_flaw_line_below:\n//\t\t\t\tif (buffer_uninit(exbh))\n//fix_flaw_line_below:\n//\t\t\t\t\tset_buffer_uninit(bh);\n \t\t\t\tcur_logical++;\n \t\t\t\tpblock++;\n \t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n}\n",
        "linevul": 0.0013623309787362814,
        "sysevr": 0.15105168521404266,
        "devign": 1.5080893478458535e-10
    },
    {
        "code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n \tunsigned long inodes;\n \tint error = -EINVAL;\n \n \tif (shmem_parse_options(data, &config, true))\n \t\treturn error;\n \n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\t/*\n\t * Those tests disallow limited->unlimited while any are in use;\n\t * but we must separately disallow unlimited->limited, because\n\t * in that case we have no record of how much is already in use.\n\t */\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n \tsbinfo->max_inodes  = config.max_inodes;\n \tsbinfo->free_inodes = config.max_inodes - inodes;\n \n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t/* transfers initial ref */\n out:\n \tspin_unlock(&sbinfo->stat_lock);\n \treturn error;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n \tunsigned long inodes;\n \tint error = -EINVAL;\n \n//fix_flaw_line_below:\n//\tconfig.mpol = NULL;\n \tif (shmem_parse_options(data, &config, true))\n \t\treturn error;\n \n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\t/*\n\t * Those tests disallow limited->unlimited while any are in use;\n\t * but we must separately disallow unlimited->limited, because\n\t * in that case we have no record of how much is already in use.\n\t */\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n \tsbinfo->max_inodes  = config.max_inodes;\n \tsbinfo->free_inodes = config.max_inodes - inodes;\n \n//flaw_line_below:\n\tmpol_put(sbinfo->mpol);\n//flaw_line_below:\n\tsbinfo->mpol        = config.mpol;\t/* transfers initial ref */\n//fix_flaw_line_below:\n//\t/*\n//fix_flaw_line_below:\n//\t * Preserve previous mempolicy unless mpol remount option was specified.\n//fix_flaw_line_below:\n//\t */\n//fix_flaw_line_below:\n//\tif (config.mpol) {\n//fix_flaw_line_below:\n//\t\tmpol_put(sbinfo->mpol);\n//fix_flaw_line_below:\n//\t\tsbinfo->mpol = config.mpol;\t/* transfers initial ref */\n//fix_flaw_line_below:\n//\t}\n out:\n \tspin_unlock(&sbinfo->stat_lock);\n \treturn error;\n}\n",
        "linevul": 0.9996163845062256,
        "sysevr": 0.14485055208206177,
        "devign": 0.9862305521965027
    },
    {
        "code": "static struct scsi_disk *scsi_disk_get(struct gendisk *disk)\n{\n\tstruct scsi_disk *sdkp;\n\n\tmutex_lock(&sd_ref_mutex);\n\tsdkp = __scsi_disk_get(disk);\n\tmutex_unlock(&sd_ref_mutex);\n\treturn sdkp;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e",
        "vul_func_with_fix": "static struct scsi_disk *scsi_disk_get(struct gendisk *disk)\n{\n\tstruct scsi_disk *sdkp;\n\n\tmutex_lock(&sd_ref_mutex);\n\tsdkp = __scsi_disk_get(disk);\n\tmutex_unlock(&sd_ref_mutex);\n\treturn sdkp;\n}\n",
        "linevul": 5.671395774697885e-05,
        "sysevr": 0.1264001578092575,
        "devign": 9.430312388758466e-07
    },
    {
        "code": "static int handle_vmoff(struct kvm_vcpu *vcpu)\n{\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tfree_nested(to_vmx(vcpu));\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388",
        "vul_func_with_fix": "static int handle_vmoff(struct kvm_vcpu *vcpu)\n{\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tfree_nested(to_vmx(vcpu));\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n",
        "linevul": 4.892516153631732e-05,
        "sysevr": 0.1285083144903183,
        "devign": 6.791218976065494e-11
    },
    {
        "code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n\tio->io_cleanup = mem_cleanup;\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint memory regions in their ACPI\n\t * tables.  This causes problems when trying to request the\n\t * entire region.  Therefore we must request each register\n\t * separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the total amount of memory to claim.  This is an\n\t * unusual looking calculation, but it avoids claiming any\n\t * more memory than it has to.  It will claim everything\n\t * between the first address to the end of the last full\n\t * register.\n\t */\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n \treturn 0;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
        "vul_func_with_fix": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n//flaw_line_below:\n\tio->io_cleanup = mem_cleanup;\n//flaw_line_below:\n\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint memory regions in their ACPI\n\t * tables.  This causes problems when trying to request the\n\t * entire region.  Therefore we must request each register\n\t * separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the total amount of memory to claim.  This is an\n\t * unusual looking calculation, but it avoids claiming any\n\t * more memory than it has to.  It will claim everything\n\t * between the first address to the end of the last full\n\t * register.\n\t */\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tio->io_cleanup = mem_cleanup;\n//fix_flaw_line_below:\n//\n \treturn 0;\n }\n",
        "linevul": 0.9976750016212463,
        "sysevr": 0.271413117647171,
        "devign": 0.00011568468471523374
    },
    {
        "code": "int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb",
        "vul_func_with_fix": "int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 6.883621972519904e-05,
        "sysevr": 0.22760643064975739,
        "devign": 8.062859508705994e-16
    },
    {
        "code": "void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)\n{\n\tvq->last_avail_idx -= n;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bd97120fc3d1a11f3124c7c9ba1d91f51829eb85",
        "vul_func_with_fix": "void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)\n{\n\tvq->last_avail_idx -= n;\n}\n",
        "linevul": 5.745467569795437e-05,
        "sysevr": 0.15623308718204498,
        "devign": 3.3932236361000623e-12
    },
    {
        "code": "int sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t            rps_resp, RPS_RESP_SIZE);\n\n\t/* 0x34 is the FIS type for the D2H fis.  There's a potential\n\t * standards cockup here.  sas-2 explicitly specifies the FIS\n\t * should be encoded so that FIS type is in resp[24].\n\t * However, some expanders endian reverse this.  Undo the\n\t * reversal here */\n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4",
        "vul_func_with_fix": "int sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t            rps_resp, RPS_RESP_SIZE);\n\n\t/* 0x34 is the FIS type for the D2H fis.  There's a potential\n\t * standards cockup here.  sas-2 explicitly specifies the FIS\n\t * should be encoded so that FIS type is in resp[24].\n\t * However, some expanders endian reverse this.  Undo the\n\t * reversal here */\n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n",
        "linevul": 0.00019212673942092806,
        "sysevr": 0.3432016670703888,
        "devign": 4.0396838651979294e-10
    },
    {
        "code": "static u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388",
        "vul_func_with_fix": "static u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}\n",
        "linevul": 5.197961945668794e-05,
        "sysevr": 0.12988010048866272,
        "devign": 1.2541492727678796e-19
    },
    {
        "code": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n \t\t\t\t   xattr_value_len, calc.digest);\n \t\tif (rc)\n \t\t\tbreak;\n\t\trc = memcmp(xattr_data->digest, calc.digest,\n \t\t\t    sizeof(calc.digest));\n \t\tif (rc)\n \t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/613317bd212c585c20796c10afe5daaa95d4b0a1",
        "vul_func_with_fix": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n \t\t\t\t   xattr_value_len, calc.digest);\n \t\tif (rc)\n \t\t\tbreak;\n//flaw_line_below:\n\t\trc = memcmp(xattr_data->digest, calc.digest,\n//fix_flaw_line_below:\n//\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n \t\t\t    sizeof(calc.digest));\n \t\tif (rc)\n \t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}\n",
        "linevul": 0.00024192724958993495,
        "sysevr": 0.1412699669599533,
        "devign": 0.9999972581863403
    },
    {
        "code": "static void edge_send(struct usb_serial_port *port, struct tty_struct *tty)\n{\n\tint count, result;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_write_urb_in_use) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tcount = kfifo_out(&port->write_fifo,\n\t\t\t\tport->write_urb->transfer_buffer,\n\t\t\t\tport->bulk_out_size);\n\n\tif (count == 0) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tedge_port->ep_write_urb_in_use = 1;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tusb_serial_debug_data(&port->dev, __func__, count, port->write_urb->transfer_buffer);\n\n\t/* set up our urb */\n\tport->write_urb->transfer_buffer_length = count;\n\n\t/* send the data out the bulk port */\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err_console(port,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\tedge_port->ep_write_urb_in_use = 0;\n\t\t/* TODO: reschedule edge_send */\n\t} else\n\t\tedge_port->port->icount.tx += count;\n\n\t/*\n\t * wakeup any process waiting for writes to complete\n\t * there is now more room in the buffer for new writes\n\t */\n\tif (tty)\n\t\ttty_wakeup(tty);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e",
        "vul_func_with_fix": "static void edge_send(struct usb_serial_port *port, struct tty_struct *tty)\n{\n\tint count, result;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->ep_write_urb_in_use) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tcount = kfifo_out(&port->write_fifo,\n\t\t\t\tport->write_urb->transfer_buffer,\n\t\t\t\tport->bulk_out_size);\n\n\tif (count == 0) {\n\t\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\t\treturn;\n\t}\n\n\tedge_port->ep_write_urb_in_use = 1;\n\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tusb_serial_debug_data(&port->dev, __func__, count, port->write_urb->transfer_buffer);\n\n\t/* set up our urb */\n\tport->write_urb->transfer_buffer_length = count;\n\n\t/* send the data out the bulk port */\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err_console(port,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\tedge_port->ep_write_urb_in_use = 0;\n\t\t/* TODO: reschedule edge_send */\n\t} else\n\t\tedge_port->port->icount.tx += count;\n\n\t/*\n\t * wakeup any process waiting for writes to complete\n\t * there is now more room in the buffer for new writes\n\t */\n\tif (tty)\n\t\ttty_wakeup(tty);\n}\n",
        "linevul": 6.143551581772044e-05,
        "sysevr": 0.13528355956077576,
        "devign": 4.333899992036036e-17
    },
    {
        "code": "int x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a2b9e6c1a35afcc0973acb72e591c714e78885ff",
        "vul_func_with_fix": "int x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\n",
        "linevul": 0.00011463871487649158,
        "sysevr": 0.30557259917259216,
        "devign": 8.207096460766117e-12
    },
    {
        "code": "int ar6000_start_ap_interface(struct ar6_softc *ar)\n{\n    struct ar_virtual_interface *arApDev;\n\n    /* Change net_device to point to AP instance */\n    arApDev = (struct ar_virtual_interface *)ar->arApDev;\n    ar->arNetDev = arApDev->arNetDev;\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "int ar6000_start_ap_interface(struct ar6_softc *ar)\n{\n    struct ar_virtual_interface *arApDev;\n\n    /* Change net_device to point to AP instance */\n    arApDev = (struct ar_virtual_interface *)ar->arApDev;\n    ar->arNetDev = arApDev->arNetDev;\n\n    return 0;\n}\n",
        "linevul": 4.9227721319766715e-05,
        "sysevr": 0.1456478238105774,
        "devign": 0.003721795277670026
    },
    {
        "code": "static void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Root hubs aren't real devices, so don't free HCD resources */\n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea",
        "vul_func_with_fix": "static void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Root hubs aren't real devices, so don't free HCD resources */\n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n",
        "linevul": 5.165142647456378e-05,
        "sysevr": 0.12343316525220871,
        "devign": 0.0001618972310097888
    },
    {
        "code": "static inline void skb_orphan_try(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\n\tif (sk && !skb_shinfo(skb)->tx_flags) {\n\t\t/* skb_tx_hash() wont be able to get sk.\n\t\t * We copy sk_hash into skb->rxhash\n\t\t */\n\t\tif (!skb->rxhash)\n\t\t\tskb->rxhash = sk->sk_hash;\n\t\tskb_orphan(skb);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "static inline void skb_orphan_try(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\n\tif (sk && !skb_shinfo(skb)->tx_flags) {\n\t\t/* skb_tx_hash() wont be able to get sk.\n\t\t * We copy sk_hash into skb->rxhash\n\t\t */\n\t\tif (!skb->rxhash)\n\t\t\tskb->rxhash = sk->sk_hash;\n\t\tskb_orphan(skb);\n\t}\n}\n",
        "linevul": 8.83313114172779e-05,
        "sysevr": 0.12243406474590302,
        "devign": 8.282507042167708e-05
    },
    {
        "code": "static inline void rb_event_discard(struct ring_buffer_event *event)\n{\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND)\n\t\tevent = skip_time_extend(event);\n\n\t/* array[0] holds the actual length for the discarded event */\n\tevent->array[0] = rb_event_data_length(event) - RB_EVNT_HDR_SIZE;\n\tevent->type_len = RINGBUF_TYPE_PADDING;\n\t/* time delta must be non zero */\n\tif (!event->time_delta)\n\t\tevent->time_delta = 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "vul_func_with_fix": "static inline void rb_event_discard(struct ring_buffer_event *event)\n{\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND)\n\t\tevent = skip_time_extend(event);\n\n\t/* array[0] holds the actual length for the discarded event */\n\tevent->array[0] = rb_event_data_length(event) - RB_EVNT_HDR_SIZE;\n\tevent->type_len = RINGBUF_TYPE_PADDING;\n\t/* time delta must be non zero */\n\tif (!event->time_delta)\n\t\tevent->time_delta = 1;\n}\n",
        "linevul": 5.011322718928568e-05,
        "sysevr": 0.14162485301494598,
        "devign": 3.3982427154294575e-16
    },
    {
        "code": "void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(vcpu, ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755",
        "vul_func_with_fix": "void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(vcpu, ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}\n",
        "linevul": 5.350444189389236e-05,
        "sysevr": 0.159027561545372,
        "devign": 2.6972459844884775e-19
    },
    {
        "code": "struct platform_device *platform_device_alloc(const char *name, int id)\n{\n\tstruct platform_object *pa;\n\n\tpa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);\n\tif (pa) {\n\t\tstrcpy(pa->name, name);\n\t\tpa->pdev.name = pa->name;\n\t\tpa->pdev.id = id;\n\t\tdevice_initialize(&pa->pdev.dev);\n\t\tpa->pdev.dev.release = platform_device_release;\n\t\tarch_setup_pdev_archdata(&pa->pdev);\n\t}\n\n\treturn pa ? &pa->pdev : NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6265539776a0810b7ce6398c27866ddb9c6bd154",
        "vul_func_with_fix": "struct platform_device *platform_device_alloc(const char *name, int id)\n{\n\tstruct platform_object *pa;\n\n\tpa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);\n\tif (pa) {\n\t\tstrcpy(pa->name, name);\n\t\tpa->pdev.name = pa->name;\n\t\tpa->pdev.id = id;\n\t\tdevice_initialize(&pa->pdev.dev);\n\t\tpa->pdev.dev.release = platform_device_release;\n\t\tarch_setup_pdev_archdata(&pa->pdev);\n\t}\n\n\treturn pa ? &pa->pdev : NULL;\n}\n",
        "linevul": 5.6289220083272085e-05,
        "sysevr": 0.16413123905658722,
        "devign": 2.9329685381773718e-12
    },
    {
        "code": "ring_buffer_lock_reserve(struct ring_buffer *buffer, unsigned long length)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint cpu;\n\n\t/* If we are tracing schedule, we don't want to recurse */\n\tpreempt_disable_notrace();\n\n\tif (unlikely(atomic_read(&buffer->record_disabled)))\n\t\tgoto out;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (unlikely(!cpumask_test_cpu(cpu, buffer->cpumask)))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\tif (unlikely(atomic_read(&cpu_buffer->record_disabled)))\n\t\tgoto out;\n\n\tif (unlikely(length > BUF_MAX_DATA_SIZE))\n\t\tgoto out;\n\n\tif (unlikely(trace_recursive_lock(cpu_buffer)))\n\t\tgoto out;\n\n\tevent = rb_reserve_next_event(buffer, cpu_buffer, length);\n\tif (!event)\n\t\tgoto out_unlock;\n\n\treturn event;\n\n out_unlock:\n\ttrace_recursive_unlock(cpu_buffer);\n out:\n\tpreempt_enable_notrace();\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "vul_func_with_fix": "ring_buffer_lock_reserve(struct ring_buffer *buffer, unsigned long length)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint cpu;\n\n\t/* If we are tracing schedule, we don't want to recurse */\n\tpreempt_disable_notrace();\n\n\tif (unlikely(atomic_read(&buffer->record_disabled)))\n\t\tgoto out;\n\n\tcpu = raw_smp_processor_id();\n\n\tif (unlikely(!cpumask_test_cpu(cpu, buffer->cpumask)))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\n\tif (unlikely(atomic_read(&cpu_buffer->record_disabled)))\n\t\tgoto out;\n\n\tif (unlikely(length > BUF_MAX_DATA_SIZE))\n\t\tgoto out;\n\n\tif (unlikely(trace_recursive_lock(cpu_buffer)))\n\t\tgoto out;\n\n\tevent = rb_reserve_next_event(buffer, cpu_buffer, length);\n\tif (!event)\n\t\tgoto out_unlock;\n\n\treturn event;\n\n out_unlock:\n\ttrace_recursive_unlock(cpu_buffer);\n out:\n\tpreempt_enable_notrace();\n\treturn NULL;\n}\n",
        "linevul": 5.674285421264358e-05,
        "sysevr": 0.18267403542995453,
        "devign": 6.99562029595489e-18
    },
    {
        "code": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\tstruct page *page;\n\n\t\tpage = can_gather_numa_stats(huge_pte, vma, addr);\n\t\tif (page)\n\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t     HPAGE_PMD_SIZE/PAGE_SIZE);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tdo {\n\t\tstruct page *page = can_gather_numa_stats(*pte, vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ab676b7d6fbf4b294bf198fb27ade5b0e865c7ce",
        "vul_func_with_fix": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md = walk->private;\n\tstruct vm_area_struct *vma = walk->vma;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tif (pmd_trans_huge_lock(pmd, vma, &ptl) == 1) {\n\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\tstruct page *page;\n\n\t\tpage = can_gather_numa_stats(huge_pte, vma, addr);\n\t\tif (page)\n\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t     HPAGE_PMD_SIZE/PAGE_SIZE);\n\t\tspin_unlock(ptl);\n\t\treturn 0;\n\t}\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tdo {\n\t\tstruct page *page = can_gather_numa_stats(*pte, vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}\n",
        "linevul": 7.73233114159666e-05,
        "sysevr": 0.12401683628559113,
        "devign": 9.502241422605968e-19
    },
    {
        "code": "static inline const char *ip_vs_fwd_name(unsigned flags)\n{\n\tswitch (flags & IP_VS_CONN_F_FWD_MASK) {\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\treturn \"Local\";\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\treturn \"Tunnel\";\n\tcase IP_VS_CONN_F_DROUTE:\n\t\treturn \"Route\";\n\tdefault:\n\t\treturn \"Masq\";\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb",
        "vul_func_with_fix": "static inline const char *ip_vs_fwd_name(unsigned flags)\n{\n\tswitch (flags & IP_VS_CONN_F_FWD_MASK) {\n\tcase IP_VS_CONN_F_LOCALNODE:\n\t\treturn \"Local\";\n\tcase IP_VS_CONN_F_TUNNEL:\n\t\treturn \"Tunnel\";\n\tcase IP_VS_CONN_F_DROUTE:\n\t\treturn \"Route\";\n\tdefault:\n\t\treturn \"Masq\";\n\t}\n}\n",
        "linevul": 4.9848029448185116e-05,
        "sysevr": 0.12198875099420547,
        "devign": 3.109855924776639e-06
    },
    {
        "code": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a430c9166312e1aa3d80bce32374233bdbfeba32",
        "vul_func_with_fix": "static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t    u16 port, u16 len)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct tr_seg;\n\tu32 base3;\n\tint r;\n\tu16 tr, io_bitmap_ptr, perm, bit_idx = port & 0x7;\n\tunsigned mask = (1 << len) - 1;\n\tunsigned long base;\n\n\tops->get_segment(ctxt, &tr, &tr_seg, &base3, VCPU_SREG_TR);\n\tif (!tr_seg.p)\n\t\treturn false;\n\tif (desc_limit_scaled(&tr_seg) < 103)\n\t\treturn false;\n\tbase = get_desc_base(&tr_seg);\n#ifdef CONFIG_X86_64\n\tbase |= ((u64)base3) << 32;\n#endif\n\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))\n\t\treturn false;\n\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn false;\n\tif ((perm >> bit_idx) & mask)\n\t\treturn false;\n\treturn true;\n}\n",
        "linevul": 5.424812115961686e-05,
        "sysevr": 0.16893894970417023,
        "devign": 1.4435720820788744e-19
    },
    {
        "code": "static int __init balloon_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising balloon driver\\n\");\n\n#ifdef CONFIG_XEN_PV\n\tballoon_stats.current_pages = xen_pv_domain()\n\t\t? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\n\t\t: get_num_physpages();\n#else\n\tballoon_stats.current_pages = get_num_physpages();\n#endif\n\tballoon_stats.target_pages  = balloon_stats.current_pages;\n\tballoon_stats.balloon_low   = 0;\n\tballoon_stats.balloon_high  = 0;\n\tballoon_stats.total_pages   = balloon_stats.current_pages;\n\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);\n\tregister_memory_notifier(&xen_memory_nb);\n\tregister_sysctl_table(xen_root);\n#endif\n\n#ifdef CONFIG_XEN_PV\n\t{\n\t\tint i;\n\n\t\t/*\n\t\t * Initialize the balloon with pages from the extra memory\n\t\t * regions (see arch/x86/xen/setup.c).\n\t\t */\n\t\tfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)\n\t\t\tif (xen_extra_mem[i].n_pfns)\n\t\t\t\tballoon_add_region(xen_extra_mem[i].start_pfn,\n\t\t\t\t\t\t   xen_extra_mem[i].n_pfns);\n\t}\n#endif\n\n\t/* Init the xen-balloon driver. */\n\txen_balloon_init();\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844",
        "vul_func_with_fix": "static int __init balloon_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising balloon driver\\n\");\n\n#ifdef CONFIG_XEN_PV\n\tballoon_stats.current_pages = xen_pv_domain()\n\t\t? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\n\t\t: get_num_physpages();\n#else\n\tballoon_stats.current_pages = get_num_physpages();\n#endif\n\tballoon_stats.target_pages  = balloon_stats.current_pages;\n\tballoon_stats.balloon_low   = 0;\n\tballoon_stats.balloon_high  = 0;\n\tballoon_stats.total_pages   = balloon_stats.current_pages;\n\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n//flaw_line_below:\n\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n//fix_flaw_line_below:\n//\tballoon_stats.max_retry_count = 4;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);\n\tregister_memory_notifier(&xen_memory_nb);\n\tregister_sysctl_table(xen_root);\n#endif\n\n#ifdef CONFIG_XEN_PV\n\t{\n\t\tint i;\n\n\t\t/*\n\t\t * Initialize the balloon with pages from the extra memory\n\t\t * regions (see arch/x86/xen/setup.c).\n\t\t */\n\t\tfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)\n\t\t\tif (xen_extra_mem[i].n_pfns)\n\t\t\t\tballoon_add_region(xen_extra_mem[i].start_pfn,\n\t\t\t\t\t\t   xen_extra_mem[i].n_pfns);\n\t}\n#endif\n\n\t/* Init the xen-balloon driver. */\n\txen_balloon_init();\n\n\treturn 0;\n}\n",
        "linevul": 0.9992550015449524,
        "sysevr": 0.15862663090229034,
        "devign": 0.6891308426856995
    },
    {
        "code": "static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)\n{\n\twhile (!list_empty(&xprt->sc_maps)) {\n\t\tstruct svc_rdma_req_map *map;\n\t\tmap = list_first_entry(&xprt->sc_maps,\n\t\t\t\t       struct svc_rdma_req_map, free);\n\t\tlist_del(&map->free);\n\t\tkfree(map);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)\n//flaw_line_below:\n{\n//flaw_line_below:\n\twhile (!list_empty(&xprt->sc_maps)) {\n//flaw_line_below:\n\t\tstruct svc_rdma_req_map *map;\n//flaw_line_below:\n\n//flaw_line_below:\n\t\tmap = list_first_entry(&xprt->sc_maps,\n//flaw_line_below:\n\t\t\t\t       struct svc_rdma_req_map, free);\n//flaw_line_below:\n\t\tlist_del(&map->free);\n//flaw_line_below:\n\t\tkfree(map);\n//flaw_line_below:\n\t}\n//flaw_line_below:\n}\n",
        "linevul": 0.9563096761703491,
        "sysevr": 0.12631767988204956,
        "devign": 0.9221997261047363
    },
    {
        "code": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4",
        "vul_func_with_fix": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n",
        "linevul": 7.239538535941392e-05,
        "sysevr": 0.15005971491336823,
        "devign": 1.462323292921768e-25
    },
    {
        "code": "static bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv, *data2;\n\tbool ack = false;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_rx_status rx_status;\n\tu64 now;\n\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\trx_status.flag |= RX_FLAG_MACTIME_START;\n\trx_status.freq = chan->center_freq;\n\trx_status.band = chan->band;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trx_status.rate_idx =\n\t\t\tieee80211_rate_get_vht_mcs(&info->control.rates[0]);\n\t\trx_status.nss =\n\t\t\tieee80211_rate_get_vht_nss(&info->control.rates[0]);\n\t\trx_status.encoding = RX_ENC_VHT;\n\t} else {\n\t\trx_status.rate_idx = info->control.rates[0].idx;\n\t\tif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\t\trx_status.encoding = RX_ENC_HT;\n\t}\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_80;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_160;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t/* TODO: simulate real signal strength (and optional packet loss) */\n\trx_status.signal = -50;\n\tif (info->control.vif)\n\t\trx_status.signal += info->control.vif->bss_conf.txpower;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\t/* release the skb's source info */\n\tskb_orphan(skb);\n\tskb_dst_drop(skb);\n\tskb->mark = 0;\n\tsecpath_reset(skb);\n\tnf_reset(skb);\n\n\t/*\n\t * Get absolute mactime here so all HWs RX at the \"same time\", and\n\t * absolute TX time for beacon mactime so the timestamp matches.\n\t * Giving beacons a different mactime than non-beacons looks messy, but\n\t * it helps the Toffset be exact and a ~10us mactime discrepancy\n\t * probably doesn't really matter.\n\t */\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\tnow = data->abs_bcn_ts;\n\telse\n\t\tnow = mac80211_hwsim_get_tsf_raw();\n\n\t/* Copy skb to all enabled radios that are on the current frequency */\n\tspin_lock(&hwsim_radio_lock);\n\tlist_for_each_entry(data2, &hwsim_radios, list) {\n\t\tstruct sk_buff *nskb;\n\t\tstruct tx_iter_data tx_iter_data = {\n\t\t\t.receive = false,\n\t\t\t.channel = chan,\n\t\t};\n\n\t\tif (data == data2)\n\t\t\tcontinue;\n\n\t\tif (!data2->started || (data2->idle && !data2->tmp_chan) ||\n\t\t    !hwsim_ps_rx_ok(data2, skb))\n\t\t\tcontinue;\n\n\t\tif (!(data->group & data2->group))\n\t\t\tcontinue;\n\n\t\tif (data->netgroup != data2->netgroup)\n\t\t\tcontinue;\n\n\t\tif (!hwsim_chans_compat(chan, data2->tmp_chan) &&\n\t\t    !hwsim_chans_compat(chan, data2->channel)) {\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata2->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_tx_iter, &tx_iter_data);\n\t\t\tif (!tx_iter_data.receive)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * reserve some space for our vendor and the normal\n\t\t * radiotap header, since we're copying anyway\n\t\t */\n\t\tif (skb->len < PAGE_SIZE && paged_rx) {\n\t\t\tstruct page *page = alloc_page(GFP_ATOMIC);\n\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnskb = dev_alloc_skb(128);\n\t\t\tif (!nskb) {\n\t\t\t\t__free_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(page_address(page), skb->data, skb->len);\n\t\t\tskb_add_rx_frag(nskb, 0, page, 0, skb->len, skb->len);\n\t\t} else {\n\t\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!nskb)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac80211_hwsim_addr_match(data2, hdr->addr1))\n\t\t\tack = true;\n\n\t\trx_status.mactime = now + data2->tsf_offset;\n\n\t\tmemcpy(IEEE80211_SKB_RXCB(nskb), &rx_status, sizeof(rx_status));\n\n\t\tmac80211_hwsim_add_vendor_rtap(nskb);\n\n\t\tdata2->rx_pkts++;\n\t\tdata2->rx_bytes += nskb->len;\n\t\tieee80211_rx_irqsafe(data2->hw, nskb);\n\t}\n\tspin_unlock(&hwsim_radio_lock);\n\n\treturn ack;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "vul_func_with_fix": "static bool mac80211_hwsim_tx_frame_no_nl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct ieee80211_channel *chan)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv, *data2;\n\tbool ack = false;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_rx_status rx_status;\n\tu64 now;\n\n\tmemset(&rx_status, 0, sizeof(rx_status));\n\trx_status.flag |= RX_FLAG_MACTIME_START;\n\trx_status.freq = chan->center_freq;\n\trx_status.band = chan->band;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trx_status.rate_idx =\n\t\t\tieee80211_rate_get_vht_mcs(&info->control.rates[0]);\n\t\trx_status.nss =\n\t\t\tieee80211_rate_get_vht_nss(&info->control.rates[0]);\n\t\trx_status.encoding = RX_ENC_VHT;\n\t} else {\n\t\trx_status.rate_idx = info->control.rates[0].idx;\n\t\tif (info->control.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\t\trx_status.encoding = RX_ENC_HT;\n\t}\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_40;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_80;\n\telse if (info->control.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\trx_status.bw = RATE_INFO_BW_160;\n\telse\n\t\trx_status.bw = RATE_INFO_BW_20;\n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t/* TODO: simulate real signal strength (and optional packet loss) */\n\trx_status.signal = -50;\n\tif (info->control.vif)\n\t\trx_status.signal += info->control.vif->bss_conf.txpower;\n\n\tif (data->ps != PS_DISABLED)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\t/* release the skb's source info */\n\tskb_orphan(skb);\n\tskb_dst_drop(skb);\n\tskb->mark = 0;\n\tsecpath_reset(skb);\n\tnf_reset(skb);\n\n\t/*\n\t * Get absolute mactime here so all HWs RX at the \"same time\", and\n\t * absolute TX time for beacon mactime so the timestamp matches.\n\t * Giving beacons a different mactime than non-beacons looks messy, but\n\t * it helps the Toffset be exact and a ~10us mactime discrepancy\n\t * probably doesn't really matter.\n\t */\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\tnow = data->abs_bcn_ts;\n\telse\n\t\tnow = mac80211_hwsim_get_tsf_raw();\n\n\t/* Copy skb to all enabled radios that are on the current frequency */\n\tspin_lock(&hwsim_radio_lock);\n\tlist_for_each_entry(data2, &hwsim_radios, list) {\n\t\tstruct sk_buff *nskb;\n\t\tstruct tx_iter_data tx_iter_data = {\n\t\t\t.receive = false,\n\t\t\t.channel = chan,\n\t\t};\n\n\t\tif (data == data2)\n\t\t\tcontinue;\n\n\t\tif (!data2->started || (data2->idle && !data2->tmp_chan) ||\n\t\t    !hwsim_ps_rx_ok(data2, skb))\n\t\t\tcontinue;\n\n\t\tif (!(data->group & data2->group))\n\t\t\tcontinue;\n\n\t\tif (data->netgroup != data2->netgroup)\n\t\t\tcontinue;\n\n\t\tif (!hwsim_chans_compat(chan, data2->tmp_chan) &&\n\t\t    !hwsim_chans_compat(chan, data2->channel)) {\n\t\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\tdata2->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\tmac80211_hwsim_tx_iter, &tx_iter_data);\n\t\t\tif (!tx_iter_data.receive)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * reserve some space for our vendor and the normal\n\t\t * radiotap header, since we're copying anyway\n\t\t */\n\t\tif (skb->len < PAGE_SIZE && paged_rx) {\n\t\t\tstruct page *page = alloc_page(GFP_ATOMIC);\n\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\tnskb = dev_alloc_skb(128);\n\t\t\tif (!nskb) {\n\t\t\t\t__free_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(page_address(page), skb->data, skb->len);\n\t\t\tskb_add_rx_frag(nskb, 0, page, 0, skb->len, skb->len);\n\t\t} else {\n\t\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!nskb)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac80211_hwsim_addr_match(data2, hdr->addr1))\n\t\t\tack = true;\n\n\t\trx_status.mactime = now + data2->tsf_offset;\n\n\t\tmemcpy(IEEE80211_SKB_RXCB(nskb), &rx_status, sizeof(rx_status));\n\n\t\tmac80211_hwsim_add_vendor_rtap(nskb);\n\n\t\tdata2->rx_pkts++;\n\t\tdata2->rx_bytes += nskb->len;\n\t\tieee80211_rx_irqsafe(data2->hw, nskb);\n\t}\n\tspin_unlock(&hwsim_radio_lock);\n\n\treturn ack;\n}\n",
        "linevul": 5.488388705998659e-05,
        "sysevr": 0.21880590915679932,
        "devign": 0.9054262638092041
    },
    {
        "code": "static void __init reserve_initrd(void)\n{\n}\n",
        "label": "0",
        "addr": "https://github.com/mjg59/linux/commit/a4a5ed2835e8ea042868b7401dced3f517cafa76",
        "vul_func_with_fix": "static void __init reserve_initrd(void)\n{\n}\n",
        "linevul": 5.330414205673151e-05,
        "sysevr": 0.12549321353435516,
        "devign": 0.07829746603965759
    },
    {
        "code": "struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "vul_func_with_fix": "struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\treturn NULL;\n}\n",
        "linevul": 6.92504909238778e-05,
        "sysevr": 0.13321147859096527,
        "devign": 1.616413669580652e-10
    },
    {
        "code": "generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct address_space *mapping = out->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tssize_t ret;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tret = file_remove_suid(out);\n\t\tif (!ret) {\n\t\t\tret = file_update_time(out);\n\t\t\tif (!ret)\n\t\t\t\tret = splice_from_pipe_feed(pipe, &sd,\n\t\t\t\t\t\t\t    pipe_to_file);\n\t\t}\n\t\tmutex_unlock(&inode->i_mutex);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\tif (ret > 0) {\n\t\tint err;\n\n\t\terr = generic_write_sync(out, *ppos, ret);\n\t\tif (err)\n\t\t\tret = err;\n\t\telse\n\t\t\t*ppos += ret;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958",
        "vul_func_with_fix": "generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct address_space *mapping = out->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tssize_t ret;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tret = file_remove_suid(out);\n\t\tif (!ret) {\n\t\t\tret = file_update_time(out);\n\t\t\tif (!ret)\n\t\t\t\tret = splice_from_pipe_feed(pipe, &sd,\n\t\t\t\t\t\t\t    pipe_to_file);\n\t\t}\n\t\tmutex_unlock(&inode->i_mutex);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\tif (ret > 0) {\n\t\tint err;\n\n\t\terr = generic_write_sync(out, *ppos, ret);\n\t\tif (err)\n\t\t\tret = err;\n\t\telse\n\t\t\t*ppos += ret;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 0.00030523192253895104,
        "sysevr": 0.22418801486492157,
        "devign": 1.1585883237349283e-21
    },
    {
        "code": "static void etm_event_stop(struct perf_event *event, int mode)\n{\n\tbool lost;\n\tint cpu = smp_processor_id();\n\tunsigned long size;\n\tstruct coresight_device *sink, *csdev = per_cpu(csdev_src, cpu);\n\tstruct perf_output_handle *handle = this_cpu_ptr(&ctx_handle);\n\tstruct etm_event_data *event_data = perf_get_aux(handle);\n\n\tif (event->hw.state == PERF_HES_STOPPED)\n\t\treturn;\n\n\tif (!csdev)\n\t\treturn;\n\n\tsink = coresight_get_sink(event_data->path[cpu]);\n\tif (!sink)\n\t\treturn;\n\n\t/* stop tracer */\n\tsource_ops(csdev)->disable(csdev, event);\n\n\t/* tell the core */\n\tevent->hw.state = PERF_HES_STOPPED;\n\n\tif (mode & PERF_EF_UPDATE) {\n\t\tif (WARN_ON_ONCE(handle->event != event))\n\t\t\treturn;\n\n\t\t/* update trace information */\n\t\tif (!sink_ops(sink)->update_buffer)\n\t\t\treturn;\n\n\t\tsink_ops(sink)->update_buffer(sink, handle,\n\t\t\t\t\t      event_data->snk_config);\n\n\t\tif (!sink_ops(sink)->reset_buffer)\n\t\t\treturn;\n\n\t\tsize = sink_ops(sink)->reset_buffer(sink, handle,\n\t\t\t\t\t\t    event_data->snk_config,\n\t\t\t\t\t\t    &lost);\n\n\t\tperf_aux_output_end(handle, size, lost);\n\t}\n\n\t/* Disabling the path make its elements available to other sessions */\n\tcoresight_disable_path(event_data->path[cpu]);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f09444639099584bc4784dfcd85ada67c6f33e0f",
        "vul_func_with_fix": "static void etm_event_stop(struct perf_event *event, int mode)\n{\n\tbool lost;\n\tint cpu = smp_processor_id();\n\tunsigned long size;\n\tstruct coresight_device *sink, *csdev = per_cpu(csdev_src, cpu);\n\tstruct perf_output_handle *handle = this_cpu_ptr(&ctx_handle);\n\tstruct etm_event_data *event_data = perf_get_aux(handle);\n\n\tif (event->hw.state == PERF_HES_STOPPED)\n\t\treturn;\n\n\tif (!csdev)\n\t\treturn;\n\n\tsink = coresight_get_sink(event_data->path[cpu]);\n\tif (!sink)\n\t\treturn;\n\n\t/* stop tracer */\n\tsource_ops(csdev)->disable(csdev, event);\n\n\t/* tell the core */\n\tevent->hw.state = PERF_HES_STOPPED;\n\n\tif (mode & PERF_EF_UPDATE) {\n\t\tif (WARN_ON_ONCE(handle->event != event))\n\t\t\treturn;\n\n\t\t/* update trace information */\n\t\tif (!sink_ops(sink)->update_buffer)\n\t\t\treturn;\n\n\t\tsink_ops(sink)->update_buffer(sink, handle,\n\t\t\t\t\t      event_data->snk_config);\n\n\t\tif (!sink_ops(sink)->reset_buffer)\n\t\t\treturn;\n\n\t\tsize = sink_ops(sink)->reset_buffer(sink, handle,\n\t\t\t\t\t\t    event_data->snk_config,\n\t\t\t\t\t\t    &lost);\n\n\t\tperf_aux_output_end(handle, size, lost);\n\t}\n\n\t/* Disabling the path make its elements available to other sessions */\n\tcoresight_disable_path(event_data->path[cpu]);\n}\n",
        "linevul": 0.0006071291281841695,
        "sysevr": 0.1296328753232956,
        "devign": 4.969630339525958e-27
    },
    {
        "code": "static struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,\n\t\t\t\t\t struct sock_iocb *siocb)\n{\n\tif (!is_sync_kiocb(iocb))\n\t\tBUG();\n\n\tsiocb->kiocb = iocb;\n\tiocb->private = siocb;\n\treturn siocb;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,\n\t\t\t\t\t struct sock_iocb *siocb)\n{\n\tif (!is_sync_kiocb(iocb))\n\t\tBUG();\n\n\tsiocb->kiocb = iocb;\n\tiocb->private = siocb;\n\treturn siocb;\n}\n",
        "linevul": 6.530470272991806e-05,
        "sysevr": 0.1269790083169937,
        "devign": 6.670655494644961e-08
    },
    {
        "code": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c8c499175f7d295ef867335bceb9a76a2c3cdc38",
        "vul_func_with_fix": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "linevul": 6.123003549873829e-05,
        "sysevr": 0.1357669234275818,
        "devign": 0.9562702178955078
    },
    {
        "code": "static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)\n{\n\tint err;\n\n\tif (dev->actconfig->desc.bConfigurationValue == 1) {\n\t\tdev_info(&dev->dev,\n\t\t\t   \"Fast Track Pro switching to config #2\\n\");\n\t\t/* This function has to be available by the usb core module.\n\t\t * if it is not avialable the boot quirk has to be left out\n\t\t * and the configuration has to be set by udev or hotplug\n\t\t * rules\n\t\t */\n\t\terr = usb_driver_set_configuration(dev, 2);\n\t\tif (err < 0)\n\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\"error usb_driver_set_configuration: %d\\n\",\n\t\t\t\terr);\n\t\t/* Always return an error, so that we stop creating a device\n\t\t   that will just be destroyed and recreated with a new\n\t\t   configuration */\n\t\treturn -ENODEV;\n\t} else\n\t\tdev_info(&dev->dev, \"Fast Track Pro config OK\\n\");\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0f886ca12765d20124bd06291c82951fd49a33be",
        "vul_func_with_fix": "static int snd_usb_fasttrackpro_boot_quirk(struct usb_device *dev)\n{\n\tint err;\n\n\tif (dev->actconfig->desc.bConfigurationValue == 1) {\n\t\tdev_info(&dev->dev,\n\t\t\t   \"Fast Track Pro switching to config #2\\n\");\n\t\t/* This function has to be available by the usb core module.\n\t\t * if it is not avialable the boot quirk has to be left out\n\t\t * and the configuration has to be set by udev or hotplug\n\t\t * rules\n\t\t */\n\t\terr = usb_driver_set_configuration(dev, 2);\n\t\tif (err < 0)\n\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\"error usb_driver_set_configuration: %d\\n\",\n\t\t\t\terr);\n\t\t/* Always return an error, so that we stop creating a device\n\t\t   that will just be destroyed and recreated with a new\n\t\t   configuration */\n\t\treturn -ENODEV;\n\t} else\n\t\tdev_info(&dev->dev, \"Fast Track Pro config OK\\n\");\n\n\treturn 0;\n}\n",
        "linevul": 6.132377893663943e-05,
        "sysevr": 0.14667873084545135,
        "devign": 6.215473694866272e-22
    },
    {
        "code": "void x25_kill_by_neigh(struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\twrite_lock_bh(&x25_list_lock);\n\n\tsk_for_each(s, &x25_list)\n\t\tif (x25_sk(s)->neighbour == nb)\n\t\t\tx25_disconnect(s, ENETUNREACH, 0, 0);\n\n\twrite_unlock_bh(&x25_list_lock);\n\n\t/* Remove any related forwards */\n\tx25_clear_forward_by_dev(nb->dev);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "void x25_kill_by_neigh(struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\twrite_lock_bh(&x25_list_lock);\n\n\tsk_for_each(s, &x25_list)\n\t\tif (x25_sk(s)->neighbour == nb)\n\t\t\tx25_disconnect(s, ENETUNREACH, 0, 0);\n\n\twrite_unlock_bh(&x25_list_lock);\n\n\t/* Remove any related forwards */\n\tx25_clear_forward_by_dev(nb->dev);\n}\n",
        "linevul": 4.91477912873961e-05,
        "sysevr": 0.1516634225845337,
        "devign": 1.3789431818622688e-08
    },
    {
        "code": "static void llc_sap_state_process(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\t/*\n\t * We have to hold the skb, because llc_sap_next_state\n\t * will kfree it in the sending path and we need to\n\t * look at the skb->cb, where we encode llc_sap_state_ev.\n\t */\n\tskb_get(skb);\n\tev->ind_cfm_flag = 0;\n\tllc_sap_next_state(sap, skb);\n\tif (ev->ind_cfm_flag == LLC_IND) {\n\t\tif (skb->sk->sk_state == TCP_LISTEN)\n\t\t\tkfree_skb(skb);\n\t\telse {\n\t\t\tllc_save_primitive(skb->sk, skb, ev->prim);\n\n\t\t\t/* queue skb to the user. */\n\t\t\tif (sock_queue_rcv_skb(skb->sk, skb))\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tkfree_skb(skb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8b74d439e1697110c5e5c600643e823eb1dd0762",
        "vul_func_with_fix": "static void llc_sap_state_process(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\t/*\n\t * We have to hold the skb, because llc_sap_next_state\n\t * will kfree it in the sending path and we need to\n\t * look at the skb->cb, where we encode llc_sap_state_ev.\n\t */\n\tskb_get(skb);\n\tev->ind_cfm_flag = 0;\n\tllc_sap_next_state(sap, skb);\n\tif (ev->ind_cfm_flag == LLC_IND) {\n\t\tif (skb->sk->sk_state == TCP_LISTEN)\n\t\t\tkfree_skb(skb);\n\t\telse {\n\t\t\tllc_save_primitive(skb->sk, skb, ev->prim);\n\n\t\t\t/* queue skb to the user. */\n\t\t\tif (sock_queue_rcv_skb(skb->sk, skb))\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tkfree_skb(skb);\n}\n",
        "linevul": 7.054724846966565e-05,
        "sysevr": 0.16000492870807648,
        "devign": 1.4046837170115737e-32
    },
    {
        "code": "static struct rds_mr *rds_mr_tree_walk(struct rb_root *root, u64 key,\n\t\t\t\t       struct rds_mr *insert)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rds_mr *mr;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmr = rb_entry(parent, struct rds_mr, r_rb_node);\n\n\t\tif (key < mr->r_key)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key > mr->r_key)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn mr;\n\t}\n\n\tif (insert) {\n\t\trb_link_node(&insert->r_rb_node, parent, p);\n\t\trb_insert_color(&insert->r_rb_node, root);\n\t\trefcount_inc(&insert->r_refcount);\n\t}\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
        "vul_func_with_fix": "static struct rds_mr *rds_mr_tree_walk(struct rb_root *root, u64 key,\n\t\t\t\t       struct rds_mr *insert)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct rds_mr *mr;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tmr = rb_entry(parent, struct rds_mr, r_rb_node);\n\n\t\tif (key < mr->r_key)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key > mr->r_key)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn mr;\n\t}\n\n\tif (insert) {\n\t\trb_link_node(&insert->r_rb_node, parent, p);\n\t\trb_insert_color(&insert->r_rb_node, root);\n\t\trefcount_inc(&insert->r_refcount);\n\t}\n\treturn NULL;\n}\n",
        "linevul": 5.3919637139188126e-05,
        "sysevr": 0.1468561589717865,
        "devign": 4.258175871985671e-23
    },
    {
        "code": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t/* Ethernet TAP Device */\n \t\tether_setup(dev);\n \n \t\trandom_ether_addr(dev->dev_addr);\n \n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t/* Ethernet TAP Device */\n \t\tether_setup(dev);\n//fix_flaw_line_below:\n//\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \t\trandom_ether_addr(dev->dev_addr);\n \n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n",
        "linevul": 0.9992856383323669,
        "sysevr": 0.13769754767417908,
        "devign": 1.3094304566219094e-15
    },
    {
        "code": "xfs_attr3_rmt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\n\t/* no verification of non-crc buffers */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = bp->b_bn;\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= XFS_LBSIZE(mp));\n\n\twhile (len > 0) {\n\t\tif (!xfs_verify_cksum(ptr, XFS_LBSIZE(mp),\n\t\t\t\t      XFS_ATTR3_RMT_CRC_OFF)) {\n\t\t\txfs_buf_ioerror(bp, EFSBADCRC);\n\t\t\tbreak;\n\t\t}\n\t\tif (!xfs_attr3_rmt_verify(mp, ptr, XFS_LBSIZE(mp), bno)) {\n\t\t\txfs_buf_ioerror(bp, EFSCORRUPTED);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= XFS_LBSIZE(mp);\n\t\tptr += XFS_LBSIZE(mp);\n\t\tbno += mp->m_bsize;\n\t}\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n\telse\n\t\tASSERT(len == 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "vul_func_with_fix": "xfs_attr3_rmt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tchar\t\t*ptr;\n\tint\t\tlen;\n\txfs_daddr_t\tbno;\n\n\t/* no verification of non-crc buffers */\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tptr = bp->b_addr;\n\tbno = bp->b_bn;\n\tlen = BBTOB(bp->b_length);\n\tASSERT(len >= XFS_LBSIZE(mp));\n\n\twhile (len > 0) {\n\t\tif (!xfs_verify_cksum(ptr, XFS_LBSIZE(mp),\n\t\t\t\t      XFS_ATTR3_RMT_CRC_OFF)) {\n\t\t\txfs_buf_ioerror(bp, EFSBADCRC);\n\t\t\tbreak;\n\t\t}\n\t\tif (!xfs_attr3_rmt_verify(mp, ptr, XFS_LBSIZE(mp), bno)) {\n\t\t\txfs_buf_ioerror(bp, EFSCORRUPTED);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= XFS_LBSIZE(mp);\n\t\tptr += XFS_LBSIZE(mp);\n\t\tbno += mp->m_bsize;\n\t}\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n\telse\n\t\tASSERT(len == 0);\n}\n",
        "linevul": 0.00016132000018842518,
        "sysevr": 0.19467133283615112,
        "devign": 7.466927077773503e-21
    },
    {
        "code": "static void eseqiv_complete2(struct skcipher_givcrypt_request *req)\n{\n\tstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\n\tstruct eseqiv_request_ctx *reqctx = skcipher_givcrypt_reqctx(req);\n\n\tmemcpy(req->giv, PTR_ALIGN((u8 *)reqctx->tail,\n\t\t\t crypto_ablkcipher_alignmask(geniv) + 1),\n\t       crypto_ablkcipher_ivsize(geniv));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "static void eseqiv_complete2(struct skcipher_givcrypt_request *req)\n{\n\tstruct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\n\tstruct eseqiv_request_ctx *reqctx = skcipher_givcrypt_reqctx(req);\n\n\tmemcpy(req->giv, PTR_ALIGN((u8 *)reqctx->tail,\n\t\t\t crypto_ablkcipher_alignmask(geniv) + 1),\n\t       crypto_ablkcipher_ivsize(geniv));\n}\n",
        "linevul": 5.288521424517967e-05,
        "sysevr": 0.13259877264499664,
        "devign": 0.025040417909622192
    },
    {
        "code": "static void kgdb_correct_hw_break(void)\n{\n\tint breakno;\n\n\tfor (breakno = 0; breakno < HBP_NUM; breakno++) {\n\t\tstruct perf_event *bp;\n\t\tstruct arch_hw_breakpoint *info;\n\t\tint val;\n\t\tint cpu = raw_smp_processor_id();\n\t\tif (!breakinfo[breakno].enabled)\n\t\t\tcontinue;\n\t\tif (dbg_is_early) {\n\t\t\tset_debugreg(breakinfo[breakno].addr, breakno);\n\t\t\tearly_dr7 |= encode_dr7(breakno,\n\t\t\t\t\t\tbreakinfo[breakno].len,\n\t\t\t\t\t\tbreakinfo[breakno].type);\n\t\t\tset_debugreg(early_dr7, 7);\n\t\t\tcontinue;\n\t\t}\n\t\tbp = *per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tinfo = counter_arch_bp(bp);\n\t\tif (bp->attr.disabled != 1)\n\t\t\tcontinue;\n\t\tbp->attr.bp_addr = breakinfo[breakno].addr;\n\t\tbp->attr.bp_len = breakinfo[breakno].len;\n\t\tbp->attr.bp_type = breakinfo[breakno].type;\n\t\tinfo->address = breakinfo[breakno].addr;\n\t\tinfo->len = breakinfo[breakno].len;\n\t\tinfo->type = breakinfo[breakno].type;\n\t\tval = arch_install_hw_breakpoint(bp);\n\t\tif (!val)\n\t\t\tbp->attr.disabled = 0;\n\t}\n\tif (!dbg_is_early)\n\t\thw_breakpoint_restore();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void kgdb_correct_hw_break(void)\n{\n\tint breakno;\n\n\tfor (breakno = 0; breakno < HBP_NUM; breakno++) {\n\t\tstruct perf_event *bp;\n\t\tstruct arch_hw_breakpoint *info;\n\t\tint val;\n\t\tint cpu = raw_smp_processor_id();\n\t\tif (!breakinfo[breakno].enabled)\n\t\t\tcontinue;\n\t\tif (dbg_is_early) {\n\t\t\tset_debugreg(breakinfo[breakno].addr, breakno);\n\t\t\tearly_dr7 |= encode_dr7(breakno,\n\t\t\t\t\t\tbreakinfo[breakno].len,\n\t\t\t\t\t\tbreakinfo[breakno].type);\n\t\t\tset_debugreg(early_dr7, 7);\n\t\t\tcontinue;\n\t\t}\n\t\tbp = *per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tinfo = counter_arch_bp(bp);\n\t\tif (bp->attr.disabled != 1)\n\t\t\tcontinue;\n\t\tbp->attr.bp_addr = breakinfo[breakno].addr;\n\t\tbp->attr.bp_len = breakinfo[breakno].len;\n\t\tbp->attr.bp_type = breakinfo[breakno].type;\n\t\tinfo->address = breakinfo[breakno].addr;\n\t\tinfo->len = breakinfo[breakno].len;\n\t\tinfo->type = breakinfo[breakno].type;\n\t\tval = arch_install_hw_breakpoint(bp);\n\t\tif (!val)\n\t\t\tbp->attr.disabled = 0;\n\t}\n\tif (!dbg_is_early)\n\t\thw_breakpoint_restore();\n}\n",
        "linevul": 0.00030551606323570013,
        "sysevr": 0.17564745247364044,
        "devign": 4.551486479918189e-14
    },
    {
        "code": "static int sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn 0;\n\n\tif (!sig_task_ignored(t, sig, force))\n\t\treturn 0;\n\n\t/*\n\t * Tracers may want to know about even ignored signals.\n\t */\n\treturn !t->ptrace;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9e146d8eb3b9ecae5086d373b50fa0c1f3e7f0f",
        "vul_func_with_fix": "static int sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn 0;\n\n\tif (!sig_task_ignored(t, sig, force))\n\t\treturn 0;\n\n\t/*\n\t * Tracers may want to know about even ignored signals.\n\t */\n\treturn !t->ptrace;\n}\n",
        "linevul": 4.6629687858512625e-05,
        "sysevr": 0.14167794585227966,
        "devign": 3.1613232032157157e-09
    },
    {
        "code": "static inline size_t bridge_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)\t/* IFLA_IFNAME */\n\t\t+ nla_total_size(MAX_ADDR_LEN)\t/* IFLA_ADDRESS */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MASTER */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MTU */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_LINK */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_OPERSTATE */\n\t\t+ nla_total_size(sizeof(u8))\t/* IFLA_PROTINFO */\n\t\t+ nla_total_size(sizeof(struct nlattr))\t/* IFLA_AF_SPEC */\n\t\t+ nla_total_size(sizeof(u16))\t/* IFLA_BRIDGE_FLAGS */\n\t\t+ nla_total_size(sizeof(u16));\t/* IFLA_BRIDGE_MODE */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/84d73cd3fb142bf1298a8c13fd4ca50fd2432372",
        "vul_func_with_fix": "static inline size_t bridge_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)\t/* IFLA_IFNAME */\n\t\t+ nla_total_size(MAX_ADDR_LEN)\t/* IFLA_ADDRESS */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MASTER */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MTU */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_LINK */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_OPERSTATE */\n\t\t+ nla_total_size(sizeof(u8))\t/* IFLA_PROTINFO */\n\t\t+ nla_total_size(sizeof(struct nlattr))\t/* IFLA_AF_SPEC */\n\t\t+ nla_total_size(sizeof(u16))\t/* IFLA_BRIDGE_FLAGS */\n\t\t+ nla_total_size(sizeof(u16));\t/* IFLA_BRIDGE_MODE */\n}\n",
        "linevul": 6.518400186905637e-05,
        "sysevr": 0.13008643686771393,
        "devign": 6.55974385921354e-10
    },
    {
        "code": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb",
        "vul_func_with_fix": "static unsigned long mmap_legacy_base(unsigned long rnd)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tif (mmap_is_ia32())\n//flaw_line_below:\n\t\treturn TASK_UNMAPPED_BASE;\n//flaw_line_below:\n\telse\n//flaw_line_below:\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n//flaw_line_below:\n}\n",
        "linevul": 0.34551796317100525,
        "sysevr": 0.13398143649101257,
        "devign": 0.9945853352546692
    },
    {
        "code": "static void aesni_xts_dec8(void *ctx, u128 *dst, const u128 *src, le128 *iv)\n{\n\taesni_xts_crypt8(ctx, (u8 *)dst, (const u8 *)src, false, (u8 *)iv);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ccfe8c3f7e52ae83155cb038753f4c75b774ca8a",
        "vul_func_with_fix": "static void aesni_xts_dec8(void *ctx, u128 *dst, const u128 *src, le128 *iv)\n{\n\taesni_xts_crypt8(ctx, (u8 *)dst, (const u8 *)src, false, (u8 *)iv);\n}\n",
        "linevul": 5.0125607231166214e-05,
        "sysevr": 0.12025420367717743,
        "devign": 1.420102944393875e-05
    },
    {
        "code": "struct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget(sb, &addr);\n\n\tif (metadata_fe == NULL)\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\telse if (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\tmetadata_fe = NULL;\n\t}\n\n\treturn metadata_fe;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/adee11b2085bee90bd8f4f52123ffb07882d6256",
        "vul_func_with_fix": "struct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget(sb, &addr);\n\n\tif (metadata_fe == NULL)\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\telse if (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\tmetadata_fe = NULL;\n\t}\n\n\treturn metadata_fe;\n}\n",
        "linevul": 5.1779308705590665e-05,
        "sysevr": 0.15625451505184174,
        "devign": 9.368507327943702e-16
    },
    {
        "code": "void hns_rcbv2_int_ctrl_hw(struct hnae_queue *q, u32 flag, u32 mask)\n{\n\tu32 int_mask_en = !!mask;\n\n\tif (flag & RCB_INT_FLAG_TX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TXWL_REG, int_mask_en);\n\n\tif (flag & RCB_INT_FLAG_RX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RXWL_REG, int_mask_en);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c",
        "vul_func_with_fix": "void hns_rcbv2_int_ctrl_hw(struct hnae_queue *q, u32 flag, u32 mask)\n{\n\tu32 int_mask_en = !!mask;\n\n\tif (flag & RCB_INT_FLAG_TX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_TXWL_REG, int_mask_en);\n\n\tif (flag & RCB_INT_FLAG_RX)\n\t\tdsaf_write_dev(q, RCB_RING_INTMSK_RXWL_REG, int_mask_en);\n}\n",
        "linevul": 4.630858893506229e-05,
        "sysevr": 0.1862747222185135,
        "devign": 0.0007212194032035768
    },
    {
        "code": "static inline struct packet_sock *pkt_sk(struct sock *sk)\n{\n\treturn (struct packet_sock *)sk;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6",
        "vul_func_with_fix": "static inline struct packet_sock *pkt_sk(struct sock *sk)\n{\n\treturn (struct packet_sock *)sk;\n}\n",
        "linevul": 8.352017175639048e-05,
        "sysevr": 0.12455670535564423,
        "devign": 1.004600380838383e-05
    },
    {
        "code": "static int skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset,\n\t\t\t\t      u8 __user *to, int len,\n\t\t\t\t      __wsum *csump)\n{\n\tint start = skb_headlen(skb);\n\tint i, copy = start - offset;\n\tstruct sk_buff *frag_iter;\n\tint pos = 0;\n\n\t/* Copy header. */\n\tif (copy > 0) {\n\t\tint err = 0;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\t*csump = csum_and_copy_to_user(skb->data + offset, to, copy,\n\t\t\t\t\t       *csump, &err);\n\t\tif (err)\n\t\t\tgoto fault;\n\t\tif ((len -= copy) == 0)\n\t\t\treturn 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tpos = copy;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(frag);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\t__wsum csum2;\n\t\t\tint err = 0;\n\t\t\tu8  *vaddr;\n\t\t\tstruct page *page = skb_frag_page(frag);\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tvaddr = kmap(page);\n\t\t\tcsum2 = csum_and_copy_to_user(vaddr +\n\t\t\t\t\t\t\tfrag->page_offset +\n\t\t\t\t\t\t\toffset - start,\n\t\t\t\t\t\t      to, copy, 0, &err);\n\t\t\tkunmap(page);\n\t\t\tif (err)\n\t\t\t\tgoto fault;\n\t\t\t*csump = csum_block_add(*csump, csum2, pos);\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn 0;\n\t\t\toffset += copy;\n\t\t\tto += copy;\n\t\t\tpos += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\t__wsum csum2 = 0;\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tif (skb_copy_and_csum_datagram(frag_iter,\n\t\t\t\t\t\t       offset - start,\n\t\t\t\t\t\t       to, copy,\n\t\t\t\t\t\t       &csum2))\n\t\t\t\tgoto fault;\n\t\t\t*csump = csum_block_add(*csump, csum2, pos);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn 0;\n\t\t\toffset += copy;\n\t\t\tto += copy;\n\t\t\tpos += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\tif (!len)\n\t\treturn 0;\n\nfault:\n\treturn -EFAULT;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77c1090f94d1b0b5186fb13a1b71b47b1343f87f",
        "vul_func_with_fix": "static int skb_copy_and_csum_datagram(const struct sk_buff *skb, int offset,\n\t\t\t\t      u8 __user *to, int len,\n\t\t\t\t      __wsum *csump)\n{\n\tint start = skb_headlen(skb);\n\tint i, copy = start - offset;\n\tstruct sk_buff *frag_iter;\n\tint pos = 0;\n\n\t/* Copy header. */\n\tif (copy > 0) {\n\t\tint err = 0;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\t*csump = csum_and_copy_to_user(skb->data + offset, to, copy,\n\t\t\t\t\t       *csump, &err);\n\t\tif (err)\n\t\t\tgoto fault;\n\t\tif ((len -= copy) == 0)\n\t\t\treturn 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tpos = copy;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(frag);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\t__wsum csum2;\n\t\t\tint err = 0;\n\t\t\tu8  *vaddr;\n\t\t\tstruct page *page = skb_frag_page(frag);\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tvaddr = kmap(page);\n\t\t\tcsum2 = csum_and_copy_to_user(vaddr +\n\t\t\t\t\t\t\tfrag->page_offset +\n\t\t\t\t\t\t\toffset - start,\n\t\t\t\t\t\t      to, copy, 0, &err);\n\t\t\tkunmap(page);\n\t\t\tif (err)\n\t\t\t\tgoto fault;\n\t\t\t*csump = csum_block_add(*csump, csum2, pos);\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn 0;\n\t\t\toffset += copy;\n\t\t\tto += copy;\n\t\t\tpos += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\t__wsum csum2 = 0;\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tif (skb_copy_and_csum_datagram(frag_iter,\n\t\t\t\t\t\t       offset - start,\n\t\t\t\t\t\t       to, copy,\n\t\t\t\t\t\t       &csum2))\n\t\t\t\tgoto fault;\n\t\t\t*csump = csum_block_add(*csump, csum2, pos);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn 0;\n\t\t\toffset += copy;\n\t\t\tto += copy;\n\t\t\tpos += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\tif (!len)\n\t\treturn 0;\n\nfault:\n\treturn -EFAULT;\n}\n",
        "linevul": 0.0008070605108514428,
        "sysevr": 0.16906926035881042,
        "devign": 0.5763201713562012
    },
    {
        "code": "static inline bool empty_bucket(const struct tcp_iter_state *st)\n{\n\treturn hlist_nulls_empty(&tcp_hashinfo.ehash[st->bucket].chain);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "vul_func_with_fix": "static inline bool empty_bucket(const struct tcp_iter_state *st)\n{\n\treturn hlist_nulls_empty(&tcp_hashinfo.ehash[st->bucket].chain);\n}\n",
        "linevul": 0.00013878123718313873,
        "sysevr": 0.12883876264095306,
        "devign": 0.9830018877983093
    },
    {
        "code": "static inline void put_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + --nd->depth;\n\tdo_delayed_call(&last->done);\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tpath_put(&last->link);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca",
        "vul_func_with_fix": "static inline void put_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + --nd->depth;\n\tdo_delayed_call(&last->done);\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tpath_put(&last->link);\n}\n",
        "linevul": 0.0005392460152506828,
        "sysevr": 0.12366105616092682,
        "devign": 7.161624071549966e-11
    },
    {
        "code": "static int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tdouble buf[33];\n\tint i;\n#endif\n\tflush_fp_to_thread(target);\n\n#ifdef CONFIG_VSX\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tmemcpy(&buf[32], &target->thread.fpscr, sizeof(double));\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_struct, fpscr) !=\n\t\t     offsetof(struct thread_struct, TS_FPR(32)));\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fpr, 0, -1);\n#endif\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tdouble buf[33];\n\tint i;\n#endif\n\tflush_fp_to_thread(target);\n\n#ifdef CONFIG_VSX\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tmemcpy(&buf[32], &target->thread.fpscr, sizeof(double));\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_struct, fpscr) !=\n\t\t     offsetof(struct thread_struct, TS_FPR(32)));\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fpr, 0, -1);\n#endif\n}\n",
        "linevul": 6.482063326984644e-05,
        "sysevr": 0.14382536709308624,
        "devign": 0.5059428215026855
    },
    {
        "code": "static u64 walk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte = 0ull;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn spte;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static u64 walk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte = 0ull;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn spte;\n}\n",
        "linevul": 4.861666093347594e-05,
        "sysevr": 0.13176865875720978,
        "devign": 0.0006347080343402922
    },
    {
        "code": "SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n\t\tstruct rusage32 __user *, ur)\n {\n \tstruct rusage r;\n \tlong ret, err;\n \tmm_segment_t old_fs;\n \n \tif (!ur)\n\t\treturn sys_wait4(pid, ustatus, options, NULL);\n\n \told_fs = get_fs();\n \t\t\n \tset_fs (KERNEL_DS);\n\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n \tset_fs (old_fs);\n \n \tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n \t\treturn -EFAULT;\n \n \terr = 0;\n \terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n \terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n \terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n\terr |= __put_user(r.ru_stime.tv_usec, &ur->ru_stime.tv_usec);\n\terr |= __put_user(r.ru_maxrss, &ur->ru_maxrss);\n\terr |= __put_user(r.ru_ixrss, &ur->ru_ixrss);\n\terr |= __put_user(r.ru_idrss, &ur->ru_idrss);\n\terr |= __put_user(r.ru_isrss, &ur->ru_isrss);\n\terr |= __put_user(r.ru_minflt, &ur->ru_minflt);\n\terr |= __put_user(r.ru_majflt, &ur->ru_majflt);\n\terr |= __put_user(r.ru_nswap, &ur->ru_nswap);\n\terr |= __put_user(r.ru_inblock, &ur->ru_inblock);\n\terr |= __put_user(r.ru_oublock, &ur->ru_oublock);\n\terr |= __put_user(r.ru_msgsnd, &ur->ru_msgsnd);\n\terr |= __put_user(r.ru_msgrcv, &ur->ru_msgrcv);\n\terr |= __put_user(r.ru_nsignals, &ur->ru_nsignals);\n\terr |= __put_user(r.ru_nvcsw, &ur->ru_nvcsw);\n\terr |= __put_user(r.ru_nivcsw, &ur->ru_nivcsw);\n\n\treturn err ? err : ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f",
        "vul_func_with_fix": "SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n\t\tstruct rusage32 __user *, ur)\n {\n \tstruct rusage r;\n \tlong ret, err;\n//fix_flaw_line_below:\n//\tunsigned int status = 0;\n \tmm_segment_t old_fs;\n \n \tif (!ur)\n\t\treturn sys_wait4(pid, ustatus, options, NULL);\n\n \told_fs = get_fs();\n \t\t\n \tset_fs (KERNEL_DS);\n//flaw_line_below:\n\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n//fix_flaw_line_below:\n//\tret = sys_wait4(pid, (unsigned int __user *) &status, options,\n//fix_flaw_line_below:\n//\t\t\t(struct rusage __user *) &r);\n \tset_fs (old_fs);\n \n \tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n \t\treturn -EFAULT;\n \n \terr = 0;\n//fix_flaw_line_below:\n//\terr |= put_user(status, ustatus);\n \terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n \terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n \terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n\terr |= __put_user(r.ru_stime.tv_usec, &ur->ru_stime.tv_usec);\n\terr |= __put_user(r.ru_maxrss, &ur->ru_maxrss);\n\terr |= __put_user(r.ru_ixrss, &ur->ru_ixrss);\n\terr |= __put_user(r.ru_idrss, &ur->ru_idrss);\n\terr |= __put_user(r.ru_isrss, &ur->ru_isrss);\n\terr |= __put_user(r.ru_minflt, &ur->ru_minflt);\n\terr |= __put_user(r.ru_majflt, &ur->ru_majflt);\n\terr |= __put_user(r.ru_nswap, &ur->ru_nswap);\n\terr |= __put_user(r.ru_inblock, &ur->ru_inblock);\n\terr |= __put_user(r.ru_oublock, &ur->ru_oublock);\n\terr |= __put_user(r.ru_msgsnd, &ur->ru_msgsnd);\n\terr |= __put_user(r.ru_msgrcv, &ur->ru_msgrcv);\n\terr |= __put_user(r.ru_nsignals, &ur->ru_nsignals);\n\terr |= __put_user(r.ru_nvcsw, &ur->ru_nvcsw);\n\terr |= __put_user(r.ru_nivcsw, &ur->ru_nivcsw);\n\n\treturn err ? err : ret;\n}\n",
        "linevul": 0.999518632888794,
        "sysevr": 0.1646592915058136,
        "devign": 0.6429727077484131
    },
    {
        "code": "unsigned int __weak arch_dynirq_lower_bound(unsigned int from)\n{\n\treturn from;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "unsigned int __weak arch_dynirq_lower_bound(unsigned int from)\n{\n\treturn from;\n}\n",
        "linevul": 5.100171983940527e-05,
        "sysevr": 0.14669445157051086,
        "devign": 0.44043460488319397
    },
    {
        "code": "static int qeth_ulp_enable(struct qeth_card *card)\n{\n\tint rc;\n\tchar prot_type;\n\tstruct qeth_cmd_buffer *iob;\n\n\t/*FIXME: trace view callbacks*/\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpenabl\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, ULP_ENABLE, ULP_ENABLE_SIZE);\n\n\t*(QETH_ULP_ENABLE_LINKNUM(iob->data)) =\n\t\t(__u8) card->info.portno;\n\tif (card->options.layer2)\n\t\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\t\tprot_type = QETH_PROT_OSN2;\n\t\telse\n\t\t\tprot_type = QETH_PROT_LAYER2;\n\telse\n\t\tprot_type = QETH_PROT_TCPIP;\n\n\tmemcpy(QETH_ULP_ENABLE_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_ULP_ENABLE_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_PORTNAME_AND_LL(iob->data),\n\t       card->info.portname, 9);\n\trc = qeth_send_control_data(card, ULP_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_ulp_enable_cb, NULL);\n\treturn rc;\n\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62",
        "vul_func_with_fix": "static int qeth_ulp_enable(struct qeth_card *card)\n{\n\tint rc;\n\tchar prot_type;\n\tstruct qeth_cmd_buffer *iob;\n\n\t/*FIXME: trace view callbacks*/\n\tQETH_DBF_TEXT(SETUP, 2, \"ulpenabl\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, ULP_ENABLE, ULP_ENABLE_SIZE);\n\n\t*(QETH_ULP_ENABLE_LINKNUM(iob->data)) =\n\t\t(__u8) card->info.portno;\n\tif (card->options.layer2)\n\t\tif (card->info.type == QETH_CARD_TYPE_OSN)\n\t\t\tprot_type = QETH_PROT_OSN2;\n\t\telse\n\t\t\tprot_type = QETH_PROT_LAYER2;\n\telse\n\t\tprot_type = QETH_PROT_TCPIP;\n\n\tmemcpy(QETH_ULP_ENABLE_PROT_TYPE(iob->data), &prot_type, 1);\n\tmemcpy(QETH_ULP_ENABLE_DEST_ADDR(iob->data),\n\t       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_ULP_ENABLE_PORTNAME_AND_LL(iob->data),\n\t       card->info.portname, 9);\n\trc = qeth_send_control_data(card, ULP_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_ulp_enable_cb, NULL);\n\treturn rc;\n\n}\n",
        "linevul": 5.2072195103392005e-05,
        "sysevr": 0.14420916140079498,
        "devign": 7.406516971284686e-17
    },
    {
        "code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n\t\t\tmark_files_ro(sb);\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87",
        "vul_func_with_fix": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n//flaw_line_below:\n\t\t\tmark_files_ro(sb);\n//fix_flaw_line_below:\n//\t\t\tsb->s_readonly_remount = 1;\n//fix_flaw_line_below:\n//\t\t\tsmp_wmb();\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}\n",
        "linevul": 0.9979649782180786,
        "sysevr": 0.2430781126022339,
        "devign": 3.813261713542913e-24
    },
    {
        "code": "build_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu(i, span) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/* See the comment near build_group_mask(). */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_cpus(sg);\n\t\tif (sibling->child)\n\t\t\tcpumask_copy(sg_span, sched_domain_span(sibling->child));\n\t\telse\n\t\t\tcpumask_set_cpu(i, sg_span);\n\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tsg->sgc = *per_cpu_ptr(sdd->sgc, i);\n\t\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\t\tbuild_group_mask(sd, sg);\n\n\t\t/*\n\t\t * Initialize sgc->capacity such that even if we mess up the\n\t\t * domains and no possible iteration will get us here, we won't\n\t\t * die on a /0 trap.\n\t\t */\n\t\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\n\t\t/*\n\t\t * Make sure the first group of this domain contains the\n\t\t * canonical balance cpu. Otherwise the sched_domain iteration\n\t\t * breaks. See update_sg_lb_stats().\n\t\t */\n\t\tif ((!groups && cpumask_test_cpu(cpu, sg_span)) ||\n\t\t    group_balance_cpu(sg) == cpu)\n\t\t\tgroups = sg;\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = groups;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "build_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu(i, span) {\n\t\tstruct cpumask *sg_span;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\n\t\t/* See the comment near build_group_mask(). */\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\n\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\n\t\tif (!sg)\n\t\t\tgoto fail;\n\n\t\tsg_span = sched_group_cpus(sg);\n\t\tif (sibling->child)\n\t\t\tcpumask_copy(sg_span, sched_domain_span(sibling->child));\n\t\telse\n\t\t\tcpumask_set_cpu(i, sg_span);\n\n\t\tcpumask_or(covered, covered, sg_span);\n\n\t\tsg->sgc = *per_cpu_ptr(sdd->sgc, i);\n\t\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\t\tbuild_group_mask(sd, sg);\n\n\t\t/*\n\t\t * Initialize sgc->capacity such that even if we mess up the\n\t\t * domains and no possible iteration will get us here, we won't\n\t\t * die on a /0 trap.\n\t\t */\n\t\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\n\t\t/*\n\t\t * Make sure the first group of this domain contains the\n\t\t * canonical balance cpu. Otherwise the sched_domain iteration\n\t\t * breaks. See update_sg_lb_stats().\n\t\t */\n\t\tif ((!groups && cpumask_test_cpu(cpu, sg_span)) ||\n\t\t    group_balance_cpu(sg) == cpu)\n\t\t\tgroups = sg;\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = groups;\n\n\treturn 0;\n\nfail:\n\tfree_sched_groups(first, 0);\n\n\treturn -ENOMEM;\n}\n",
        "linevul": 5.995312312734313e-05,
        "sysevr": 0.2240435928106308,
        "devign": 9.86005350235956e-35
    },
    {
        "code": "static struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/93362fa47fe98b62e4a34ab408c4a418432e7939",
        "vul_func_with_fix": "static struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}\n",
        "linevul": 4.9236641643801704e-05,
        "sysevr": 0.13152258098125458,
        "devign": 0.24833795428276062
    },
    {
        "code": "static struct page *get_a_page(struct receive_queue *rq, gfp_t gfp_mask)\n{\n\tstruct page *p = rq->pages;\n\n\tif (p) {\n\t\trq->pages = (struct page *)p->private;\n\t\t/* clear private here, it is used to chain pages */\n\t\tp->private = 0;\n\t} else\n\t\tp = alloc_page(gfp_mask);\n\treturn p;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39",
        "vul_func_with_fix": "static struct page *get_a_page(struct receive_queue *rq, gfp_t gfp_mask)\n{\n\tstruct page *p = rq->pages;\n\n\tif (p) {\n\t\trq->pages = (struct page *)p->private;\n\t\t/* clear private here, it is used to chain pages */\n\t\tp->private = 0;\n\t} else\n\t\tp = alloc_page(gfp_mask);\n\treturn p;\n}\n",
        "linevul": 0.00010001048940466717,
        "sysevr": 0.11922331899404526,
        "devign": 0.04126354679465294
    },
    {
        "code": "static bool is_sysenter_singlestep(struct pt_regs *regs)\n{\n\t/*\n\t * We don't try for precision here.  If we're anywhere in the region of\n\t * code that can be single-stepped in the SYSENTER entry path, then\n\t * assume that this is a useless single-step trap due to SYSENTER\n\t * being invoked with TF set.  (We don't know in advance exactly\n\t * which instructions will be hit because BTF could plausibly\n\t * be set.)\n\t */\n#ifdef CONFIG_X86_32\n\treturn (regs->ip - (unsigned long)__begin_SYSENTER_singlestep_region) <\n\t\t(unsigned long)__end_SYSENTER_singlestep_region -\n\t\t(unsigned long)__begin_SYSENTER_singlestep_region;\n#elif defined(CONFIG_IA32_EMULATION)\n\treturn (regs->ip - (unsigned long)entry_SYSENTER_compat) <\n\t\t(unsigned long)__end_entry_SYSENTER_compat -\n\t\t(unsigned long)entry_SYSENTER_compat;\n#else\n\treturn false;\n#endif\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9",
        "vul_func_with_fix": "static bool is_sysenter_singlestep(struct pt_regs *regs)\n{\n\t/*\n\t * We don't try for precision here.  If we're anywhere in the region of\n\t * code that can be single-stepped in the SYSENTER entry path, then\n\t * assume that this is a useless single-step trap due to SYSENTER\n\t * being invoked with TF set.  (We don't know in advance exactly\n\t * which instructions will be hit because BTF could plausibly\n\t * be set.)\n\t */\n#ifdef CONFIG_X86_32\n\treturn (regs->ip - (unsigned long)__begin_SYSENTER_singlestep_region) <\n\t\t(unsigned long)__end_SYSENTER_singlestep_region -\n\t\t(unsigned long)__begin_SYSENTER_singlestep_region;\n#elif defined(CONFIG_IA32_EMULATION)\n\treturn (regs->ip - (unsigned long)entry_SYSENTER_compat) <\n\t\t(unsigned long)__end_entry_SYSENTER_compat -\n\t\t(unsigned long)entry_SYSENTER_compat;\n#else\n\treturn false;\n#endif\n}\n",
        "linevul": 9.315676288679242e-05,
        "sysevr": 0.15723979473114014,
        "devign": 0.0020832482259720564
    },
    {
        "code": "static int misaligned_store(struct pt_regs *regs,\n\t\t\t    __u32 opcode,\n\t\t\t    int displacement_not_indexed,\n\t\t\t    int width_shift)\n{\n\t/* Return -1 for a fault, 0 for OK */\n\tint error;\n\tint srcreg;\n\t__u64 address;\n\n\terror = generate_and_check_address(regs, opcode,\n\t\t\tdisplacement_not_indexed, width_shift, &address);\n\tif (error < 0) {\n \t\treturn error;\n \t}\n \n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n \n \tsrcreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n\t\t__u64 buffer;\n\n\t\tif (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\t*(__u16 *) &buffer = (__u16) regs->regs[srcreg];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*(__u32 *) &buffer = (__u32) regs->regs[srcreg];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbuffer = regs->regs[srcreg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {\n\t\t\treturn -1; /* fault */\n\t\t}\n\t} else {\n\t\t/* kernel mode - we can take short cuts since if we fault, it's a genuine bug */\n\t\t__u64 val = regs->regs[srcreg];\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\tmisaligned_kernel_word_store(address, val);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tasm (\"stlo.l %1, 0, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tasm (\"sthi.l %1, 3, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tasm (\"stlo.q %1, 0, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tasm (\"sthi.q %1, 7, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int misaligned_store(struct pt_regs *regs,\n\t\t\t    __u32 opcode,\n\t\t\t    int displacement_not_indexed,\n\t\t\t    int width_shift)\n{\n\t/* Return -1 for a fault, 0 for OK */\n\tint error;\n\tint srcreg;\n\t__u64 address;\n\n\terror = generate_and_check_address(regs, opcode,\n\t\t\tdisplacement_not_indexed, width_shift, &address);\n\tif (error < 0) {\n \t\treturn error;\n \t}\n \n//flaw_line_below:\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n//fix_flaw_line_below:\n//\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\n \n \tsrcreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n\t\t__u64 buffer;\n\n\t\tif (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\t*(__u16 *) &buffer = (__u16) regs->regs[srcreg];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*(__u32 *) &buffer = (__u32) regs->regs[srcreg];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbuffer = regs->regs[srcreg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {\n\t\t\treturn -1; /* fault */\n\t\t}\n\t} else {\n\t\t/* kernel mode - we can take short cuts since if we fault, it's a genuine bug */\n\t\t__u64 val = regs->regs[srcreg];\n\n\t\tswitch (width_shift) {\n\t\tcase 1:\n\t\t\tmisaligned_kernel_word_store(address, val);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tasm (\"stlo.l %1, 0, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tasm (\"sthi.l %1, 3, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tasm (\"stlo.q %1, 0, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tasm (\"sthi.q %1, 7, %0\" : : \"r\" (val), \"r\" (address));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(\"Unexpected width_shift %d in misaligned_store, PC=%08lx\\n\",\n\t\t\t\twidth_shift, (unsigned long) regs->pc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n",
        "linevul": 0.9996461868286133,
        "sysevr": 0.15704627335071564,
        "devign": 0.9808856844902039
    },
    {
        "code": "static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),\n\t\t\t  struct sk_buff_head *hitlist)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *next;\n\n\tspin_lock(&x->sk_receive_queue.lock);\n\tskb_queue_walk_safe(&x->sk_receive_queue, skb, next) {\n\t\t/* Do we have file descriptors ? */\n\t\tif (UNIXCB(skb).fp) {\n\t\t\tbool hit = false;\n\t\t\t/* Process the descriptors of this socket */\n\t\t\tint nfd = UNIXCB(skb).fp->count;\n\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\n\t\t\twhile (nfd--) {\n\t\t\t\t/* Get the socket the fd matches if it indeed does so */\n\t\t\t\tstruct sock *sk = unix_get_socket(*fp++);\n\n\t\t\t\tif (sk) {\n\t\t\t\t\tstruct unix_sock *u = unix_sk(sk);\n\n\t\t\t\t\t/* Ignore non-candidates, they could\n\t\t\t\t\t * have been added to the queues after\n\t\t\t\t\t * starting the garbage collection\n\t\t\t\t\t */\n\t\t\t\t\tif (test_bit(UNIX_GC_CANDIDATE, &u->gc_flags)) {\n\t\t\t\t\t\thit = true;\n\n\t\t\t\t\t\tfunc(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hit && hitlist != NULL) {\n\t\t\t\t__skb_unlink(skb, &x->sk_receive_queue);\n\t\t\t\t__skb_queue_tail(hitlist, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&x->sk_receive_queue.lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6",
        "vul_func_with_fix": "static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),\n\t\t\t  struct sk_buff_head *hitlist)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *next;\n\n\tspin_lock(&x->sk_receive_queue.lock);\n\tskb_queue_walk_safe(&x->sk_receive_queue, skb, next) {\n\t\t/* Do we have file descriptors ? */\n\t\tif (UNIXCB(skb).fp) {\n\t\t\tbool hit = false;\n\t\t\t/* Process the descriptors of this socket */\n\t\t\tint nfd = UNIXCB(skb).fp->count;\n\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\n\t\t\twhile (nfd--) {\n\t\t\t\t/* Get the socket the fd matches if it indeed does so */\n\t\t\t\tstruct sock *sk = unix_get_socket(*fp++);\n\n\t\t\t\tif (sk) {\n\t\t\t\t\tstruct unix_sock *u = unix_sk(sk);\n\n\t\t\t\t\t/* Ignore non-candidates, they could\n\t\t\t\t\t * have been added to the queues after\n\t\t\t\t\t * starting the garbage collection\n\t\t\t\t\t */\n\t\t\t\t\tif (test_bit(UNIX_GC_CANDIDATE, &u->gc_flags)) {\n\t\t\t\t\t\thit = true;\n\n\t\t\t\t\t\tfunc(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hit && hitlist != NULL) {\n\t\t\t\t__skb_unlink(skb, &x->sk_receive_queue);\n\t\t\t\t__skb_queue_tail(hitlist, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&x->sk_receive_queue.lock);\n}\n",
        "linevul": 6.411732465494424e-05,
        "sysevr": 0.14090202748775482,
        "devign": 6.172562867735529e-15
    },
    {
        "code": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_state_recovery(server->nfs_client);\n\t\t\t\treturn err;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\t\treturn err;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_state_recovery(server->nfs_client);\n\t\t\t\treturn err;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "linevul": 0.0001925153046613559,
        "sysevr": 0.15974415838718414,
        "devign": 3.1320835681969417e-12
    },
    {
        "code": "static int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -EIO;\n\t}\n\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\treq->num_pages++;\n\tdata->nr_pages--;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876",
        "vul_func_with_fix": "static int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tint nr_alloc = min_t(unsigned, data->nr_pages,\n\t\t\t\t     FUSE_MAX_PAGES_PER_REQ);\n\t\tfuse_send_readpages(req, data->file);\n\t\tif (fc->async_read)\n\t\t\treq = fuse_get_req_for_background(fc, nr_alloc);\n\t\telse\n\t\t\treq = fuse_get_req(fc, nr_alloc);\n\n\t\tdata->req = req;\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\n\tif (WARN_ON(req->num_pages >= req->max_pages)) {\n\t\tfuse_put_request(fc, req);\n\t\treturn -EIO;\n\t}\n\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->page_descs[req->num_pages].length = PAGE_SIZE;\n\treq->num_pages++;\n\tdata->nr_pages--;\n\treturn 0;\n}\n",
        "linevul": 0.00011755847663152963,
        "sysevr": 0.15360061824321747,
        "devign": 2.4063277407208348e-29
    },
    {
        "code": "nfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}\n",
        "linevul": 5.411259553511627e-05,
        "sysevr": 0.16375017166137695,
        "devign": 2.3898244307929417e-06
    },
    {
        "code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n \t\tconst struct iovec *iov = i->iov;\n \t\tsize_t base = i->iov_offset;\n \n\t\twhile (bytes) {\n \t\t\tint copy = min(bytes, iov->iov_len - base);\n \n \t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
        "vul_func_with_fix": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n \t\tconst struct iovec *iov = i->iov;\n \t\tsize_t base = i->iov_offset;\n \n//flaw_line_below:\n\t\twhile (bytes) {\n//fix_flaw_line_below:\n//\t\t/*\n//fix_flaw_line_below:\n//\t\t * The !iov->iov_len check ensures we skip over unlikely\n//fix_flaw_line_below:\n//\t\t * zero-length segments.\n//fix_flaw_line_below:\n//\t\t */\n//fix_flaw_line_below:\n//\t\twhile (bytes || !iov->iov_len) {\n \t\t\tint copy = min(bytes, iov->iov_len - base);\n \n \t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}\n",
        "linevul": 0.9995998740196228,
        "sysevr": 0.15217387676239014,
        "devign": 0.9943944215774536
    },
    {
        "code": "static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n \tunsigned delay;\n \n \t/* Continue a partial initialization */\n\tif (type == HUB_INIT2)\n\t\tgoto init2;\n\tif (type == HUB_INIT3)\n \t\tgoto init3;\n \n \t/* The superspeed hub except for root hub has to use Hub Depth\n \t * value as an offset into the route string to locate the bits\n\t * it uses to determine the downstream port number. So hub driver\n\t * should send a set hub depth request to superspeed hub after\n\t * the superspeed hub is set configuration in initialization or\n\t * reset procedure.\n\t *\n\t * After a resume, port power should still be on.\n\t * For any other type of activation, turn it on.\n\t */\n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t/* Speed up system boot by using a delayed_work for the\n\t\t * hub's initial power-up delays.  This is pretty awkward\n\t\t * and the implementation looks like a home-brewed sort of\n\t\t * setjmp/longjmp, but it saves at least 100 ms for each\n\t\t * root hub (assuming usbcore is compiled into the kernel\n\t\t * rather than as a module).  It adds up.\n\t\t *\n\t\t * This can't be done for HUB_RESUME or HUB_RESET_RESUME\n\t\t * because for those activation types the ports have to be\n\t\t * operational when we return.  In theory this could be done\n\t\t * for HUB_POST_RESET, but it's easier not to.\n\t\t */\n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t/* Suppress autosuspend until init is done */\n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t/* Continues at init2: below */\n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t/* The internal host controller state for the hub device\n\t\t\t * may be gone after a host power loss on system resume.\n\t\t\t * Update the device's info so the HW knows it's a hub.\n\t\t\t */\n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev, \"Host not \"\n\t\t\t\t\t\t\t\"accepting hub info \"\n\t\t\t\t\t\t\t\"update.\\n\");\n\t\t\t\t\tdev_err(hub->intfdev, \"LS/FS devices \"\n\t\t\t\t\t\t\t\"and hubs may not work \"\n\t\t\t\t\t\t\t\"under this hub\\n.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t}\n init2:\n\n\t/*\n\t * Check each port and set hub->change_bits to let hub_wq know\n\t * which ports need attention.\n\t */\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t/*\n\t\t * After anything other than HUB_RESUME (i.e., initialization\n\t\t * or any sort of reset), every port should be disabled.\n\t\t * Unconnected ports should likewise be disabled (paranoia),\n\t\t * and so should ports for which we have no usb_device.\n\t\t */\n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t/*\n\t\t\t * USB3 protocol ports will automatically transition\n\t\t\t * to Enabled state when detect an USB3.0 device attach.\n\t\t\t * Do not disable USB3 protocol ports, just pretend\n\t\t\t * power was lost\n\t\t\t */\n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t/* Clear status-change flags; we'll debounce later */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t/* We can forget about a \"removed\" device when there's a\n\t\t * physical disconnect or the connect status changes.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t/* Tell hub_wq to disconnect the device or\n\t\t\t * check for a new connection\n\t\t\t */\n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t/* The power session apparently survived the resume.\n\t\t\t * If there was an overcurrent or suspend change\n\t\t\t * (i.e., remote wakeup request), have hub_wq\n\t\t\t * take care of it.  Look at the port link state\n\t\t\t * for USB 3.0 hubs, since they don't have a suspend\n\t\t\t * change bit, and they don't set the port link change\n\t\t\t * bit on device-initiated resume.\n\t\t\t */\n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t/* Don't set the change_bits when the device\n\t\t\t * was powered off.\n\t\t\t */\n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t/* The power session is gone; tell hub_wq */\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t/* If no port-status-change flags were set, we don't need any\n\t * debouncing.  If flags were set we can try to debounce the\n\t * ports all at once right now, instead of letting hub_wq do them\n\t * one at a time later on.\n\t *\n\t * If any port-status changes do occur during this delay, hub_wq\n\t * will see them later and handle them normally.\n\t */\n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t/* Don't do a long sleep inside a workqueue routine */\n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n \t\t\tqueue_delayed_work(system_power_efficient_wq,\n \t\t\t\t\t&hub->init_work,\n \t\t\t\t\tmsecs_to_jiffies(delay));\n \t\t\treturn;\t\t/* Continues at init3: below */\n \t\t} else {\n \t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t/* Scan all ports that need attention */\n\tkick_hub_wq(hub);\n\n \t/* Allow autosuspend if it was suppressed */\n \tif (type <= HUB_INIT3)\n \t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea",
        "vul_func_with_fix": "static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n \tunsigned delay;\n \n \t/* Continue a partial initialization */\n//flaw_line_below:\n\tif (type == HUB_INIT2)\n//flaw_line_below:\n\t\tgoto init2;\n//flaw_line_below:\n\tif (type == HUB_INIT3)\n//fix_flaw_line_below:\n//\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n//fix_flaw_line_below:\n//\t\tdevice_lock(hub->intfdev);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/* Was the hub disconnected while we were waiting? */\n//fix_flaw_line_below:\n//\t\tif (hub->disconnected) {\n//fix_flaw_line_below:\n//\t\t\tdevice_unlock(hub->intfdev);\n//fix_flaw_line_below:\n//\t\t\tkref_put(&hub->kref, hub_release);\n//fix_flaw_line_below:\n//\t\t\treturn;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tif (type == HUB_INIT2)\n//fix_flaw_line_below:\n//\t\t\tgoto init2;\n \t\tgoto init3;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\tkref_get(&hub->kref);\n \n \t/* The superspeed hub except for root hub has to use Hub Depth\n \t * value as an offset into the route string to locate the bits\n\t * it uses to determine the downstream port number. So hub driver\n\t * should send a set hub depth request to superspeed hub after\n\t * the superspeed hub is set configuration in initialization or\n\t * reset procedure.\n\t *\n\t * After a resume, port power should still be on.\n\t * For any other type of activation, turn it on.\n\t */\n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t/* Speed up system boot by using a delayed_work for the\n\t\t * hub's initial power-up delays.  This is pretty awkward\n\t\t * and the implementation looks like a home-brewed sort of\n\t\t * setjmp/longjmp, but it saves at least 100 ms for each\n\t\t * root hub (assuming usbcore is compiled into the kernel\n\t\t * rather than as a module).  It adds up.\n\t\t *\n\t\t * This can't be done for HUB_RESUME or HUB_RESET_RESUME\n\t\t * because for those activation types the ports have to be\n\t\t * operational when we return.  In theory this could be done\n\t\t * for HUB_POST_RESET, but it's easier not to.\n\t\t */\n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t/* Suppress autosuspend until init is done */\n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t/* Continues at init2: below */\n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t/* The internal host controller state for the hub device\n\t\t\t * may be gone after a host power loss on system resume.\n\t\t\t * Update the device's info so the HW knows it's a hub.\n\t\t\t */\n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev, \"Host not \"\n\t\t\t\t\t\t\t\"accepting hub info \"\n\t\t\t\t\t\t\t\"update.\\n\");\n\t\t\t\t\tdev_err(hub->intfdev, \"LS/FS devices \"\n\t\t\t\t\t\t\t\"and hubs may not work \"\n\t\t\t\t\t\t\t\"under this hub\\n.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t}\n init2:\n\n\t/*\n\t * Check each port and set hub->change_bits to let hub_wq know\n\t * which ports need attention.\n\t */\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t/*\n\t\t * After anything other than HUB_RESUME (i.e., initialization\n\t\t * or any sort of reset), every port should be disabled.\n\t\t * Unconnected ports should likewise be disabled (paranoia),\n\t\t * and so should ports for which we have no usb_device.\n\t\t */\n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t/*\n\t\t\t * USB3 protocol ports will automatically transition\n\t\t\t * to Enabled state when detect an USB3.0 device attach.\n\t\t\t * Do not disable USB3 protocol ports, just pretend\n\t\t\t * power was lost\n\t\t\t */\n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t/* Clear status-change flags; we'll debounce later */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t/* We can forget about a \"removed\" device when there's a\n\t\t * physical disconnect or the connect status changes.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t/* Tell hub_wq to disconnect the device or\n\t\t\t * check for a new connection\n\t\t\t */\n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t/* The power session apparently survived the resume.\n\t\t\t * If there was an overcurrent or suspend change\n\t\t\t * (i.e., remote wakeup request), have hub_wq\n\t\t\t * take care of it.  Look at the port link state\n\t\t\t * for USB 3.0 hubs, since they don't have a suspend\n\t\t\t * change bit, and they don't set the port link change\n\t\t\t * bit on device-initiated resume.\n\t\t\t */\n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t/* Don't set the change_bits when the device\n\t\t\t * was powered off.\n\t\t\t */\n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t/* The power session is gone; tell hub_wq */\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t/* If no port-status-change flags were set, we don't need any\n\t * debouncing.  If flags were set we can try to debounce the\n\t * ports all at once right now, instead of letting hub_wq do them\n\t * one at a time later on.\n\t *\n\t * If any port-status changes do occur during this delay, hub_wq\n\t * will see them later and handle them normally.\n\t */\n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t/* Don't do a long sleep inside a workqueue routine */\n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n \t\t\tqueue_delayed_work(system_power_efficient_wq,\n \t\t\t\t\t&hub->init_work,\n \t\t\t\t\tmsecs_to_jiffies(delay));\n//fix_flaw_line_below:\n//\t\t\tdevice_unlock(hub->intfdev);\n \t\t\treturn;\t\t/* Continues at init3: below */\n \t\t} else {\n \t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t/* Scan all ports that need attention */\n\tkick_hub_wq(hub);\n\n \t/* Allow autosuspend if it was suppressed */\n \tif (type <= HUB_INIT3)\n \t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (type == HUB_INIT2 || type == HUB_INIT3)\n//fix_flaw_line_below:\n//\t\tdevice_unlock(hub->intfdev);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tkref_put(&hub->kref, hub_release);\n }\n",
        "linevul": 0.9995952248573303,
        "sysevr": 0.18886759877204895,
        "devign": 4.516684183104467e-15
    },
    {
        "code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n",
        "linevul": 5.450605385703966e-05,
        "sysevr": 0.15566816926002502,
        "devign": 6.756923698266219e-16
    },
    {
        "code": "static int uvesafb_is_valid_mode(struct fb_videomode *mode,\n\t\t\t\t struct fb_info *info)\n{\n\tif (info->monspecs.gtf) {\n\t\tfb_videomode_to_var(&info->var, mode);\n\t\tif (fb_validate_mode(&info->var, info))\n\t\t\treturn 0;\n\t}\n\n\tif (uvesafb_vbe_find_mode(info->par, mode->xres, mode->yres, 8,\n\t\t\t\tUVESAFB_EXACT_RES) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713",
        "vul_func_with_fix": "static int uvesafb_is_valid_mode(struct fb_videomode *mode,\n\t\t\t\t struct fb_info *info)\n{\n\tif (info->monspecs.gtf) {\n\t\tfb_videomode_to_var(&info->var, mode);\n\t\tif (fb_validate_mode(&info->var, info))\n\t\t\treturn 0;\n\t}\n\n\tif (uvesafb_vbe_find_mode(info->par, mode->xres, mode->yres, 8,\n\t\t\t\tUVESAFB_EXACT_RES) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}\n",
        "linevul": 4.606290895026177e-05,
        "sysevr": 0.1276020109653473,
        "devign": 4.549508270113023e-10
    },
    {
        "code": "static int snd_seq_client_enqueue_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tstruct file *file, int blocking,\n\t\t\t\t\tint atomic, int hop)\n{\n\tstruct snd_seq_event_cell *cell;\n\tint err;\n\n\t/* special queue values - force direct passing */\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t} else\n#ifdef SUPPORT_BROADCAST\n\t\tif (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST) {\n\t\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_BROADCAST;\n\t\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t\t}\n#endif\n\tif (event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\t/* check presence of source port */\n\t\tstruct snd_seq_client_port *src_port = snd_seq_port_use_ptr(client, event->source.port);\n\t\tif (src_port == NULL)\n\t\t\treturn -EINVAL;\n\t\tsnd_seq_port_unlock(src_port);\n\t}\n\n\t/* direct event processing without enqueued */\n\tif (snd_seq_ev_is_direct(event)) {\n\t\tif (event->type == SNDRV_SEQ_EVENT_NOTE)\n\t\t\treturn -EINVAL; /* this event must be enqueued! */\n\t\treturn snd_seq_deliver_event(client, event, atomic, hop);\n\t}\n\n\t/* Not direct, normal queuing */\n\tif (snd_seq_queue_is_used(event->queue, client->number) <= 0)\n\t\treturn -EINVAL;  /* invalid queue */\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn -ENXIO; /* queue is not allocated */\n\n\t/* allocate an event cell */\n\terr = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic, file);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* we got a cell. enqueue it. */\n\tif ((err = snd_seq_enqueue_event(cell, atomic, hop)) < 0) {\n\t\tsnd_seq_cell_free(cell);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/030e2c78d3a91dd0d27fef37e91950dde333eba1",
        "vul_func_with_fix": "static int snd_seq_client_enqueue_event(struct snd_seq_client *client,\n\t\t\t\t\tstruct snd_seq_event *event,\n\t\t\t\t\tstruct file *file, int blocking,\n\t\t\t\t\tint atomic, int hop)\n{\n\tstruct snd_seq_event_cell *cell;\n\tint err;\n\n\t/* special queue values - force direct passing */\n\tif (event->queue == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\n\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t} else\n#ifdef SUPPORT_BROADCAST\n\t\tif (event->queue == SNDRV_SEQ_ADDRESS_BROADCAST) {\n\t\t\tevent->dest.client = SNDRV_SEQ_ADDRESS_BROADCAST;\n\t\t\tevent->queue = SNDRV_SEQ_QUEUE_DIRECT;\n\t\t}\n#endif\n\tif (event->dest.client == SNDRV_SEQ_ADDRESS_SUBSCRIBERS) {\n\t\t/* check presence of source port */\n\t\tstruct snd_seq_client_port *src_port = snd_seq_port_use_ptr(client, event->source.port);\n\t\tif (src_port == NULL)\n\t\t\treturn -EINVAL;\n\t\tsnd_seq_port_unlock(src_port);\n\t}\n\n\t/* direct event processing without enqueued */\n\tif (snd_seq_ev_is_direct(event)) {\n\t\tif (event->type == SNDRV_SEQ_EVENT_NOTE)\n\t\t\treturn -EINVAL; /* this event must be enqueued! */\n\t\treturn snd_seq_deliver_event(client, event, atomic, hop);\n\t}\n\n\t/* Not direct, normal queuing */\n\tif (snd_seq_queue_is_used(event->queue, client->number) <= 0)\n\t\treturn -EINVAL;  /* invalid queue */\n\tif (! snd_seq_write_pool_allocated(client))\n\t\treturn -ENXIO; /* queue is not allocated */\n\n\t/* allocate an event cell */\n\terr = snd_seq_event_dup(client->pool, event, &cell, !blocking || atomic, file);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* we got a cell. enqueue it. */\n\tif ((err = snd_seq_enqueue_event(cell, atomic, hop)) < 0) {\n\t\tsnd_seq_cell_free(cell);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 0.00011885153799084947,
        "sysevr": 0.1471220850944519,
        "devign": 1.917751889129243e-30
    },
    {
        "code": "static int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_lookup_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lookup(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server\n\t\t\t,!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int nfs4_xdr_dec_lookup(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs4_lookup_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_lookup(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfh(xdr, res->fh);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getfattr(xdr, res->fattr, res->server\n\t\t\t,!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}\n",
        "linevul": 0.00014669344818685204,
        "sysevr": 0.14979596436023712,
        "devign": 2.182900288971723e-06
    },
    {
        "code": "static int l2cap_parse_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *req = pi->conf_req;\n\tint len = pi->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n \t\t}\n \t}\n \n \tif (result == L2CAP_CONF_SUCCESS) {\n \t\t/* Configure output options and let the other side know\n \t\t * which ones we don't like. */\n \n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n\t\t\tif (mtu < pi->omtu)\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\t\telse {\n\t\t\t\tpi->omtu = mtu;\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t\t\t}\n \n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t} else {\n \t\t\tresult = L2CAP_CONF_UNACCEPT;\n \n \t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n \n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n \t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t}\n\t}\n \n \trsp->scid   = cpu_to_le16(pi->dcid);\n \trsp->result = cpu_to_le16(result);\n \trsp->flags  = cpu_to_le16(0x0000);\n \n \treturn ptr - data;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
        "vul_func_with_fix": "static int l2cap_parse_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *req = pi->conf_req;\n\tint len = pi->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tpi->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen == sizeof(rfc))\n\t\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n \t\t}\n \t}\n \n//fix_flaw_line_below:\n//\tif (pi->num_conf_rsp || pi->num_conf_req)\n//fix_flaw_line_below:\n//\t\tgoto done;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tswitch (pi->mode) {\n//fix_flaw_line_below:\n//\tcase L2CAP_MODE_STREAMING:\n//fix_flaw_line_below:\n//\tcase L2CAP_MODE_ERTM:\n//fix_flaw_line_below:\n//\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n//fix_flaw_line_below:\n//\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))\n//fix_flaw_line_below:\n//\t\t\treturn -ECONNREFUSED;\n//fix_flaw_line_below:\n//\t\tbreak;\n//fix_flaw_line_below:\n//\tdefault:\n//fix_flaw_line_below:\n//\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n//fix_flaw_line_below:\n//\t\tbreak;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//done:\n//fix_flaw_line_below:\n//\tif (pi->mode != rfc.mode) {\n//fix_flaw_line_below:\n//\t\tresult = L2CAP_CONF_UNACCEPT;\n//fix_flaw_line_below:\n//\t\trfc.mode = pi->mode;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (pi->num_conf_rsp == 1)\n//fix_flaw_line_below:\n//\t\t\treturn -ECONNREFUSED;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n//fix_flaw_line_below:\n//\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\n \tif (result == L2CAP_CONF_SUCCESS) {\n \t\t/* Configure output options and let the other side know\n \t\t * which ones we don't like. */\n \n//flaw_line_below:\n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n//flaw_line_below:\n\t\t\tif (mtu < pi->omtu)\n//flaw_line_below:\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n//flaw_line_below:\n\t\t\telse {\n//flaw_line_below:\n\t\t\t\tpi->omtu = mtu;\n//flaw_line_below:\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n//flaw_line_below:\n\t\t\t}\n//fix_flaw_line_below:\n//\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n//fix_flaw_line_below:\n//\t\t\tresult = L2CAP_CONF_UNACCEPT;\n//fix_flaw_line_below:\n//\t\telse {\n//fix_flaw_line_below:\n//\t\t\tpi->omtu = mtu;\n//fix_flaw_line_below:\n//\t\t\tpi->conf_state |= L2CAP_CONF_MTU_DONE;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n \n//flaw_line_below:\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n//flaw_line_below:\n\t\t} else {\n//fix_flaw_line_below:\n//\t\tswitch (rfc.mode) {\n//fix_flaw_line_below:\n//\t\tcase L2CAP_MODE_BASIC:\n//fix_flaw_line_below:\n//\t\t\tpi->fcs = L2CAP_FCS_NONE;\n//fix_flaw_line_below:\n//\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tcase L2CAP_MODE_ERTM:\n//fix_flaw_line_below:\n//\t\t\tpi->remote_tx_win = rfc.txwin_size;\n//fix_flaw_line_below:\n//\t\t\tpi->remote_max_tx = rfc.max_transmit;\n//fix_flaw_line_below:\n//\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\trfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n//fix_flaw_line_below:\n//\t\t\trfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tcase L2CAP_MODE_STREAMING:\n//fix_flaw_line_below:\n//\t\t\tpi->remote_tx_win = rfc.txwin_size;\n//fix_flaw_line_below:\n//\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n//fix_flaw_line_below:\n//\t\t\tbreak;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tdefault:\n \t\t\tresult = L2CAP_CONF_UNACCEPT;\n \n \t\t\tmemset(&rfc, 0, sizeof(rfc));\n//flaw_line_below:\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n//fix_flaw_line_below:\n//\t\t\trfc.mode = pi->mode;\n//fix_flaw_line_below:\n//\t\t}\n \n//flaw_line_below:\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n//fix_flaw_line_below:\n//\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n \t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t}\n \n//fix_flaw_line_below:\n//\t\tif (result == L2CAP_CONF_SUCCESS)\n//fix_flaw_line_below:\n//\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n//fix_flaw_line_below:\n//\t}\n \trsp->scid   = cpu_to_le16(pi->dcid);\n \trsp->result = cpu_to_le16(result);\n \trsp->flags  = cpu_to_le16(0x0000);\n \n \treturn ptr - data;\n }\n",
        "linevul": 5.866187348146923e-05,
        "sysevr": 0.15914295613765717,
        "devign": 0.9999544620513916
    },
    {
        "code": "static int tm_cvsx_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c1fa0768a8713b135848f78fd43ffc208d8ded70",
        "vul_func_with_fix": "static int tm_cvsx_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}\n",
        "linevul": 8.039369276957586e-05,
        "sysevr": 0.12586252391338348,
        "devign": 0.5015424489974976
    },
    {
        "code": " static int __init init(void)\n {\n\tint ret;\n\n\tif (!crypt_s390_func_available(KIMD_SHA_512, CRYPT_S390_MSA))\n\t\treturn -EOPNOTSUPP;\n\tif ((ret = crypto_register_shash(&sha512_alg)) < 0)\n\t\tgoto out;\n\tif ((ret = crypto_register_shash(&sha384_alg)) < 0)\n\t\tcrypto_unregister_shash(&sha512_alg);\nout:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": " static int __init init(void)\n {\n\tint ret;\n\n\tif (!crypt_s390_func_available(KIMD_SHA_512, CRYPT_S390_MSA))\n\t\treturn -EOPNOTSUPP;\n\tif ((ret = crypto_register_shash(&sha512_alg)) < 0)\n\t\tgoto out;\n\tif ((ret = crypto_register_shash(&sha384_alg)) < 0)\n\t\tcrypto_unregister_shash(&sha512_alg);\nout:\n\treturn ret;\n}\n",
        "linevul": 7.963821553857997e-05,
        "sysevr": 0.12784959375858307,
        "devign": 0.610379159450531
    },
    {
        "code": "int hugetlb_mempolicy_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *length, loff_t *ppos)\n{\n\treturn hugetlb_sysctl_handler_common(true, table, write,\n\t\t\t\t\t\t\tbuffer, length, ppos);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c50ac050811d6485616a193eb0f37bfbd191cc89",
        "vul_func_with_fix": "int hugetlb_mempolicy_sysctl_handler(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *length, loff_t *ppos)\n{\n\treturn hugetlb_sysctl_handler_common(true, table, write,\n\t\t\t\t\t\t\tbuffer, length, ppos);\n}\n",
        "linevul": 5.3662388381781057e-05,
        "sysevr": 0.1665354073047638,
        "devign": 0.3788151741027832
    },
    {
        "code": "size_t get_numpages(const size_t wsize, const size_t len, size_t *cur_len)\n{\n\tsize_t num_pages;\n\tsize_t clen;\n\n\tclen = min_t(const size_t, len, wsize);\n\tnum_pages = DIV_ROUND_UP(clen, PAGE_SIZE);\n\n\tif (cur_len)\n\t\t*cur_len = clen;\n\n\treturn num_pages;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f",
        "vul_func_with_fix": "size_t get_numpages(const size_t wsize, const size_t len, size_t *cur_len)\n{\n\tsize_t num_pages;\n\tsize_t clen;\n\n\tclen = min_t(const size_t, len, wsize);\n\tnum_pages = DIV_ROUND_UP(clen, PAGE_SIZE);\n\n\tif (cur_len)\n\t\t*cur_len = clen;\n\n\treturn num_pages;\n}\n",
        "linevul": 5.8281428209738806e-05,
        "sysevr": 0.1986089050769806,
        "devign": 3.250183664414187e-14
    },
    {
        "code": "static inline void unregister_as_ext3(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b",
        "vul_func_with_fix": "static inline void unregister_as_ext3(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n}\n",
        "linevul": 7.809011003701016e-05,
        "sysevr": 0.12558448314666748,
        "devign": 1.4329007314017872e-08
    },
    {
        "code": "isdn_net_rcv_skb(int idx, struct sk_buff *skb)\n{\n\tisdn_net_dev *p = dev->rx_netdev[idx];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\n\t\t    (!lp->dialstate)) {\n\t\t\tisdn_net_receive(p->dev, skb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "isdn_net_rcv_skb(int idx, struct sk_buff *skb)\n{\n\tisdn_net_dev *p = dev->rx_netdev[idx];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\n\t\t    (!lp->dialstate)) {\n\t\t\tisdn_net_receive(p->dev, skb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "linevul": 4.9809827032731846e-05,
        "sysevr": 0.15309301018714905,
        "devign": 1.750255357313435e-10
    },
    {
        "code": "static ssize_t usbip_debug_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lx\\n\", usbip_debug_flag);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b348d7dddb6c4fbfc810b7a0626e8ec9e29f7cbb",
        "vul_func_with_fix": "static ssize_t usbip_debug_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lx\\n\", usbip_debug_flag);\n}\n",
        "linevul": 5.790112481918186e-05,
        "sysevr": 0.12323302775621414,
        "devign": 7.346808388319914e-07
    },
    {
        "code": "static int follow_managed(struct path *path, struct nameidata *nd)\n{\n\tstruct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */\n\tunsigned managed;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\t/* Given that we're not holding a lock here, we retain the value in a\n\t * local variable for each dentry as we look at it so that we don't see\n\t * the components of that value change under us */\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       managed &= DCACHE_MANAGED_DENTRY,\n\t       unlikely(managed != 0)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Something is mounted on this dentry in another\n\t\t\t * namespace and/or whatever was mounted there in this\n\t\t\t * namespace got unmounted before lookup_mnt() could\n\t\t\t * get it */\n\t\t}\n\n\t\t/* Handle an automount point */\n\t\tif (managed & DCACHE_NEED_AUTOMOUNT) {\n\t\t\tret = follow_automount(path, nd, &need_mntput);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We didn't change the current path point */\n\t\tbreak;\n\t}\n\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (ret == -EISDIR || !ret)\n\t\tret = 1;\n\tif (need_mntput)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\tif (unlikely(ret < 0))\n\t\tpath_put_conditional(path, nd);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca",
        "vul_func_with_fix": "static int follow_managed(struct path *path, struct nameidata *nd)\n{\n\tstruct vfsmount *mnt = path->mnt; /* held by caller, must be left alone */\n\tunsigned managed;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\t/* Given that we're not holding a lock here, we retain the value in a\n\t * local variable for each dentry as we look at it so that we don't see\n\t * the components of that value change under us */\n\twhile (managed = ACCESS_ONCE(path->dentry->d_flags),\n\t       managed &= DCACHE_MANAGED_DENTRY,\n\t       unlikely(managed != 0)) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (managed & DCACHE_MANAGE_TRANSIT) {\n\t\t\tBUG_ON(!path->dentry->d_op);\n\t\t\tBUG_ON(!path->dentry->d_op->d_manage);\n\t\t\tret = path->dentry->d_op->d_manage(path->dentry, false);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Transit to a mounted filesystem. */\n\t\tif (managed & DCACHE_MOUNTED) {\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Something is mounted on this dentry in another\n\t\t\t * namespace and/or whatever was mounted there in this\n\t\t\t * namespace got unmounted before lookup_mnt() could\n\t\t\t * get it */\n\t\t}\n\n\t\t/* Handle an automount point */\n\t\tif (managed & DCACHE_NEED_AUTOMOUNT) {\n\t\t\tret = follow_automount(path, nd, &need_mntput);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We didn't change the current path point */\n\t\tbreak;\n\t}\n\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (ret == -EISDIR || !ret)\n\t\tret = 1;\n\tif (need_mntput)\n\t\tnd->flags |= LOOKUP_JUMPED;\n\tif (unlikely(ret < 0))\n\t\tpath_put_conditional(path, nd);\n\treturn ret;\n}\n",
        "linevul": 6.498118455056101e-05,
        "sysevr": 0.17895738780498505,
        "devign": 4.1915756784111956e-19
    },
    {
        "code": "static int init_subctxts(struct hfi1_ctxtdata *uctxt,\n\t\t\t const struct hfi1_user_info *uinfo)\n{\n\tunsigned num_subctxts;\n\n\tnum_subctxts = uinfo->subctxt_cnt;\n\tif (num_subctxts > HFI1_MAX_SHARED_CTXTS)\n\t\treturn -EINVAL;\n\n\tuctxt->subctxt_cnt = uinfo->subctxt_cnt;\n\tuctxt->subctxt_id = uinfo->subctxt_id;\n\tuctxt->active_slaves = 1;\n\tuctxt->redirect_seq_cnt = 1;\n\tset_bit(HFI1_CTXT_MASTER_UNINIT, &uctxt->event_flags);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static int init_subctxts(struct hfi1_ctxtdata *uctxt,\n\t\t\t const struct hfi1_user_info *uinfo)\n{\n\tunsigned num_subctxts;\n\n\tnum_subctxts = uinfo->subctxt_cnt;\n\tif (num_subctxts > HFI1_MAX_SHARED_CTXTS)\n\t\treturn -EINVAL;\n\n\tuctxt->subctxt_cnt = uinfo->subctxt_cnt;\n\tuctxt->subctxt_id = uinfo->subctxt_id;\n\tuctxt->active_slaves = 1;\n\tuctxt->redirect_seq_cnt = 1;\n\tset_bit(HFI1_CTXT_MASTER_UNINIT, &uctxt->event_flags);\n\n\treturn 0;\n}\n",
        "linevul": 4.707442349172197e-05,
        "sysevr": 0.1455220729112625,
        "devign": 7.052109367577941e-07
    },
    {
        "code": "void fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\twrite_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\twrite_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2",
        "vul_func_with_fix": "void fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),\n\t\t    int prune, void *arg)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\twrite_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, prune, arg);\n\t\t\twrite_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n",
        "linevul": 5.386315388022922e-05,
        "sysevr": 0.15606918931007385,
        "devign": 1.0024848963738143e-18
    },
    {
        "code": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\tret = do_writepages(mapping, &wbc);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
        "vul_func_with_fix": "int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,\n\t\t\t\tloff_t end, int sync_mode)\n{\n\tint ret;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = sync_mode,\n\t\t.nr_to_write = mapping->nrpages * 2,\n\t\t.range_start = start,\n\t\t.range_end = end,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(mapping))\n\t\treturn 0;\n\n\tret = do_writepages(mapping, &wbc);\n\treturn ret;\n}\n",
        "linevul": 0.0001357507280772552,
        "sysevr": 0.17347078025341034,
        "devign": 6.560427084276975e-34
    },
    {
        "code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d",
        "vul_func_with_fix": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n",
        "linevul": 5.397277345764451e-05,
        "sysevr": 0.20881089568138123,
        "devign": 3.474730269140136e-13
    },
    {
        "code": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = __sync_dirty_buffer(sbh,\n\t\t\ttest_opt(sb, BARRIER) ? WRITE_FUA : WRITE_SYNC);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeclusters_counter))\n\t\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tif (percpu_counter_initialized(&EXT4_SB(sb)->s_freeinodes_counter))\n\t\tes->s_free_inodes_count =\n\t\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = __sync_dirty_buffer(sbh,\n\t\t\ttest_opt(sb, BARRIER) ? WRITE_FUA : WRITE_SYNC);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}\n",
        "linevul": 0.00021083762112539262,
        "sysevr": 0.18145114183425903,
        "devign": 0.0
    },
    {
        "code": "static int airspy_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848",
        "vul_func_with_fix": "static int airspy_enum_fmt_sdr_cap(struct file *file, void *priv,\n\t\tstruct v4l2_fmtdesc *f)\n{\n\tif (f->index >= NUM_FORMATS)\n\t\treturn -EINVAL;\n\n\tstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\n\tf->pixelformat = formats[f->index].pixelformat;\n\n\treturn 0;\n}\n",
        "linevul": 5.1490849727997556e-05,
        "sysevr": 0.12618055939674377,
        "devign": 9.294551890290381e-13
    },
    {
        "code": "nfsd4_lm_notify(struct file_lock *fl)\n{\n\tstruct nfs4_lockowner\t\t*lo = (struct nfs4_lockowner *)fl->fl_owner;\n\tstruct net\t\t\t*net = lo->lo_owner.so_client->net;\n\tstruct nfsd_net\t\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(fl,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lock);\n\tbool queue = false;\n\n\t/* An empty list means that something else is going to be using it */\n\tspin_lock(&nn->blocked_locks_lock);\n\tif (!list_empty(&nbl->nbl_list)) {\n\t\tlist_del_init(&nbl->nbl_list);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tqueue = true;\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\tif (queue)\n\t\tnfsd4_run_cb(&nbl->nbl_cb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd4_lm_notify(struct file_lock *fl)\n{\n\tstruct nfs4_lockowner\t\t*lo = (struct nfs4_lockowner *)fl->fl_owner;\n\tstruct net\t\t\t*net = lo->lo_owner.so_client->net;\n\tstruct nfsd_net\t\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct nfsd4_blocked_lock\t*nbl = container_of(fl,\n\t\t\t\t\t\tstruct nfsd4_blocked_lock, nbl_lock);\n\tbool queue = false;\n\n\t/* An empty list means that something else is going to be using it */\n\tspin_lock(&nn->blocked_locks_lock);\n\tif (!list_empty(&nbl->nbl_list)) {\n\t\tlist_del_init(&nbl->nbl_list);\n\t\tlist_del_init(&nbl->nbl_lru);\n\t\tqueue = true;\n\t}\n\tspin_unlock(&nn->blocked_locks_lock);\n\n\tif (queue)\n\t\tnfsd4_run_cb(&nbl->nbl_cb);\n}\n",
        "linevul": 0.00021446710161399096,
        "sysevr": 0.1940077394247055,
        "devign": 4.386135196134846e-27
    },
    {
        "code": "long sys_arch_prctl(int code, unsigned long addr)\n{\n\treturn do_arch_prctl(current, code, addr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f647d7c155f069c1a068030255c300663516420e",
        "vul_func_with_fix": "long sys_arch_prctl(int code, unsigned long addr)\n{\n\treturn do_arch_prctl(current, code, addr);\n}\n",
        "linevul": 6.227819540072232e-05,
        "sysevr": 0.1896866410970688,
        "devign": 8.35024839034304e-05
    },
    {
        "code": "static void schedule_orphans_remove(struct perf_event_context *ctx)\n{\n\tif (!ctx->task || ctx->orphans_remove_sched || !perf_wq)\n\t\treturn;\n\n\tif (queue_delayed_work(perf_wq, &ctx->orphans_remove, 1)) {\n\t\tget_ctx(ctx);\n\t\tctx->orphans_remove_sched = true;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
        "vul_func_with_fix": "static void schedule_orphans_remove(struct perf_event_context *ctx)\n{\n\tif (!ctx->task || ctx->orphans_remove_sched || !perf_wq)\n\t\treturn;\n\n\tif (queue_delayed_work(perf_wq, &ctx->orphans_remove, 1)) {\n\t\tget_ctx(ctx);\n\t\tctx->orphans_remove_sched = true;\n\t}\n}\n",
        "linevul": 5.6342869356740266e-05,
        "sysevr": 0.1283133327960968,
        "devign": 4.727961641037837e-05
    },
    {
        "code": "static void *__netdev_alloc_frag(unsigned int fragsz, gfp_t gfp_mask)\n{\n\tstruct netdev_alloc_cache *nc;\n\tvoid *data = NULL;\n\tint order;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tnc = &__get_cpu_var(netdev_alloc_cache);\n\tif (unlikely(!nc->frag.page)) {\nrefill:\n\t\tfor (order = NETDEV_FRAG_PAGE_MAX_ORDER; ;) {\n\t\t\tgfp_t gfp = gfp_mask;\n\n\t\t\tif (order)\n\t\t\t\tgfp |= __GFP_COMP | __GFP_NOWARN;\n\t\t\tnc->frag.page = alloc_pages(gfp, order);\n\t\t\tif (likely(nc->frag.page))\n\t\t\t\tbreak;\n\t\t\tif (--order < 0)\n\t\t\t\tgoto end;\n\t\t}\n\t\tnc->frag.size = PAGE_SIZE << order;\nrecycle:\n\t\tatomic_set(&nc->frag.page->_count, NETDEV_PAGECNT_MAX_BIAS);\n\t\tnc->pagecnt_bias = NETDEV_PAGECNT_MAX_BIAS;\n\t\tnc->frag.offset = 0;\n\t}\n\n\tif (nc->frag.offset + fragsz > nc->frag.size) {\n\t\t/* avoid unnecessary locked operations if possible */\n\t\tif ((atomic_read(&nc->frag.page->_count) == nc->pagecnt_bias) ||\n\t\t    atomic_sub_and_test(nc->pagecnt_bias, &nc->frag.page->_count))\n\t\t\tgoto recycle;\n\t\tgoto refill;\n\t}\n\n\tdata = page_address(nc->frag.page) + nc->frag.offset;\n\tnc->frag.offset += fragsz;\n\tnc->pagecnt_bias--;\nend:\n\tlocal_irq_restore(flags);\n\treturn data;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "vul_func_with_fix": "static void *__netdev_alloc_frag(unsigned int fragsz, gfp_t gfp_mask)\n{\n\tstruct netdev_alloc_cache *nc;\n\tvoid *data = NULL;\n\tint order;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tnc = &__get_cpu_var(netdev_alloc_cache);\n\tif (unlikely(!nc->frag.page)) {\nrefill:\n\t\tfor (order = NETDEV_FRAG_PAGE_MAX_ORDER; ;) {\n\t\t\tgfp_t gfp = gfp_mask;\n\n\t\t\tif (order)\n\t\t\t\tgfp |= __GFP_COMP | __GFP_NOWARN;\n\t\t\tnc->frag.page = alloc_pages(gfp, order);\n\t\t\tif (likely(nc->frag.page))\n\t\t\t\tbreak;\n\t\t\tif (--order < 0)\n\t\t\t\tgoto end;\n\t\t}\n\t\tnc->frag.size = PAGE_SIZE << order;\nrecycle:\n\t\tatomic_set(&nc->frag.page->_count, NETDEV_PAGECNT_MAX_BIAS);\n\t\tnc->pagecnt_bias = NETDEV_PAGECNT_MAX_BIAS;\n\t\tnc->frag.offset = 0;\n\t}\n\n\tif (nc->frag.offset + fragsz > nc->frag.size) {\n\t\t/* avoid unnecessary locked operations if possible */\n\t\tif ((atomic_read(&nc->frag.page->_count) == nc->pagecnt_bias) ||\n\t\t    atomic_sub_and_test(nc->pagecnt_bias, &nc->frag.page->_count))\n\t\t\tgoto recycle;\n\t\tgoto refill;\n\t}\n\n\tdata = page_address(nc->frag.page) + nc->frag.offset;\n\tnc->frag.offset += fragsz;\n\tnc->pagecnt_bias--;\nend:\n\tlocal_irq_restore(flags);\n\treturn data;\n}\n",
        "linevul": 0.00010776371345855296,
        "sysevr": 0.13253922760486603,
        "devign": 1.4569091888461116e-07
    },
    {
        "code": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = ((1ull << (51 - maxphyaddr + 1)) - 1) << maxphyaddr;\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd",
        "vul_func_with_fix": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\tint maxphyaddr = boot_cpu_data.x86_phys_bits;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\t /* Mask the reserved physical address bits. */\n\tmask = ((1ull << (51 - maxphyaddr + 1)) - 1) << maxphyaddr;\n\n\t/* Bit 62 is always reserved for 32bit host. */\n\tmask |= 0x3ull << 62;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (maxphyaddr == 52)\n\t\tmask &= ~1ull;\n#endif\n\n\tkvm_mmu_set_mmio_spte_mask(mask);\n}\n",
        "linevul": 5.031568434787914e-05,
        "sysevr": 0.15148718655109406,
        "devign": 3.395386727333971e-07
    },
    {
        "code": "assemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\n\t/* +4 is to account for the RFC1001 len field */\n\tchar *pneg_ctxt = (char *)req + OFFSET_OF_NEG_CONTEXT + 4;\n\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\t/* Add 2 to size to round to 8 byte boundary */\n\tpneg_ctxt += 2 + sizeof(struct smb2_preauth_neg_context);\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\treq->NegotiateContextOffset = cpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\treq->NegotiateContextCount = cpu_to_le16(2);\n\tinc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context) + 2\n\t\t\t+ sizeof(struct smb2_encryption_neg_context)); /* calculate hash */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb",
        "vul_func_with_fix": "assemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\n\t/* +4 is to account for the RFC1001 len field */\n\tchar *pneg_ctxt = (char *)req + OFFSET_OF_NEG_CONTEXT + 4;\n\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\t/* Add 2 to size to round to 8 byte boundary */\n\tpneg_ctxt += 2 + sizeof(struct smb2_preauth_neg_context);\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\treq->NegotiateContextOffset = cpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\treq->NegotiateContextCount = cpu_to_le16(2);\n\tinc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context) + 2\n\t\t\t+ sizeof(struct smb2_encryption_neg_context)); /* calculate hash */\n}\n",
        "linevul": 5.089541446068324e-05,
        "sysevr": 0.25593143701553345,
        "devign": 5.520527091018579e-11
    },
    {
        "code": "static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFSPLUS_MAX_STRLEN + 1];\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (filp->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tswitch ((u32)filp->f_pos) {\n\tcase 0:\n\t\t/* This is completely artificial... */\n\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n \t\tfilp->f_pos++;\n \t\t/* fall through */\n \tcase 1:\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (filldir(dirent, \"..\", 2, 1,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, filp->f_pos - 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tprintk(KERN_ERR \"hfs: walked past end of dir\\n\");\n \t\t\terr = -EIO;\n \t\t\tgoto out;\n \t\t}\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\ttype = be16_to_cpu(entry.type);\n\t\tlen = HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.file.id), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tfilp->f_pos++;\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = filp->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilp->private_data = rd;\n\t\trd->file = filp;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77",
        "vul_func_with_fix": "static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFSPLUS_MAX_STRLEN + 1];\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (filp->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tswitch ((u32)filp->f_pos) {\n\tcase 0:\n\t\t/* This is completely artificial... */\n\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n \t\tfilp->f_pos++;\n \t\t/* fall through */\n \tcase 1:\n//fix_flaw_line_below:\n//\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n//fix_flaw_line_below:\n//\t\t\terr = -EIO;\n//fix_flaw_line_below:\n//\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (filldir(dirent, \"..\", 2, 1,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, filp->f_pos - 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tprintk(KERN_ERR \"hfs: walked past end of dir\\n\");\n \t\t\terr = -EIO;\n \t\t\tgoto out;\n \t\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n//fix_flaw_line_below:\n//\t\t\terr = -EIO;\n//fix_flaw_line_below:\n//\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\ttype = be16_to_cpu(entry.type);\n\t\tlen = HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.file.id), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tfilp->f_pos++;\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = filp->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilp->private_data = rd;\n\t\trd->file = filp;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n",
        "linevul": 0.0003066883946303278,
        "sysevr": 0.16783371567726135,
        "devign": 0.9883776307106018
    },
    {
        "code": " static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n \t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n {\n \tstruct sock_exterr_skb *serr;\n \tint err;\n \n \tserr = SKB_EXT_ERR(skb);\n \tmemset(serr, 0, sizeof(*serr));\n \tserr->ee.ee_errno = ENOMSG;\n \tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n \tserr->ee.ee_info = tstype;\n \tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n \t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n \t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\n\terr = sock_queue_err_skb(sk, skb);\n\n\tif (err)\n\t\tkfree_skb(skb);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a",
        "vul_func_with_fix": " static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n \t\t\t\t\tstruct sock *sk,\n//flaw_line_below:\n\t\t\t\t\tint tstype)\n//fix_flaw_line_below:\n//\t\t\t\t\tint tstype,\n//fix_flaw_line_below:\n//\t\t\t\t\tbool opt_stats)\n {\n \tstruct sock_exterr_skb *serr;\n \tint err;\n \n//fix_flaw_line_below:\n//\tBUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));\n//fix_flaw_line_below:\n//\n \tserr = SKB_EXT_ERR(skb);\n \tmemset(serr, 0, sizeof(*serr));\n \tserr->ee.ee_errno = ENOMSG;\n \tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n \tserr->ee.ee_info = tstype;\n//fix_flaw_line_below:\n//\tserr->opt_stats = opt_stats;\n \tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n \t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n \t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\n\terr = sock_queue_err_skb(sk, skb);\n\n\tif (err)\n\t\tkfree_skb(skb);\n}\n",
        "linevul": 0.9994284510612488,
        "sysevr": 0.13582439720630646,
        "devign": 0.999764621257782
    },
    {
        "code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n {\n \tstruct nfs_delegation *delegation;\n \n \trcu_read_lock();\n \tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n \t\trcu_read_unlock();\n \t\treturn;\n \t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n//fix_flaw_line_below:\n//static void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n {\n \tstruct nfs_delegation *delegation;\n \n \trcu_read_lock();\n \tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n//flaw_line_below:\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n//fix_flaw_line_below:\n//\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n \t\trcu_read_unlock();\n \t\treturn;\n \t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}\n",
        "linevul": 0.9996211528778076,
        "sysevr": 0.12647901475429535,
        "devign": 0.9995220899581909
    },
    {
        "code": "static void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n",
        "linevul": 6.087820656830445e-05,
        "sysevr": 0.1284775733947754,
        "devign": 0.0003957828157581389
    },
    {
        "code": "xfs_acl_from_disk(\n\tconst struct xfs_acl\t*aclp,\n\tint\t\t\tlen,\n\tint\t\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tconst struct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tif (len < sizeof(*aclp))\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries || XFS_ACL_SIZE(count) != len)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef",
        "vul_func_with_fix": "xfs_acl_from_disk(\n\tconst struct xfs_acl\t*aclp,\n\tint\t\t\tlen,\n\tint\t\t\tmax_entries)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tconst struct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tif (len < sizeof(*aclp))\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > max_entries || XFS_ACL_SIZE(count) != len)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tacl_e->e_uid = xfs_uid_to_kuid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_gid = xfs_gid_to_kgid(be32_to_cpu(ace->ae_id));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n",
        "linevul": 8.349405106855556e-05,
        "sysevr": 0.18553350865840912,
        "devign": 0.0002871049800887704
    },
    {
        "code": "static ssize_t show_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\taiptek->curSetting.programmableDelay);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8e20cf2bce122ce9262d6034ee5d5b76fbb92f96",
        "vul_func_with_fix": "static ssize_t show_tabletProgrammableDelay(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct aiptek *aiptek = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\taiptek->curSetting.programmableDelay);\n}\n",
        "linevul": 5.458079249365255e-05,
        "sysevr": 0.12166926264762878,
        "devign": 1.2597248799650629e-09
    },
    {
        "code": "static void pit_latch_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(kvm, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2",
        "vul_func_with_fix": "static void pit_latch_count(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(kvm, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}\n",
        "linevul": 4.825490395887755e-05,
        "sysevr": 0.12621094286441803,
        "devign": 0.0006187703111208975
    },
    {
        "code": "static ssize_t regulator_max_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uA);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "vul_func_with_fix": "static ssize_t regulator_max_uA_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uA);\n}\n",
        "linevul": 4.799267480848357e-05,
        "sysevr": 0.12036032229661942,
        "devign": 5.580844120167683e-10
    },
    {
        "code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n \n \t/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5",
        "vul_func_with_fix": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n//fix_flaw_line_below:\n//\tif (!r)\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n \n \t/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n",
        "linevul": 0.9995960593223572,
        "sysevr": 0.17940692603588104,
        "devign": 0.999512791633606
    },
    {
        "code": "xfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03",
        "vul_func_with_fix": "xfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}\n",
        "linevul": 0.00014379346976056695,
        "sysevr": 0.16206617653369904,
        "devign": 4.000708884177584e-07
    },
    {
        "code": "static void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred_cxt(cred));\n\tcred_cxt(cred) = NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca",
        "vul_func_with_fix": "static void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred_cxt(cred));\n\tcred_cxt(cred) = NULL;\n}\n",
        "linevul": 4.9541558837518096e-05,
        "sysevr": 0.1282385289669037,
        "devign": 0.017451133579015732
    },
    {
        "code": "static void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task_async(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tfput(data->fl.fl_file);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task_async(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tfput(data->fl.fl_file);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n",
        "linevul": 6.927400681888685e-05,
        "sysevr": 0.1283876895904541,
        "devign": 4.0892800257097406e-07
    },
    {
        "code": "static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)\n{\n\tstruct rfcomm_dev *dev = dlc->owner;\n\tif (!dev)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p dev %p v24_sig 0x%02x\", dlc, dev, v24_sig);\n\n\tif ((dev->modem_status & TIOCM_CD) && !(v24_sig & RFCOMM_V24_DV)) {\n\t\tif (dev->port.tty && !C_CLOCAL(dev->port.tty))\n\t\t\ttty_hangup(dev->port.tty);\n\t}\n\n\tdev->modem_status =\n\t\t((v24_sig & RFCOMM_V24_RTC) ? (TIOCM_DSR | TIOCM_DTR) : 0) |\n\t\t((v24_sig & RFCOMM_V24_RTR) ? (TIOCM_RTS | TIOCM_CTS) : 0) |\n\t\t((v24_sig & RFCOMM_V24_IC)  ? TIOCM_RI : 0) |\n\t\t((v24_sig & RFCOMM_V24_DV)  ? TIOCM_CD : 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f9432c5ec8b1e9a09b9b0e5569e3c73db8de432a",
        "vul_func_with_fix": "static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)\n{\n\tstruct rfcomm_dev *dev = dlc->owner;\n\tif (!dev)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p dev %p v24_sig 0x%02x\", dlc, dev, v24_sig);\n\n\tif ((dev->modem_status & TIOCM_CD) && !(v24_sig & RFCOMM_V24_DV)) {\n\t\tif (dev->port.tty && !C_CLOCAL(dev->port.tty))\n\t\t\ttty_hangup(dev->port.tty);\n\t}\n\n\tdev->modem_status =\n\t\t((v24_sig & RFCOMM_V24_RTC) ? (TIOCM_DSR | TIOCM_DTR) : 0) |\n\t\t((v24_sig & RFCOMM_V24_RTR) ? (TIOCM_RTS | TIOCM_CTS) : 0) |\n\t\t((v24_sig & RFCOMM_V24_IC)  ? TIOCM_RI : 0) |\n\t\t((v24_sig & RFCOMM_V24_DV)  ? TIOCM_CD : 0);\n}\n",
        "linevul": 4.5500673877540976e-05,
        "sysevr": 0.25320178270339966,
        "devign": 2.6023815514196578e-18
    },
    {
        "code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \n \tdev = file->private_data;\n \n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t/* already disconnected */\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n \t}\n \n \tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n \tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f1e255d60ae66a9f672ff9a207ee6cd8e33d2679",
        "vul_func_with_fix": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n//flaw_line_below:\n\tint retval = 0;\n//flaw_line_below:\n\tint bytes_read = 0;\n//fix_flaw_line_below:\n//\tint len = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \n \tdev = file->private_data;\n \n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t/* already disconnected */\n//flaw_line_below:\n\t\tretval = -ENODEV;\n//flaw_line_below:\n\t\tgoto exit;\n//fix_flaw_line_below:\n//\t\tmutex_unlock(&dev->io_mutex);\n//fix_flaw_line_below:\n//\t\treturn -ENODEV;\n \t}\n \n \tspin_lock_irqsave(&dev->lock, flags);\n//flaw_line_below:\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n//fix_flaw_line_below:\n//\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (*ppos < bytes_read) {\n//flaw_line_below:\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n//flaw_line_below:\n\t\t\tretval = -EFAULT;\n//flaw_line_below:\n\t\telse {\n//flaw_line_below:\n\t\t\tretval = bytes_read - *ppos;\n//flaw_line_below:\n\t\t\t*ppos += bytes_read;\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\nexit:\n \tmutex_unlock(&dev->io_mutex);\n//flaw_line_below:\n\treturn retval;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n }\n",
        "linevul": 0.9996606111526489,
        "sysevr": 0.1305556744337082,
        "devign": 0.6195167303085327
    },
    {
        "code": "int generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\tkey->type_data.p[0] = prep->type_data[0];\n\t\tkey->type_data.p[1] = prep->type_data[1];\n\t\trcu_assign_keypointer(key, prep->payload[0]);\n\t\tkey->payload.data2[1] = prep->payload[1];\n\t\tprep->type_data[0] = NULL;\n\t\tprep->type_data[1] = NULL;\n\t\tprep->payload[0] = NULL;\n\t\tprep->payload[1] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "int generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\tkey->type_data.p[0] = prep->type_data[0];\n\t\tkey->type_data.p[1] = prep->type_data[1];\n\t\trcu_assign_keypointer(key, prep->payload[0]);\n\t\tkey->payload.data2[1] = prep->payload[1];\n\t\tprep->type_data[0] = NULL;\n\t\tprep->type_data[1] = NULL;\n\t\tprep->payload[0] = NULL;\n\t\tprep->payload[1] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "linevul": 5.7239703892264515e-05,
        "sysevr": 0.2203536480665207,
        "devign": 1.4324608198341652e-38
    },
    {
        "code": "xfs_inode_from_disk(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*from)\n{\n\tstruct xfs_icdinode\t*to = &ip->i_d;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\n\t/*\n\t * Convert v1 inodes immediately to v2 inode format as this is the\n\t * minimum inode version format we support in the rest of the code.\n\t */\n\tto->di_version = from->di_version;\n\tif (to->di_version == 1) {\n\t\tset_nlink(inode, be16_to_cpu(from->di_onlink));\n\t\tto->di_projid_lo = 0;\n\t\tto->di_projid_hi = 0;\n\t\tto->di_version = 2;\n\t} else {\n\t\tset_nlink(inode, be32_to_cpu(from->di_nlink));\n\t\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\t\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\t}\n\n\tto->di_format = from->di_format;\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\n\t/*\n\t * Time is signed, so need to convert to signed 32 bit before\n\t * storing in inode timestamp which may be 64 bit. Otherwise\n\t * a time before epoch is converted to a time long after epoch\n\t * on 64 bit systems.\n\t */\n\tinode->i_atime.tv_sec = (int)be32_to_cpu(from->di_atime.t_sec);\n\tinode->i_atime.tv_nsec = (int)be32_to_cpu(from->di_atime.t_nsec);\n\tinode->i_mtime.tv_sec = (int)be32_to_cpu(from->di_mtime.t_sec);\n\tinode->i_mtime.tv_nsec = (int)be32_to_cpu(from->di_mtime.t_nsec);\n\tinode->i_ctime.tv_sec = (int)be32_to_cpu(from->di_ctime.t_sec);\n\tinode->i_ctime.tv_nsec = (int)be32_to_cpu(from->di_ctime.t_nsec);\n\tinode->i_generation = be32_to_cpu(from->di_gen);\n\tinode->i_mode = be16_to_cpu(from->di_mode);\n\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\n\tif (to->di_version == 3) {\n\t\tinode_set_iversion_queried(inode,\n\t\t\t\t\t   be64_to_cpu(from->di_changecount));\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_cowextsize = be32_to_cpu(from->di_cowextsize);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3",
        "vul_func_with_fix": "xfs_inode_from_disk(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dinode\t*from)\n{\n\tstruct xfs_icdinode\t*to = &ip->i_d;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\n\t/*\n\t * Convert v1 inodes immediately to v2 inode format as this is the\n\t * minimum inode version format we support in the rest of the code.\n\t */\n\tto->di_version = from->di_version;\n\tif (to->di_version == 1) {\n\t\tset_nlink(inode, be16_to_cpu(from->di_onlink));\n\t\tto->di_projid_lo = 0;\n\t\tto->di_projid_hi = 0;\n\t\tto->di_version = 2;\n\t} else {\n\t\tset_nlink(inode, be32_to_cpu(from->di_nlink));\n\t\tto->di_projid_lo = be16_to_cpu(from->di_projid_lo);\n\t\tto->di_projid_hi = be16_to_cpu(from->di_projid_hi);\n\t}\n\n\tto->di_format = from->di_format;\n\tto->di_uid = be32_to_cpu(from->di_uid);\n\tto->di_gid = be32_to_cpu(from->di_gid);\n\tto->di_flushiter = be16_to_cpu(from->di_flushiter);\n\n\t/*\n\t * Time is signed, so need to convert to signed 32 bit before\n\t * storing in inode timestamp which may be 64 bit. Otherwise\n\t * a time before epoch is converted to a time long after epoch\n\t * on 64 bit systems.\n\t */\n\tinode->i_atime.tv_sec = (int)be32_to_cpu(from->di_atime.t_sec);\n\tinode->i_atime.tv_nsec = (int)be32_to_cpu(from->di_atime.t_nsec);\n\tinode->i_mtime.tv_sec = (int)be32_to_cpu(from->di_mtime.t_sec);\n\tinode->i_mtime.tv_nsec = (int)be32_to_cpu(from->di_mtime.t_nsec);\n\tinode->i_ctime.tv_sec = (int)be32_to_cpu(from->di_ctime.t_sec);\n\tinode->i_ctime.tv_nsec = (int)be32_to_cpu(from->di_ctime.t_nsec);\n\tinode->i_generation = be32_to_cpu(from->di_gen);\n\tinode->i_mode = be16_to_cpu(from->di_mode);\n\n\tto->di_size = be64_to_cpu(from->di_size);\n\tto->di_nblocks = be64_to_cpu(from->di_nblocks);\n\tto->di_extsize = be32_to_cpu(from->di_extsize);\n\tto->di_nextents = be32_to_cpu(from->di_nextents);\n\tto->di_anextents = be16_to_cpu(from->di_anextents);\n\tto->di_forkoff = from->di_forkoff;\n\tto->di_aformat\t= from->di_aformat;\n\tto->di_dmevmask\t= be32_to_cpu(from->di_dmevmask);\n\tto->di_dmstate\t= be16_to_cpu(from->di_dmstate);\n\tto->di_flags\t= be16_to_cpu(from->di_flags);\n\n\tif (to->di_version == 3) {\n\t\tinode_set_iversion_queried(inode,\n\t\t\t\t\t   be64_to_cpu(from->di_changecount));\n\t\tto->di_crtime.t_sec = be32_to_cpu(from->di_crtime.t_sec);\n\t\tto->di_crtime.t_nsec = be32_to_cpu(from->di_crtime.t_nsec);\n\t\tto->di_flags2 = be64_to_cpu(from->di_flags2);\n\t\tto->di_cowextsize = be32_to_cpu(from->di_cowextsize);\n\t}\n}\n",
        "linevul": 8.214281842811033e-05,
        "sysevr": 0.2636486887931824,
        "devign": 9.769470619051557e-38
    },
    {
        "code": "sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n \t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n \t\t\tscatter_elem_sz_prev : rem_sz;\n \n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n \t\tif (!schp->pages[k])\n \t\t\tgoto out;\n \n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a45b599ad808c3c982fdcdc12b0b8611c2f92824",
        "vul_func_with_fix": "sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n \t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n \t\t\tscatter_elem_sz_prev : rem_sz;\n \n//flaw_line_below:\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n//fix_flaw_line_below:\n//\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n \t\tif (!schp->pages[k])\n \t\t\tgoto out;\n \n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}\n",
        "linevul": 0.0006831415230408311,
        "sysevr": 0.18761715292930603,
        "devign": 0.9306056499481201
    },
    {
        "code": " bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n {\n \tstatic DEFINE_SPINLOCK(lock);\n \tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n \t*done = true;\n \tspin_unlock_irqrestore(&lock, flags);\n \n\t__net_random_once_disable_jump(done_key);\n \n \treturn true;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/3d4405226d27b3a215e4d03cfa51f536244e5de7",
        "vul_func_with_fix": " bool __net_get_random_once(void *buf, int nbytes, bool *done,\n//flaw_line_below:\n\t\t\t   struct static_key *done_key)\n//fix_flaw_line_below:\n//\t\t\t   struct static_key *once_key)\n {\n \tstatic DEFINE_SPINLOCK(lock);\n \tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n \t*done = true;\n \tspin_unlock_irqrestore(&lock, flags);\n \n//flaw_line_below:\n\t__net_random_once_disable_jump(done_key);\n//fix_flaw_line_below:\n//\t__net_random_once_disable_jump(once_key);\n \n \treturn true;\n }\n",
        "linevul": 0.9992772936820984,
        "sysevr": 0.1464250385761261,
        "devign": 0.9997665286064148
    },
    {
        "code": "rb_event_ts_length(struct ring_buffer_event *event)\n{\n\tunsigned len = 0;\n\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND) {\n\t\t/* time extends include the data event after it */\n\t\tlen = RB_LEN_TIME_EXTEND;\n\t\tevent = skip_time_extend(event);\n\t}\n\treturn len + rb_event_length(event);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59643d1535eb220668692a5359de22545af579f6",
        "vul_func_with_fix": "rb_event_ts_length(struct ring_buffer_event *event)\n{\n\tunsigned len = 0;\n\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND) {\n\t\t/* time extends include the data event after it */\n\t\tlen = RB_LEN_TIME_EXTEND;\n\t\tevent = skip_time_extend(event);\n\t}\n\treturn len + rb_event_length(event);\n}\n",
        "linevul": 4.7237663238774985e-05,
        "sysevr": 0.21259385347366333,
        "devign": 4.868559722037702e-11
    },
    {
        "code": "static void f2fs_write_end_io(struct bio *bio)\n{\n\tstruct f2fs_sb_info *sbi = bio->bi_private;\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\t\tenum count_type type = WB_DATA_TYPE(page);\n\n\t\tif (IS_DUMMY_WRITTEN_PAGE(page)) {\n\t\t\tset_page_private(page, (unsigned long)NULL);\n\t\t\tClearPagePrivate(page);\n\t\t\tunlock_page(page);\n\t\t\tmempool_free(page, sbi->write_io_dummy);\n\n\t\t\tif (unlikely(bio->bi_error))\n\t\t\t\tf2fs_stop_checkpoint(sbi, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfscrypt_pullback_bio_page(&page, true);\n\n\t\tif (unlikely(bio->bi_error)) {\n\t\t\tmapping_set_error(page->mapping, -EIO);\n\t\t\tf2fs_stop_checkpoint(sbi, true);\n\t\t}\n\t\tdec_page_count(sbi, type);\n\t\tclear_cold_data(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (!get_pages(sbi, F2FS_WB_CP_DATA) &&\n\t\t\t\twq_has_sleeper(&sbi->cp_wait))\n\t\twake_up(&sbi->cp_wait);\n\n\tbio_put(bio);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b86e33075ed1909d8002745b56ecf73b833db143",
        "vul_func_with_fix": "static void f2fs_write_end_io(struct bio *bio)\n{\n\tstruct f2fs_sb_info *sbi = bio->bi_private;\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\t\tenum count_type type = WB_DATA_TYPE(page);\n\n\t\tif (IS_DUMMY_WRITTEN_PAGE(page)) {\n\t\t\tset_page_private(page, (unsigned long)NULL);\n\t\t\tClearPagePrivate(page);\n\t\t\tunlock_page(page);\n\t\t\tmempool_free(page, sbi->write_io_dummy);\n\n\t\t\tif (unlikely(bio->bi_error))\n\t\t\t\tf2fs_stop_checkpoint(sbi, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfscrypt_pullback_bio_page(&page, true);\n\n\t\tif (unlikely(bio->bi_error)) {\n\t\t\tmapping_set_error(page->mapping, -EIO);\n\t\t\tf2fs_stop_checkpoint(sbi, true);\n\t\t}\n\t\tdec_page_count(sbi, type);\n\t\tclear_cold_data(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (!get_pages(sbi, F2FS_WB_CP_DATA) &&\n\t\t\t\twq_has_sleeper(&sbi->cp_wait))\n\t\twake_up(&sbi->cp_wait);\n\n\tbio_put(bio);\n}\n",
        "linevul": 0.00011402904783608392,
        "sysevr": 0.1211131364107132,
        "devign": 8.296325413247574e-18
    },
    {
        "code": "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f",
        "vul_func_with_fix": "static int enable_cpucache(struct kmem_cache *cachep, gfp_t gfp)\n{\n\tint err;\n\tint limit = 0;\n\tint shared = 0;\n\tint batchcount = 0;\n\n\terr = cache_random_seq_create(cachep, cachep->num, gfp);\n\tif (err)\n\t\tgoto end;\n\n\tif (!is_root_cache(cachep)) {\n\t\tstruct kmem_cache *root = memcg_root_cache(cachep);\n\t\tlimit = root->limit;\n\t\tshared = root->shared;\n\t\tbatchcount = root->batchcount;\n\t}\n\n\tif (limit && shared && batchcount)\n\t\tgoto skip_setup;\n\t/*\n\t * The head array serves three purposes:\n\t * - create a LIFO ordering, i.e. return objects that are cache-warm\n\t * - reduce the number of spinlock operations.\n\t * - reduce the number of linked list operations on the slab and\n\t *   bufctl chains: array operations are cheaper.\n\t * The numbers are guessed, we should auto-tune as described by\n\t * Bonwick.\n\t */\n\tif (cachep->size > 131072)\n\t\tlimit = 1;\n\telse if (cachep->size > PAGE_SIZE)\n\t\tlimit = 8;\n\telse if (cachep->size > 1024)\n\t\tlimit = 24;\n\telse if (cachep->size > 256)\n\t\tlimit = 54;\n\telse\n\t\tlimit = 120;\n\n\t/*\n\t * CPU bound tasks (e.g. network routing) can exhibit cpu bound\n\t * allocation behaviour: Most allocs on one cpu, most free operations\n\t * on another cpu. For these cases, an efficient object passing between\n\t * cpus is necessary. This is provided by a shared array. The array\n\t * replaces Bonwick's magazine layer.\n\t * On uniprocessor, it's functionally equivalent (but less efficient)\n\t * to a larger limit. Thus disabled by default.\n\t */\n\tshared = 0;\n\tif (cachep->size <= PAGE_SIZE && num_possible_cpus() > 1)\n\t\tshared = 8;\n\n#if DEBUG\n\t/*\n\t * With debugging enabled, large batchcount lead to excessively long\n\t * periods with disabled local interrupts. Limit the batchcount\n\t */\n\tif (limit > 32)\n\t\tlimit = 32;\n#endif\n\tbatchcount = (limit + 1) / 2;\nskip_setup:\n\terr = do_tune_cpucache(cachep, limit, batchcount, shared, gfp);\nend:\n\tif (err)\n\t\tpr_err(\"enable_cpucache failed for %s, error %d\\n\",\n\t\t       cachep->name, -err);\n\treturn err;\n}\n",
        "linevul": 0.00017946396837942302,
        "sysevr": 0.18698982894420624,
        "devign": 1.786596785233221e-34
    },
    {
        "code": "static void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\n\t\t\t\t umode_t *pbits_to_set)\n{\n\t__u32 flags = le32_to_cpu(ace_flags);\n\t/* the order of ACEs is important.  The canonical order is to begin with\n\t   DENY entries followed by ALLOW, otherwise an allow entry could be\n\t   encountered first, making the subsequent deny entry like \"dead code\"\n\t   which would be superflous since Windows stops when a match is made\n\t   for the operation you are trying to perform for your user */\n\n\t/* For deny ACEs we change the mask so that subsequent allow access\n\t   control entries do not turn on the bits we are denying */\n\tif (type == ACCESS_DENIED) {\n\t\tif (flags & GENERIC_ALL)\n\t\t\t*pbits_to_set &= ~S_IRWXUGO;\n\n\t\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IWUGO;\n\t\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IRUGO;\n\t\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t\t*pbits_to_set &= ~S_IXUGO;\n\t\treturn;\n\t} else if (type != ACCESS_ALLOWED) {\n\t\tcifs_dbg(VFS, \"unknown access control type %d\\n\", type);\n\t\treturn;\n\t}\n\t/* else ACCESS_ALLOWED type */\n\n\tif (flags & GENERIC_ALL) {\n\t\t*pmode |= (S_IRWXUGO & (*pbits_to_set));\n\t\tcifs_dbg(NOISY, \"all perms\\n\");\n\t\treturn;\n\t}\n\tif ((flags & GENERIC_WRITE) ||\n\t\t\t((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\n\t\t*pmode |= (S_IWUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_READ) ||\n\t\t\t((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\n\t\t*pmode |= (S_IRUGO & (*pbits_to_set));\n\tif ((flags & GENERIC_EXECUTE) ||\n\t\t\t((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\n\t\t*pmode |= (S_IXUGO & (*pbits_to_set));\n\n\tcifs_dbg(NOISY, \"access flags 0x%x mode now 0x%x\\n\", flags, *pmode);\n\treturn;\n}\n",
        "linevul": 7.935560279292986e-05,
        "sysevr": 0.44763824343681335,
        "devign": 4.797851370110494e-16
    },
    {
        "code": "bool inode_capable(const struct inode *inode, int cap)\n {\n \tstruct user_namespace *ns = current_user_ns();\n \n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03",
        "vul_func_with_fix": "bool inode_capable(const struct inode *inode, int cap)\n//fix_flaw_line_below:\n//bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n {\n \tstruct user_namespace *ns = current_user_ns();\n \n//flaw_line_below:\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n//fix_flaw_line_below:\n//\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&\n//fix_flaw_line_below:\n//\t\tkgid_has_mapping(ns, inode->i_gid);\n }\n",
        "linevul": 0.9900407195091248,
        "sysevr": 0.14737556874752045,
        "devign": 4.1531933447913616e-07
    },
    {
        "code": "static void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_shrink(vcpu->vcpu_id, vmx->ple_window, old);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old)\n\t\tvmx->ple_window_dirty = true;\n\n\ttrace_kvm_ple_window_shrink(vcpu->vcpu_id, vmx->ple_window, old);\n}\n",
        "linevul": 5.306029925122857e-05,
        "sysevr": 0.12887659668922424,
        "devign": 1.4612351151299663e-05
    },
    {
        "code": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\trefcount_inc(&ctx->refcount);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a",
        "vul_func_with_fix": "static void userfaultfd_ctx_get(struct userfaultfd_ctx *ctx)\n{\n\trefcount_inc(&ctx->refcount);\n}\n",
        "linevul": 0.0003383972798474133,
        "sysevr": 0.12878932058811188,
        "devign": 2.195641002344928e-08
    },
    {
        "code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\n \tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n \t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n \t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n \t\t[DISCE_SUSPEND] = sas_suspend_devices,\n \t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n \t};\n \n \tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d",
        "vul_func_with_fix": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\n \tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n \t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n \t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n//flaw_line_below:\n\t\t[DISCE_PROBE] = sas_probe_devices,\n \t\t[DISCE_SUSPEND] = sas_suspend_devices,\n \t\t[DISCE_RESUME] = sas_resume_devices,\n//flaw_line_below:\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n \t};\n \n \tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}\n",
        "linevul": 0.9995508790016174,
        "sysevr": 0.21042251586914062,
        "devign": 0.0
    },
    {
        "code": "SYSCALL_DEFINE2(umount, char __user *, name, int, flags)\n{\n\tstruct path path;\n\tstruct mount *mnt;\n\tint retval;\n\tint lookup_flags = 0;\n\n\tif (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))\n\t\treturn -EINVAL;\n\n\tif (!may_mount())\n\t\treturn -EPERM;\n\n\tif (!(flags & UMOUNT_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\n\tretval = user_path_mountpoint_at(AT_FDCWD, name, lookup_flags, &path);\n\tif (retval)\n\t\tgoto out;\n\tmnt = real_mount(path.mnt);\n\tretval = -EINVAL;\n\tif (path.dentry != path.mnt->mnt_root)\n\t\tgoto dput_and_out;\n\tif (!check_mnt(mnt))\n\t\tgoto dput_and_out;\n\tif (mnt->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto dput_and_out;\n\tretval = -EPERM;\n\tif (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))\n\t\tgoto dput_and_out;\n\n\tretval = do_umount(mnt, flags);\ndput_and_out:\n\t/* we mustn't call path_put() as that would clear mnt_expiry_mark */\n\tdput(path.dentry);\n\tmntput_no_expire(mnt);\nout:\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "SYSCALL_DEFINE2(umount, char __user *, name, int, flags)\n{\n\tstruct path path;\n\tstruct mount *mnt;\n\tint retval;\n\tint lookup_flags = 0;\n\n\tif (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))\n\t\treturn -EINVAL;\n\n\tif (!may_mount())\n\t\treturn -EPERM;\n\n\tif (!(flags & UMOUNT_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\n\tretval = user_path_mountpoint_at(AT_FDCWD, name, lookup_flags, &path);\n\tif (retval)\n\t\tgoto out;\n\tmnt = real_mount(path.mnt);\n\tretval = -EINVAL;\n\tif (path.dentry != path.mnt->mnt_root)\n\t\tgoto dput_and_out;\n\tif (!check_mnt(mnt))\n\t\tgoto dput_and_out;\n\tif (mnt->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto dput_and_out;\n\tretval = -EPERM;\n\tif (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))\n\t\tgoto dput_and_out;\n\n\tretval = do_umount(mnt, flags);\ndput_and_out:\n\t/* we mustn't call path_put() as that would clear mnt_expiry_mark */\n\tdput(path.dentry);\n\tmntput_no_expire(mnt);\nout:\n\treturn retval;\n}\n",
        "linevul": 7.659954280825332e-05,
        "sysevr": 0.2111779898405075,
        "devign": 0.6728524565696716
    },
    {
        "code": "int snd_seq_kernel_client_enqueue_blocking(int client, struct snd_seq_event * ev,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   int atomic, int hop)\n{\n\treturn kernel_client_enqueue(client, ev, file, 1, atomic, hop);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/030e2c78d3a91dd0d27fef37e91950dde333eba1",
        "vul_func_with_fix": "int snd_seq_kernel_client_enqueue_blocking(int client, struct snd_seq_event * ev,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   int atomic, int hop)\n{\n\treturn kernel_client_enqueue(client, ev, file, 1, atomic, hop);\n}\n",
        "linevul": 5.3710300562670454e-05,
        "sysevr": 0.1503726840019226,
        "devign": 0.010405058041214943
    },
    {
        "code": "long keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey_invalidate(key_ref_to_ptr(key_ref));\n\tret = 0;\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b4a1b4f5047e4f54e194681125c74c0aa64d637d",
        "vul_func_with_fix": "long keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey_invalidate(key_ref_to_ptr(key_ref));\n\tret = 0;\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n",
        "linevul": 5.448058800539002e-05,
        "sysevr": 0.17020748555660248,
        "devign": 6.883398473607472e-13
    },
    {
        "code": " static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n \tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n {\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826",
        "vul_func_with_fix": " static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n \tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n {\n//flaw_line_below:\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n//fix_flaw_line_below:\n//\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}\n",
        "linevul": 0.9996345043182373,
        "sysevr": 0.12738680839538574,
        "devign": 0.9980564713478088
    },
    {
        "code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n \n\t\tkey_user_put(key->user);\n \t\t/* now throw away the key memory */\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tkfree(key->description);\n \n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a3a8784454692dd72e5d5d34dcdab17b4420e74c",
        "vul_func_with_fix": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n \n//flaw_line_below:\n\t\tkey_user_put(key->user);\n//flaw_line_below:\n\n \t\t/* now throw away the key memory */\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n//fix_flaw_line_below:\n//\t\tkey_user_put(key->user);\n//fix_flaw_line_below:\n//\n \t\tkfree(key->description);\n \n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n",
        "linevul": 0.9978121519088745,
        "sysevr": 0.16302993893623352,
        "devign": 0.548445999622345
    },
    {
        "code": "static void hw_perf_event_destroy(struct perf_event *event)\n{\n\tif (atomic_dec_and_mutex_lock(&active_events,\n\t\t\t\t&pmu_reserve_mutex)) {\n\t\t/*\n\t\t * We must not call the destroy function with interrupts\n\t\t * disabled.\n\t\t */\n\t\ton_each_cpu(reset_counters,\n\t\t\t(void *)(long)mipspmu->num_counters, 1);\n\t\tmipspmu_free_irq();\n\t\tmutex_unlock(&pmu_reserve_mutex);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void hw_perf_event_destroy(struct perf_event *event)\n{\n\tif (atomic_dec_and_mutex_lock(&active_events,\n\t\t\t\t&pmu_reserve_mutex)) {\n\t\t/*\n\t\t * We must not call the destroy function with interrupts\n\t\t * disabled.\n\t\t */\n\t\ton_each_cpu(reset_counters,\n\t\t\t(void *)(long)mipspmu->num_counters, 1);\n\t\tmipspmu_free_irq();\n\t\tmutex_unlock(&pmu_reserve_mutex);\n\t}\n}\n",
        "linevul": 4.96377469971776e-05,
        "sysevr": 0.1262146681547165,
        "devign": 9.510153176961467e-05
    },
    {
        "code": "int kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tiov_iter_kvec(&msg->msg_iter, READ | ITER_KVEC, vec, num, size);\n\tset_fs(KERNEL_DS);\n\tresult = sock_recvmsg(sock, msg, size, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/34b88a68f26a75e4fded796f1a49c40f82234b7d",
        "vul_func_with_fix": "int kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tiov_iter_kvec(&msg->msg_iter, READ | ITER_KVEC, vec, num, size);\n\tset_fs(KERNEL_DS);\n\tresult = sock_recvmsg(sock, msg, size, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\n",
        "linevul": 5.3090978326508775e-05,
        "sysevr": 0.18005719780921936,
        "devign": 7.798963110872137e-07
    },
    {
        "code": "static noinline void do_sigbus(struct pt_regs *regs, long int_code,\n\t\t\t       unsigned long trans_exc_code)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long address;\n\tstruct siginfo si;\n\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n\taddress = trans_exc_code & __FAIL_ADDR_MASK;\n\ttsk->thread.prot_addr = address;\n\ttsk->thread.trap_no = int_code;\n\tsi.si_signo = SIGBUS;\n\tsi.si_errno = 0;\n\tsi.si_code = BUS_ADRERR;\n\tsi.si_addr = (void __user *) address;\n\tforce_sig_info(SIGBUS, &si, tsk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static noinline void do_sigbus(struct pt_regs *regs, long int_code,\n\t\t\t       unsigned long trans_exc_code)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long address;\n\tstruct siginfo si;\n\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n\taddress = trans_exc_code & __FAIL_ADDR_MASK;\n\ttsk->thread.prot_addr = address;\n\ttsk->thread.trap_no = int_code;\n\tsi.si_signo = SIGBUS;\n\tsi.si_errno = 0;\n\tsi.si_code = BUS_ADRERR;\n\tsi.si_addr = (void __user *) address;\n\tforce_sig_info(SIGBUS, &si, tsk);\n}\n",
        "linevul": 4.6423814637819305e-05,
        "sysevr": 0.19585950672626495,
        "devign": 0.6848013401031494
    },
    {
        "code": "static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\t\tif (ibss.beacon_interval < 1 || ibss.beacon_interval > 10000)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tibss.channel = ieee80211_get_channel(wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!ibss.channel ||\n\t    ibss.channel->flags & IEEE80211_CHAN_NO_IBSS ||\n\t    ibss.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn -EINVAL;\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.channel->band];\n\t\tint i, j;\n\n\t\tif (n_rates == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < n_rates; i++) {\n\t\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\t\tbool found = false;\n\n\t\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\t\tif (sband->bitrates[j].bitrate == rate) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tibss.basic_rates |= BIT(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
        "vul_func_with_fix": "static int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\t\tif (ibss.beacon_interval < 1 || ibss.beacon_interval > 10000)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tibss.channel = ieee80211_get_channel(wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!ibss.channel ||\n\t    ibss.channel->flags & IEEE80211_CHAN_NO_IBSS ||\n\t    ibss.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn -EINVAL;\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.channel->band];\n\t\tint i, j;\n\n\t\tif (n_rates == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < n_rates; i++) {\n\t\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\t\tbool found = false;\n\n\t\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\t\tif (sband->bitrates[j].bitrate == rate) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tibss.basic_rates |= BIT(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n",
        "linevul": 5.8594665460987017e-05,
        "sysevr": 0.14585553109645844,
        "devign": 1.8051328651507092e-21
    },
    {
        "code": "static int ext4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long old_sb_flags;\n\tstruct ext4_mount_options old_opts;\n\tint enable_quota = 0;\n\text4_group_t g;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\tint err = 0;\n#ifdef CONFIG_QUOTA\n\tint i, j;\n#endif\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_mount_opt2 = sbi->s_mount_opt2;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n\told_opts.s_min_batch_time = sbi->s_min_batch_time;\n\told_opts.s_max_batch_time = sbi->s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\tkfree(orig_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\tif (sbi->s_journal && sbi->s_journal->j_task->io_context)\n\t\tjournal_ioprio = sbi->s_journal->j_task->io_context->ioprio;\n\n\tif (!parse_options(data, sb, NULL, &journal_ioprio, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif ((old_opts.s_mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) ^\n\t    test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\text4_msg(sb, KERN_ERR, \"changing journal_checksum \"\n\t\t\t \"during remount not supported; ignoring\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_DAX) {\n\t\text4_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t\"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_DAX;\n\t}\n\n\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\text4_abort(sb, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\tif (sbi->s_journal) {\n\t\text4_init_journal_params(sb, sbi->s_journal);\n\t\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\t}\n\n\tif (*flags & MS_LAZYTIME)\n\t\tsb->s_flags |= MS_LAZYTIME;\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = sync_filesystem(sb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT4_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT4_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t/* Make sure we can mount this feature set readwrite */\n\t\t\tif (ext4_has_feature_readonly(sb) ||\n\t\t\t    !ext4_feature_set_ok(sb, 0)) {\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Make sure the group descriptor checksums\n\t\t\t * are sane.  If they aren't, refuse to remount r/w.\n\t\t\t */\n\t\t\tfor (g = 0; g < sbi->s_groups_count; g++) {\n\t\t\t\tstruct ext4_group_desc *gdp =\n\t\t\t\t\text4_get_group_desc(sb, g, NULL);\n\n\t\t\t\tif (!ext4_group_desc_csum_verify(sb, g, gdp)) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t       \"ext4_remount: Checksum for group %u failed (%u!=%u)\",\n\t\tg, le16_to_cpu(ext4_group_desc_csum(sb, g, gdp)),\n\t\t\t\t\t       le16_to_cpu(gdp->bg_checksum));\n\t\t\t\t\terr = -EFSBADCRC;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount/remount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount/remount instead\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif (!ext4_setup_super(sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tif (ext4_has_feature_mmp(sb))\n\t\t\t\tif (ext4_multi_mount_protect(sb,\n\t\t\t\t\t\tle64_to_cpu(es->s_mmp_block))) {\n\t\t\t\t\terr = -EROFS;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Reinitialize lazy itable initialization thread based on\n\t * current settings\n\t */\n\tif ((sb->s_flags & MS_RDONLY) || !test_opt(sb, INIT_INODE_TABLE))\n\t\text4_unregister_li_request(sb);\n\telse {\n\t\text4_group_t first_not_zeroed;\n\t\tfirst_not_zeroed = ext4_has_uninit_itable(sb);\n\t\text4_register_li_request(sb, first_not_zeroed);\n\t}\n\n\text4_setup_system_zone(sb);\n\tif (sbi->s_journal == NULL && !(old_sb_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n\tif (enable_quota) {\n\t\tif (sb_any_quota_suspended(sb))\n\t\t\tdquot_resume(sb, -1);\n\t\telse if (ext4_has_feature_quota(sb)) {\n\t\t\terr = ext4_enable_quotas(sb);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\t\t}\n\t}\n#endif\n\n\t*flags = (*flags & ~MS_LAZYTIME) | (sb->s_flags & MS_LAZYTIME);\n\text4_msg(sb, KERN_INFO, \"re-mounted. Opts: %s\", orig_data);\n\tkfree(orig_data);\n\treturn 0;\n\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_mount_opt2 = old_opts.s_mount_opt2;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n\tsbi->s_min_batch_time = old_opts.s_min_batch_time;\n\tsbi->s_max_batch_time = old_opts.s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\tkfree(orig_data);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static int ext4_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long old_sb_flags;\n\tstruct ext4_mount_options old_opts;\n\tint enable_quota = 0;\n\text4_group_t g;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\tint err = 0;\n#ifdef CONFIG_QUOTA\n\tint i, j;\n#endif\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_mount_opt2 = sbi->s_mount_opt2;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n\told_opts.s_min_batch_time = sbi->s_min_batch_time;\n\told_opts.s_max_batch_time = sbi->s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\told_opts.s_qf_names[i] = kstrdup(sbi->s_qf_names[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\tkfree(orig_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\tif (sbi->s_journal && sbi->s_journal->j_task->io_context)\n\t\tjournal_ioprio = sbi->s_journal->j_task->io_context->ioprio;\n\n\tif (!parse_options(data, sb, NULL, &journal_ioprio, 1)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif ((old_opts.s_mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) ^\n\t    test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\text4_msg(sb, KERN_ERR, \"changing journal_checksum \"\n\t\t\t \"during remount not supported; ignoring\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_DAX) {\n\t\text4_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t\"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_DAX;\n\t}\n\n\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\text4_abort(sb, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\tif (sbi->s_journal) {\n\t\text4_init_journal_params(sb, sbi->s_journal);\n\t\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\t}\n\n\tif (*flags & MS_LAZYTIME)\n\t\tsb->s_flags |= MS_LAZYTIME;\n\n\tif ((*flags & MS_RDONLY) != (sb->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_mount_flags & EXT4_MF_FS_ABORTED) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (*flags & MS_RDONLY) {\n\t\t\terr = sync_filesystem(sb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= MS_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT4_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT4_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_mark_recovery_complete(sb, es);\n\t\t} else {\n\t\t\t/* Make sure we can mount this feature set readwrite */\n\t\t\tif (ext4_has_feature_readonly(sb) ||\n\t\t\t    !ext4_feature_set_ok(sb, 0)) {\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Make sure the group descriptor checksums\n\t\t\t * are sane.  If they aren't, refuse to remount r/w.\n\t\t\t */\n\t\t\tfor (g = 0; g < sbi->s_groups_count; g++) {\n\t\t\t\tstruct ext4_group_desc *gdp =\n\t\t\t\t\text4_get_group_desc(sb, g, NULL);\n\n\t\t\t\tif (!ext4_group_desc_csum_verify(sb, g, gdp)) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t       \"ext4_remount: Checksum for group %u failed (%u!=%u)\",\n\t\tg, le16_to_cpu(ext4_group_desc_csum(sb, g, gdp)),\n\t\t\t\t\t       le16_to_cpu(gdp->bg_checksum));\n\t\t\t\t\terr = -EFSBADCRC;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount/remount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount/remount instead\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\tif (sbi->s_journal)\n\t\t\t\text4_clear_journal_err(sb, es);\n\t\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\t\tif (!ext4_setup_super(sb, es, 0))\n\t\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\t\tif (ext4_has_feature_mmp(sb))\n\t\t\t\tif (ext4_multi_mount_protect(sb,\n\t\t\t\t\t\tle64_to_cpu(es->s_mmp_block))) {\n\t\t\t\t\terr = -EROFS;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\tenable_quota = 1;\n\t\t}\n\t}\n\n\t/*\n\t * Reinitialize lazy itable initialization thread based on\n\t * current settings\n\t */\n\tif ((sb->s_flags & MS_RDONLY) || !test_opt(sb, INIT_INODE_TABLE))\n\t\text4_unregister_li_request(sb);\n\telse {\n\t\text4_group_t first_not_zeroed;\n\t\tfirst_not_zeroed = ext4_has_uninit_itable(sb);\n\t\text4_register_li_request(sb, first_not_zeroed);\n\t}\n\n\text4_setup_system_zone(sb);\n\tif (sbi->s_journal == NULL && !(old_sb_flags & MS_RDONLY))\n\t\text4_commit_super(sb, 1);\n\n#ifdef CONFIG_QUOTA\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n\tif (enable_quota) {\n\t\tif (sb_any_quota_suspended(sb))\n\t\t\tdquot_resume(sb, -1);\n\t\telse if (ext4_has_feature_quota(sb)) {\n\t\t\terr = ext4_enable_quotas(sb);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\t\t}\n\t}\n#endif\n\n\t*flags = (*flags & ~MS_LAZYTIME) | (sb->s_flags & MS_LAZYTIME);\n\text4_msg(sb, KERN_INFO, \"re-mounted. Opts: %s\", orig_data);\n\tkfree(orig_data);\n\treturn 0;\n\nrestore_opts:\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_mount_opt2 = old_opts.s_mount_opt2;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n\tsbi->s_min_batch_time = old_opts.s_min_batch_time;\n\tsbi->s_max_batch_time = old_opts.s_max_batch_time;\n#ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tkfree(sbi->s_qf_names[i]);\n\t\tsbi->s_qf_names[i] = old_opts.s_qf_names[i];\n\t}\n#endif\n\tkfree(orig_data);\n\treturn err;\n}\n",
        "linevul": 0.0008314853766933084,
        "sysevr": 0.2801249623298645,
        "devign": 0.0
    },
    {
        "code": "static u64 ldm_get_vnum (const u8 *block)\n{\n\tu64 tmp = 0;\n\tu8 length;\n\n\tBUG_ON (!block);\n\n\tlength = *block++;\n\n\tif (length && length <= 8)\n\t\twhile (length--)\n\t\t\ttmp = (tmp << 8) | *block++;\n\telse\n\t\tldm_error (\"Illegal length %d.\", length);\n\n\treturn tmp;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4",
        "vul_func_with_fix": "static u64 ldm_get_vnum (const u8 *block)\n{\n\tu64 tmp = 0;\n\tu8 length;\n\n\tBUG_ON (!block);\n\n\tlength = *block++;\n\n\tif (length && length <= 8)\n\t\twhile (length--)\n\t\t\ttmp = (tmp << 8) | *block++;\n\telse\n\t\tldm_error (\"Illegal length %d.\", length);\n\n\treturn tmp;\n}\n",
        "linevul": 5.656063149217516e-05,
        "sysevr": 0.13407838344573975,
        "devign": 2.2877308936131158e-07
    },
    {
        "code": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "linevul": 0.00011933588393731043,
        "sysevr": 0.1762186884880066,
        "devign": 7.563376388895974e-18
    },
    {
        "code": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\tdown_write(&current->mm->mmap_sem);\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = do_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tdo_munmap(current->mm, map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = do_mmap(filep, addr, size, prot, type, off);\n\n\tup_write(&current->mm->mmap_sem);\n\treturn(map_addr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c8e252586f8d5de906385d8cf6385fee289a825e",
        "vul_func_with_fix": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\tdown_write(&current->mm->mmap_sem);\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = do_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tdo_munmap(current->mm, map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = do_mmap(filep, addr, size, prot, type, off);\n\n\tup_write(&current->mm->mmap_sem);\n\treturn(map_addr);\n}\n",
        "linevul": 0.0005310673150233924,
        "sysevr": 0.24354664981365204,
        "devign": 7.20919312880439e-15
    },
    {
        "code": "unhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "unhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}\n",
        "linevul": 6.376830424414948e-05,
        "sysevr": 0.16943277418613434,
        "devign": 4.781043472235069e-08
    },
    {
        "code": "static int xt_match_open(struct inode *inode, struct file *file)\n{\n\tstruct nf_mttg_trav *trav;\n\ttrav = __seq_open_private(file, &xt_match_seq_ops, sizeof(*trav));\n\tif (!trav)\n\t\treturn -ENOMEM;\n\n\ttrav->nfproto = (unsigned long)PDE_DATA(inode);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c",
        "vul_func_with_fix": "static int xt_match_open(struct inode *inode, struct file *file)\n{\n\tstruct nf_mttg_trav *trav;\n\ttrav = __seq_open_private(file, &xt_match_seq_ops, sizeof(*trav));\n\tif (!trav)\n\t\treturn -ENOMEM;\n\n\ttrav->nfproto = (unsigned long)PDE_DATA(inode);\n\treturn 0;\n}\n",
        "linevul": 6.087640576879494e-05,
        "sysevr": 0.12915244698524475,
        "devign": 9.569583685199013e-17
    },
    {
        "code": "void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)\n{\n\tint r;\n\n\tif (vq->used_flags & VRING_USED_F_NO_NOTIFY)\n\t\treturn;\n\tvq->used_flags |= VRING_USED_F_NO_NOTIFY;\n\tif (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {\n\t\tr = vhost_update_used_flags(vq);\n\t\tif (r)\n\t\t\tvq_err(vq, \"Failed to enable notification at %p: %d\\n\",\n\t\t\t       &vq->used->flags, r);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5",
        "vul_func_with_fix": "void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)\n{\n\tint r;\n\n\tif (vq->used_flags & VRING_USED_F_NO_NOTIFY)\n\t\treturn;\n\tvq->used_flags |= VRING_USED_F_NO_NOTIFY;\n\tif (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {\n\t\tr = vhost_update_used_flags(vq);\n\t\tif (r)\n\t\t\tvq_err(vq, \"Failed to enable notification at %p: %d\\n\",\n\t\t\t       &vq->used->flags, r);\n\t}\n}\n",
        "linevul": 6.0327052779030055e-05,
        "sysevr": 0.16295456886291504,
        "devign": 1.1946261757600496e-08
    },
    {
        "code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n \tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n \tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n \tint current_profile;\n\tchar data[8];\n \n \tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n \t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n \tif (ret < 0) {\n \t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n \t\t\t ret);\n\t\treturn -EIO;\n \t}\n \tcurrent_profile = data[7];\n \tif (current_profile < 1 || current_profile > 3) {\n \t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n \t\t\t data[7]);\n\t\treturn -EIO;\n \t}\n \n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d",
        "vul_func_with_fix": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n \tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n \tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n \tint current_profile;\n//flaw_line_below:\n\tchar data[8];\n//fix_flaw_line_below:\n//\tchar *data;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tdata = kmalloc(8, GFP_KERNEL);\n//fix_flaw_line_below:\n//\tif (!data)\n//fix_flaw_line_below:\n//\t\treturn -ENOMEM;\n \n \tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n \t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n \tif (ret < 0) {\n \t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n \t\t\t ret);\n//flaw_line_below:\n\t\treturn -EIO;\n//fix_flaw_line_below:\n//\t\tret = -EIO;\n//fix_flaw_line_below:\n//\t\tgoto out;\n \t}\n \tcurrent_profile = data[7];\n \tif (current_profile < 1 || current_profile > 3) {\n \t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n \t\t\t data[7]);\n//flaw_line_below:\n\t\treturn -EIO;\n//fix_flaw_line_below:\n//\t\tret = -EIO;\n//fix_flaw_line_below:\n//\t\tgoto out;\n \t}\n \n//flaw_line_below:\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n//fix_flaw_line_below:\n//\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n//fix_flaw_line_below:\n//out:\n//fix_flaw_line_below:\n//\tkfree(data);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\treturn ret;\n }\n",
        "linevul": 0.9994956254959106,
        "sysevr": 0.12531858682632446,
        "devign": 0.9997755885124207
    },
    {
        "code": "static void efx_set_channels(struct efx_nic *efx)\n{\n\tstruct efx_channel *channel;\n\tstruct efx_tx_queue *tx_queue;\n\n\tefx->tx_channel_offset =\n\t\tseparate_tx_channels ? efx->n_channels - efx->n_tx_channels : 0;\n\n\t/* We need to adjust the TX queue numbers if we have separate\n\t * RX-only and TX-only channels.\n\t */\n\tefx_for_each_channel(channel, efx) {\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\ttx_queue->queue -= (efx->tx_channel_offset *\n\t\t\t\t\t    EFX_TXQ_TYPES);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "vul_func_with_fix": "static void efx_set_channels(struct efx_nic *efx)\n{\n\tstruct efx_channel *channel;\n\tstruct efx_tx_queue *tx_queue;\n\n\tefx->tx_channel_offset =\n\t\tseparate_tx_channels ? efx->n_channels - efx->n_tx_channels : 0;\n\n\t/* We need to adjust the TX queue numbers if we have separate\n\t * RX-only and TX-only channels.\n\t */\n\tefx_for_each_channel(channel, efx) {\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\ttx_queue->queue -= (efx->tx_channel_offset *\n\t\t\t\t\t    EFX_TXQ_TYPES);\n\t}\n}\n",
        "linevul": 4.5538701670011505e-05,
        "sysevr": 0.13030663132667542,
        "devign": 2.376772201273525e-08
    },
    {
        "code": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n \t\tunsigned char tmp;\n \n \t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND &&\n\t\t     flags & FLAG_MATCHED) ||\n\t\t    dp == datalen) {\n \t\t\tflags &= ~FLAG_LAST_MATCHED;\n \t\t\tpc += asn1_op_lengths[op];\n \t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0d62e9dd6da45bbf0f33a8617afc5fe774c8f45f",
        "vul_func_with_fix": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n \t\tunsigned char tmp;\n \n \t\t/* Skip conditional matches if possible */\n//flaw_line_below:\n\t\tif ((op & ASN1_OP_MATCH__COND &&\n//flaw_line_below:\n\t\t     flags & FLAG_MATCHED) ||\n//flaw_line_below:\n\t\t    dp == datalen) {\n//fix_flaw_line_below:\n//\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n//fix_flaw_line_below:\n//\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n \t\t\tflags &= ~FLAG_LAST_MATCHED;\n \t\t\tpc += asn1_op_lengths[op];\n \t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}\n",
        "linevul": 0.0341610461473465,
        "sysevr": 0.342461496591568,
        "devign": 0.9992559552192688
    },
    {
        "code": "static int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ce1fad2740c648a4340f6f6c391a8a83769d2e8c",
        "vul_func_with_fix": "static int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n",
        "linevul": 0.000446572172222659,
        "sysevr": 0.21046558022499084,
        "devign": 8.542419296902765e-19
    },
    {
        "code": "sync_speed_show(struct mddev *mddev, char *page)\n{\n\tunsigned long resync, dt, db;\n\tif (mddev->curr_resync == 0)\n\t\treturn sprintf(page, \"none\\n\");\n\tresync = mddev->curr_mark_cnt - atomic_read(&mddev->recovery_active);\n\tdt = (jiffies - mddev->resync_mark) / HZ;\n\tif (!dt) dt++;\n\tdb = resync - mddev->resync_mark_cnt;\n\treturn sprintf(page, \"%lu\\n\", db/dt/2); /* K/sec */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "sync_speed_show(struct mddev *mddev, char *page)\n{\n\tunsigned long resync, dt, db;\n\tif (mddev->curr_resync == 0)\n\t\treturn sprintf(page, \"none\\n\");\n\tresync = mddev->curr_mark_cnt - atomic_read(&mddev->recovery_active);\n\tdt = (jiffies - mddev->resync_mark) / HZ;\n\tif (!dt) dt++;\n\tdb = resync - mddev->resync_mark_cnt;\n\treturn sprintf(page, \"%lu\\n\", db/dt/2); /* K/sec */\n}\n",
        "linevul": 4.946706030750647e-05,
        "sysevr": 0.1668362021446228,
        "devign": 1.617592602087825e-07
    },
    {
        "code": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n \n \t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n \t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1)\n \t\t\t\tgoto retry;\n \t\t\tif (ret) {\n \t\t\t\tsock = NULL;\n \t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f991af3daabaecff34684fd51fac80319d1baad1",
        "vul_func_with_fix": "static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t/* create the notify skb */\n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* TODO: add a header? */\n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t/* and attach it to the socket */\nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n \n \t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n \t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n//flaw_line_below:\n\t\t\tif (ret == 1)\n//fix_flaw_line_below:\n//\t\t\tif (ret == 1) {\n//fix_flaw_line_below:\n//\t\t\t\tsock = NULL;\n \t\t\t\tgoto retry;\n//fix_flaw_line_below:\n//\t\t\t}\n \t\t\tif (ret) {\n \t\t\t\tsock = NULL;\n \t\t\t\tnc = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode->i_ctime = current_time(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse if (nc)\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}\n",
        "linevul": 0.00012193518341518939,
        "sysevr": 0.2047041654586792,
        "devign": 1.4499280942548154e-10
    },
    {
        "code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n \tif (!unifilename)\n \t\tgoto out1;\n \n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n \t} else\n \t\tgoto out2;\n \n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
        "vul_func_with_fix": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n//flaw_line_below:\n\t\t     int flen)\n//fix_flaw_line_below:\n//int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n//fix_flaw_line_below:\n//\t\t     uint8_t *dname, int dlen)\n {\n \tstruct ustr *filename, *unifilename;\n \tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n \tif (!unifilename)\n \t\tgoto out1;\n \n//flaw_line_below:\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n//fix_flaw_line_below:\n//\tif (udf_build_ustr_exact(unifilename, sname, slen))\n \t\tgoto out2;\n \n \tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n \t} else\n \t\tgoto out2;\n \n//flaw_line_below:\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n//fix_flaw_line_below:\n//\tlen = udf_translate_to_linux(dname, dlen,\n//fix_flaw_line_below:\n//\t\t\t\t     filename->u_name, filename->u_len,\n \t\t\t\t     unifilename->u_name, unifilename->u_len);\n out2:\n \tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}\n",
        "linevul": 0.9996132254600525,
        "sysevr": 0.16448624432086945,
        "devign": 0.9610555768013
    },
    {
        "code": "static unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tint8_t etype;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/adee11b2085bee90bd8f4f52123ffb07882d6256",
        "vul_func_with_fix": "static unsigned int udf_count_free_table(struct super_block *sb,\n\t\t\t\t\t struct inode *table)\n{\n\tunsigned int accum = 0;\n\tuint32_t elen;\n\tstruct kernel_lb_addr eloc;\n\tint8_t etype;\n\tstruct extent_position epos;\n\n\tmutex_lock(&UDF_SB(sb)->s_alloc_mutex);\n\tepos.block = UDF_I(table)->i_location;\n\tepos.offset = sizeof(struct unallocSpaceEntry);\n\tepos.bh = NULL;\n\n\twhile ((etype = udf_next_aext(table, &epos, &eloc, &elen, 1)) != -1)\n\t\taccum += (elen >> table->i_sb->s_blocksize_bits);\n\n\tbrelse(epos.bh);\n\tmutex_unlock(&UDF_SB(sb)->s_alloc_mutex);\n\n\treturn accum;\n}\n",
        "linevul": 6.447933265008032e-05,
        "sysevr": 0.13229960203170776,
        "devign": 5.654168778675727e-19
    },
    {
        "code": "void sctp_assoc_del_peer(struct sctp_association *asoc,\n\t\t\t const union sctp_addr *addr)\n{\n\tstruct list_head\t*pos;\n\tstruct list_head\t*temp;\n\tstruct sctp_transport\t*transport;\n\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (sctp_cmp_addr_exact(addr, &transport->ipaddr)) {\n\t\t\t/* Do book keeping for removing the peer and free it. */\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa",
        "vul_func_with_fix": "void sctp_assoc_del_peer(struct sctp_association *asoc,\n\t\t\t const union sctp_addr *addr)\n{\n\tstruct list_head\t*pos;\n\tstruct list_head\t*temp;\n\tstruct sctp_transport\t*transport;\n\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (sctp_cmp_addr_exact(addr, &transport->ipaddr)) {\n\t\t\t/* Do book keeping for removing the peer and free it. */\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
        "linevul": 5.026106009609066e-05,
        "sysevr": 0.19184373319149017,
        "devign": 1.5695178988937852e-13
    },
    {
        "code": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq)\n{\n\treturn __apic_accept_irq(vcpu, irq->vector);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c895160d25a76c21b65bad141b08e8d4f99afef",
        "vul_func_with_fix": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq)\n{\n\treturn __apic_accept_irq(vcpu, irq->vector);\n}\n",
        "linevul": 5.2696883358294144e-05,
        "sysevr": 0.14980527758598328,
        "devign": 0.0015079209115356207
    },
    {
        "code": "static void hid_cease_io(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbctrl);\n\tusb_kill_urb(usbhid->urbout);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b",
        "vul_func_with_fix": "static void hid_cease_io(struct usbhid_device *usbhid)\n{\n\tdel_timer_sync(&usbhid->io_retry);\n\tusb_kill_urb(usbhid->urbin);\n\tusb_kill_urb(usbhid->urbctrl);\n\tusb_kill_urb(usbhid->urbout);\n}\n",
        "linevul": 0.00025482973433099687,
        "sysevr": 0.12857651710510254,
        "devign": 0.24759909510612488
    },
    {
        "code": "static int keyring_search_iterator(const void *object, void *iterator_data)\n {\n \tstruct keyring_search_context *ctx = iterator_data;\n \tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n \n \tkenter(\"{%d}\", key->serial);\n \n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n \n \tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n \t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n \t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n \t\t\tgoto skipped;\n \t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static int keyring_search_iterator(const void *object, void *iterator_data)\n {\n \tstruct keyring_search_context *ctx = iterator_data;\n \tconst struct key *key = keyring_ptr_to_key(object);\n//flaw_line_below:\n\tunsigned long kflags = key->flags;\n//fix_flaw_line_below:\n//\tunsigned long kflags = READ_ONCE(key->flags);\n//fix_flaw_line_below:\n//\tshort state = READ_ONCE(key->state);\n \n \tkenter(\"{%d}\", key->serial);\n \n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n \n \tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n \t\t/* we set a different error code if we pass a negative key */\n//flaw_line_below:\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n//flaw_line_below:\n\t\t\tsmp_rmb();\n//flaw_line_below:\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n//fix_flaw_line_below:\n//\t\tif (state < 0) {\n//fix_flaw_line_below:\n//\t\t\tctx->result = ERR_PTR(state);\n \t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n \t\t\tgoto skipped;\n \t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n",
        "linevul": 0.999618649482727,
        "sysevr": 0.1645756959915161,
        "devign": 0.9874820709228516
    },
    {
        "code": "vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)\n{\n\tstruct vhost_scsi_tpg **vs_tpg, *tpg;\n\tstruct virtio_scsi_cmd_req v_req;\n\tstruct virtio_scsi_cmd_req_pi v_req_pi;\n\tstruct vhost_scsi_cmd *cmd;\n\tstruct iov_iter out_iter, in_iter, prot_iter, data_iter;\n\tu64 tag;\n\tu32 exp_data_len, data_direction;\n\tunsigned out, in;\n\tint head, ret, prot_bytes;\n\tsize_t req_size, rsp_size = sizeof(struct virtio_scsi_cmd_resp);\n\tsize_t out_size, in_size;\n\tu16 lun;\n\tu8 *target, *lunp, task_attr;\n\tbool t10_pi = vhost_has_feature(vq, VIRTIO_SCSI_F_T10_PI);\n\tvoid *req, *cdb;\n\n\tmutex_lock(&vq->mutex);\n\t/*\n\t * We can handle the vq only after the endpoint is setup by calling the\n\t * VHOST_SCSI_SET_ENDPOINT ioctl.\n\t */\n\tvs_tpg = vq->private_data;\n\tif (!vs_tpg)\n\t\tgoto out;\n\n\tvhost_disable_notify(&vs->dev, vq);\n\n\tfor (;;) {\n\t\thead = vhost_get_vq_desc(vq, vq->iov,\n\t\t\t\t\t ARRAY_SIZE(vq->iov), &out, &in,\n\t\t\t\t\t NULL, NULL);\n\t\tpr_debug(\"vhost_get_vq_desc: head: %d, out: %u in: %u\\n\",\n\t\t\t head, out, in);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(head < 0))\n\t\t\tbreak;\n\t\t/* Nothing new?  Wait for eventfd to tell us they refilled. */\n\t\tif (head == vq->num) {\n\t\t\tif (unlikely(vhost_enable_notify(&vs->dev, vq))) {\n\t\t\t\tvhost_disable_notify(&vs->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Check for a sane response buffer so we can report early\n\t\t * errors back to the guest.\n\t\t */\n\t\tif (unlikely(vq->iov[out].iov_len < rsp_size)) {\n\t\t\tvq_err(vq, \"Expecting at least virtio_scsi_cmd_resp\"\n\t\t\t\t\" size, got %zu bytes\\n\", vq->iov[out].iov_len);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Setup pointers and values based upon different virtio-scsi\n\t\t * request header if T10_PI is enabled in KVM guest.\n\t\t */\n\t\tif (t10_pi) {\n\t\t\treq = &v_req_pi;\n\t\t\treq_size = sizeof(v_req_pi);\n\t\t\tlunp = &v_req_pi.lun[0];\n\t\t\ttarget = &v_req_pi.lun[1];\n\t\t} else {\n\t\t\treq = &v_req;\n\t\t\treq_size = sizeof(v_req);\n\t\t\tlunp = &v_req.lun[0];\n\t\t\ttarget = &v_req.lun[1];\n\t\t}\n\t\t/*\n\t\t * FIXME: Not correct for BIDI operation\n\t\t */\n\t\tout_size = iov_length(vq->iov, out);\n\t\tin_size = iov_length(&vq->iov[out], in);\n\n\t\t/*\n\t\t * Copy over the virtio-scsi request header, which for a\n\t\t * ANY_LAYOUT enabled guest may span multiple iovecs, or a\n\t\t * single iovec may contain both the header + outgoing\n\t\t * WRITE payloads.\n\t\t *\n\t\t * copy_from_iter() will advance out_iter, so that it will\n\t\t * point at the start of the outgoing WRITE payload, if\n\t\t * DMA_TO_DEVICE is set.\n\t\t */\n\t\tiov_iter_init(&out_iter, WRITE, vq->iov, out, out_size);\n\n\t\tret = copy_from_iter(req, req_size, &out_iter);\n\t\tif (unlikely(ret != req_size)) {\n\t\t\tvq_err(vq, \"Faulted on copy_from_iter\\n\");\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\t/* virtio-scsi spec requires byte 0 of the lun to be 1 */\n\t\tif (unlikely(*lunp != 1)) {\n\t\t\tvq_err(vq, \"Illegal virtio-scsi lun: %u\\n\", *lunp);\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttpg = ACCESS_ONCE(vs_tpg[*target]);\n\t\tif (unlikely(!tpg)) {\n\t\t\t/* Target does not exist, fail the request */\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Determine data_direction by calculating the total outgoing\n\t\t * iovec sizes + incoming iovec sizes vs. virtio-scsi request +\n\t\t * response headers respectively.\n\t\t *\n\t\t * For DMA_TO_DEVICE this is out_iter, which is already pointing\n\t\t * to the right place.\n\t\t *\n\t\t * For DMA_FROM_DEVICE, the iovec will be just past the end\n\t\t * of the virtio-scsi response header in either the same\n\t\t * or immediately following iovec.\n\t\t *\n\t\t * Any associated T10_PI bytes for the outgoing / incoming\n\t\t * payloads are included in calculation of exp_data_len here.\n\t\t */\n\t\tprot_bytes = 0;\n\n\t\tif (out_size > req_size) {\n\t\t\tdata_direction = DMA_TO_DEVICE;\n\t\t\texp_data_len = out_size - req_size;\n\t\t\tdata_iter = out_iter;\n\t\t} else if (in_size > rsp_size) {\n\t\t\tdata_direction = DMA_FROM_DEVICE;\n\t\t\texp_data_len = in_size - rsp_size;\n\n\t\t\tiov_iter_init(&in_iter, READ, &vq->iov[out], in,\n\t\t\t\t      rsp_size + exp_data_len);\n\t\t\tiov_iter_advance(&in_iter, rsp_size);\n\t\t\tdata_iter = in_iter;\n\t\t} else {\n\t\t\tdata_direction = DMA_NONE;\n\t\t\texp_data_len = 0;\n\t\t}\n\t\t/*\n\t\t * If T10_PI header + payload is present, setup prot_iter values\n\t\t * and recalculate data_iter for vhost_scsi_mapal() mapping to\n\t\t * host scatterlists via get_user_pages_fast().\n\t\t */\n\t\tif (t10_pi) {\n\t\t\tif (v_req_pi.pi_bytesout) {\n\t\t\t\tif (data_direction != DMA_TO_DEVICE) {\n\t\t\t\t\tvq_err(vq, \"Received non zero pi_bytesout,\"\n\t\t\t\t\t\t\" but wrong data_direction\\n\");\n\t\t\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprot_bytes = vhost32_to_cpu(vq, v_req_pi.pi_bytesout);\n\t\t\t} else if (v_req_pi.pi_bytesin) {\n\t\t\t\tif (data_direction != DMA_FROM_DEVICE) {\n\t\t\t\t\tvq_err(vq, \"Received non zero pi_bytesin,\"\n\t\t\t\t\t\t\" but wrong data_direction\\n\");\n\t\t\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprot_bytes = vhost32_to_cpu(vq, v_req_pi.pi_bytesin);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Set prot_iter to data_iter, and advance past any\n\t\t\t * preceeding prot_bytes that may be present.\n\t\t\t *\n\t\t\t * Also fix up the exp_data_len to reflect only the\n\t\t\t * actual data payload length.\n\t\t\t */\n\t\t\tif (prot_bytes) {\n\t\t\t\texp_data_len -= prot_bytes;\n\t\t\t\tprot_iter = data_iter;\n\t\t\t\tiov_iter_advance(&data_iter, prot_bytes);\n\t\t\t}\n\t\t\ttag = vhost64_to_cpu(vq, v_req_pi.tag);\n\t\t\ttask_attr = v_req_pi.task_attr;\n\t\t\tcdb = &v_req_pi.cdb[0];\n\t\t\tlun = ((v_req_pi.lun[2] << 8) | v_req_pi.lun[3]) & 0x3FFF;\n\t\t} else {\n\t\t\ttag = vhost64_to_cpu(vq, v_req.tag);\n\t\t\ttask_attr = v_req.task_attr;\n\t\t\tcdb = &v_req.cdb[0];\n\t\t\tlun = ((v_req.lun[2] << 8) | v_req.lun[3]) & 0x3FFF;\n\t\t}\n\t\t/*\n\t\t * Check that the received CDB size does not exceeded our\n\t\t * hardcoded max for vhost-scsi, then get a pre-allocated\n\t\t * cmd descriptor for the new virtio-scsi tag.\n\t\t *\n\t\t * TODO what if cdb was too small for varlen cdb header?\n\t\t */\n\t\tif (unlikely(scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE)) {\n\t\t\tvq_err(vq, \"Received SCSI CDB with command_size: %d that\"\n\t\t\t\t\" exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d\\n\",\n\t\t\t\tscsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\tcmd = vhost_scsi_get_tag(vq, tpg, cdb, tag, lun, task_attr,\n\t\t\t\t\t exp_data_len + prot_bytes,\n\t\t\t\t\t data_direction);\n\t\tif (IS_ERR(cmd)) {\n\t\t\tvq_err(vq, \"vhost_scsi_get_tag failed %ld\\n\",\n\t\t\t       PTR_ERR(cmd));\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\tcmd->tvc_vhost = vs;\n\t\tcmd->tvc_vq = vq;\n\t\tcmd->tvc_resp_iov = &vq->iov[out];\n\t\tcmd->tvc_in_iovs = in;\n\n\t\tpr_debug(\"vhost_scsi got command opcode: %#02x, lun: %d\\n\",\n\t\t\t cmd->tvc_cdb[0], cmd->tvc_lun);\n\t\tpr_debug(\"cmd: %p exp_data_len: %d, prot_bytes: %d data_direction:\"\n\t\t\t \" %d\\n\", cmd, exp_data_len, prot_bytes, data_direction);\n\n\t\tif (data_direction != DMA_NONE) {\n\t\t\tret = vhost_scsi_mapal(cmd,\n\t\t\t\t\t       prot_bytes, &prot_iter,\n\t\t\t\t\t       exp_data_len, &data_iter);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tvq_err(vq, \"Failed to map iov to sgl\\n\");\n\t\t\t\tvhost_scsi_release_cmd(&cmd->tvc_se_cmd);\n\t\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Save the descriptor from vhost_get_vq_desc() to be used to\n\t\t * complete the virtio-scsi request in TCM callback context via\n\t\t * vhost_scsi_queue_data_in() and vhost_scsi_queue_status()\n\t\t */\n\t\tcmd->tvc_vq_desc = head;\n\t\t/*\n\t\t * Dispatch cmd descriptor for cmwq execution in process\n\t\t * context provided by vhost_scsi_workqueue.  This also ensures\n\t\t * cmd is executed on the same kworker CPU as this vhost\n\t\t * thread to gain positive L2 cache locality effects.\n\t\t */\n\t\tINIT_WORK(&cmd->work, vhost_scsi_submission_work);\n\t\tqueue_work(vhost_scsi_workqueue, &cmd->work);\n\t}\nout:\n\tmutex_unlock(&vq->mutex);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c",
        "vul_func_with_fix": "vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)\n{\n\tstruct vhost_scsi_tpg **vs_tpg, *tpg;\n\tstruct virtio_scsi_cmd_req v_req;\n\tstruct virtio_scsi_cmd_req_pi v_req_pi;\n\tstruct vhost_scsi_cmd *cmd;\n\tstruct iov_iter out_iter, in_iter, prot_iter, data_iter;\n\tu64 tag;\n\tu32 exp_data_len, data_direction;\n\tunsigned out, in;\n\tint head, ret, prot_bytes;\n\tsize_t req_size, rsp_size = sizeof(struct virtio_scsi_cmd_resp);\n\tsize_t out_size, in_size;\n\tu16 lun;\n\tu8 *target, *lunp, task_attr;\n\tbool t10_pi = vhost_has_feature(vq, VIRTIO_SCSI_F_T10_PI);\n\tvoid *req, *cdb;\n\n\tmutex_lock(&vq->mutex);\n\t/*\n\t * We can handle the vq only after the endpoint is setup by calling the\n\t * VHOST_SCSI_SET_ENDPOINT ioctl.\n\t */\n\tvs_tpg = vq->private_data;\n\tif (!vs_tpg)\n\t\tgoto out;\n\n\tvhost_disable_notify(&vs->dev, vq);\n\n\tfor (;;) {\n\t\thead = vhost_get_vq_desc(vq, vq->iov,\n\t\t\t\t\t ARRAY_SIZE(vq->iov), &out, &in,\n\t\t\t\t\t NULL, NULL);\n\t\tpr_debug(\"vhost_get_vq_desc: head: %d, out: %u in: %u\\n\",\n\t\t\t head, out, in);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(head < 0))\n\t\t\tbreak;\n\t\t/* Nothing new?  Wait for eventfd to tell us they refilled. */\n\t\tif (head == vq->num) {\n\t\t\tif (unlikely(vhost_enable_notify(&vs->dev, vq))) {\n\t\t\t\tvhost_disable_notify(&vs->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Check for a sane response buffer so we can report early\n\t\t * errors back to the guest.\n\t\t */\n\t\tif (unlikely(vq->iov[out].iov_len < rsp_size)) {\n\t\t\tvq_err(vq, \"Expecting at least virtio_scsi_cmd_resp\"\n\t\t\t\t\" size, got %zu bytes\\n\", vq->iov[out].iov_len);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Setup pointers and values based upon different virtio-scsi\n\t\t * request header if T10_PI is enabled in KVM guest.\n\t\t */\n\t\tif (t10_pi) {\n\t\t\treq = &v_req_pi;\n\t\t\treq_size = sizeof(v_req_pi);\n\t\t\tlunp = &v_req_pi.lun[0];\n\t\t\ttarget = &v_req_pi.lun[1];\n\t\t} else {\n\t\t\treq = &v_req;\n\t\t\treq_size = sizeof(v_req);\n\t\t\tlunp = &v_req.lun[0];\n\t\t\ttarget = &v_req.lun[1];\n\t\t}\n\t\t/*\n\t\t * FIXME: Not correct for BIDI operation\n\t\t */\n\t\tout_size = iov_length(vq->iov, out);\n\t\tin_size = iov_length(&vq->iov[out], in);\n\n\t\t/*\n\t\t * Copy over the virtio-scsi request header, which for a\n\t\t * ANY_LAYOUT enabled guest may span multiple iovecs, or a\n\t\t * single iovec may contain both the header + outgoing\n\t\t * WRITE payloads.\n\t\t *\n\t\t * copy_from_iter() will advance out_iter, so that it will\n\t\t * point at the start of the outgoing WRITE payload, if\n\t\t * DMA_TO_DEVICE is set.\n\t\t */\n\t\tiov_iter_init(&out_iter, WRITE, vq->iov, out, out_size);\n\n\t\tret = copy_from_iter(req, req_size, &out_iter);\n\t\tif (unlikely(ret != req_size)) {\n\t\t\tvq_err(vq, \"Faulted on copy_from_iter\\n\");\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\t/* virtio-scsi spec requires byte 0 of the lun to be 1 */\n\t\tif (unlikely(*lunp != 1)) {\n\t\t\tvq_err(vq, \"Illegal virtio-scsi lun: %u\\n\", *lunp);\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttpg = ACCESS_ONCE(vs_tpg[*target]);\n\t\tif (unlikely(!tpg)) {\n\t\t\t/* Target does not exist, fail the request */\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Determine data_direction by calculating the total outgoing\n\t\t * iovec sizes + incoming iovec sizes vs. virtio-scsi request +\n\t\t * response headers respectively.\n\t\t *\n\t\t * For DMA_TO_DEVICE this is out_iter, which is already pointing\n\t\t * to the right place.\n\t\t *\n\t\t * For DMA_FROM_DEVICE, the iovec will be just past the end\n\t\t * of the virtio-scsi response header in either the same\n\t\t * or immediately following iovec.\n\t\t *\n\t\t * Any associated T10_PI bytes for the outgoing / incoming\n\t\t * payloads are included in calculation of exp_data_len here.\n\t\t */\n\t\tprot_bytes = 0;\n\n\t\tif (out_size > req_size) {\n\t\t\tdata_direction = DMA_TO_DEVICE;\n\t\t\texp_data_len = out_size - req_size;\n\t\t\tdata_iter = out_iter;\n\t\t} else if (in_size > rsp_size) {\n\t\t\tdata_direction = DMA_FROM_DEVICE;\n\t\t\texp_data_len = in_size - rsp_size;\n\n\t\t\tiov_iter_init(&in_iter, READ, &vq->iov[out], in,\n\t\t\t\t      rsp_size + exp_data_len);\n\t\t\tiov_iter_advance(&in_iter, rsp_size);\n\t\t\tdata_iter = in_iter;\n\t\t} else {\n\t\t\tdata_direction = DMA_NONE;\n\t\t\texp_data_len = 0;\n\t\t}\n\t\t/*\n\t\t * If T10_PI header + payload is present, setup prot_iter values\n\t\t * and recalculate data_iter for vhost_scsi_mapal() mapping to\n\t\t * host scatterlists via get_user_pages_fast().\n\t\t */\n\t\tif (t10_pi) {\n\t\t\tif (v_req_pi.pi_bytesout) {\n\t\t\t\tif (data_direction != DMA_TO_DEVICE) {\n\t\t\t\t\tvq_err(vq, \"Received non zero pi_bytesout,\"\n\t\t\t\t\t\t\" but wrong data_direction\\n\");\n\t\t\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprot_bytes = vhost32_to_cpu(vq, v_req_pi.pi_bytesout);\n\t\t\t} else if (v_req_pi.pi_bytesin) {\n\t\t\t\tif (data_direction != DMA_FROM_DEVICE) {\n\t\t\t\t\tvq_err(vq, \"Received non zero pi_bytesin,\"\n\t\t\t\t\t\t\" but wrong data_direction\\n\");\n\t\t\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprot_bytes = vhost32_to_cpu(vq, v_req_pi.pi_bytesin);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Set prot_iter to data_iter, and advance past any\n\t\t\t * preceeding prot_bytes that may be present.\n\t\t\t *\n\t\t\t * Also fix up the exp_data_len to reflect only the\n\t\t\t * actual data payload length.\n\t\t\t */\n\t\t\tif (prot_bytes) {\n\t\t\t\texp_data_len -= prot_bytes;\n\t\t\t\tprot_iter = data_iter;\n\t\t\t\tiov_iter_advance(&data_iter, prot_bytes);\n\t\t\t}\n\t\t\ttag = vhost64_to_cpu(vq, v_req_pi.tag);\n\t\t\ttask_attr = v_req_pi.task_attr;\n\t\t\tcdb = &v_req_pi.cdb[0];\n\t\t\tlun = ((v_req_pi.lun[2] << 8) | v_req_pi.lun[3]) & 0x3FFF;\n\t\t} else {\n\t\t\ttag = vhost64_to_cpu(vq, v_req.tag);\n\t\t\ttask_attr = v_req.task_attr;\n\t\t\tcdb = &v_req.cdb[0];\n\t\t\tlun = ((v_req.lun[2] << 8) | v_req.lun[3]) & 0x3FFF;\n\t\t}\n\t\t/*\n\t\t * Check that the received CDB size does not exceeded our\n\t\t * hardcoded max for vhost-scsi, then get a pre-allocated\n\t\t * cmd descriptor for the new virtio-scsi tag.\n\t\t *\n\t\t * TODO what if cdb was too small for varlen cdb header?\n\t\t */\n\t\tif (unlikely(scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE)) {\n\t\t\tvq_err(vq, \"Received SCSI CDB with command_size: %d that\"\n\t\t\t\t\" exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d\\n\",\n\t\t\t\tscsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\tcmd = vhost_scsi_get_tag(vq, tpg, cdb, tag, lun, task_attr,\n\t\t\t\t\t exp_data_len + prot_bytes,\n\t\t\t\t\t data_direction);\n\t\tif (IS_ERR(cmd)) {\n\t\t\tvq_err(vq, \"vhost_scsi_get_tag failed %ld\\n\",\n\t\t\t       PTR_ERR(cmd));\n\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\tcontinue;\n\t\t}\n\t\tcmd->tvc_vhost = vs;\n\t\tcmd->tvc_vq = vq;\n\t\tcmd->tvc_resp_iov = &vq->iov[out];\n\t\tcmd->tvc_in_iovs = in;\n\n\t\tpr_debug(\"vhost_scsi got command opcode: %#02x, lun: %d\\n\",\n\t\t\t cmd->tvc_cdb[0], cmd->tvc_lun);\n\t\tpr_debug(\"cmd: %p exp_data_len: %d, prot_bytes: %d data_direction:\"\n\t\t\t \" %d\\n\", cmd, exp_data_len, prot_bytes, data_direction);\n\n\t\tif (data_direction != DMA_NONE) {\n\t\t\tret = vhost_scsi_mapal(cmd,\n\t\t\t\t\t       prot_bytes, &prot_iter,\n\t\t\t\t\t       exp_data_len, &data_iter);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tvq_err(vq, \"Failed to map iov to sgl\\n\");\n\t\t\t\tvhost_scsi_release_cmd(&cmd->tvc_se_cmd);\n\t\t\t\tvhost_scsi_send_bad_target(vs, vq, head, out);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Save the descriptor from vhost_get_vq_desc() to be used to\n\t\t * complete the virtio-scsi request in TCM callback context via\n\t\t * vhost_scsi_queue_data_in() and vhost_scsi_queue_status()\n\t\t */\n\t\tcmd->tvc_vq_desc = head;\n\t\t/*\n\t\t * Dispatch cmd descriptor for cmwq execution in process\n\t\t * context provided by vhost_scsi_workqueue.  This also ensures\n\t\t * cmd is executed on the same kworker CPU as this vhost\n\t\t * thread to gain positive L2 cache locality effects.\n\t\t */\n\t\tINIT_WORK(&cmd->work, vhost_scsi_submission_work);\n\t\tqueue_work(vhost_scsi_workqueue, &cmd->work);\n\t}\nout:\n\tmutex_unlock(&vq->mutex);\n}\n",
        "linevul": 0.0007679192931391299,
        "sysevr": 0.33287766575813293,
        "devign": 9.560007132182165e-28
    },
    {
        "code": "static inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23",
        "vul_func_with_fix": "static inline bool nested_svm_intr(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn true;\n\n\tif (!(svm->vcpu.arch.hflags & HF_HIF_MASK))\n\t\treturn false;\n\n\t/*\n\t * if vmexit was already requested (by intercepted exception\n\t * for instance) do not overwrite it with \"external interrupt\"\n\t * vmexit.\n\t */\n\tif (svm->nested.exit_required)\n\t\treturn false;\n\n\tsvm->vmcb->control.exit_code   = SVM_EXIT_INTR;\n\tsvm->vmcb->control.exit_info_1 = 0;\n\tsvm->vmcb->control.exit_info_2 = 0;\n\n\tif (svm->nested.intercept & 1ULL) {\n\t\t/*\n\t\t * The #vmexit can't be emulated here directly because this\n\t\t * code path runs with irqs and preemption disabled. A\n\t\t * #vmexit emulation might sleep. Only signal request for\n\t\t * the #vmexit here.\n\t\t */\n\t\tsvm->nested.exit_required = true;\n\t\ttrace_kvm_nested_intr_vmexit(svm->vmcb->save.rip);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "linevul": 5.138024425832555e-05,
        "sysevr": 0.1343507468700409,
        "devign": 4.791637261123728e-14
    },
    {
        "code": "xfs_handle_acceptable(\n\tvoid\t\t\t*context,\n\tstruct dentry\t\t*dentry)\n{\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03",
        "vul_func_with_fix": "xfs_handle_acceptable(\n\tvoid\t\t\t*context,\n\tstruct dentry\t\t*dentry)\n{\n\treturn 1;\n}\n",
        "linevul": 6.107504304964095e-05,
        "sysevr": 0.16206617653369904,
        "devign": 1.4883613230765036e-09
    },
    {
        "code": "static void ctr_crypt_final(struct blkcipher_desc *desc,\n\t\t\t    struct blkcipher_walk *walk)\n{\n\tstruct cast5_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\tu8 *ctrblk = walk->iv;\n\tu8 keystream[CAST5_BLOCK_SIZE];\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tunsigned int nbytes = walk->nbytes;\n\n\t__cast5_encrypt(ctx, keystream, ctrblk);\n\tcrypto_xor(keystream, src, nbytes);\n\tmemcpy(dst, keystream, nbytes);\n\n\tcrypto_inc(ctrblk, CAST5_BLOCK_SIZE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static void ctr_crypt_final(struct blkcipher_desc *desc,\n\t\t\t    struct blkcipher_walk *walk)\n{\n\tstruct cast5_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\tu8 *ctrblk = walk->iv;\n\tu8 keystream[CAST5_BLOCK_SIZE];\n\tu8 *src = walk->src.virt.addr;\n\tu8 *dst = walk->dst.virt.addr;\n\tunsigned int nbytes = walk->nbytes;\n\n\t__cast5_encrypt(ctx, keystream, ctrblk);\n\tcrypto_xor(keystream, src, nbytes);\n\tmemcpy(dst, keystream, nbytes);\n\n\tcrypto_inc(ctrblk, CAST5_BLOCK_SIZE);\n}\n",
        "linevul": 5.345930912881158e-05,
        "sysevr": 0.1390404999256134,
        "devign": 7.756919798428402e-20
    },
    {
        "code": "static int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tbool hash_enable = true;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tftrace_start_up++;\n\tcommand |= FTRACE_UPDATE_CALLS;\n\n\t/* ops marked global share the filter hashes */\n\tif (ops->flags & FTRACE_OPS_FL_GLOBAL) {\n\t\tops = &global_ops;\n\t\t/* Don't update hash if global is already set */\n\t\tif (global_start_up)\n\t\t\thash_enable = false;\n\t\tglobal_start_up++;\n\t}\n\n\tops->flags |= FTRACE_OPS_FL_ENABLED;\n\tif (hash_enable)\n\t\tftrace_hash_rec_enable(ops, 1);\n\n\tftrace_startup_enable(command);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6a76f8c0ab19f215af2a3442870eeb5f0e81998d",
        "vul_func_with_fix": "static int ftrace_startup(struct ftrace_ops *ops, int command)\n{\n\tbool hash_enable = true;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -ENODEV;\n\n\tftrace_start_up++;\n\tcommand |= FTRACE_UPDATE_CALLS;\n\n\t/* ops marked global share the filter hashes */\n\tif (ops->flags & FTRACE_OPS_FL_GLOBAL) {\n\t\tops = &global_ops;\n\t\t/* Don't update hash if global is already set */\n\t\tif (global_start_up)\n\t\t\thash_enable = false;\n\t\tglobal_start_up++;\n\t}\n\n\tops->flags |= FTRACE_OPS_FL_ENABLED;\n\tif (hash_enable)\n\t\tftrace_hash_rec_enable(ops, 1);\n\n\tftrace_startup_enable(command);\n\n\treturn 0;\n}\n",
        "linevul": 4.7650373744545504e-05,
        "sysevr": 0.12263603508472443,
        "devign": 7.563991100134615e-12
    },
    {
        "code": "static int vcpu_interrupt_line(struct kvm_vcpu *vcpu, int number, bool level)\n{\n\tint bit_index;\n\tbool set;\n\tunsigned long *ptr;\n\n\tif (number == KVM_ARM_IRQ_CPU_IRQ)\n\t\tbit_index = __ffs(HCR_VI);\n\telse /* KVM_ARM_IRQ_CPU_FIQ */\n\t\tbit_index = __ffs(HCR_VF);\n\n\tptr = (unsigned long *)&vcpu->arch.irq_lines;\n\tif (level)\n\t\tset = test_and_set_bit(bit_index, ptr);\n\telse\n\t\tset = test_and_clear_bit(bit_index, ptr);\n\n\t/*\n\t * If we didn't change anything, no need to wake up or kick other CPUs\n\t */\n\tif (set == level)\n\t\treturn 0;\n\n\t/*\n\t * The vcpu irq_lines field was updated, wake up sleeping VCPUs and\n\t * trigger a world-switch round on the running physical CPU to set the\n\t * virtual IRQ/FIQ fields in the HCR appropriately.\n\t */\n\tkvm_vcpu_kick(vcpu);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e8180dcaa8470ceca21109f143876fdcd9fe050a",
        "vul_func_with_fix": "static int vcpu_interrupt_line(struct kvm_vcpu *vcpu, int number, bool level)\n{\n\tint bit_index;\n\tbool set;\n\tunsigned long *ptr;\n\n\tif (number == KVM_ARM_IRQ_CPU_IRQ)\n\t\tbit_index = __ffs(HCR_VI);\n\telse /* KVM_ARM_IRQ_CPU_FIQ */\n\t\tbit_index = __ffs(HCR_VF);\n\n\tptr = (unsigned long *)&vcpu->arch.irq_lines;\n\tif (level)\n\t\tset = test_and_set_bit(bit_index, ptr);\n\telse\n\t\tset = test_and_clear_bit(bit_index, ptr);\n\n\t/*\n\t * If we didn't change anything, no need to wake up or kick other CPUs\n\t */\n\tif (set == level)\n\t\treturn 0;\n\n\t/*\n\t * The vcpu irq_lines field was updated, wake up sleeping VCPUs and\n\t * trigger a world-switch round on the running physical CPU to set the\n\t * virtual IRQ/FIQ fields in the HCR appropriately.\n\t */\n\tkvm_vcpu_kick(vcpu);\n\n\treturn 0;\n}\n",
        "linevul": 5.123345908941701e-05,
        "sysevr": 0.13363121449947357,
        "devign": 4.408160255605076e-19
    },
    {
        "code": "static inline u32 tg3_rx_ret_ring_size(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, LRG_PROD_RING_CAP))\n\t\treturn TG3_RX_RET_MAX_SIZE_5717;\n\telse if (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS))\n\t\treturn TG3_RX_RET_MAX_SIZE_5700;\n\telse\n\t\treturn TG3_RX_RET_MAX_SIZE_5705;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
        "vul_func_with_fix": "static inline u32 tg3_rx_ret_ring_size(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, LRG_PROD_RING_CAP))\n\t\treturn TG3_RX_RET_MAX_SIZE_5717;\n\telse if (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS))\n\t\treturn TG3_RX_RET_MAX_SIZE_5700;\n\telse\n\t\treturn TG3_RX_RET_MAX_SIZE_5705;\n}\n",
        "linevul": 4.729499414679594e-05,
        "sysevr": 0.12425817549228668,
        "devign": 3.358714195655921e-07
    },
    {
        "code": "resync_start_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tunsigned long long n;\n\tint err;\n\n\tif (cmd_match(buf, \"none\"))\n\t\tn = MaxSector;\n\telse {\n\t\terr = kstrtoull(buf, 10, &n);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (n != (sector_t)n)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = mddev_lock(mddev);\n\tif (err)\n\t\treturn err;\n\tif (mddev->pers && !test_bit(MD_RECOVERY_FROZEN, &mddev->recovery))\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tmddev->recovery_cp = n;\n\t\tif (mddev->pers)\n\t\t\tset_bit(MD_CHANGE_CLEAN, &mddev->flags);\n\t}\n\tmddev_unlock(mddev);\n\treturn err ?: len;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "resync_start_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tunsigned long long n;\n\tint err;\n\n\tif (cmd_match(buf, \"none\"))\n\t\tn = MaxSector;\n\telse {\n\t\terr = kstrtoull(buf, 10, &n);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (n != (sector_t)n)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = mddev_lock(mddev);\n\tif (err)\n\t\treturn err;\n\tif (mddev->pers && !test_bit(MD_RECOVERY_FROZEN, &mddev->recovery))\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tmddev->recovery_cp = n;\n\t\tif (mddev->pers)\n\t\t\tset_bit(MD_CHANGE_CLEAN, &mddev->flags);\n\t}\n\tmddev_unlock(mddev);\n\treturn err ?: len;\n}\n",
        "linevul": 7.731209916528314e-05,
        "sysevr": 0.14749620854854584,
        "devign": 2.150492623586403e-31
    },
    {
        "code": "static void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f2815633504b442ca0b0605c16bf3d88a3a0fcea",
        "vul_func_with_fix": "static void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n",
        "linevul": 6.478468276327476e-05,
        "sysevr": 0.20736926794052124,
        "devign": 3.108518997763099e-10
    },
    {
        "code": "static ssize_t lbs_rdmac_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t res, buf_size;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf_size = min(count, len - 1);\n\tif (copy_from_user(buf, userbuf, buf_size)) {\n\t\tres = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\tpriv->mac_offset = simple_strtoul(buf, NULL, 16);\n\tres = count;\nout_unlock:\n\tfree_page(addr);\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a497e47d4aec37aaf8f13509f3ef3d1f6a717d88",
        "vul_func_with_fix": "static ssize_t lbs_rdmac_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t res, buf_size;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf_size = min(count, len - 1);\n\tif (copy_from_user(buf, userbuf, buf_size)) {\n\t\tres = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\tpriv->mac_offset = simple_strtoul(buf, NULL, 16);\n\tres = count;\nout_unlock:\n\tfree_page(addr);\n\treturn res;\n}\n",
        "linevul": 6.697947537759319e-05,
        "sysevr": 0.1326216161251068,
        "devign": 0.6286410093307495
    },
    {
        "code": "int may_open(struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (path->mnt->mnt_flags & MNT_NODEV)\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & FMODE_WRITE) && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !is_owner_or_cap(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * Ensure there are no outstanding leases on the file.\n\t */\n\treturn break_lease(inode, flag);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "vul_func_with_fix": "int may_open(struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (path->mnt->mnt_flags & MNT_NODEV)\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & FMODE_WRITE) && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !is_owner_or_cap(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * Ensure there are no outstanding leases on the file.\n\t */\n\treturn break_lease(inode, flag);\n}\n",
        "linevul": 0.00014221417950466275,
        "sysevr": 0.18048909306526184,
        "devign": 1.70974571306326e-11
    },
    {
        "code": "static int netlink_mmap(struct file *file, struct socket *sock,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_ring *ring;\n\tunsigned long start, size, expected;\n\tunsigned int i;\n\tint err = -EINVAL;\n\n\tif (vma->vm_pgoff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nlk->pg_vec_lock);\n\n\texpected = 0;\n\tfor (ring = &nlk->rx_ring; ring <= &nlk->tx_ring; ring++) {\n\t\tif (ring->pg_vec == NULL)\n\t\t\tcontinue;\n\t\texpected += ring->pg_vec_len * ring->pg_vec_pages * PAGE_SIZE;\n\t}\n\n\tif (expected == 0)\n\t\tgoto out;\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (size != expected)\n\t\tgoto out;\n\n\tstart = vma->vm_start;\n\tfor (ring = &nlk->rx_ring; ring <= &nlk->tx_ring; ring++) {\n\t\tif (ring->pg_vec == NULL)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ring->pg_vec_len; i++) {\n\t\t\tstruct page *page;\n\t\t\tvoid *kaddr = ring->pg_vec[i];\n\t\t\tunsigned int pg_num;\n\n\t\t\tfor (pg_num = 0; pg_num < ring->pg_vec_pages; pg_num++) {\n\t\t\t\tpage = pgvec_to_page(kaddr);\n\t\t\t\terr = vm_insert_page(vma, start, page);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t\tkaddr += PAGE_SIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_inc(&nlk->mapped);\n\tvma->vm_ops = &netlink_mmap_ops;\n\terr = 0;\nout:\n\tmutex_unlock(&nlk->pg_vec_lock);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int netlink_mmap(struct file *file, struct socket *sock,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_ring *ring;\n\tunsigned long start, size, expected;\n\tunsigned int i;\n\tint err = -EINVAL;\n\n\tif (vma->vm_pgoff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nlk->pg_vec_lock);\n\n\texpected = 0;\n\tfor (ring = &nlk->rx_ring; ring <= &nlk->tx_ring; ring++) {\n\t\tif (ring->pg_vec == NULL)\n\t\t\tcontinue;\n\t\texpected += ring->pg_vec_len * ring->pg_vec_pages * PAGE_SIZE;\n\t}\n\n\tif (expected == 0)\n\t\tgoto out;\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (size != expected)\n\t\tgoto out;\n\n\tstart = vma->vm_start;\n\tfor (ring = &nlk->rx_ring; ring <= &nlk->tx_ring; ring++) {\n\t\tif (ring->pg_vec == NULL)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ring->pg_vec_len; i++) {\n\t\t\tstruct page *page;\n\t\t\tvoid *kaddr = ring->pg_vec[i];\n\t\t\tunsigned int pg_num;\n\n\t\t\tfor (pg_num = 0; pg_num < ring->pg_vec_pages; pg_num++) {\n\t\t\t\tpage = pgvec_to_page(kaddr);\n\t\t\t\terr = vm_insert_page(vma, start, page);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t\tkaddr += PAGE_SIZE;\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_inc(&nlk->mapped);\n\tvma->vm_ops = &netlink_mmap_ops;\n\terr = 0;\nout:\n\tmutex_unlock(&nlk->pg_vec_lock);\n\treturn err;\n}\n",
        "linevul": 0.00022203050320968032,
        "sysevr": 0.1467283070087433,
        "devign": 0.5901289582252502
    },
    {
        "code": "static void collect_signal(int sig, struct sigpending *list, siginfo_t *info)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9e146d8eb3b9ecae5086d373b50fa0c1f3e7f0f",
        "vul_func_with_fix": "static void collect_signal(int sig, struct sigpending *list, siginfo_t *info)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}\n",
        "linevul": 5.825042171636596e-05,
        "sysevr": 0.1828342229127884,
        "devign": 1.1257390419155966e-13
    },
    {
        "code": "bool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);\n\n\tif (!memslot || memslot->id >= KVM_USER_MEM_SLOTS ||\n\t      memslot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "vul_func_with_fix": "bool kvm_is_visible_gfn(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = gfn_to_memslot(kvm, gfn);\n\n\tif (!memslot || memslot->id >= KVM_USER_MEM_SLOTS ||\n\t      memslot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\n\treturn true;\n}\n",
        "linevul": 4.753355824504979e-05,
        "sysevr": 0.1430753767490387,
        "devign": 5.788042471976951e-07
    },
    {
        "code": "nfsd_get_write_access(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct iattr *iap)\n{\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\tint host_err;\n\n\tif (iap->ia_size < inode->i_size) {\n\t\t__be32 err;\n\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_TRUNC | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thost_err = get_write_access(inode);\n\tif (host_err)\n\t\tgoto out_nfserrno;\n\n\thost_err = locks_verify_truncate(inode, NULL, iap->ia_size);\n\tif (host_err)\n\t\tgoto out_put_write_access;\n\treturn 0;\n\nout_put_write_access:\n\tput_write_access(inode);\nout_nfserrno:\n\treturn nfserrno(host_err);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfsd_get_write_access(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct iattr *iap)\n{\n\tstruct inode *inode = d_inode(fhp->fh_dentry);\n\tint host_err;\n\n\tif (iap->ia_size < inode->i_size) {\n\t\t__be32 err;\n\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_TRUNC | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\thost_err = get_write_access(inode);\n\tif (host_err)\n\t\tgoto out_nfserrno;\n\n\thost_err = locks_verify_truncate(inode, NULL, iap->ia_size);\n\tif (host_err)\n\t\tgoto out_put_write_access;\n\treturn 0;\n\nout_put_write_access:\n\tput_write_access(inode);\nout_nfserrno:\n\treturn nfserrno(host_err);\n}\n",
        "linevul": 6.976444274187088e-05,
        "sysevr": 0.16776859760284424,
        "devign": 1.4287764305009887e-09
    },
    {
        "code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\tevent = cpuhw->event[i];\n\n\t\tval = read_pmc(i);\n\t\tif ((int)val < 0) {\n \t\t\tif (event) {\n \t\t\t\t/* event has overflowed */\n \t\t\t\tfound = 1;\n\t\t\t\trecord_and_restart(event, val, regs, nmi);\n \t\t\t} else {\n \t\t\t\t/*\n \t\t\t\t * Disabled counter is negative,\n\t\t\t\t * reset it just in case.\n\t\t\t\t */\n\t\t\t\twrite_pmc(i, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* PMM will keep counters frozen until we return from the interrupt. */\n\tmtmsr(mfmsr() | MSR_PMM);\n\tmtpmr(PMRN_PMGC0, PMGC0_PMIE | PMGC0_FCECE);\n\tisync();\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\tevent = cpuhw->event[i];\n\n\t\tval = read_pmc(i);\n\t\tif ((int)val < 0) {\n \t\t\tif (event) {\n \t\t\t\t/* event has overflowed */\n \t\t\t\tfound = 1;\n//flaw_line_below:\n\t\t\t\trecord_and_restart(event, val, regs, nmi);\n//fix_flaw_line_below:\n//\t\t\t\trecord_and_restart(event, val, regs);\n \t\t\t} else {\n \t\t\t\t/*\n \t\t\t\t * Disabled counter is negative,\n\t\t\t\t * reset it just in case.\n\t\t\t\t */\n\t\t\t\twrite_pmc(i, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* PMM will keep counters frozen until we return from the interrupt. */\n\tmtmsr(mfmsr() | MSR_PMM);\n\tmtpmr(PMRN_PMGC0, PMGC0_PMIE | PMGC0_FCECE);\n\tisync();\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}\n",
        "linevul": 0.9976873397827148,
        "sysevr": 0.1405341476202011,
        "devign": 4.76135540732858e-21
    },
    {
        "code": " nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n {\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n \t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n \tproc = rqstp->rq_procinfo;\n \n \t/*\n \t * Give the xdr decoder a chance to change this if it wants\n \t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e6838a29ecb484c97e4efef9429643b9851fba6e",
        "vul_func_with_fix": " nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n {\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n \t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n \tproc = rqstp->rq_procinfo;\n \n//fix_flaw_line_below:\n//\tif (nfs_request_too_big(rqstp, proc)) {\n//fix_flaw_line_below:\n//\t\tdprintk(\"nfsd: NFSv%d argument too large\\n\", rqstp->rq_vers);\n//fix_flaw_line_below:\n//\t\t*statp = rpc_garbage_args;\n//fix_flaw_line_below:\n//\t\treturn 1;\n//fix_flaw_line_below:\n//\t}\n \t/*\n \t * Give the xdr decoder a chance to change this if it wants\n \t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}\n",
        "linevul": 0.9995693564414978,
        "sysevr": 0.19048669934272766,
        "devign": 8.810217444477075e-09
    },
    {
        "code": "static int dm_any_congested(void *congested_data, int bdi_bits)\n{\n\tint r = bdi_bits;\n\tstruct mapped_device *md = congested_data;\n\tstruct dm_table *map;\n\n\tif (!test_bit(DMF_BLOCK_IO_FOR_SUSPEND, &md->flags)) {\n\t\tif (dm_request_based(md)) {\n\t\t\t/*\n\t\t\t * With request-based DM we only need to check the\n\t\t\t * top-level queue for congestion.\n\t\t\t */\n\t\t\tr = md->queue->backing_dev_info->wb.state & bdi_bits;\n\t\t} else {\n\t\t\tmap = dm_get_live_table_fast(md);\n\t\t\tif (map)\n\t\t\t\tr = dm_table_any_congested(map, bdi_bits);\n\t\t\tdm_put_live_table_fast(md);\n\t\t}\n\t}\n\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b9a41d21dceadf8104812626ef85dc56ee8a60ed",
        "vul_func_with_fix": "static int dm_any_congested(void *congested_data, int bdi_bits)\n{\n\tint r = bdi_bits;\n\tstruct mapped_device *md = congested_data;\n\tstruct dm_table *map;\n\n\tif (!test_bit(DMF_BLOCK_IO_FOR_SUSPEND, &md->flags)) {\n\t\tif (dm_request_based(md)) {\n\t\t\t/*\n\t\t\t * With request-based DM we only need to check the\n\t\t\t * top-level queue for congestion.\n\t\t\t */\n\t\t\tr = md->queue->backing_dev_info->wb.state & bdi_bits;\n\t\t} else {\n\t\t\tmap = dm_get_live_table_fast(md);\n\t\t\tif (map)\n\t\t\t\tr = dm_table_any_congested(map, bdi_bits);\n\t\t\tdm_put_live_table_fast(md);\n\t\t}\n\t}\n\n\treturn r;\n}\n",
        "linevul": 4.803544288733974e-05,
        "sysevr": 0.12718477845191956,
        "devign": 5.72413512145431e-08
    },
    {
        "code": "ext4_ext_shift_extents(struct inode *inode, handle_t *handle,\n\t\t       ext4_lblk_t start, ext4_lblk_t shift)\n{\n\tstruct ext4_ext_path *path;\n\tint ret = 0, depth;\n\tstruct ext4_extent *extent;\n\text4_lblk_t stop_block;\n\text4_lblk_t ex_start, ex_end;\n\n\t/* Let path point to the last extent */\n\tpath = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL, 0);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tdepth = path->p_depth;\n\textent = path[depth].p_ext;\n\tif (!extent)\n\t\tgoto out;\n\n\tstop_block = le32_to_cpu(extent->ee_block) +\n\t\t\text4_ext_get_actual_len(extent);\n\n\t/* Nothing to shift, if hole is at the end of file */\n\tif (start >= stop_block)\n\t\tgoto out;\n\n\t/*\n\t * Don't start shifting extents until we make sure the hole is big\n\t * enough to accomodate the shift.\n\t */\n\tpath = ext4_find_extent(inode, start - 1, &path, 0);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tdepth = path->p_depth;\n\textent =  path[depth].p_ext;\n\tif (extent) {\n\t\tex_start = le32_to_cpu(extent->ee_block);\n\t\tex_end = le32_to_cpu(extent->ee_block) +\n\t\t\text4_ext_get_actual_len(extent);\n\t} else {\n\t\tex_start = 0;\n\t\tex_end = 0;\n\t}\n\n\tif ((start == ex_start && shift > ex_start) ||\n\t    (shift > start - ex_end))\n\t\treturn -EINVAL;\n\n\t/* Its safe to start updating extents */\n\twhile (start < stop_block) {\n\t\tpath = ext4_find_extent(inode, start, &path, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = path->p_depth;\n\t\textent = path[depth].p_ext;\n\t\tif (!extent) {\n\t\t\tEXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",\n\t\t\t\t\t (unsigned long) start);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (start > le32_to_cpu(extent->ee_block)) {\n\t\t\t/* Hole, move to the next extent */\n\t\t\tif (extent < EXT_LAST_EXTENT(path[depth].p_hdr)) {\n\t\t\t\tpath[depth].p_ext++;\n\t\t\t} else {\n\t\t\t\tstart = ext4_ext_next_allocated_block(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tret = ext4_ext_shift_path_extents(path, shift, inode,\n\t\t\t\thandle, &start);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8",
        "vul_func_with_fix": "ext4_ext_shift_extents(struct inode *inode, handle_t *handle,\n\t\t       ext4_lblk_t start, ext4_lblk_t shift)\n{\n\tstruct ext4_ext_path *path;\n\tint ret = 0, depth;\n\tstruct ext4_extent *extent;\n\text4_lblk_t stop_block;\n\text4_lblk_t ex_start, ex_end;\n\n\t/* Let path point to the last extent */\n\tpath = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL, 0);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tdepth = path->p_depth;\n\textent = path[depth].p_ext;\n\tif (!extent)\n\t\tgoto out;\n\n\tstop_block = le32_to_cpu(extent->ee_block) +\n\t\t\text4_ext_get_actual_len(extent);\n\n\t/* Nothing to shift, if hole is at the end of file */\n\tif (start >= stop_block)\n\t\tgoto out;\n\n\t/*\n\t * Don't start shifting extents until we make sure the hole is big\n\t * enough to accomodate the shift.\n\t */\n\tpath = ext4_find_extent(inode, start - 1, &path, 0);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tdepth = path->p_depth;\n\textent =  path[depth].p_ext;\n\tif (extent) {\n\t\tex_start = le32_to_cpu(extent->ee_block);\n\t\tex_end = le32_to_cpu(extent->ee_block) +\n\t\t\text4_ext_get_actual_len(extent);\n\t} else {\n\t\tex_start = 0;\n\t\tex_end = 0;\n\t}\n\n\tif ((start == ex_start && shift > ex_start) ||\n\t    (shift > start - ex_end))\n\t\treturn -EINVAL;\n\n\t/* Its safe to start updating extents */\n\twhile (start < stop_block) {\n\t\tpath = ext4_find_extent(inode, start, &path, 0);\n\t\tif (IS_ERR(path))\n\t\t\treturn PTR_ERR(path);\n\t\tdepth = path->p_depth;\n\t\textent = path[depth].p_ext;\n\t\tif (!extent) {\n\t\t\tEXT4_ERROR_INODE(inode, \"unexpected hole at %lu\",\n\t\t\t\t\t (unsigned long) start);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (start > le32_to_cpu(extent->ee_block)) {\n\t\t\t/* Hole, move to the next extent */\n\t\t\tif (extent < EXT_LAST_EXTENT(path[depth].p_hdr)) {\n\t\t\t\tpath[depth].p_ext++;\n\t\t\t} else {\n\t\t\t\tstart = ext4_ext_next_allocated_block(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tret = ext4_ext_shift_path_extents(path, shift, inode,\n\t\t\t\thandle, &start);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\treturn ret;\n}\n",
        "linevul": 0.00018112979887519032,
        "sysevr": 0.21111944317817688,
        "devign": 2.0618914765130857e-14
    },
    {
        "code": "static int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/942080643bce061c3dd9d5718d3b745dcb39a8bc",
        "vul_func_with_fix": "static int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}\n",
        "linevul": 5.6272743677254766e-05,
        "sysevr": 0.14962738752365112,
        "devign": 4.917031018458751e-11
    },
    {
        "code": "ip6_tnl_bucket(struct ip6_tnl_net *ip6n, struct ip6_tnl_parm *p)\n{\n\tstruct in6_addr *remote = &p->raddr;\n\tstruct in6_addr *local = &p->laddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\n\t\tprio = 1;\n\t\th = HASH(remote) ^ HASH(local);\n\t}\n\treturn &ip6n->tnls[prio][h];\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d5aa407f59f5b83d2c50ec88f5bf56d40f1f8978",
        "vul_func_with_fix": "ip6_tnl_bucket(struct ip6_tnl_net *ip6n, struct ip6_tnl_parm *p)\n{\n\tstruct in6_addr *remote = &p->raddr;\n\tstruct in6_addr *local = &p->laddr;\n\tunsigned h = 0;\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\n\t\tprio = 1;\n\t\th = HASH(remote) ^ HASH(local);\n\t}\n\treturn &ip6n->tnls[prio][h];\n}\n",
        "linevul": 8.087911555776373e-05,
        "sysevr": 0.1823474019765854,
        "devign": 6.700314782170924e-12
    },
    {
        "code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a6138db815df5ee542d848318e5dae681590fccd",
        "vul_func_with_fix": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n//flaw_line_below:\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n//fix_flaw_line_below:\n//\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}\n",
        "linevul": 0.9991872906684875,
        "sysevr": 0.12756898999214172,
        "devign": 0.0
    },
    {
        "code": "static int setup_e820_entries(struct boot_params *params)\n{\n\tunsigned int nr_e820_entries;\n\n\tnr_e820_entries = e820_saved.nr_map;\n\n\t/* TODO: Pass entries more than E820MAX in bootparams setup data */\n\tif (nr_e820_entries > E820MAX)\n\t\tnr_e820_entries = E820MAX;\n\n\tparams->e820_entries = nr_e820_entries;\n\tmemcpy(&params->e820_map, &e820_saved.map,\n\t       nr_e820_entries * sizeof(struct e820entry));\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/mjg59/linux/commit/4b2b64d5a6ebc84214755ebccd599baef7c1b798",
        "vul_func_with_fix": "static int setup_e820_entries(struct boot_params *params)\n{\n\tunsigned int nr_e820_entries;\n\n\tnr_e820_entries = e820_saved.nr_map;\n\n\t/* TODO: Pass entries more than E820MAX in bootparams setup data */\n\tif (nr_e820_entries > E820MAX)\n\t\tnr_e820_entries = E820MAX;\n\n\tparams->e820_entries = nr_e820_entries;\n\tmemcpy(&params->e820_map, &e820_saved.map,\n\t       nr_e820_entries * sizeof(struct e820entry));\n\n\treturn 0;\n}\n",
        "linevul": 5.235541902948171e-05,
        "sysevr": 0.1355140209197998,
        "devign": 3.890088392469876e-13
    },
    {
        "code": "ebt_check_entry(struct ebt_entry *e, struct net *net,\n   const struct ebt_table_info *newinfo,\n   const char *name, unsigned int *cnt,\n   struct ebt_cl_stack *cl_s, unsigned int udc_cnt)\n{\n\tstruct ebt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int i, j, hook = 0, hookmask = 0;\n\tsize_t gap;\n\tint ret;\n\tstruct xt_mtchk_param mtpar;\n\tstruct xt_tgchk_param tgpar;\n\n\t/* don't mess with the struct ebt_entries */\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\tif (e->bitmask & ~EBT_F_MASK) {\n\t\tBUGPRINT(\"Unknown flag for bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (e->invflags & ~EBT_INV_MASK) {\n\t\tBUGPRINT(\"Unknown flag for inv bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ( (e->bitmask & EBT_NOPROTO) && (e->bitmask & EBT_802_3) ) {\n\t\tBUGPRINT(\"NOPROTO & 802_3 not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* what hook do we belong to? */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i])\n\t\t\tcontinue;\n\t\tif ((char *)newinfo->hook_entry[i] < (char *)e)\n\t\t\thook = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* (1 << NF_BR_NUMHOOKS) tells the check functions the rule is on\n\t   a base chain */\n\tif (i < NF_BR_NUMHOOKS)\n\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\telse {\n\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\tif ((char *)(cl_s[i].cs.chaininfo) > (char *)e)\n\t\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\t\telse\n\t\t\thookmask = cl_s[i - 1].hookmask;\n\t}\n\ti = 0;\n\n\tmtpar.net\t= tgpar.net       = net;\n\tmtpar.table     = tgpar.table     = name;\n\tmtpar.entryinfo = tgpar.entryinfo = e;\n\tmtpar.hook_mask = tgpar.hook_mask = hookmask;\n\tmtpar.family    = tgpar.family    = NFPROTO_BRIDGE;\n\tret = EBT_MATCH_ITERATE(e, ebt_check_match, &mtpar, &i);\n\tif (ret != 0)\n\t\tgoto cleanup_matches;\n\tj = 0;\n\tret = EBT_WATCHER_ITERATE(e, ebt_check_watcher, &tgpar, &j);\n\tif (ret != 0)\n\t\tgoto cleanup_watchers;\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\tgap = e->next_offset - e->target_offset;\n\n\ttarget = xt_request_find_target(NFPROTO_BRIDGE, t->u.name, 0);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto cleanup_watchers;\n\t}\n\n\tt->u.target = target;\n\tif (t->u.target == &ebt_standard_target) {\n\t\tif (gap < sizeof(struct ebt_standard_target)) {\n\t\t\tBUGPRINT(\"Standard target size too big\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t\tif (((struct ebt_standard_target *)t)->verdict <\n\t\t   -NUM_STANDARD_TARGETS) {\n\t\t\tBUGPRINT(\"Invalid standard target\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t} else if (t->target_size > gap - sizeof(struct ebt_entry_target)) {\n\t\tmodule_put(t->u.target->me);\n\t\tret = -EFAULT;\n\t\tgoto cleanup_watchers;\n\t}\n\n\ttgpar.target   = target;\n\ttgpar.targinfo = t->data;\n\tret = xt_check_target(&tgpar, t->target_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(target->me);\n\t\tgoto cleanup_watchers;\n\t}\n\t(*cnt)++;\n\treturn 0;\ncleanup_watchers:\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, &j);\ncleanup_matches:\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, &i);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d846f71195d57b0bbb143382647c2c6638b04c5a",
        "vul_func_with_fix": "ebt_check_entry(struct ebt_entry *e, struct net *net,\n   const struct ebt_table_info *newinfo,\n   const char *name, unsigned int *cnt,\n   struct ebt_cl_stack *cl_s, unsigned int udc_cnt)\n{\n\tstruct ebt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int i, j, hook = 0, hookmask = 0;\n\tsize_t gap;\n\tint ret;\n\tstruct xt_mtchk_param mtpar;\n\tstruct xt_tgchk_param tgpar;\n\n\t/* don't mess with the struct ebt_entries */\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\tif (e->bitmask & ~EBT_F_MASK) {\n\t\tBUGPRINT(\"Unknown flag for bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (e->invflags & ~EBT_INV_MASK) {\n\t\tBUGPRINT(\"Unknown flag for inv bitmask\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ( (e->bitmask & EBT_NOPROTO) && (e->bitmask & EBT_802_3) ) {\n\t\tBUGPRINT(\"NOPROTO & 802_3 not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* what hook do we belong to? */\n\tfor (i = 0; i < NF_BR_NUMHOOKS; i++) {\n\t\tif (!newinfo->hook_entry[i])\n\t\t\tcontinue;\n\t\tif ((char *)newinfo->hook_entry[i] < (char *)e)\n\t\t\thook = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/* (1 << NF_BR_NUMHOOKS) tells the check functions the rule is on\n\t   a base chain */\n\tif (i < NF_BR_NUMHOOKS)\n\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\telse {\n\t\tfor (i = 0; i < udc_cnt; i++)\n\t\t\tif ((char *)(cl_s[i].cs.chaininfo) > (char *)e)\n\t\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\thookmask = (1 << hook) | (1 << NF_BR_NUMHOOKS);\n\t\telse\n\t\t\thookmask = cl_s[i - 1].hookmask;\n\t}\n\ti = 0;\n\n\tmtpar.net\t= tgpar.net       = net;\n\tmtpar.table     = tgpar.table     = name;\n\tmtpar.entryinfo = tgpar.entryinfo = e;\n\tmtpar.hook_mask = tgpar.hook_mask = hookmask;\n\tmtpar.family    = tgpar.family    = NFPROTO_BRIDGE;\n\tret = EBT_MATCH_ITERATE(e, ebt_check_match, &mtpar, &i);\n\tif (ret != 0)\n\t\tgoto cleanup_matches;\n\tj = 0;\n\tret = EBT_WATCHER_ITERATE(e, ebt_check_watcher, &tgpar, &j);\n\tif (ret != 0)\n\t\tgoto cleanup_watchers;\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\tgap = e->next_offset - e->target_offset;\n\n\ttarget = xt_request_find_target(NFPROTO_BRIDGE, t->u.name, 0);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto cleanup_watchers;\n\t}\n\n\tt->u.target = target;\n\tif (t->u.target == &ebt_standard_target) {\n\t\tif (gap < sizeof(struct ebt_standard_target)) {\n\t\t\tBUGPRINT(\"Standard target size too big\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t\tif (((struct ebt_standard_target *)t)->verdict <\n\t\t   -NUM_STANDARD_TARGETS) {\n\t\t\tBUGPRINT(\"Invalid standard target\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup_watchers;\n\t\t}\n\t} else if (t->target_size > gap - sizeof(struct ebt_entry_target)) {\n\t\tmodule_put(t->u.target->me);\n\t\tret = -EFAULT;\n\t\tgoto cleanup_watchers;\n\t}\n\n\ttgpar.target   = target;\n\ttgpar.targinfo = t->data;\n\tret = xt_check_target(&tgpar, t->target_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(target->me);\n\t\tgoto cleanup_watchers;\n\t}\n\t(*cnt)++;\n\treturn 0;\ncleanup_watchers:\n\tEBT_WATCHER_ITERATE(e, ebt_cleanup_watcher, net, &j);\ncleanup_matches:\n\tEBT_MATCH_ITERATE(e, ebt_cleanup_match, net, &i);\n\treturn ret;\n}\n",
        "linevul": 0.0005029264721088111,
        "sysevr": 0.3299061059951782,
        "devign": 8.792849985184148e-05
    },
    {
        "code": "static int netlink_autobind(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct nl_pid_hash *hash = &nl_table[sk->sk_protocol].hash;\n\tstruct hlist_head *head;\n\tstruct sock *osk;\n\tstruct hlist_node *node;\n\ts32 pid = task_tgid_vnr(current);\n\tint err;\n\tstatic s32 rover = -4097;\n\nretry:\n\tcond_resched();\n\tnetlink_table_grab();\n\thead = nl_pid_hashfn(hash, pid);\n\tsk_for_each(osk, node, head) {\n\t\tif (!net_eq(sock_net(osk), net))\n\t\t\tcontinue;\n\t\tif (nlk_sk(osk)->pid == pid) {\n\t\t\t/* Bind collision, search negative pid values. */\n\t\t\tpid = rover--;\n\t\t\tif (rover > -4097)\n\t\t\t\trover = -4097;\n\t\t\tnetlink_table_ungrab();\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tnetlink_table_ungrab();\n\n\terr = netlink_insert(sk, net, pid);\n\tif (err == -EADDRINUSE)\n\t\tgoto retry;\n\n\t/* If 2 threads race to autobind, that is fine.  */\n\tif (err == -EBUSY)\n\t\terr = 0;\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "vul_func_with_fix": "static int netlink_autobind(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct nl_pid_hash *hash = &nl_table[sk->sk_protocol].hash;\n\tstruct hlist_head *head;\n\tstruct sock *osk;\n\tstruct hlist_node *node;\n\ts32 pid = task_tgid_vnr(current);\n\tint err;\n\tstatic s32 rover = -4097;\n\nretry:\n\tcond_resched();\n\tnetlink_table_grab();\n\thead = nl_pid_hashfn(hash, pid);\n\tsk_for_each(osk, node, head) {\n\t\tif (!net_eq(sock_net(osk), net))\n\t\t\tcontinue;\n\t\tif (nlk_sk(osk)->pid == pid) {\n\t\t\t/* Bind collision, search negative pid values. */\n\t\t\tpid = rover--;\n\t\t\tif (rover > -4097)\n\t\t\t\trover = -4097;\n\t\t\tnetlink_table_ungrab();\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tnetlink_table_ungrab();\n\n\terr = netlink_insert(sk, net, pid);\n\tif (err == -EADDRINUSE)\n\t\tgoto retry;\n\n\t/* If 2 threads race to autobind, that is fine.  */\n\tif (err == -EBUSY)\n\t\terr = 0;\n\n\treturn err;\n}\n",
        "linevul": 6.762848352082074e-05,
        "sysevr": 0.14982970058918,
        "devign": 2.1679715314637527e-12
    },
    {
        "code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n \ttpgt_str += 5; /* Skip ahead of \"tpgt_\" */\n \ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n \n\tif (tpgt > TL_TPGS_PER_HBA) {\n \t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n \t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t/*\n\t * Register the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8",
        "vul_func_with_fix": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n \ttpgt_str += 5; /* Skip ahead of \"tpgt_\" */\n \ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n \n//flaw_line_below:\n\tif (tpgt > TL_TPGS_PER_HBA) {\n//fix_flaw_line_below:\n//\tif (tpgt >= TL_TPGS_PER_HBA) {\n \t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n \t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t/*\n\t * Register the tl_tpg as a emulated SAS TCM Target Endpoint\n\t */\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}\n",
        "linevul": 0.9985476136207581,
        "sysevr": 0.15852361917495728,
        "devign": 3.841787737388513e-26
    },
    {
        "code": "__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)\n{\n\tstruct rb_node *rightmost = NULL;\n\tstruct mem_cgroup_per_zone *mz;\n\nretry:\n\tmz = NULL;\n\trightmost = rb_last(&mctz->rb_root);\n\tif (!rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(rightmost, struct mem_cgroup_per_zone, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz->mem, mz, mctz);\n\tif (!res_counter_soft_limit_excess(&mz->mem->res) ||\n\t\t!css_tryget(&mz->mem->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "__mem_cgroup_largest_soft_limit_node(struct mem_cgroup_tree_per_zone *mctz)\n{\n\tstruct rb_node *rightmost = NULL;\n\tstruct mem_cgroup_per_zone *mz;\n\nretry:\n\tmz = NULL;\n\trightmost = rb_last(&mctz->rb_root);\n\tif (!rightmost)\n\t\tgoto done;\t\t/* Nothing to reclaim from */\n\n\tmz = rb_entry(rightmost, struct mem_cgroup_per_zone, tree_node);\n\t/*\n\t * Remove the node now but someone else can add it back,\n\t * we will to add it back at the end of reclaim to its correct\n\t * position in the tree.\n\t */\n\t__mem_cgroup_remove_exceeded(mz->mem, mz, mctz);\n\tif (!res_counter_soft_limit_excess(&mz->mem->res) ||\n\t\t!css_tryget(&mz->mem->css))\n\t\tgoto retry;\ndone:\n\treturn mz;\n}\n",
        "linevul": 6.700924859615043e-05,
        "sysevr": 0.23124167323112488,
        "devign": 5.247829948373806e-10
    },
    {
        "code": "static inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(dir->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca",
        "vul_func_with_fix": "static inline unsigned dx_node_limit(struct inode *dir)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(0);\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(dir->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n",
        "linevul": 7.212932541733608e-05,
        "sysevr": 0.12199559062719345,
        "devign": 0.0007609762833453715
    },
    {
        "code": "static int modify_raw_packet_qp_sq(struct mlx5_core_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq,\n\t\t\t\t   int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tstruct mlx5_ib_qp *ibqp = sq->base.container_mibqp;\n\tstruct mlx5_rate_limit old_rl = ibqp->rl;\n\tstruct mlx5_rate_limit new_rl = old_rl;\n\tbool new_rate_added = false;\n\tu16 rl_index = 0;\n\tvoid *in;\n\tvoid *sqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, sq_state, sq->state);\n\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_RATE_LIMIT) {\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tpr_warn(\"%s: Rate limit can only be changed when SQ is moving to RDY\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tnew_rl = raw_qp_param->rl;\n\t}\n\n\tif (!mlx5_rl_are_equal(&old_rl, &new_rl)) {\n\t\tif (new_rl.rate) {\n\t\t\terr = mlx5_rl_add_rate(dev, &rl_index, &new_rl);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed configuring rate limit(err %d): \\\n\t\t\t\t       rate %u, max_burst_sz %u, typical_pkt_sz %u\\n\",\n\t\t\t\t       err, new_rl.rate, new_rl.max_burst_sz,\n\t\t\t\t       new_rl.typical_pkt_sz);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnew_rate_added = true;\n\t\t}\n\n\t\tMLX5_SET64(modify_sq_in, in, modify_bitmask, 1);\n\t\t/* index 0 means no limit */\n\t\tMLX5_SET(sqc, sqc, packet_pacing_rate_limit_index, rl_index);\n\t}\n\n\terr = mlx5_core_modify_sq(dev, sq->base.mqp.qpn, in, inlen);\n\tif (err) {\n\t\t/* Remove new rate from table if failed */\n\t\tif (new_rate_added)\n\t\t\tmlx5_rl_remove_rate(dev, &new_rl);\n\t\tgoto out;\n\t}\n\n\t/* Only remove the old rate after new rate was set */\n\tif ((old_rl.rate &&\n\t     !mlx5_rl_are_equal(&old_rl, &new_rl)) ||\n\t    (new_state != MLX5_SQC_STATE_RDY))\n\t\tmlx5_rl_remove_rate(dev, &old_rl);\n\n\tibqp->rl = new_rl;\n\tsq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00",
        "vul_func_with_fix": "static int modify_raw_packet_qp_sq(struct mlx5_core_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq,\n\t\t\t\t   int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tstruct mlx5_ib_qp *ibqp = sq->base.container_mibqp;\n\tstruct mlx5_rate_limit old_rl = ibqp->rl;\n\tstruct mlx5_rate_limit new_rl = old_rl;\n\tbool new_rate_added = false;\n\tu16 rl_index = 0;\n\tvoid *in;\n\tvoid *sqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, sq_state, sq->state);\n\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_RATE_LIMIT) {\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tpr_warn(\"%s: Rate limit can only be changed when SQ is moving to RDY\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tnew_rl = raw_qp_param->rl;\n\t}\n\n\tif (!mlx5_rl_are_equal(&old_rl, &new_rl)) {\n\t\tif (new_rl.rate) {\n\t\t\terr = mlx5_rl_add_rate(dev, &rl_index, &new_rl);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed configuring rate limit(err %d): \\\n\t\t\t\t       rate %u, max_burst_sz %u, typical_pkt_sz %u\\n\",\n\t\t\t\t       err, new_rl.rate, new_rl.max_burst_sz,\n\t\t\t\t       new_rl.typical_pkt_sz);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnew_rate_added = true;\n\t\t}\n\n\t\tMLX5_SET64(modify_sq_in, in, modify_bitmask, 1);\n\t\t/* index 0 means no limit */\n\t\tMLX5_SET(sqc, sqc, packet_pacing_rate_limit_index, rl_index);\n\t}\n\n\terr = mlx5_core_modify_sq(dev, sq->base.mqp.qpn, in, inlen);\n\tif (err) {\n\t\t/* Remove new rate from table if failed */\n\t\tif (new_rate_added)\n\t\t\tmlx5_rl_remove_rate(dev, &new_rl);\n\t\tgoto out;\n\t}\n\n\t/* Only remove the old rate after new rate was set */\n\tif ((old_rl.rate &&\n\t     !mlx5_rl_are_equal(&old_rl, &new_rl)) ||\n\t    (new_state != MLX5_SQC_STATE_RDY))\n\t\tmlx5_rl_remove_rate(dev, &old_rl);\n\n\tibqp->rl = new_rl;\n\tsq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n",
        "linevul": 0.00017679267330095172,
        "sysevr": 0.15919145941734314,
        "devign": 1.0733335155449252e-17
    },
    {
        "code": "struct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct filename *filename;\n\tstruct dentry *d;\n\tstruct qstr last;\n\tint type;\n\n\tfilename = filename_parentat(AT_FDCWD, getname_kernel(name), 0, path,\n\t\t\t\t    &last, &type);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(path);\n\t\tputname(filename);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_lock_nested(&path->dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\td = __lookup_hash(&last, path->dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\t\tpath_put(path);\n\t}\n\tputname(filename);\n\treturn d;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "vul_func_with_fix": "struct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct filename *filename;\n\tstruct dentry *d;\n\tstruct qstr last;\n\tint type;\n\n\tfilename = filename_parentat(AT_FDCWD, getname_kernel(name), 0, path,\n\t\t\t\t    &last, &type);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(path);\n\t\tputname(filename);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tmutex_lock_nested(&path->dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\td = __lookup_hash(&last, path->dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\t\tpath_put(path);\n\t}\n\tputname(filename);\n\treturn d;\n}\n",
        "linevul": 5.441340181278065e-05,
        "sysevr": 0.13573311269283295,
        "devign": 7.156934251730388e-24
    },
    {
        "code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Initially, just behave like get_mr().\n\t * TODO: Implement get_mr as wrapper around this\n\t *\t and deprecate it.\n\t */\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
        "vul_func_with_fix": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Initially, just behave like get_mr().\n\t * TODO: Implement get_mr as wrapper around this\n\t *\t and deprecate it.\n\t */\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}\n",
        "linevul": 0.00012445467291399837,
        "sysevr": 0.15896883606910706,
        "devign": 0.6504037976264954
    },
    {
        "code": "int hns_roce_init(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Reset RoCE engine failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (hr_dev->hw->cmq_init) {\n\t\tret = hr_dev->hw->cmq_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Init RoCE Command Queue failed!\\n\");\n\t\t\tgoto error_failed_cmq_init;\n\t\t}\n\t}\n\n\tret = hr_dev->hw->hw_profile(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Get RoCE engine profile failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hns_roce_cmd_init(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"cmd init failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hr_dev->hw->init_eq(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"eq init failed!\\n\");\n\t\tgoto error_failed_eq_table;\n\t}\n\n\tif (hr_dev->cmd_mod) {\n\t\tret = hns_roce_cmd_use_events(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Switch to event-driven cmd failed!\\n\");\n\t\t\tgoto error_failed_use_event;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"init HEM(Hardware Entry Memory) failed!\\n\");\n\t\tgoto error_failed_init_hem;\n\t}\n\n\tret = hns_roce_setup_hca(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"setup hca failed!\\n\");\n\t\tgoto error_failed_setup_hca;\n\t}\n\n\tif (hr_dev->hw->hw_init) {\n\t\tret = hr_dev->hw->hw_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"hw_init failed!\\n\");\n\t\t\tgoto error_failed_engine_init;\n\t\t}\n\t}\n\n\tret = hns_roce_register_device(hr_dev);\n\tif (ret)\n\t\tgoto error_failed_register_device;\n\n\treturn 0;\n\nerror_failed_register_device:\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\nerror_failed_engine_init:\n\thns_roce_cleanup_bitmap(hr_dev);\n\nerror_failed_setup_hca:\n\thns_roce_cleanup_hem(hr_dev);\n\nerror_failed_init_hem:\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\nerror_failed_use_event:\n\thr_dev->hw->cleanup_eq(hr_dev);\n\nerror_failed_eq_table:\n\thns_roce_cmd_cleanup(hr_dev);\n\nerror_failed_cmd_init:\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\nerror_failed_cmq_init:\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, false);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Dereset RoCE engine failed!\\n\");\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/df7e40425813c50cd252e6f5e348a81ef1acae56",
        "vul_func_with_fix": "int hns_roce_init(struct hns_roce_dev *hr_dev)\n{\n\tint ret;\n\tstruct device *dev = hr_dev->dev;\n\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, true);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Reset RoCE engine failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (hr_dev->hw->cmq_init) {\n\t\tret = hr_dev->hw->cmq_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Init RoCE Command Queue failed!\\n\");\n\t\t\tgoto error_failed_cmq_init;\n\t\t}\n\t}\n\n\tret = hr_dev->hw->hw_profile(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Get RoCE engine profile failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hns_roce_cmd_init(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"cmd init failed!\\n\");\n\t\tgoto error_failed_cmd_init;\n\t}\n\n\tret = hr_dev->hw->init_eq(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"eq init failed!\\n\");\n\t\tgoto error_failed_eq_table;\n\t}\n\n\tif (hr_dev->cmd_mod) {\n\t\tret = hns_roce_cmd_use_events(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Switch to event-driven cmd failed!\\n\");\n\t\t\tgoto error_failed_use_event;\n\t\t}\n\t}\n\n\tret = hns_roce_init_hem(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"init HEM(Hardware Entry Memory) failed!\\n\");\n\t\tgoto error_failed_init_hem;\n\t}\n\n\tret = hns_roce_setup_hca(hr_dev);\n\tif (ret) {\n\t\tdev_err(dev, \"setup hca failed!\\n\");\n\t\tgoto error_failed_setup_hca;\n\t}\n\n\tif (hr_dev->hw->hw_init) {\n\t\tret = hr_dev->hw->hw_init(hr_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"hw_init failed!\\n\");\n\t\t\tgoto error_failed_engine_init;\n\t\t}\n\t}\n\n\tret = hns_roce_register_device(hr_dev);\n\tif (ret)\n\t\tgoto error_failed_register_device;\n\n\treturn 0;\n\nerror_failed_register_device:\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\nerror_failed_engine_init:\n\thns_roce_cleanup_bitmap(hr_dev);\n\nerror_failed_setup_hca:\n\thns_roce_cleanup_hem(hr_dev);\n\nerror_failed_init_hem:\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\nerror_failed_use_event:\n\thr_dev->hw->cleanup_eq(hr_dev);\n\nerror_failed_eq_table:\n\thns_roce_cmd_cleanup(hr_dev);\n\nerror_failed_cmd_init:\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\nerror_failed_cmq_init:\n\tif (hr_dev->hw->reset) {\n\t\tret = hr_dev->hw->reset(hr_dev, false);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Dereset RoCE engine failed!\\n\");\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 6.785133882658556e-05,
        "sysevr": 0.1771795153617859,
        "devign": 4.841918830938638e-14
    },
    {
        "code": "cifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo until the NEGOTIATE_PROTOCOL request is\n\t * done, which is indicated by maxBuf != 0. Also, no need to ping if\n\t * we got a response recently\n\t */\n\tif (server->maxBuf == 0 ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = CIFSSMBEcho(server);\n\tif (rc)\n\t\tcFYI(1, \"Unable to send echo request to server: %s\",\n\t\t\tserver->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(system_nrt_wq, &server->echo, SMB_ECHO_INTERVAL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/70945643722ffeac779d2529a348f99567fa5c33",
        "vul_func_with_fix": "cifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo until the NEGOTIATE_PROTOCOL request is\n\t * done, which is indicated by maxBuf != 0. Also, no need to ping if\n\t * we got a response recently\n\t */\n\tif (server->maxBuf == 0 ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = CIFSSMBEcho(server);\n\tif (rc)\n\t\tcFYI(1, \"Unable to send echo request to server: %s\",\n\t\t\tserver->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(system_nrt_wq, &server->echo, SMB_ECHO_INTERVAL);\n}\n",
        "linevul": 5.116315878694877e-05,
        "sysevr": 0.17431001365184784,
        "devign": 0.0009355582878924906
    },
    {
        "code": "static ssize_t __send_control_msg(struct ports_device *portdev, u32 port_id,\n\t\t\t\t  unsigned int event, unsigned int value)\n{\n\tstruct scatterlist sg[1];\n\tstruct virtqueue *vq;\n\tunsigned int len;\n\n\tif (!use_multiport(portdev))\n\t\treturn 0;\n\n\tvq = portdev->c_ovq;\n\n\tspin_lock(&portdev->c_ovq_lock);\n\n\tportdev->cpkt.id = cpu_to_virtio32(portdev->vdev, port_id);\n\tportdev->cpkt.event = cpu_to_virtio16(portdev->vdev, event);\n\tportdev->cpkt.value = cpu_to_virtio16(portdev->vdev, value);\n\n\tsg_init_one(sg, &portdev->cpkt, sizeof(struct virtio_console_control));\n\n\tif (virtqueue_add_outbuf(vq, sg, 1, &portdev->cpkt, GFP_ATOMIC) == 0) {\n\t\tvirtqueue_kick(vq);\n\t\twhile (!virtqueue_get_buf(vq, &len)\n\t\t\t&& !virtqueue_is_broken(vq))\n\t\t\tcpu_relax();\n\t}\n\n\tspin_unlock(&portdev->c_ovq_lock);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4baad50297d84bde1a7ad45e50c73adae4a2192",
        "vul_func_with_fix": "static ssize_t __send_control_msg(struct ports_device *portdev, u32 port_id,\n\t\t\t\t  unsigned int event, unsigned int value)\n{\n\tstruct scatterlist sg[1];\n\tstruct virtqueue *vq;\n\tunsigned int len;\n\n\tif (!use_multiport(portdev))\n\t\treturn 0;\n\n\tvq = portdev->c_ovq;\n\n\tspin_lock(&portdev->c_ovq_lock);\n\n\tportdev->cpkt.id = cpu_to_virtio32(portdev->vdev, port_id);\n\tportdev->cpkt.event = cpu_to_virtio16(portdev->vdev, event);\n\tportdev->cpkt.value = cpu_to_virtio16(portdev->vdev, value);\n\n\tsg_init_one(sg, &portdev->cpkt, sizeof(struct virtio_console_control));\n\n\tif (virtqueue_add_outbuf(vq, sg, 1, &portdev->cpkt, GFP_ATOMIC) == 0) {\n\t\tvirtqueue_kick(vq);\n\t\twhile (!virtqueue_get_buf(vq, &len)\n\t\t\t&& !virtqueue_is_broken(vq))\n\t\t\tcpu_relax();\n\t}\n\n\tspin_unlock(&portdev->c_ovq_lock);\n\treturn 0;\n}\n",
        "linevul": 5.3627903980668634e-05,
        "sysevr": 0.1351536065340042,
        "devign": 0.18890143930912018
    },
    {
        "code": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca",
        "vul_func_with_fix": "static struct buffer_head * ext4_find_entry (struct inode *dir,\n\t\t\t\t\tconst struct qstr *d_name,\n\t\t\t\t\tstruct ext4_dir_entry_2 **res_dir,\n\t\t\t\t\tint *inlined)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh_use[NAMEI_RA_SIZE];\n\tstruct buffer_head *bh, *ret = NULL;\n\text4_lblk_t start, block, b;\n\tconst u8 *name = d_name->name;\n\tint ra_max = 0;\t\t/* Number of bh's in the readahead\n\t\t\t\t   buffer, bh_use[] */\n\tint ra_ptr = 0;\t\t/* Current index into readahead\n\t\t\t\t   buffer */\n\tint num = 0;\n\text4_lblk_t  nblocks;\n\tint i, err;\n\tint namelen;\n\n\t*res_dir = NULL;\n\tsb = dir->i_sb;\n\tnamelen = d_name->len;\n\tif (namelen > EXT4_NAME_LEN)\n\t\treturn NULL;\n\n\tif (ext4_has_inline_data(dir)) {\n\t\tint has_inline_data = 1;\n\t\tret = ext4_find_inline_entry(dir, d_name, res_dir,\n\t\t\t\t\t     &has_inline_data);\n\t\tif (has_inline_data) {\n\t\t\tif (inlined)\n\t\t\t\t*inlined = 1;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif ((namelen <= 2) && (name[0] == '.') &&\n\t    (name[1] == '.' || name[1] == '\\0')) {\n\t\t/*\n\t\t * \".\" or \"..\" will only be in the first block\n\t\t * NFS may look up \"..\"; \".\" should be handled by the VFS\n\t\t */\n\t\tblock = start = 0;\n\t\tnblocks = 1;\n\t\tgoto restart;\n\t}\n\tif (is_dx(dir)) {\n\t\tbh = ext4_dx_find_entry(dir, d_name, res_dir, &err);\n\t\t/*\n\t\t * On success, or if the error was file not found,\n\t\t * return.  Otherwise, fall back to doing a search the\n\t\t * old fashioned way.\n\t\t */\n\t\tif (bh || (err != ERR_BAD_DX_DIR))\n\t\t\treturn bh;\n\t\tdxtrace(printk(KERN_DEBUG \"ext4_find_entry: dx failed, \"\n\t\t\t       \"falling back\\n\"));\n\t}\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tstart = EXT4_I(dir)->i_dir_start_lookup;\n\tif (start >= nblocks)\n\t\tstart = 0;\n\tblock = start;\nrestart:\n\tdo {\n\t\t/*\n\t\t * We deal with the read-ahead logic here.\n\t\t */\n\t\tif (ra_ptr >= ra_max) {\n\t\t\t/* Refill the readahead buffer */\n\t\t\tra_ptr = 0;\n\t\t\tb = block;\n\t\t\tfor (ra_max = 0; ra_max < NAMEI_RA_SIZE; ra_max++) {\n\t\t\t\t/*\n\t\t\t\t * Terminate if we reach the end of the\n\t\t\t\t * directory and must wrap, or if our\n\t\t\t\t * search has finished at this block.\n\t\t\t\t */\n\t\t\t\tif (b >= nblocks || (num && block == start)) {\n\t\t\t\t\tbh_use[ra_max] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tbh = ext4_getblk(NULL, dir, b++, 0, &err);\n\t\t\t\tbh_use[ra_max] = bh;\n\t\t\t\tif (bh)\n\t\t\t\t\tll_rw_block(READ | REQ_META | REQ_PRIO,\n\t\t\t\t\t\t    1, &bh);\n\t\t\t}\n\t\t}\n\t\tif ((bh = bh_use[ra_ptr++]) == NULL)\n\t\t\tgoto next;\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* read error, skip block & hope for the best */\n\t\t\tEXT4_ERROR_INODE(dir, \"reading directory lblock %lu\",\n\t\t\t\t\t (unsigned long) block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tif (!buffer_verified(bh) &&\n\t\t    !is_dx_internal_node(dir, block,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data) &&\n\t\t    !ext4_dirent_csum_verify(dir,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_INODE(dir, \"checksumming directory \"\n\t\t\t\t\t \"block %lu\", (unsigned long)block);\n\t\t\tbrelse(bh);\n\t\t\tgoto next;\n\t\t}\n\t\tset_buffer_verified(bh);\n\t\ti = search_dirblock(bh, dir, d_name,\n\t\t\t    block << EXT4_BLOCK_SIZE_BITS(sb), res_dir);\n\t\tif (i == 1) {\n\t\t\tEXT4_I(dir)->i_dir_start_lookup = block;\n\t\t\tret = bh;\n\t\t\tgoto cleanup_and_exit;\n\t\t} else {\n\t\t\tbrelse(bh);\n\t\t\tif (i < 0)\n\t\t\t\tgoto cleanup_and_exit;\n\t\t}\n\tnext:\n\t\tif (++block >= nblocks)\n\t\t\tblock = 0;\n\t} while (block != start);\n\n\t/*\n\t * If the directory has grown while we were searching, then\n\t * search the last part of the directory before giving up.\n\t */\n\tblock = nblocks;\n\tnblocks = dir->i_size >> EXT4_BLOCK_SIZE_BITS(sb);\n\tif (block < nblocks) {\n\t\tstart = 0;\n\t\tgoto restart;\n\t}\n\ncleanup_and_exit:\n\t/* Clean up the read-ahead blocks */\n\tfor (; ra_ptr < ra_max; ra_ptr++)\n\t\tbrelse(bh_use[ra_ptr]);\n\treturn ret;\n}\n",
        "linevul": 0.0030626626685261726,
        "sysevr": 0.20044520497322083,
        "devign": 0.0
    },
    {
        "code": "asmlinkage void __div0(void)\n{\n\tprintk(\"Division by zero in kernel.\\n\");\n\tdump_stack();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760",
        "vul_func_with_fix": "asmlinkage void __div0(void)\n{\n\tprintk(\"Division by zero in kernel.\\n\");\n\tdump_stack();\n}\n",
        "linevul": 5.1318540499778464e-05,
        "sysevr": 0.1631551831960678,
        "devign": 4.372143092012948e-09
    },
    {
        "code": "static struct sk_buff *tipc_get_err_tlv(char *str)\n{\n\tint str_len = strlen(str) + 1;\n\tstruct sk_buff *buf;\n\n\tbuf = tipc_tlv_alloc(TLV_SPACE(str_len));\n\tif (buf)\n\t\ttipc_add_tlv(buf, TIPC_TLV_ERROR_STRING, str, str_len);\n\n\treturn buf;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2",
        "vul_func_with_fix": "static struct sk_buff *tipc_get_err_tlv(char *str)\n{\n\tint str_len = strlen(str) + 1;\n\tstruct sk_buff *buf;\n\n\tbuf = tipc_tlv_alloc(TLV_SPACE(str_len));\n\tif (buf)\n\t\ttipc_add_tlv(buf, TIPC_TLV_ERROR_STRING, str, str_len);\n\n\treturn buf;\n}\n",
        "linevul": 4.7826011723373085e-05,
        "sysevr": 0.1252884566783905,
        "devign": 0.0012767129810526967
    },
    {
        "code": "static void shmem_recalc_inode(struct inode *inode)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tlong freed;\n\n\tfreed = info->alloced - info->swapped - inode->i_mapping->nrpages;\n\tif (freed > 0) {\n\t\tstruct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks)\n\t\t\tpercpu_counter_add(&sbinfo->used_blocks, -freed);\n\t\tinfo->alloced -= freed;\n\t\tinode->i_blocks -= freed * BLOCKS_PER_PAGE;\n\t\tshmem_unacct_blocks(info->flags, freed);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "static void shmem_recalc_inode(struct inode *inode)\n{\n\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\tlong freed;\n\n\tfreed = info->alloced - info->swapped - inode->i_mapping->nrpages;\n\tif (freed > 0) {\n\t\tstruct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);\n\t\tif (sbinfo->max_blocks)\n\t\t\tpercpu_counter_add(&sbinfo->used_blocks, -freed);\n\t\tinfo->alloced -= freed;\n\t\tinode->i_blocks -= freed * BLOCKS_PER_PAGE;\n\t\tshmem_unacct_blocks(info->flags, freed);\n\t}\n}\n",
        "linevul": 0.0003379280387889594,
        "sysevr": 0.1372067928314209,
        "devign": 1.7459135187578748e-22
    },
    {
        "code": "static int determine_cipher_type(struct fscrypt_info *ci, struct inode *inode,\n\t\t\t\t const char **cipher_str_ret, int *keysize_ret)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (ci->ci_data_mode == FS_ENCRYPTION_MODE_AES_256_XTS) {\n\t\t\t*cipher_str_ret = \"xts(aes)\";\n\t\t\t*keysize_ret = FS_AES_256_XTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported contents encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_data_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\tif (ci->ci_filename_mode == FS_ENCRYPTION_MODE_AES_256_CTS) {\n\t\t\t*cipher_str_ret = \"cts(cbc(aes))\";\n\t\t\t*keysize_ret = FS_AES_256_CTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported filenames encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_filename_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tpr_warn_once(\"fscrypto: unsupported file type %d for inode %lu\\n\",\n\t\t     (inode->i_mode & S_IFMT), inode->i_ino);\n\treturn -ENOKEY;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "vul_func_with_fix": "static int determine_cipher_type(struct fscrypt_info *ci, struct inode *inode,\n\t\t\t\t const char **cipher_str_ret, int *keysize_ret)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (ci->ci_data_mode == FS_ENCRYPTION_MODE_AES_256_XTS) {\n\t\t\t*cipher_str_ret = \"xts(aes)\";\n\t\t\t*keysize_ret = FS_AES_256_XTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported contents encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_data_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\tif (ci->ci_filename_mode == FS_ENCRYPTION_MODE_AES_256_CTS) {\n\t\t\t*cipher_str_ret = \"cts(cbc(aes))\";\n\t\t\t*keysize_ret = FS_AES_256_CTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported filenames encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_filename_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tpr_warn_once(\"fscrypto: unsupported file type %d for inode %lu\\n\",\n\t\t     (inode->i_mode & S_IFMT), inode->i_ino);\n\treturn -ENOKEY;\n}\n",
        "linevul": 8.565795724280179e-05,
        "sysevr": 0.12308955192565918,
        "devign": 8.858783935743544e-27
    },
    {
        "code": "static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tret = dvb_register_adapter(&adap->dvb_adap, d->name, d->props->owner,\n\t\t\t&d->udev->dev, d->props->adapter_nr);\n\tif (ret < 0) {\n\t\tdev_dbg(&d->udev->dev, \"%s: dvb_register_adapter() failed=%d\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto err_dvb_register_adapter;\n\t}\n\n\tadap->dvb_adap.priv = adap;\n\n\tret = dvb_usbv2_media_device_init(adap);\n\tif (ret < 0) {\n\t\tdev_dbg(&d->udev->dev, \"%s: dvb_usbv2_media_device_init() failed=%d\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto err_dvb_register_mc;\n\t}\n\n\tif (d->props->read_mac_address) {\n\t\tret = d->props->read_mac_address(adap,\n\t\t\t\tadap->dvb_adap.proposed_mac);\n\t\tif (ret < 0)\n\t\t\tgoto err_dvb_dmx_init;\n\n\t\tdev_info(&d->udev->dev, \"%s: MAC address: %pM\\n\",\n\t\t\t\tKBUILD_MODNAME, adap->dvb_adap.proposed_mac);\n\t}\n\n\tadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tadap->demux.priv             = adap;\n\tadap->demux.filternum        = 0;\n\tadap->demux.filternum        = adap->max_feed_count;\n\tadap->demux.feednum          = adap->demux.filternum;\n\tadap->demux.start_feed       = dvb_usb_start_feed;\n\tadap->demux.stop_feed        = dvb_usb_stop_feed;\n\tadap->demux.write_to_decoder = NULL;\n\tret = dvb_dmx_init(&adap->demux);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_dmx_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_dmx_init;\n\t}\n\n\tadap->dmxdev.filternum       = adap->demux.filternum;\n\tadap->dmxdev.demux           = &adap->demux.dmx;\n\tadap->dmxdev.capabilities    = 0;\n\tret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_dmxdev_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_dmxdev_init;\n\t}\n\n\tret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_net_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_net_init;\n\t}\n\n\treturn 0;\nerr_dvb_net_init:\n\tdvb_dmxdev_release(&adap->dmxdev);\nerr_dvb_dmxdev_init:\n\tdvb_dmx_release(&adap->demux);\nerr_dvb_dmx_init:\n\tdvb_usbv2_media_device_unregister(adap);\nerr_dvb_register_mc:\n\tdvb_unregister_adapter(&adap->dvb_adap);\nerr_dvb_register_adapter:\n\tadap->dvb_adap.priv = NULL;\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/005145378c9ad7575a01b6ce1ba118fb427f583a",
        "vul_func_with_fix": "static int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)\n{\n\tint ret;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tret = dvb_register_adapter(&adap->dvb_adap, d->name, d->props->owner,\n\t\t\t&d->udev->dev, d->props->adapter_nr);\n\tif (ret < 0) {\n\t\tdev_dbg(&d->udev->dev, \"%s: dvb_register_adapter() failed=%d\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto err_dvb_register_adapter;\n\t}\n\n\tadap->dvb_adap.priv = adap;\n\n\tret = dvb_usbv2_media_device_init(adap);\n\tif (ret < 0) {\n\t\tdev_dbg(&d->udev->dev, \"%s: dvb_usbv2_media_device_init() failed=%d\\n\",\n\t\t\t\t__func__, ret);\n\t\tgoto err_dvb_register_mc;\n\t}\n\n\tif (d->props->read_mac_address) {\n\t\tret = d->props->read_mac_address(adap,\n\t\t\t\tadap->dvb_adap.proposed_mac);\n\t\tif (ret < 0)\n\t\t\tgoto err_dvb_dmx_init;\n\n\t\tdev_info(&d->udev->dev, \"%s: MAC address: %pM\\n\",\n\t\t\t\tKBUILD_MODNAME, adap->dvb_adap.proposed_mac);\n\t}\n\n\tadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\n\tadap->demux.priv             = adap;\n\tadap->demux.filternum        = 0;\n\tadap->demux.filternum        = adap->max_feed_count;\n\tadap->demux.feednum          = adap->demux.filternum;\n\tadap->demux.start_feed       = dvb_usb_start_feed;\n\tadap->demux.stop_feed        = dvb_usb_stop_feed;\n\tadap->demux.write_to_decoder = NULL;\n\tret = dvb_dmx_init(&adap->demux);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_dmx_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_dmx_init;\n\t}\n\n\tadap->dmxdev.filternum       = adap->demux.filternum;\n\tadap->dmxdev.demux           = &adap->demux.dmx;\n\tadap->dmxdev.capabilities    = 0;\n\tret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_dmxdev_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_dmxdev_init;\n\t}\n\n\tret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\n\tif (ret < 0) {\n\t\tdev_err(&d->udev->dev, \"%s: dvb_net_init() failed=%d\\n\",\n\t\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto err_dvb_net_init;\n\t}\n\n\treturn 0;\nerr_dvb_net_init:\n\tdvb_dmxdev_release(&adap->dmxdev);\nerr_dvb_dmxdev_init:\n\tdvb_dmx_release(&adap->demux);\nerr_dvb_dmx_init:\n\tdvb_usbv2_media_device_unregister(adap);\nerr_dvb_register_mc:\n\tdvb_unregister_adapter(&adap->dvb_adap);\nerr_dvb_register_adapter:\n\tadap->dvb_adap.priv = NULL;\n\treturn ret;\n}\n",
        "linevul": 4.876905950368382e-05,
        "sysevr": 0.1908441036939621,
        "devign": 0.2527432441711426
    },
    {
        "code": "static unsigned int userfaultfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tunsigned int ret;\n\n\tpoll_wait(file, &ctx->fd_wqh, wait);\n\n\tswitch (ctx->state) {\n\tcase UFFD_STATE_WAIT_API:\n\t\treturn POLLERR;\n\tcase UFFD_STATE_RUNNING:\n\t\t/*\n\t\t * poll() never guarantees that read won't block.\n\t\t * userfaults can be waken before they're read().\n\t\t */\n\t\tif (unlikely(!(file->f_flags & O_NONBLOCK)))\n\t\t\treturn POLLERR;\n\t\t/*\n\t\t * lockless access to see if there are pending faults\n\t\t * __pollwait last action is the add_wait_queue but\n\t\t * the spin_unlock would allow the waitqueue_active to\n\t\t * pass above the actual list_add inside\n\t\t * add_wait_queue critical section. So use a full\n\t\t * memory barrier to serialize the list_add write of\n\t\t * add_wait_queue() with the waitqueue_active read\n\t\t * below.\n\t\t */\n\t\tret = 0;\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t\tret = POLLIN;\n\t\telse if (waitqueue_active(&ctx->event_wqh))\n\t\t\tret = POLLIN;\n\n\t\treturn ret;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn POLLERR;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252",
        "vul_func_with_fix": "static unsigned int userfaultfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tunsigned int ret;\n\n\tpoll_wait(file, &ctx->fd_wqh, wait);\n\n\tswitch (ctx->state) {\n\tcase UFFD_STATE_WAIT_API:\n\t\treturn POLLERR;\n\tcase UFFD_STATE_RUNNING:\n\t\t/*\n\t\t * poll() never guarantees that read won't block.\n\t\t * userfaults can be waken before they're read().\n\t\t */\n\t\tif (unlikely(!(file->f_flags & O_NONBLOCK)))\n\t\t\treturn POLLERR;\n\t\t/*\n\t\t * lockless access to see if there are pending faults\n\t\t * __pollwait last action is the add_wait_queue but\n\t\t * the spin_unlock would allow the waitqueue_active to\n\t\t * pass above the actual list_add inside\n\t\t * add_wait_queue critical section. So use a full\n\t\t * memory barrier to serialize the list_add write of\n\t\t * add_wait_queue() with the waitqueue_active read\n\t\t * below.\n\t\t */\n\t\tret = 0;\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&ctx->fault_pending_wqh))\n\t\t\tret = POLLIN;\n\t\telse if (waitqueue_active(&ctx->event_wqh))\n\t\t\tret = POLLIN;\n\n\t\treturn ret;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn POLLERR;\n\t}\n}\n",
        "linevul": 0.000641076301690191,
        "sysevr": 0.1437983363866806,
        "devign": 3.138694477391145e-14
    },
    {
        "code": "int inet_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tif (sk->sk_family == AF_INET)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len, addr_len);\n#endif\n\treturn -EINVAL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9",
        "vul_func_with_fix": "int inet_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tif (sk->sk_family == AF_INET)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len, addr_len);\n#endif\n\treturn -EINVAL;\n}\n",
        "linevul": 5.209295704844408e-05,
        "sysevr": 0.1617182344198227,
        "devign": 1.6814681591537095e-10
    },
    {
        "code": "static int cryp_algs_register_all(void)\n{\n\tint ret;\n\tint i;\n\tint count;\n\n\tpr_debug(\"[%s]\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(cryp_algs); i++) {\n\t\tret = crypto_register_alg(&cryp_algs[i].crypto);\n\t\tif (ret) {\n\t\t\tcount = i;\n\t\t\tpr_err(\"[%s] alg registration failed\",\n\t\t\t\t\tcryp_algs[i].crypto.cra_driver_name);\n\t\t\tgoto unreg;\n\t\t}\n\t}\n\treturn 0;\nunreg:\n\tfor (i = 0; i < count; i++)\n\t\tcrypto_unregister_alg(&cryp_algs[i].crypto);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int cryp_algs_register_all(void)\n{\n\tint ret;\n\tint i;\n\tint count;\n\n\tpr_debug(\"[%s]\", __func__);\n\n\tfor (i = 0; i < ARRAY_SIZE(cryp_algs); i++) {\n\t\tret = crypto_register_alg(&cryp_algs[i].crypto);\n\t\tif (ret) {\n\t\t\tcount = i;\n\t\t\tpr_err(\"[%s] alg registration failed\",\n\t\t\t\t\tcryp_algs[i].crypto.cra_driver_name);\n\t\t\tgoto unreg;\n\t\t}\n\t}\n\treturn 0;\nunreg:\n\tfor (i = 0; i < count; i++)\n\t\tcrypto_unregister_alg(&cryp_algs[i].crypto);\n\treturn ret;\n}\n",
        "linevul": 4.652353163692169e-05,
        "sysevr": 0.13346128165721893,
        "devign": 3.1621976507393232e-24
    },
    {
        "code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n \n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n \t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n \t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n \t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a2b9e6c1a35afcc0973acb72e591c714e78885ff",
        "vul_func_with_fix": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n \n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n//flaw_line_below:\n\tif (!is_guest_mode(vcpu)) {\n//fix_flaw_line_below:\n//\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n \t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n \t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n \t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n",
        "linevul": 0.9995483756065369,
        "sysevr": 0.13607746362686157,
        "devign": 0.998172402381897
    },
    {
        "code": "static int fwnet_header_cache(const struct neighbour *neigh,\n\t\t\t      struct hh_cache *hh, __be16 type)\n{\n\tstruct net_device *net;\n\tstruct fwnet_header *h;\n\n\tif (type == cpu_to_be16(ETH_P_802_3))\n\t\treturn -1;\n\tnet = neigh->dev;\n\th = (struct fwnet_header *)((u8 *)hh->hh_data + HH_DATA_OFF(sizeof(*h)));\n\th->h_proto = type;\n\tmemcpy(h->h_dest, neigh->ha, net->addr_len);\n\thh->hh_len = FWNET_HLEN;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac",
        "vul_func_with_fix": "static int fwnet_header_cache(const struct neighbour *neigh,\n\t\t\t      struct hh_cache *hh, __be16 type)\n{\n\tstruct net_device *net;\n\tstruct fwnet_header *h;\n\n\tif (type == cpu_to_be16(ETH_P_802_3))\n\t\treturn -1;\n\tnet = neigh->dev;\n\th = (struct fwnet_header *)((u8 *)hh->hh_data + HH_DATA_OFF(sizeof(*h)));\n\th->h_proto = type;\n\tmemcpy(h->h_dest, neigh->ha, net->addr_len);\n\thh->hh_len = FWNET_HLEN;\n\n\treturn 0;\n}\n",
        "linevul": 4.8833560867933556e-05,
        "sysevr": 0.13953743875026703,
        "devign": 2.810145588227897e-06
    },
    {
        "code": "static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)\n{\n\tint def_errors;\n\tunsigned long def_mount_opts;\n\tstruct super_block *sb = vfs->mnt_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tdef_errors     = le16_to_cpu(es->s_errors);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%llu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID) && !(def_mount_opts & EXT4_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT4_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (sbi->s_resuid != EXT4_DEF_RESUID ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\", sbi->s_resuid);\n\t}\n\tif (sbi->s_resgid != EXT4_DEF_RESGID ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\", sbi->s_resgid);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tif (def_errors == EXT4_ERRORS_PANIC ||\n\t\t    def_errors == EXT4_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32) && !(def_mount_opts & EXT4_DEFM_UID16))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG) && !(def_mount_opts & EXT4_DEFM_DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (test_opt(sb, XATTR_USER) &&\n\t\t!(def_mount_opts & EXT4_DEFM_XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT4_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL) && !(def_mount_opts & EXT4_DEFM_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT4_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\tseq_printf(seq, \",commit=%u\",\n\t\t\t   (unsigned) (sbi->s_commit_interval / HZ));\n\t}\n\tif (sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME) {\n\t\tseq_printf(seq, \",min_batch_time=%u\",\n\t\t\t   (unsigned) sbi->s_min_batch_time);\n\t}\n\tif (sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME) {\n\t\tseq_printf(seq, \",max_batch_time=%u\",\n\t\t\t   (unsigned) sbi->s_min_batch_time);\n\t}\n\n\t/*\n\t * We're changing the default of barrier mount option, so\n\t * let's always display its mount state so it's clear what its\n\t * status is.\n\t */\n\tseq_puts(seq, \",barrier=\");\n\tseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT))\n\t\tseq_puts(seq, \",journal_async_commit\");\n\tif (test_opt(sb, NOBH))\n\t\tseq_puts(seq, \",nobh\");\n\tif (test_opt(sb, I_VERSION))\n\t\tseq_puts(seq, \",i_version\");\n\tif (!test_opt(sb, DELALLOC))\n\t\tseq_puts(seq, \",nodelalloc\");\n\n\n\tif (sbi->s_stripe)\n\t\tseq_printf(seq, \",stripe=%lu\", sbi->s_stripe);\n\t/*\n\t * journal mode get enabled in different ways\n\t * So just print the value even if we didn't specify it\n\t */\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\tseq_puts(seq, \",data=journal\");\n\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\tseq_puts(seq, \",data=ordered\");\n\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\tseq_puts(seq, \",data=writeback\");\n\n\tif (sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tseq_printf(seq, \",inode_readahead_blks=%u\",\n\t\t\t   sbi->s_inode_readahead_blks);\n\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tseq_puts(seq, \",data_err=abort\");\n\n\tif (test_opt(sb, NO_AUTO_DA_ALLOC))\n\t\tseq_puts(seq, \",noauto_da_alloc\");\n\n\tif (test_opt(sb, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\n \tif (test_opt(sb, NOLOAD))\n \t\tseq_puts(seq, \",norecovery\");\n \n \text4_show_quota_options(seq, sb);\n \n \treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
        "vul_func_with_fix": "static int ext4_show_options(struct seq_file *seq, struct vfsmount *vfs)\n{\n\tint def_errors;\n\tunsigned long def_mount_opts;\n\tstruct super_block *sb = vfs->mnt_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tdef_errors     = le16_to_cpu(es->s_errors);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%llu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID) && !(def_mount_opts & EXT4_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT4_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (sbi->s_resuid != EXT4_DEF_RESUID ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT4_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\", sbi->s_resuid);\n\t}\n\tif (sbi->s_resgid != EXT4_DEF_RESGID ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT4_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\", sbi->s_resgid);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tif (def_errors == EXT4_ERRORS_PANIC ||\n\t\t    def_errors == EXT4_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT) && def_errors != EXT4_ERRORS_CONTINUE)\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC) && def_errors != EXT4_ERRORS_PANIC)\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32) && !(def_mount_opts & EXT4_DEFM_UID16))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG) && !(def_mount_opts & EXT4_DEFM_DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n#ifdef CONFIG_EXT4_FS_XATTR\n\tif (test_opt(sb, XATTR_USER) &&\n\t\t!(def_mount_opts & EXT4_DEFM_XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT4_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL) && !(def_mount_opts & EXT4_DEFM_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT4_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\tseq_printf(seq, \",commit=%u\",\n\t\t\t   (unsigned) (sbi->s_commit_interval / HZ));\n\t}\n\tif (sbi->s_min_batch_time != EXT4_DEF_MIN_BATCH_TIME) {\n\t\tseq_printf(seq, \",min_batch_time=%u\",\n\t\t\t   (unsigned) sbi->s_min_batch_time);\n\t}\n\tif (sbi->s_max_batch_time != EXT4_DEF_MAX_BATCH_TIME) {\n\t\tseq_printf(seq, \",max_batch_time=%u\",\n\t\t\t   (unsigned) sbi->s_min_batch_time);\n\t}\n\n\t/*\n\t * We're changing the default of barrier mount option, so\n\t * let's always display its mount state so it's clear what its\n\t * status is.\n\t */\n\tseq_puts(seq, \",barrier=\");\n\tseq_puts(seq, test_opt(sb, BARRIER) ? \"1\" : \"0\");\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT))\n\t\tseq_puts(seq, \",journal_async_commit\");\n\tif (test_opt(sb, NOBH))\n\t\tseq_puts(seq, \",nobh\");\n\tif (test_opt(sb, I_VERSION))\n\t\tseq_puts(seq, \",i_version\");\n\tif (!test_opt(sb, DELALLOC))\n\t\tseq_puts(seq, \",nodelalloc\");\n\n\n\tif (sbi->s_stripe)\n\t\tseq_printf(seq, \",stripe=%lu\", sbi->s_stripe);\n\t/*\n\t * journal mode get enabled in different ways\n\t * So just print the value even if we didn't specify it\n\t */\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\tseq_puts(seq, \",data=journal\");\n\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\tseq_puts(seq, \",data=ordered\");\n\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\tseq_puts(seq, \",data=writeback\");\n\n\tif (sbi->s_inode_readahead_blks != EXT4_DEF_INODE_READAHEAD_BLKS)\n\t\tseq_printf(seq, \",inode_readahead_blks=%u\",\n\t\t\t   sbi->s_inode_readahead_blks);\n\n\tif (test_opt(sb, DATA_ERR_ABORT))\n\t\tseq_puts(seq, \",data_err=abort\");\n\n\tif (test_opt(sb, NO_AUTO_DA_ALLOC))\n\t\tseq_puts(seq, \",noauto_da_alloc\");\n\n\tif (test_opt(sb, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\n \tif (test_opt(sb, NOLOAD))\n \t\tseq_puts(seq, \",norecovery\");\n \n//fix_flaw_line_below:\n//\tif (test_opt(sb, DIOREAD_NOLOCK))\n//fix_flaw_line_below:\n//\t\tseq_puts(seq, \",dioread_nolock\");\n//fix_flaw_line_below:\n//\n \text4_show_quota_options(seq, sb);\n \n \treturn 0;\n}\n",
        "linevul": 0.0018166484078392386,
        "sysevr": 0.2608509957790375,
        "devign": 3.6643068597186357e-06
    },
    {
        "code": "static unsigned xen_netbk_tx_build_gops(struct xen_netbk *netbk)\n{\n\tstruct gnttab_copy *gop = netbk->tx_copy_ops, *request_gop;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\twhile (((nr_pending_reqs(netbk) + MAX_SKB_FRAGS) < MAX_PENDING_REQS) &&\n\t\t!list_empty(&netbk->net_schedule_list)) {\n\t\tstruct xenvif *vif;\n\t\tstruct xen_netif_tx_request txreq;\n\t\tstruct xen_netif_tx_request txfrags[MAX_SKB_FRAGS];\n\t\tstruct page *page;\n\t\tstruct xen_netif_extra_info extras[XEN_NETIF_EXTRA_TYPE_MAX-1];\n\t\tu16 pending_idx;\n\t\tRING_IDX idx;\n\t\tint work_to_do;\n\t\tunsigned int data_len;\n\t\tpending_ring_idx_t index;\n \n \t\t/* Get a netif from the list with work to do. */\n \t\tvif = poll_net_schedule_list(netbk);\n \t\tif (!vif)\n \t\t\tcontinue;\n \n \t\tRING_FINAL_CHECK_FOR_REQUESTS(&vif->tx, work_to_do);\n \t\tif (!work_to_do) {\n \t\t\txenvif_put(vif);\n\t\t\tcontinue;\n\t\t}\n\n\t\tidx = vif->tx.req_cons;\n\t\trmb(); /* Ensure that we see the request before we copy it. */\n\t\tmemcpy(&txreq, RING_GET_REQUEST(&vif->tx, idx), sizeof(txreq));\n\n\t\t/* Credit-based scheduling. */\n\t\tif (txreq.size > vif->remaining_credit &&\n\t\t    tx_credit_exceeded(vif, txreq.size)) {\n\t\t\txenvif_put(vif);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvif->remaining_credit -= txreq.size;\n\n\t\twork_to_do--;\n\t\tvif->tx.req_cons = ++idx;\n\n\t\tmemset(extras, 0, sizeof(extras));\n\t\tif (txreq.flags & XEN_NETTXF_extra_info) {\n \t\t\twork_to_do = xen_netbk_get_extras(vif, extras,\n \t\t\t\t\t\t\t  work_to_do);\n \t\t\tidx = vif->tx.req_cons;\n\t\t\tif (unlikely(work_to_do < 0)) {\n\t\t\t\tnetbk_tx_err(vif, &txreq, idx);\n \t\t\t\tcontinue;\n\t\t\t}\n \t\t}\n \n \t\tret = netbk_count_requests(vif, &txreq, txfrags, work_to_do);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tnetbk_tx_err(vif, &txreq, idx - ret);\n \t\t\tcontinue;\n\t\t}\n \t\tidx += ret;\n \n \t\tif (unlikely(txreq.size < ETH_HLEN)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Bad packet size: %d\\n\", txreq.size);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tcontinue;\n\t\t}\n \n \t\t/* No crossing a page as the payload mustn't fragment. */\n \t\tif (unlikely((txreq.offset + txreq.size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev,\n \t\t\t\t   \"txreq.offset: %x, size: %u, end: %lu\\n\",\n \t\t\t\t   txreq.offset, txreq.size,\n \t\t\t\t   (txreq.offset&~PAGE_MASK) + txreq.size);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n \t\t\tcontinue;\n \t\t}\n \n\t\tindex = pending_index(netbk->pending_cons);\n\t\tpending_idx = netbk->pending_ring[index];\n\n\t\tdata_len = (txreq.size > PKT_PROT_LEN &&\n\t\t\t    ret < MAX_SKB_FRAGS) ?\n\t\t\tPKT_PROT_LEN : txreq.size;\n\n\t\tskb = alloc_skb(data_len + NET_SKB_PAD + NET_IP_ALIGN,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (unlikely(skb == NULL)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Can't allocate a skb in start_xmit.\\n\");\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Packets passed to netif_rx() must have some headroom. */\n\t\tskb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);\n\n\t\tif (extras[XEN_NETIF_EXTRA_TYPE_GSO - 1].type) {\n\t\t\tstruct xen_netif_extra_info *gso;\n \t\t\tgso = &extras[XEN_NETIF_EXTRA_TYPE_GSO - 1];\n \n \t\t\tif (netbk_set_skb_gso(vif, skb, gso)) {\n \t\t\t\tkfree_skb(skb);\n\t\t\t\tnetbk_tx_err(vif, &txreq, idx);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n\n\t\t/* XXX could copy straight to head */\n\t\tpage = xen_netbk_alloc_page(netbk, skb, pending_idx);\n\t\tif (!page) {\n\t\t\tkfree_skb(skb);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgop->source.u.ref = txreq.gref;\n\t\tgop->source.domid = vif->domid;\n\t\tgop->source.offset = txreq.offset;\n\n\t\tgop->dest.u.gmfn = virt_to_mfn(page_address(page));\n\t\tgop->dest.domid = DOMID_SELF;\n\t\tgop->dest.offset = txreq.offset;\n\n\t\tgop->len = txreq.size;\n\t\tgop->flags = GNTCOPY_source_gref;\n\n\t\tgop++;\n\n\t\tmemcpy(&netbk->pending_tx_info[pending_idx].req,\n\t\t       &txreq, sizeof(txreq));\n\t\tnetbk->pending_tx_info[pending_idx].vif = vif;\n\t\t*((u16 *)skb->data) = pending_idx;\n\n\t\t__skb_put(skb, data_len);\n\n\t\tskb_shinfo(skb)->nr_frags = ret;\n\t\tif (data_len < txreq.size) {\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\tfrag_set_pending_idx(&skb_shinfo(skb)->frags[0],\n\t\t\t\t\t     pending_idx);\n\t\t} else {\n\t\t\tfrag_set_pending_idx(&skb_shinfo(skb)->frags[0],\n\t\t\t\t\t     INVALID_PENDING_IDX);\n\t\t}\n\n\t\tnetbk->pending_cons++;\n\n\t\trequest_gop = xen_netbk_get_requests(netbk, vif,\n\t\t\t\t\t\t     skb, txfrags, gop);\n\t\tif (request_gop == NULL) {\n\t\t\tkfree_skb(skb);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tgop = request_gop;\n\n\t\t__skb_queue_tail(&netbk->tx_queue, skb);\n\n\t\tvif->tx.req_cons = idx;\n\t\txen_netbk_check_rx_xenvif(vif);\n\n\t\tif ((gop-netbk->tx_copy_ops) >= ARRAY_SIZE(netbk->tx_copy_ops))\n\t\t\tbreak;\n\t}\n\n\treturn gop - netbk->tx_copy_ops;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664",
        "vul_func_with_fix": "static unsigned xen_netbk_tx_build_gops(struct xen_netbk *netbk)\n{\n\tstruct gnttab_copy *gop = netbk->tx_copy_ops, *request_gop;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\twhile (((nr_pending_reqs(netbk) + MAX_SKB_FRAGS) < MAX_PENDING_REQS) &&\n\t\t!list_empty(&netbk->net_schedule_list)) {\n\t\tstruct xenvif *vif;\n\t\tstruct xen_netif_tx_request txreq;\n\t\tstruct xen_netif_tx_request txfrags[MAX_SKB_FRAGS];\n\t\tstruct page *page;\n\t\tstruct xen_netif_extra_info extras[XEN_NETIF_EXTRA_TYPE_MAX-1];\n\t\tu16 pending_idx;\n\t\tRING_IDX idx;\n\t\tint work_to_do;\n\t\tunsigned int data_len;\n\t\tpending_ring_idx_t index;\n \n \t\t/* Get a netif from the list with work to do. */\n \t\tvif = poll_net_schedule_list(netbk);\n//fix_flaw_line_below:\n//\t\t/* This can sometimes happen because the test of\n//fix_flaw_line_below:\n//\t\t * list_empty(net_schedule_list) at the top of the\n//fix_flaw_line_below:\n//\t\t * loop is unlocked.  Just go back and have another\n//fix_flaw_line_below:\n//\t\t * look.\n//fix_flaw_line_below:\n//\t\t */\n \t\tif (!vif)\n \t\t\tcontinue;\n \n//fix_flaw_line_below:\n//\t\tif (vif->tx.sring->req_prod - vif->tx.req_cons >\n//fix_flaw_line_below:\n//\t\t    XEN_NETIF_TX_RING_SIZE) {\n//fix_flaw_line_below:\n//\t\t\tnetdev_err(vif->dev,\n//fix_flaw_line_below:\n//\t\t\t\t   \"Impossible number of requests. \"\n//fix_flaw_line_below:\n//\t\t\t\t   \"req_prod %d, req_cons %d, size %ld\\n\",\n//fix_flaw_line_below:\n//\t\t\t\t   vif->tx.sring->req_prod, vif->tx.req_cons,\n//fix_flaw_line_below:\n//\t\t\t\t   XEN_NETIF_TX_RING_SIZE);\n//fix_flaw_line_below:\n//\t\t\tnetbk_fatal_tx_err(vif);\n//fix_flaw_line_below:\n//\t\t\tcontinue;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\n \t\tRING_FINAL_CHECK_FOR_REQUESTS(&vif->tx, work_to_do);\n \t\tif (!work_to_do) {\n \t\t\txenvif_put(vif);\n\t\t\tcontinue;\n\t\t}\n\n\t\tidx = vif->tx.req_cons;\n\t\trmb(); /* Ensure that we see the request before we copy it. */\n\t\tmemcpy(&txreq, RING_GET_REQUEST(&vif->tx, idx), sizeof(txreq));\n\n\t\t/* Credit-based scheduling. */\n\t\tif (txreq.size > vif->remaining_credit &&\n\t\t    tx_credit_exceeded(vif, txreq.size)) {\n\t\t\txenvif_put(vif);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvif->remaining_credit -= txreq.size;\n\n\t\twork_to_do--;\n\t\tvif->tx.req_cons = ++idx;\n\n\t\tmemset(extras, 0, sizeof(extras));\n\t\tif (txreq.flags & XEN_NETTXF_extra_info) {\n \t\t\twork_to_do = xen_netbk_get_extras(vif, extras,\n \t\t\t\t\t\t\t  work_to_do);\n \t\t\tidx = vif->tx.req_cons;\n//flaw_line_below:\n\t\t\tif (unlikely(work_to_do < 0)) {\n//flaw_line_below:\n\t\t\t\tnetbk_tx_err(vif, &txreq, idx);\n//fix_flaw_line_below:\n//\t\t\tif (unlikely(work_to_do < 0))\n \t\t\t\tcontinue;\n//flaw_line_below:\n\t\t\t}\n \t\t}\n \n \t\tret = netbk_count_requests(vif, &txreq, txfrags, work_to_do);\n//flaw_line_below:\n\t\tif (unlikely(ret < 0)) {\n//flaw_line_below:\n\t\t\tnetbk_tx_err(vif, &txreq, idx - ret);\n//fix_flaw_line_below:\n//\t\tif (unlikely(ret < 0))\n \t\t\tcontinue;\n//flaw_line_below:\n\t\t}\n//fix_flaw_line_below:\n//\n \t\tidx += ret;\n \n \t\tif (unlikely(txreq.size < ETH_HLEN)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Bad packet size: %d\\n\", txreq.size);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tcontinue;\n\t\t}\n \n \t\t/* No crossing a page as the payload mustn't fragment. */\n \t\tif (unlikely((txreq.offset + txreq.size) > PAGE_SIZE)) {\n//flaw_line_below:\n\t\t\tnetdev_dbg(vif->dev,\n//fix_flaw_line_below:\n//\t\t\tnetdev_err(vif->dev,\n \t\t\t\t   \"txreq.offset: %x, size: %u, end: %lu\\n\",\n \t\t\t\t   txreq.offset, txreq.size,\n \t\t\t\t   (txreq.offset&~PAGE_MASK) + txreq.size);\n//flaw_line_below:\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n//fix_flaw_line_below:\n//\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\tcontinue;\n \t\t}\n \n\t\tindex = pending_index(netbk->pending_cons);\n\t\tpending_idx = netbk->pending_ring[index];\n\n\t\tdata_len = (txreq.size > PKT_PROT_LEN &&\n\t\t\t    ret < MAX_SKB_FRAGS) ?\n\t\t\tPKT_PROT_LEN : txreq.size;\n\n\t\tskb = alloc_skb(data_len + NET_SKB_PAD + NET_IP_ALIGN,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (unlikely(skb == NULL)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Can't allocate a skb in start_xmit.\\n\");\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Packets passed to netif_rx() must have some headroom. */\n\t\tskb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);\n\n\t\tif (extras[XEN_NETIF_EXTRA_TYPE_GSO - 1].type) {\n\t\t\tstruct xen_netif_extra_info *gso;\n \t\t\tgso = &extras[XEN_NETIF_EXTRA_TYPE_GSO - 1];\n \n \t\t\tif (netbk_set_skb_gso(vif, skb, gso)) {\n//fix_flaw_line_below:\n//\t\t\t\t/* Failure in netbk_set_skb_gso is fatal. */\n \t\t\t\tkfree_skb(skb);\n//flaw_line_below:\n\t\t\t\tnetbk_tx_err(vif, &txreq, idx);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n\n\t\t/* XXX could copy straight to head */\n\t\tpage = xen_netbk_alloc_page(netbk, skb, pending_idx);\n\t\tif (!page) {\n\t\t\tkfree_skb(skb);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgop->source.u.ref = txreq.gref;\n\t\tgop->source.domid = vif->domid;\n\t\tgop->source.offset = txreq.offset;\n\n\t\tgop->dest.u.gmfn = virt_to_mfn(page_address(page));\n\t\tgop->dest.domid = DOMID_SELF;\n\t\tgop->dest.offset = txreq.offset;\n\n\t\tgop->len = txreq.size;\n\t\tgop->flags = GNTCOPY_source_gref;\n\n\t\tgop++;\n\n\t\tmemcpy(&netbk->pending_tx_info[pending_idx].req,\n\t\t       &txreq, sizeof(txreq));\n\t\tnetbk->pending_tx_info[pending_idx].vif = vif;\n\t\t*((u16 *)skb->data) = pending_idx;\n\n\t\t__skb_put(skb, data_len);\n\n\t\tskb_shinfo(skb)->nr_frags = ret;\n\t\tif (data_len < txreq.size) {\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\tfrag_set_pending_idx(&skb_shinfo(skb)->frags[0],\n\t\t\t\t\t     pending_idx);\n\t\t} else {\n\t\t\tfrag_set_pending_idx(&skb_shinfo(skb)->frags[0],\n\t\t\t\t\t     INVALID_PENDING_IDX);\n\t\t}\n\n\t\tnetbk->pending_cons++;\n\n\t\trequest_gop = xen_netbk_get_requests(netbk, vif,\n\t\t\t\t\t\t     skb, txfrags, gop);\n\t\tif (request_gop == NULL) {\n\t\t\tkfree_skb(skb);\n\t\t\tnetbk_tx_err(vif, &txreq, idx);\n\t\t\tcontinue;\n\t\t}\n\t\tgop = request_gop;\n\n\t\t__skb_queue_tail(&netbk->tx_queue, skb);\n\n\t\tvif->tx.req_cons = idx;\n\t\txen_netbk_check_rx_xenvif(vif);\n\n\t\tif ((gop-netbk->tx_copy_ops) >= ARRAY_SIZE(netbk->tx_copy_ops))\n\t\t\tbreak;\n\t}\n\n\treturn gop - netbk->tx_copy_ops;\n}\n",
        "linevul": 0.0004946836270391941,
        "sysevr": 0.23392383754253387,
        "devign": 0.9989848732948303
    },
    {
        "code": "static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned char *vec)\n{\n\tunsigned long next;\n\tpmd_t *pmd;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (mincore_huge_pmd(vma, pmd, addr, next, vec)) {\n\t\t\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\t/* fall through */\n \t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n \t\t\tmincore_unmapped_range(vma, addr, next, vec);\n \t\telse\n \t\t\tmincore_pte_range(vma, pmd, addr, next, vec);\n\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t} while (pmd++, addr = next, addr != end);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n\t\t\tunsigned long addr, unsigned long end,\n\t\t\tunsigned char *vec)\n{\n\tunsigned long next;\n\tpmd_t *pmd;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (mincore_huge_pmd(vma, pmd, addr, next, vec)) {\n\t\t\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\t/* fall through */\n \t\t}\n//flaw_line_below:\n\t\tif (pmd_none_or_clear_bad(pmd))\n//fix_flaw_line_below:\n//\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tmincore_unmapped_range(vma, addr, next, vec);\n \t\telse\n \t\t\tmincore_pte_range(vma, pmd, addr, next, vec);\n\t\tvec += (next - addr) >> PAGE_SHIFT;\n\t} while (pmd++, addr = next, addr != end);\n}\n",
        "linevul": 0.9979606866836548,
        "sysevr": 0.14766407012939453,
        "devign": 0.9873799085617065
    },
    {
        "code": "static int __init nvmet_fc_init_module(void)\n{\n\treturn nvmet_register_transport(&nvmet_fc_tgt_fcp_ops);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0c319d3a144d4b8f1ea2047fd614d2149b68f889",
        "vul_func_with_fix": "static int __init nvmet_fc_init_module(void)\n{\n\treturn nvmet_register_transport(&nvmet_fc_tgt_fcp_ops);\n}\n",
        "linevul": 5.773054726887494e-05,
        "sysevr": 0.12619057297706604,
        "devign": 0.3145204782485962
    },
    {
        "code": "static int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\n{\n\tuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\n\tdma_addr_t dma_coherent_handle;\n\n\t/*\n\t********************************************************************\n\t** here we need to tell iop 331 our freeccb.HighPart\n\t** if freeccb.HighPart is not zero\n\t********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tdma_coherent_handle = acb->dma_coherent_handle2;\n\t\tbreak;\n\tdefault:\n\t\tdma_coherent_handle = acb->dma_coherent_handle;\n\t\tbreak;\n\t}\n\tcdb_phyaddr = lower_32_bits(dma_coherent_handle);\n\tcdb_phyaddr_hi32 = upper_32_bits(dma_coherent_handle);\n\tacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\n\t/*\n\t***********************************************************************\n\t**    if adapter type B, set window of \"post command Q\"\n\t***********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, \\\n\t\t\t\t\t\t&reg->message_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\\n\t\t\t\t\t\t\t&reg->inbound_msgaddr0);\n\t\t\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: \"\"set ccb high \\\n\t\t\t\tpart physical address timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tuint32_t __iomem *rwbuffer;\n\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\twritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cannot set driver mode\\n\", \\\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\trwbuffer = reg->message_rwbuffer;\n\t\t/* driver \"set config\" signature */\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\t/* normal should be zero */\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\t/* postQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\t/* doneQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr + 1056, rwbuffer++);\n\t\t/* ccb maxQ size must be --> [(256 + 8)*4]*/\n\t\twritel(1056, rwbuffer);\n\n\t\twritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\ttimeout \\n\",acb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tpr_err(\"arcmsr%d: can't set driver mode.\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cdb_phyaddr_hi32=0x%x\\n\",\n\t\t\t\t\tacb->adapter_index, cdb_phyaddr_hi32);\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tif (!arcmsr_hbaC_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\t\ttimeout \\n\", acb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tuint32_t __iomem *rwbuffer;\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\trwbuffer = reg->msgcode_rwbuffer;\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\twritel(cdb_phyaddr + (ARCMSR_MAX_ARC1214_POSTQUEUE *\n\t\t\tsizeof(struct InBound_SRB)), rwbuffer++);\n\t\twritel(0x100, rwbuffer);\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, reg->inbound_msgaddr0);\n\t\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7bc2b55a5c030685b399bb65b6baa9ccc3d1f167",
        "vul_func_with_fix": "static int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\n{\n\tuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\n\tdma_addr_t dma_coherent_handle;\n\n\t/*\n\t********************************************************************\n\t** here we need to tell iop 331 our freeccb.HighPart\n\t** if freeccb.HighPart is not zero\n\t********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_B:\n\tcase ACB_ADAPTER_TYPE_D:\n\t\tdma_coherent_handle = acb->dma_coherent_handle2;\n\t\tbreak;\n\tdefault:\n\t\tdma_coherent_handle = acb->dma_coherent_handle;\n\t\tbreak;\n\t}\n\tcdb_phyaddr = lower_32_bits(dma_coherent_handle);\n\tcdb_phyaddr_hi32 = upper_32_bits(dma_coherent_handle);\n\tacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\n\t/*\n\t***********************************************************************\n\t**    if adapter type B, set window of \"post command Q\"\n\t***********************************************************************\n\t*/\n\tswitch (acb->adapter_type) {\n\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, \\\n\t\t\t\t\t\t&reg->message_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\\n\t\t\t\t\t\t\t&reg->inbound_msgaddr0);\n\t\t\tif (!arcmsr_hbaA_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: \"\"set ccb high \\\n\t\t\t\tpart physical address timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tuint32_t __iomem *rwbuffer;\n\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\twritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cannot set driver mode\\n\", \\\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\trwbuffer = reg->message_rwbuffer;\n\t\t/* driver \"set config\" signature */\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\t/* normal should be zero */\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\t/* postQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\t/* doneQ size (256 + 8)*4\t */\n\t\twritel(cdb_phyaddr + 1056, rwbuffer++);\n\t\t/* ccb maxQ size must be --> [(256 + 8)*4]*/\n\t\twritel(1056, rwbuffer);\n\n\t\twritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\ttimeout \\n\",acb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\twritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\n\t\tif (!arcmsr_hbaB_wait_msgint_ready(acb)) {\n\t\t\tpr_err(\"arcmsr%d: can't set driver mode.\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tif (cdb_phyaddr_hi32 != 0) {\n\t\t\tstruct MessageUnit_C __iomem *reg = acb->pmuC;\n\n\t\t\tprintk(KERN_NOTICE \"arcmsr%d: cdb_phyaddr_hi32=0x%x\\n\",\n\t\t\t\t\tacb->adapter_index, cdb_phyaddr_hi32);\n\t\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\n\t\t\twritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\n\t\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\n\t\t\twritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\n\t\t\tif (!arcmsr_hbaC_wait_msgint_ready(acb)) {\n\t\t\t\tprintk(KERN_NOTICE \"arcmsr%d: 'set command Q window' \\\n\t\t\t\ttimeout \\n\", acb->host->host_no);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tuint32_t __iomem *rwbuffer;\n\t\tstruct MessageUnit_D *reg = acb->pmuD;\n\t\treg->postq_index = 0;\n\t\treg->doneq_index = 0;\n\t\trwbuffer = reg->msgcode_rwbuffer;\n\t\twritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\n\t\twritel(cdb_phyaddr_hi32, rwbuffer++);\n\t\twritel(cdb_phyaddr, rwbuffer++);\n\t\twritel(cdb_phyaddr + (ARCMSR_MAX_ARC1214_POSTQUEUE *\n\t\t\tsizeof(struct InBound_SRB)), rwbuffer++);\n\t\twritel(0x100, rwbuffer);\n\t\twritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, reg->inbound_msgaddr0);\n\t\tif (!arcmsr_hbaD_wait_msgint_ready(acb)) {\n\t\t\tpr_notice(\"arcmsr%d: 'set command Q window' timeout\\n\",\n\t\t\t\tacb->host->host_no);\n\t\t\treturn 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "linevul": 5.389727448346093e-05,
        "sysevr": 0.19816072285175323,
        "devign": 0.01218643318861723
    },
    {
        "code": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/43a6684519ab0a6c52024b5e25322476cabad893",
        "vul_func_with_fix": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}\n",
        "linevul": 6.925471825525165e-05,
        "sysevr": 0.18435122072696686,
        "devign": 5.109899896065754e-15
    },
    {
        "code": "static struct sk_buff *validate_xmit_skb(struct sk_buff *skb, struct net_device *dev)\n{\n\tnetdev_features_t features;\n\n\tfeatures = netif_skb_features(skb);\n\tskb = validate_xmit_vlan(skb, features);\n\tif (unlikely(!skb))\n\t\tgoto out_null;\n\n\tif (netif_needs_gso(skb, features)) {\n\t\tstruct sk_buff *segs;\n\n\t\tsegs = skb_gso_segment(skb, features);\n\t\tif (IS_ERR(segs)) {\n\t\t\tgoto out_kfree_skb;\n\t\t} else if (segs) {\n\t\t\tconsume_skb(skb);\n\t\t\tskb = segs;\n\t\t}\n\t} else {\n\t\tif (skb_needs_linearize(skb, features) &&\n\t\t    __skb_linearize(skb))\n\t\t\tgoto out_kfree_skb;\n\n\t\tif (validate_xmit_xfrm(skb, features))\n\t\t\tgoto out_kfree_skb;\n\n\t\t/* If packet is not checksummed and device does not\n\t\t * support checksumming for this protocol, complete\n\t\t * checksumming here.\n\t\t */\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tif (skb->encapsulation)\n\t\t\t\tskb_set_inner_transport_header(skb,\n\t\t\t\t\t\t\t       skb_checksum_start_offset(skb));\n\t\t\telse\n\t\t\t\tskb_set_transport_header(skb,\n\t\t\t\t\t\t\t skb_checksum_start_offset(skb));\n\t\t\tif (skb_csum_hwoffload_help(skb, features))\n\t\t\t\tgoto out_kfree_skb;\n\t\t}\n\t}\n\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\nout_null:\n\tatomic_long_inc(&dev->tx_dropped);\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d",
        "vul_func_with_fix": "static struct sk_buff *validate_xmit_skb(struct sk_buff *skb, struct net_device *dev)\n{\n\tnetdev_features_t features;\n\n\tfeatures = netif_skb_features(skb);\n\tskb = validate_xmit_vlan(skb, features);\n\tif (unlikely(!skb))\n\t\tgoto out_null;\n\n\tif (netif_needs_gso(skb, features)) {\n\t\tstruct sk_buff *segs;\n\n\t\tsegs = skb_gso_segment(skb, features);\n\t\tif (IS_ERR(segs)) {\n\t\t\tgoto out_kfree_skb;\n\t\t} else if (segs) {\n\t\t\tconsume_skb(skb);\n\t\t\tskb = segs;\n\t\t}\n\t} else {\n\t\tif (skb_needs_linearize(skb, features) &&\n\t\t    __skb_linearize(skb))\n\t\t\tgoto out_kfree_skb;\n\n\t\tif (validate_xmit_xfrm(skb, features))\n\t\t\tgoto out_kfree_skb;\n\n\t\t/* If packet is not checksummed and device does not\n\t\t * support checksumming for this protocol, complete\n\t\t * checksumming here.\n\t\t */\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tif (skb->encapsulation)\n\t\t\t\tskb_set_inner_transport_header(skb,\n\t\t\t\t\t\t\t       skb_checksum_start_offset(skb));\n\t\t\telse\n\t\t\t\tskb_set_transport_header(skb,\n\t\t\t\t\t\t\t skb_checksum_start_offset(skb));\n\t\t\tif (skb_csum_hwoffload_help(skb, features))\n\t\t\t\tgoto out_kfree_skb;\n\t\t}\n\t}\n\n\treturn skb;\n\nout_kfree_skb:\n\tkfree_skb(skb);\nout_null:\n\tatomic_long_inc(&dev->tx_dropped);\n\treturn NULL;\n}\n",
        "linevul": 5.776523539680056e-05,
        "sysevr": 0.12922661006450653,
        "devign": 3.4021730745126266e-12
    },
    {
        "code": "static int _proc_do_string(void* data, int maxlen, int write,\n\t\t\t   void __user *buffer,\n\t\t\t   size_t *lenp, loff_t *ppos)\n{\n\tsize_t len;\n\tchar __user *p;\n\tchar c;\n\n\tif (!data || !maxlen || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tlen = 0;\n\t\tp = buffer;\n\t\twhile (len < *lenp) {\n\t\t\tif (get_user(c, p++))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tlen++;\n\t\t}\n\t\tif (len >= maxlen)\n\t\t\tlen = maxlen-1;\n\t\tif(copy_from_user(data, buffer, len))\n\t\t\treturn -EFAULT;\n\t\t((char *) data)[len] = 0;\n\t\t*ppos += *lenp;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (*ppos > len) {\n\t\t\t*lenp = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata += *ppos;\n\t\tlen  -= *ppos;\n\n\t\tif (len > *lenp)\n\t\t\tlen = *lenp;\n\t\tif (len)\n\t\t\tif(copy_to_user(buffer, data, len))\n\t\t\t\treturn -EFAULT;\n\t\tif (len < *lenp) {\n\t\t\tif(put_user('\\n', ((char __user *) buffer) + len))\n\t\t\t\treturn -EFAULT;\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfdc0b497faa82a0ba2f9dddcf109231dd519fcc",
        "vul_func_with_fix": "static int _proc_do_string(void* data, int maxlen, int write,\n\t\t\t   void __user *buffer,\n\t\t\t   size_t *lenp, loff_t *ppos)\n{\n\tsize_t len;\n\tchar __user *p;\n\tchar c;\n\n\tif (!data || !maxlen || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tlen = 0;\n\t\tp = buffer;\n\t\twhile (len < *lenp) {\n\t\t\tif (get_user(c, p++))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tlen++;\n\t\t}\n\t\tif (len >= maxlen)\n\t\t\tlen = maxlen-1;\n\t\tif(copy_from_user(data, buffer, len))\n\t\t\treturn -EFAULT;\n\t\t((char *) data)[len] = 0;\n\t\t*ppos += *lenp;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len > maxlen)\n\t\t\tlen = maxlen;\n\n\t\tif (*ppos > len) {\n\t\t\t*lenp = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdata += *ppos;\n\t\tlen  -= *ppos;\n\n\t\tif (len > *lenp)\n\t\t\tlen = *lenp;\n\t\tif (len)\n\t\t\tif(copy_to_user(buffer, data, len))\n\t\t\t\treturn -EFAULT;\n\t\tif (len < *lenp) {\n\t\t\tif(put_user('\\n', ((char __user *) buffer) + len))\n\t\t\t\treturn -EFAULT;\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n",
        "linevul": 0.001157455495558679,
        "sysevr": 0.13993774354457855,
        "devign": 0.5638466477394104
    },
    {
        "code": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n \t\treturn -EFAULT;\n \n \t/* Not even root can pretend to send signals from the kernel.\n\t   Nor can they impersonate a kill(), which adds source info.  */\n\tif (info.si_code >= 0)\n \t\treturn -EPERM;\n \tinfo.si_signo = sig;\n \n \t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/da48524eb20662618854bb3df2db01fc65f3070c",
        "vul_func_with_fix": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n \t\treturn -EFAULT;\n \n \t/* Not even root can pretend to send signals from the kernel.\n//flaw_line_below:\n\t   Nor can they impersonate a kill(), which adds source info.  */\n//flaw_line_below:\n\tif (info.si_code >= 0)\n//fix_flaw_line_below:\n//\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n//fix_flaw_line_below:\n//\t */\n//fix_flaw_line_below:\n//\tif (info.si_code != SI_QUEUE) {\n//fix_flaw_line_below:\n//\t\t/* We used to allow any < 0 si_code */\n//fix_flaw_line_below:\n//\t\tWARN_ON_ONCE(info.si_code < 0);\n \t\treturn -EPERM;\n//fix_flaw_line_below:\n//\t}\n \tinfo.si_signo = sig;\n \n \t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, &info, pid);\n}\n",
        "linevul": 0.9996141195297241,
        "sysevr": 0.18741783499717712,
        "devign": 0.6025647521018982
    },
    {
        "code": "static int __must_check __sta_info_destroy_part1(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tlocal = sta->local;\n\tsdata = sta->sdata;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/*\n\t * Before removing the station from the driver and\n\t * rate control, it might still start new aggregation\n\t * sessions -- block that to make sure the tear-down\n\t * will be sufficient.\n\t */\n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\tieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\n\n\tret = sta_info_hash_del(local, sta);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\tlist_del_rcu(&sta->list);\n\n\tdrv_sta_pre_rcu_remove(local, sta->sdata, sta);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    rcu_access_pointer(sdata->u.vlan.sta) == sta)\n\t\tRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba",
        "vul_func_with_fix": "static int __must_check __sta_info_destroy_part1(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tlocal = sta->local;\n\tsdata = sta->sdata;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/*\n\t * Before removing the station from the driver and\n\t * rate control, it might still start new aggregation\n\t * sessions -- block that to make sure the tear-down\n\t * will be sufficient.\n\t */\n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\tieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\n\n\tret = sta_info_hash_del(local, sta);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\tlist_del_rcu(&sta->list);\n\n\tdrv_sta_pre_rcu_remove(local, sta->sdata, sta);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    rcu_access_pointer(sdata->u.vlan.sta) == sta)\n\t\tRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\n\n\treturn 0;\n}\n",
        "linevul": 6.826215394539759e-05,
        "sysevr": 0.1470964401960373,
        "devign": 0.6484596729278564
    },
    {
        "code": "int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,\n\t\t\text4_lblk_t iblock,\n\t\t\tunsigned int max_blocks, struct buffer_head *bh_result,\n\t\t\tint flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent newex, *ex, *last_ex;\n\text4_fsblk_t newblock;\n\tint err = 0, depth, ret, cache_type;\n\tunsigned int allocated = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;\n\n\t__clear_bit(BH_New, &bh_result->b_state);\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t\tiblock, max_blocks, inode->i_ino);\n\n\t/* check in cache */\n\tcache_type = ext4_ext_in_cache(inode, iblock, &newex);\n\tif (cache_type) {\n\t\tif (cache_type == EXT4_EXT_CACHE_GAP) {\n\t\t\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * block isn't allocated yet and\n\t\t\t\t * user doesn't want to allocate it\n\t\t\t\t */\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t\t/* we should allocate requested block */\n\t\t} else if (cache_type == EXT4_EXT_CACHE_EXTENT) {\n\t\t\t/* block is already allocated */\n\t\t\tnewblock = iblock\n\t\t\t\t   - le32_to_cpu(newex.ee_block)\n\t\t\t\t   + ext_pblock(&newex);\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ext4_ext_get_actual_len(&newex) -\n\t\t\t\t\t(iblock - le32_to_cpu(newex.ee_block));\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/* find extent for this block */\n\tpath = ext4_ext_find_extent(inode, iblock, NULL);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_ext_find_extent()\n\t */\n\tif (path[depth].p_ext == NULL && depth != 0) {\n\t\text4_error(inode->i_sb, \"bad extent address \"\n\t\t\t   \"inode: %lu, iblock: %d, depth: %d\",\n\t\t\t   inode->i_ino, iblock, depth);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\teh = path[depth].p_hdr;\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\t\t/*\n\t\t * Uninitialized extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\t\t/* if found extent covers block, simply return it */\n\t\tif (iblock >= ee_block && iblock < ee_block + ee_len) {\n\t\t\tnewblock = iblock - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (iblock - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", iblock,\n\t\t\t\t\tee_block, ee_len, newblock);\n\n\t\t\t/* Do not put uninitialized extent in the cache */\n\t\t\tif (!ext4_ext_is_uninitialized(ex)) {\n\t\t\t\text4_ext_put_in_cache(inode, ee_block,\n\t\t\t\t\t\t\tee_len, ee_start,\n\t\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_ext_handle_uninitialized_extents(handle,\n\t\t\t\t\tinode, iblock, max_blocks, path,\n\t\t\t\t\tflags, allocated, bh_result, newblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, iblock);\n\t\tgoto out2;\n\t}\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = iblock;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = iblock;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright);\n\tif (err)\n\t\tgoto out2;\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an uninitialized extent this limit is\n\t * EXT_UNINIT_MAX_LEN.\n\t */\n\tif (max_blocks > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_INIT_MAX_LEN;\n\telse if (max_blocks > EXT_UNINIT_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_UNINIT_MAX_LEN;\n\n\t/* Check if we can really insert (iblock)::(iblock+max_blocks) extent */\n\tnewex.ee_block = cpu_to_le32(iblock);\n\tnewex.ee_len = cpu_to_le16(max_blocks);\n\terr = ext4_ext_check_overlap(inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = max_blocks;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, iblock);\n\tar.logical = iblock;\n\tar.len = allocated;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark uninitialized */\n \tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT){\n \t\text4_ext_mark_uninitialized(&newex);\n \t\t/*\n\t\t * io_end structure was created for every async\n\t\t * direct IO write to the middle of the file.\n\t\t * To avoid unecessary convertion for every aio dio rewrite\n\t\t * to the mid of file, here we flag the IO that is really\n\t\t * need the convertion.\n \t\t * For non asycn direct IO case, flag the inode state\n \t\t * that we need to perform convertion when IO is done.\n \t\t */\n\t\tif (flags == EXT4_GET_BLOCKS_PRE_IO) {\n \t\t\tif (io)\n \t\t\t\tio->flag = EXT4_IO_UNWRITTEN;\n \t\t\telse\n \t\t\t\text4_set_inode_state(inode,\n \t\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n \t\t}\n \t}\n \n \tif (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {\n\t\tif (eh->eh_entries) {\n\t\t\tlast_ex = EXT_LAST_EXTENT(eh);\n\t\t\tif (iblock + ar.len > le32_to_cpu(last_ex->ee_block)\n\t\t\t\t\t    + ext4_ext_get_actual_len(last_ex))\n\t\t\t\tEXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;\n\t\t} else {\n\t\t\tWARN_ON(eh->eh_entries == 0);\n\t\t\text4_error(inode->i_sb, __func__,\n\t\t\t\t\"inode#%lu, eh->eh_entries = 0!\", inode->i_ino);\n\t\t\t}\n\t}\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err) {\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, 0, ext_pblock(&newex),\n\t\t\t\t ext4_ext_get_actual_len(&newex), 0);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\tset_buffer_new(bh_result);\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\text4_da_update_reserve_space(inode, allocated, 1);\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an uninitialized extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {\n\t\text4_ext_put_in_cache(inode, iblock, allocated, newblock,\n\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t} else\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\text4_ext_show_leaf(inode, path);\n\tset_buffer_mapped(bh_result);\n\tbh_result->b_bdev = inode->i_sb->s_bdev;\n\tbh_result->b_blocknr = newblock;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
        "vul_func_with_fix": "int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,\n\t\t\text4_lblk_t iblock,\n\t\t\tunsigned int max_blocks, struct buffer_head *bh_result,\n\t\t\tint flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent newex, *ex, *last_ex;\n\text4_fsblk_t newblock;\n\tint err = 0, depth, ret, cache_type;\n\tunsigned int allocated = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;\n\n\t__clear_bit(BH_New, &bh_result->b_state);\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t\tiblock, max_blocks, inode->i_ino);\n\n\t/* check in cache */\n\tcache_type = ext4_ext_in_cache(inode, iblock, &newex);\n\tif (cache_type) {\n\t\tif (cache_type == EXT4_EXT_CACHE_GAP) {\n\t\t\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t\t\t/*\n\t\t\t\t * block isn't allocated yet and\n\t\t\t\t * user doesn't want to allocate it\n\t\t\t\t */\n\t\t\t\tgoto out2;\n\t\t\t}\n\t\t\t/* we should allocate requested block */\n\t\t} else if (cache_type == EXT4_EXT_CACHE_EXTENT) {\n\t\t\t/* block is already allocated */\n\t\t\tnewblock = iblock\n\t\t\t\t   - le32_to_cpu(newex.ee_block)\n\t\t\t\t   + ext_pblock(&newex);\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ext4_ext_get_actual_len(&newex) -\n\t\t\t\t\t(iblock - le32_to_cpu(newex.ee_block));\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/* find extent for this block */\n\tpath = ext4_ext_find_extent(inode, iblock, NULL);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_ext_find_extent()\n\t */\n\tif (path[depth].p_ext == NULL && depth != 0) {\n\t\text4_error(inode->i_sb, \"bad extent address \"\n\t\t\t   \"inode: %lu, iblock: %d, depth: %d\",\n\t\t\t   inode->i_ino, iblock, depth);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\teh = path[depth].p_hdr;\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\t\t/*\n\t\t * Uninitialized extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\t\t/* if found extent covers block, simply return it */\n\t\tif (iblock >= ee_block && iblock < ee_block + ee_len) {\n\t\t\tnewblock = iblock - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (iblock - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", iblock,\n\t\t\t\t\tee_block, ee_len, newblock);\n\n\t\t\t/* Do not put uninitialized extent in the cache */\n\t\t\tif (!ext4_ext_is_uninitialized(ex)) {\n\t\t\t\text4_ext_put_in_cache(inode, ee_block,\n\t\t\t\t\t\t\tee_len, ee_start,\n\t\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_ext_handle_uninitialized_extents(handle,\n\t\t\t\t\tinode, iblock, max_blocks, path,\n\t\t\t\t\tflags, allocated, bh_result, newblock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, iblock);\n\t\tgoto out2;\n\t}\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = iblock;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = iblock;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright);\n\tif (err)\n\t\tgoto out2;\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an uninitialized extent this limit is\n\t * EXT_UNINIT_MAX_LEN.\n\t */\n\tif (max_blocks > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_INIT_MAX_LEN;\n\telse if (max_blocks > EXT_UNINIT_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNINIT_EXT))\n\t\tmax_blocks = EXT_UNINIT_MAX_LEN;\n\n\t/* Check if we can really insert (iblock)::(iblock+max_blocks) extent */\n\tnewex.ee_block = cpu_to_le32(iblock);\n\tnewex.ee_len = cpu_to_le16(max_blocks);\n\terr = ext4_ext_check_overlap(inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = max_blocks;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, iblock);\n\tar.logical = iblock;\n\tar.len = allocated;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark uninitialized */\n \tif (flags & EXT4_GET_BLOCKS_UNINIT_EXT){\n \t\text4_ext_mark_uninitialized(&newex);\n \t\t/*\n//flaw_line_below:\n\t\t * io_end structure was created for every async\n//flaw_line_below:\n\t\t * direct IO write to the middle of the file.\n//flaw_line_below:\n\t\t * To avoid unecessary convertion for every aio dio rewrite\n//flaw_line_below:\n\t\t * to the mid of file, here we flag the IO that is really\n//flaw_line_below:\n\t\t * need the convertion.\n//fix_flaw_line_below:\n//\t\t * io_end structure was created for every IO write to an\n//fix_flaw_line_below:\n//\t\t * uninitialized extent. To avoid unecessary conversion,\n//fix_flaw_line_below:\n//\t\t * here we flag the IO that really needs the conversion.\n \t\t * For non asycn direct IO case, flag the inode state\n \t\t * that we need to perform convertion when IO is done.\n \t\t */\n//flaw_line_below:\n\t\tif (flags == EXT4_GET_BLOCKS_PRE_IO) {\n//fix_flaw_line_below:\n//\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO)) {\n \t\t\tif (io)\n \t\t\t\tio->flag = EXT4_IO_UNWRITTEN;\n \t\t\telse\n \t\t\t\text4_set_inode_state(inode,\n \t\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n \t\t}\n//fix_flaw_line_below:\n//\t\tif (ext4_should_dioread_nolock(inode))\n//fix_flaw_line_below:\n//\t\t\tset_buffer_uninit(bh_result);\n \t}\n \n \tif (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {\n\t\tif (eh->eh_entries) {\n\t\t\tlast_ex = EXT_LAST_EXTENT(eh);\n\t\t\tif (iblock + ar.len > le32_to_cpu(last_ex->ee_block)\n\t\t\t\t\t    + ext4_ext_get_actual_len(last_ex))\n\t\t\t\tEXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;\n\t\t} else {\n\t\t\tWARN_ON(eh->eh_entries == 0);\n\t\t\text4_error(inode->i_sb, __func__,\n\t\t\t\t\"inode#%lu, eh->eh_entries = 0!\", inode->i_ino);\n\t\t\t}\n\t}\n\terr = ext4_ext_insert_extent(handle, inode, path, &newex, flags);\n\tif (err) {\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, 0, ext_pblock(&newex),\n\t\t\t\t ext4_ext_get_actual_len(&newex), 0);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\tset_buffer_new(bh_result);\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\text4_da_update_reserve_space(inode, allocated, 1);\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an uninitialized extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {\n\t\text4_ext_put_in_cache(inode, iblock, allocated, newblock,\n\t\t\t\t\t\tEXT4_EXT_CACHE_EXTENT);\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\t} else\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > max_blocks)\n\t\tallocated = max_blocks;\n\text4_ext_show_leaf(inode, path);\n\tset_buffer_mapped(bh_result);\n\tbh_result->b_bdev = inode->i_sb->s_bdev;\n\tbh_result->b_blocknr = newblock;\nout2:\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\treturn err ? err : allocated;\n}\n",
        "linevul": 0.014242556877434254,
        "sysevr": 0.2877238988876343,
        "devign": 1.1983834263582222e-29
    },
    {
        "code": "ar6000_rx(void *Context, struct htc_packet *pPacket)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)Context;\n    struct sk_buff *skb = (struct sk_buff *)pPacket->pPktContext;\n    int minHdrLen;\n    u8 containsDot11Hdr = 0;\n    int        status = pPacket->Status;\n    HTC_ENDPOINT_ID   ept = pPacket->Endpoint;\n\n    A_ASSERT((status) ||\n             (pPacket->pBuffer == (A_NETBUF_DATA(skb) + HTC_HEADER_LEN)));\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_rx ar=0x%lx eid=%d, skb=0x%lx, data=0x%lx, len=0x%x status:%d\",\n                    (unsigned long)ar, ept, (unsigned long)skb, (unsigned long)pPacket->pBuffer,\n                    pPacket->ActualLength, status));\n    if (status) {\n        if (status != A_ECANCELED) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"RX ERR (%d) \\n\",status));\n        }\n    }\n\n        /* take lock to protect buffer counts\n         * and adaptive power throughput state */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (!status) {\n        AR6000_STAT_INC(ar, rx_packets);\n        ar->arNetStats.rx_bytes += pPacket->ActualLength;\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n        aptcTR.bytesReceived += a_netbuf_to_len(skb);\n        applyAPTCHeuristics(ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n        A_NETBUF_PUT(skb, pPacket->ActualLength +  HTC_HEADER_LEN);\n        A_NETBUF_PULL(skb, HTC_HEADER_LEN);\n\n#ifdef DEBUG\n        if (debugdriver >= 2) {\n            ar6000_dump_skb(skb);\n        }\n#endif /* DEBUG */\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    skb->dev = ar->arNetDev;\n    if (status) {\n        AR6000_STAT_INC(ar, rx_errors);\n        A_NETBUF_FREE(skb);\n    } else if (ar->arWmiEnabled == true) {\n        if (ept == ar->arControlEp) {\n           /*\n            * this is a wmi control msg\n            */\n#ifdef CONFIG_PM \n            ar6000_check_wow_status(ar, skb, true);\n#endif /* CONFIG_PM */\n            wmi_control_rx(ar->arWmi, skb);\n        } else {\n                WMI_DATA_HDR *dhdr = (WMI_DATA_HDR *)A_NETBUF_DATA(skb);\n                bool is_amsdu;\n                u8 tid;\n\n\t\t/*\n\t\t * This check can be removed if after a while we do not\n\t\t * see the warning. For now we leave it to ensure\n\t\t * we drop these frames accordingly in case the\n\t\t * target generates them for some reason. These\n\t\t * were used for an internal PAL but that's not\n\t\t * used or supported anymore. These frames should\n\t\t * not come up from the target.\n\t\t */\n                if (WARN_ON(WMI_DATA_HDR_GET_DATA_TYPE(dhdr) ==\n\t\t\t    WMI_DATA_HDR_DATA_TYPE_ACL)) {\n\t\t\tAR6000_STAT_INC(ar, rx_errors);\n\t\t\tA_NETBUF_FREE(skb);\n\t\t\treturn;\n\t\t}\n\n#ifdef CONFIG_PM \n                ar6000_check_wow_status(ar, NULL, false);\n#endif /* CONFIG_PM */\n                /*\n                 * this is a wmi data packet\n                 */\n\n                if (processDot11Hdr) {\n                    minHdrLen = sizeof(WMI_DATA_HDR) + sizeof(struct ieee80211_frame) + sizeof(ATH_LLC_SNAP_HDR);\n                } else {\n                    minHdrLen = sizeof (WMI_DATA_HDR) + sizeof(ATH_MAC_HDR) +\n                          sizeof(ATH_LLC_SNAP_HDR);\n                }\n\n                /* In the case of AP mode we may receive NULL data frames\n                 * that do not have LLC hdr. They are 16 bytes in size.\n                 * Allow these frames in the AP mode.\n                 * ACL data frames don't follow ethernet frame bounds for\n                 * min length\n                 */\n                if (ar->arNetworkType != AP_NETWORK &&\n                    ((pPacket->ActualLength < minHdrLen) ||\n                    (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)))\n                {\n                    /*\n                     * packet is too short or too long\n                     */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"TOO SHORT or TOO LONG\\n\"));\n                    AR6000_STAT_INC(ar, rx_errors);\n                    AR6000_STAT_INC(ar, rx_length_errors);\n                    A_NETBUF_FREE(skb);\n                } else {\n                    u16 seq_no;\n                    u8 meta_type;\n\n#if 0\n                    /* Access RSSI values here */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"RSSI %d\\n\",\n                        ((WMI_DATA_HDR *) A_NETBUF_DATA(skb))->rssi));\n#endif\n                    /* Get the Power save state of the STA */\n                    if (ar->arNetworkType == AP_NETWORK) {\n                        sta_t *conn = NULL;\n                        u8 psState=0,prevPsState;\n                        ATH_MAC_HDR *datap=NULL;\n                        u16 offset;\n\n                        meta_type = WMI_DATA_HDR_GET_META(dhdr);\n\n                        psState = (((WMI_DATA_HDR *)A_NETBUF_DATA(skb))->info\n                                     >> WMI_DATA_HDR_PS_SHIFT) & WMI_DATA_HDR_PS_MASK;\n\n                        offset = sizeof(WMI_DATA_HDR);\n\n                        switch (meta_type) {\n                            case 0:\n                                break;\n                            case WMI_META_VERSION_1:\n                                offset += sizeof(WMI_RX_META_V1);\n                                break;\n                            case WMI_META_VERSION_2:\n                                offset += sizeof(WMI_RX_META_V2);\n                                break;\n                            default:\n                                break;\n                        }\n\n                        datap = (ATH_MAC_HDR *)(A_NETBUF_DATA(skb)+offset);\n                        conn = ieee80211_find_conn(ar, datap->srcMac);\n\n                        if (conn) {\n                            /* if there is a change in PS state of the STA,\n                             * take appropriate steps.\n                             * 1. If Sleep-->Awake, flush the psq for the STA\n                             *    Clear the PVB for the STA.\n                             * 2. If Awake-->Sleep, Starting queueing frames\n                             * the STA.\n                             */\n                            prevPsState = STA_IS_PWR_SLEEP(conn);\n                            if (psState) {\n                                STA_SET_PWR_SLEEP(conn);\n                            } else {\n                                STA_CLR_PWR_SLEEP(conn);\n                            }\n\n                            if (prevPsState ^ STA_IS_PWR_SLEEP(conn)) {\n\n                                if (!STA_IS_PWR_SLEEP(conn)) {\n\n                                    A_MUTEX_LOCK(&conn->psqLock);\n                                    while (!A_NETBUF_QUEUE_EMPTY(&conn->psq)) {\n                                        struct sk_buff *skb=NULL;\n\n                                        skb = A_NETBUF_DEQUEUE(&conn->psq);\n                                        A_MUTEX_UNLOCK(&conn->psqLock);\n                                        ar6000_data_tx(skb,ar->arNetDev);\n                                        A_MUTEX_LOCK(&conn->psqLock);\n                                    }\n                                    A_MUTEX_UNLOCK(&conn->psqLock);\n                                    /* Clear the PVB for this STA */\n                                    wmi_set_pvb_cmd(ar->arWmi, conn->aid, 0);\n                                }\n                            }\n                        } else {\n                            /* This frame is from a STA that is not associated*/\n                            A_ASSERT(false);\n                        }\n\n                        /* Drop NULL data frames here */\n                        if((pPacket->ActualLength < minHdrLen) ||\n                                (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)) {\n                            A_NETBUF_FREE(skb);\n                            goto rx_done;\n                        }\n                    }\n\n                    is_amsdu = WMI_DATA_HDR_IS_AMSDU(dhdr) ? true : false;\n                    tid = WMI_DATA_HDR_GET_UP(dhdr);\n                    seq_no = WMI_DATA_HDR_GET_SEQNO(dhdr);\n                    meta_type = WMI_DATA_HDR_GET_META(dhdr);\n                    containsDot11Hdr = WMI_DATA_HDR_GET_DOT11(dhdr);\n\n                    wmi_data_hdr_remove(ar->arWmi, skb);\n\n                    switch (meta_type) {\n                        case WMI_META_VERSION_1:\n                            {\n                                WMI_RX_META_V1 *pMeta = (WMI_RX_META_V1 *)A_NETBUF_DATA(skb);\n                                A_PRINTF(\"META %d %d %d %d %x\\n\", pMeta->status, pMeta->rix, pMeta->rssi, pMeta->channel, pMeta->flags);\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V1));\n                                break;\n                            }\n                        case WMI_META_VERSION_2:\n                            {\n                                WMI_RX_META_V2 *pMeta = (WMI_RX_META_V2 *)A_NETBUF_DATA(skb);\n                                if(pMeta->csumFlags & 0x1){\n                                    skb->ip_summed=CHECKSUM_COMPLETE;\n                                    skb->csum=(pMeta->csum);\n                                }\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V2));\n                                break;\n                            }\n                        default:\n                            break;\n                    }\n\n                    A_ASSERT(status == 0);\n\n                    /* NWF: print the 802.11 hdr bytes */\n                    if(containsDot11Hdr) {\n                        status = wmi_dot11_hdr_remove(ar->arWmi,skb);\n                    } else if(!is_amsdu) {\n                        status = wmi_dot3_2_dix(skb);\n                    }\n\n                    if (status) {\n                        /* Drop frames that could not be processed (lack of memory, etc.) */\n                        A_NETBUF_FREE(skb);\n                        goto rx_done;\n                    }\n\n                    if ((ar->arNetDev->flags & IFF_UP) == IFF_UP) {\n                        if (ar->arNetworkType == AP_NETWORK) {\n                            struct sk_buff *skb1 = NULL;\n                            ATH_MAC_HDR *datap;\n\n                            datap = (ATH_MAC_HDR *)A_NETBUF_DATA(skb);\n                            if (IEEE80211_IS_MULTICAST(datap->dstMac)) {\n                                /* Bcast/Mcast frames should be sent to the OS\n                                 * stack as well as on the air.\n                                 */\n                                skb1 = skb_copy(skb,GFP_ATOMIC);\n                            } else {\n                                /* Search for a connected STA with dstMac as\n                                 * the Mac address. If found send the frame to\n                                 * it on the air else send the frame up the\n                                 * stack\n                                 */\n                                sta_t *conn = NULL;\n                                conn = ieee80211_find_conn(ar, datap->dstMac);\n\n                                if (conn && ar->intra_bss) {\n                                    skb1 = skb;\n                                    skb = NULL;\n                                } else if(conn && !ar->intra_bss) {\n                                    A_NETBUF_FREE(skb);\n                                    skb = NULL;\n                                }\n                            }\n                            if (skb1) {\n                                ar6000_data_tx(skb1, ar->arNetDev);\n                            }\n                        }\n                    }\n                    aggr_process_recv_frm(ar->aggr_cntxt, tid, seq_no, is_amsdu, (void **)&skb);\n                    ar6000_deliver_frames_to_nw_stack((void *) ar->arNetDev, (void *)skb);\n                }\n            }\n    } else {\n        if (EPPING_ALIGNMENT_PAD > 0) {\n            A_NETBUF_PULL(skb, EPPING_ALIGNMENT_PAD);\n        }\n        ar6000_deliver_frames_to_nw_stack((void *)ar->arNetDev, (void *)skb);\n    }\n\nrx_done:\n\n    return;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "ar6000_rx(void *Context, struct htc_packet *pPacket)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)Context;\n    struct sk_buff *skb = (struct sk_buff *)pPacket->pPktContext;\n    int minHdrLen;\n    u8 containsDot11Hdr = 0;\n    int        status = pPacket->Status;\n    HTC_ENDPOINT_ID   ept = pPacket->Endpoint;\n\n    A_ASSERT((status) ||\n             (pPacket->pBuffer == (A_NETBUF_DATA(skb) + HTC_HEADER_LEN)));\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_rx ar=0x%lx eid=%d, skb=0x%lx, data=0x%lx, len=0x%x status:%d\",\n                    (unsigned long)ar, ept, (unsigned long)skb, (unsigned long)pPacket->pBuffer,\n                    pPacket->ActualLength, status));\n    if (status) {\n        if (status != A_ECANCELED) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"RX ERR (%d) \\n\",status));\n        }\n    }\n\n        /* take lock to protect buffer counts\n         * and adaptive power throughput state */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (!status) {\n        AR6000_STAT_INC(ar, rx_packets);\n        ar->arNetStats.rx_bytes += pPacket->ActualLength;\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n        aptcTR.bytesReceived += a_netbuf_to_len(skb);\n        applyAPTCHeuristics(ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n        A_NETBUF_PUT(skb, pPacket->ActualLength +  HTC_HEADER_LEN);\n        A_NETBUF_PULL(skb, HTC_HEADER_LEN);\n\n#ifdef DEBUG\n        if (debugdriver >= 2) {\n            ar6000_dump_skb(skb);\n        }\n#endif /* DEBUG */\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    skb->dev = ar->arNetDev;\n    if (status) {\n        AR6000_STAT_INC(ar, rx_errors);\n        A_NETBUF_FREE(skb);\n    } else if (ar->arWmiEnabled == true) {\n        if (ept == ar->arControlEp) {\n           /*\n            * this is a wmi control msg\n            */\n#ifdef CONFIG_PM \n            ar6000_check_wow_status(ar, skb, true);\n#endif /* CONFIG_PM */\n            wmi_control_rx(ar->arWmi, skb);\n        } else {\n                WMI_DATA_HDR *dhdr = (WMI_DATA_HDR *)A_NETBUF_DATA(skb);\n                bool is_amsdu;\n                u8 tid;\n\n\t\t/*\n\t\t * This check can be removed if after a while we do not\n\t\t * see the warning. For now we leave it to ensure\n\t\t * we drop these frames accordingly in case the\n\t\t * target generates them for some reason. These\n\t\t * were used for an internal PAL but that's not\n\t\t * used or supported anymore. These frames should\n\t\t * not come up from the target.\n\t\t */\n                if (WARN_ON(WMI_DATA_HDR_GET_DATA_TYPE(dhdr) ==\n\t\t\t    WMI_DATA_HDR_DATA_TYPE_ACL)) {\n\t\t\tAR6000_STAT_INC(ar, rx_errors);\n\t\t\tA_NETBUF_FREE(skb);\n\t\t\treturn;\n\t\t}\n\n#ifdef CONFIG_PM \n                ar6000_check_wow_status(ar, NULL, false);\n#endif /* CONFIG_PM */\n                /*\n                 * this is a wmi data packet\n                 */\n                 // NWF\n\n                if (processDot11Hdr) {\n                    minHdrLen = sizeof(WMI_DATA_HDR) + sizeof(struct ieee80211_frame) + sizeof(ATH_LLC_SNAP_HDR);\n                } else {\n                    minHdrLen = sizeof (WMI_DATA_HDR) + sizeof(ATH_MAC_HDR) +\n                          sizeof(ATH_LLC_SNAP_HDR);\n                }\n\n                /* In the case of AP mode we may receive NULL data frames\n                 * that do not have LLC hdr. They are 16 bytes in size.\n                 * Allow these frames in the AP mode.\n                 * ACL data frames don't follow ethernet frame bounds for\n                 * min length\n                 */\n                if (ar->arNetworkType != AP_NETWORK &&\n                    ((pPacket->ActualLength < minHdrLen) ||\n                    (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)))\n                {\n                    /*\n                     * packet is too short or too long\n                     */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"TOO SHORT or TOO LONG\\n\"));\n                    AR6000_STAT_INC(ar, rx_errors);\n                    AR6000_STAT_INC(ar, rx_length_errors);\n                    A_NETBUF_FREE(skb);\n                } else {\n                    u16 seq_no;\n                    u8 meta_type;\n\n#if 0\n                    /* Access RSSI values here */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"RSSI %d\\n\",\n                        ((WMI_DATA_HDR *) A_NETBUF_DATA(skb))->rssi));\n#endif\n                    /* Get the Power save state of the STA */\n                    if (ar->arNetworkType == AP_NETWORK) {\n                        sta_t *conn = NULL;\n                        u8 psState=0,prevPsState;\n                        ATH_MAC_HDR *datap=NULL;\n                        u16 offset;\n\n                        meta_type = WMI_DATA_HDR_GET_META(dhdr);\n\n                        psState = (((WMI_DATA_HDR *)A_NETBUF_DATA(skb))->info\n                                     >> WMI_DATA_HDR_PS_SHIFT) & WMI_DATA_HDR_PS_MASK;\n\n                        offset = sizeof(WMI_DATA_HDR);\n\n                        switch (meta_type) {\n                            case 0:\n                                break;\n                            case WMI_META_VERSION_1:\n                                offset += sizeof(WMI_RX_META_V1);\n                                break;\n                            case WMI_META_VERSION_2:\n                                offset += sizeof(WMI_RX_META_V2);\n                                break;\n                            default:\n                                break;\n                        }\n\n                        datap = (ATH_MAC_HDR *)(A_NETBUF_DATA(skb)+offset);\n                        conn = ieee80211_find_conn(ar, datap->srcMac);\n\n                        if (conn) {\n                            /* if there is a change in PS state of the STA,\n                             * take appropriate steps.\n                             * 1. If Sleep-->Awake, flush the psq for the STA\n                             *    Clear the PVB for the STA.\n                             * 2. If Awake-->Sleep, Starting queueing frames\n                             * the STA.\n                             */\n                            prevPsState = STA_IS_PWR_SLEEP(conn);\n                            if (psState) {\n                                STA_SET_PWR_SLEEP(conn);\n                            } else {\n                                STA_CLR_PWR_SLEEP(conn);\n                            }\n\n                            if (prevPsState ^ STA_IS_PWR_SLEEP(conn)) {\n\n                                if (!STA_IS_PWR_SLEEP(conn)) {\n\n                                    A_MUTEX_LOCK(&conn->psqLock);\n                                    while (!A_NETBUF_QUEUE_EMPTY(&conn->psq)) {\n                                        struct sk_buff *skb=NULL;\n\n                                        skb = A_NETBUF_DEQUEUE(&conn->psq);\n                                        A_MUTEX_UNLOCK(&conn->psqLock);\n                                        ar6000_data_tx(skb,ar->arNetDev);\n                                        A_MUTEX_LOCK(&conn->psqLock);\n                                    }\n                                    A_MUTEX_UNLOCK(&conn->psqLock);\n                                    /* Clear the PVB for this STA */\n                                    wmi_set_pvb_cmd(ar->arWmi, conn->aid, 0);\n                                }\n                            }\n                        } else {\n                            /* This frame is from a STA that is not associated*/\n                            A_ASSERT(false);\n                        }\n\n                        /* Drop NULL data frames here */\n                        if((pPacket->ActualLength < minHdrLen) ||\n                                (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)) {\n                            A_NETBUF_FREE(skb);\n                            goto rx_done;\n                        }\n                    }\n\n                    is_amsdu = WMI_DATA_HDR_IS_AMSDU(dhdr) ? true : false;\n                    tid = WMI_DATA_HDR_GET_UP(dhdr);\n                    seq_no = WMI_DATA_HDR_GET_SEQNO(dhdr);\n                    meta_type = WMI_DATA_HDR_GET_META(dhdr);\n                    containsDot11Hdr = WMI_DATA_HDR_GET_DOT11(dhdr);\n\n                    wmi_data_hdr_remove(ar->arWmi, skb);\n\n                    switch (meta_type) {\n                        case WMI_META_VERSION_1:\n                            {\n                                WMI_RX_META_V1 *pMeta = (WMI_RX_META_V1 *)A_NETBUF_DATA(skb);\n                                A_PRINTF(\"META %d %d %d %d %x\\n\", pMeta->status, pMeta->rix, pMeta->rssi, pMeta->channel, pMeta->flags);\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V1));\n                                break;\n                            }\n                        case WMI_META_VERSION_2:\n                            {\n                                WMI_RX_META_V2 *pMeta = (WMI_RX_META_V2 *)A_NETBUF_DATA(skb);\n                                if(pMeta->csumFlags & 0x1){\n                                    skb->ip_summed=CHECKSUM_COMPLETE;\n                                    skb->csum=(pMeta->csum);\n                                }\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V2));\n                                break;\n                            }\n                        default:\n                            break;\n                    }\n\n                    A_ASSERT(status == 0);\n\n                    /* NWF: print the 802.11 hdr bytes */\n                    if(containsDot11Hdr) {\n                        status = wmi_dot11_hdr_remove(ar->arWmi,skb);\n                    } else if(!is_amsdu) {\n                        status = wmi_dot3_2_dix(skb);\n                    }\n\n                    if (status) {\n                        /* Drop frames that could not be processed (lack of memory, etc.) */\n                        A_NETBUF_FREE(skb);\n                        goto rx_done;\n                    }\n\n                    if ((ar->arNetDev->flags & IFF_UP) == IFF_UP) {\n                        if (ar->arNetworkType == AP_NETWORK) {\n                            struct sk_buff *skb1 = NULL;\n                            ATH_MAC_HDR *datap;\n\n                            datap = (ATH_MAC_HDR *)A_NETBUF_DATA(skb);\n                            if (IEEE80211_IS_MULTICAST(datap->dstMac)) {\n                                /* Bcast/Mcast frames should be sent to the OS\n                                 * stack as well as on the air.\n                                 */\n                                skb1 = skb_copy(skb,GFP_ATOMIC);\n                            } else {\n                                /* Search for a connected STA with dstMac as\n                                 * the Mac address. If found send the frame to\n                                 * it on the air else send the frame up the\n                                 * stack\n                                 */\n                                sta_t *conn = NULL;\n                                conn = ieee80211_find_conn(ar, datap->dstMac);\n\n                                if (conn && ar->intra_bss) {\n                                    skb1 = skb;\n                                    skb = NULL;\n                                } else if(conn && !ar->intra_bss) {\n                                    A_NETBUF_FREE(skb);\n                                    skb = NULL;\n                                }\n                            }\n                            if (skb1) {\n                                ar6000_data_tx(skb1, ar->arNetDev);\n                            }\n                        }\n                    }\n                    aggr_process_recv_frm(ar->aggr_cntxt, tid, seq_no, is_amsdu, (void **)&skb);\n                    ar6000_deliver_frames_to_nw_stack((void *) ar->arNetDev, (void *)skb);\n                }\n            }\n    } else {\n        if (EPPING_ALIGNMENT_PAD > 0) {\n            A_NETBUF_PULL(skb, EPPING_ALIGNMENT_PAD);\n        }\n        ar6000_deliver_frames_to_nw_stack((void *)ar->arNetDev, (void *)skb);\n    }\n\nrx_done:\n\n    return;\n}\n",
        "linevul": 0.0001013446380966343,
        "sysevr": 0.27021628618240356,
        "devign": 2.744709858576072e-35
    },
    {
        "code": "void md_ack_all_badblocks(struct badblocks *bb)\n{\n\tif (bb->page == NULL || bb->changed)\n\t\t/* no point even trying */\n\t\treturn;\n\twrite_seqlock_irq(&bb->lock);\n\n\tif (bb->changed == 0 && bb->unacked_exist) {\n\t\tu64 *p = bb->page;\n\t\tint i;\n\t\tfor (i = 0; i < bb->count ; i++) {\n\t\t\tif (!BB_ACK(p[i])) {\n\t\t\t\tsector_t start = BB_OFFSET(p[i]);\n\t\t\t\tint len = BB_LEN(p[i]);\n\t\t\t\tp[i] = BB_MAKE(start, len, 1);\n\t\t\t}\n\t\t}\n\t\tbb->unacked_exist = 0;\n\t}\n\twrite_sequnlock_irq(&bb->lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "void md_ack_all_badblocks(struct badblocks *bb)\n{\n\tif (bb->page == NULL || bb->changed)\n\t\t/* no point even trying */\n\t\treturn;\n\twrite_seqlock_irq(&bb->lock);\n\n\tif (bb->changed == 0 && bb->unacked_exist) {\n\t\tu64 *p = bb->page;\n\t\tint i;\n\t\tfor (i = 0; i < bb->count ; i++) {\n\t\t\tif (!BB_ACK(p[i])) {\n\t\t\t\tsector_t start = BB_OFFSET(p[i]);\n\t\t\t\tint len = BB_LEN(p[i]);\n\t\t\t\tp[i] = BB_MAKE(start, len, 1);\n\t\t\t}\n\t\t}\n\t\tbb->unacked_exist = 0;\n\t}\n\twrite_sequnlock_irq(&bb->lock);\n}\n",
        "linevul": 6.734030466759577e-05,
        "sysevr": 0.16710057854652405,
        "devign": 5.3863794597428265e-20
    },
    {
        "code": "void __init set_handler(unsigned long offset, void *addr, unsigned long size)\n{\n\tmemcpy((void *)(ebase + offset), addr, size);\n\tlocal_flush_icache_range(ebase + offset, ebase + offset + size);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "void __init set_handler(unsigned long offset, void *addr, unsigned long size)\n{\n\tmemcpy((void *)(ebase + offset), addr, size);\n\tlocal_flush_icache_range(ebase + offset, ebase + offset + size);\n}\n",
        "linevul": 0.00014961084525566548,
        "sysevr": 0.251178503036499,
        "devign": 0.3082708716392517
    },
    {
        "code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n \n \tar2->udev = udev;\n \n \tar2->intf[0] = interface;\n \tar2->ep[0] = &alt->endpoint[0].desc;\n \n \tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n \tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n \tif (r)\n \t\tgoto fail1;\n \talt = ar2->intf[1]->cur_altsetting;\n \tar2->ep[1] = &alt->endpoint[0].desc;\n \n \tr = ati_remote2_urb_init(ar2);\n \tif (r)\n\t\tgoto fail2;\n \n \tar2->channel_mask = channel_mask;\n \tar2->mode_mask = mode_mask;\n \n \tr = ati_remote2_setup(ar2, ar2->channel_mask);\n \tif (r)\n\t\tgoto fail2;\n \n \tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n \tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n \n \tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n \tif (r)\n\t\tgoto fail2;\n \n \tr = ati_remote2_input_init(ar2);\n \tif (r)\n\t\tgoto fail3;\n \n \tusb_set_intfdata(interface, ar2);\n \n \tinterface->needs_remote_wakeup = 1;\n \n \treturn 0;\n \n fail3:\n \tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n \tati_remote2_urb_cleanup(ar2);\n \tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n  fail1:\n \tkfree(ar2);\n\n\treturn r;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d",
        "vul_func_with_fix": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n \n \tar2->udev = udev;\n \n//fix_flaw_line_below:\n//\t/* Sanity check, first interface must have an endpoint */\n//fix_flaw_line_below:\n//\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n//fix_flaw_line_below:\n//\t\tdev_err(&interface->dev,\n//fix_flaw_line_below:\n//\t\t\t\"%s(): interface 0 must have an endpoint\\n\", __func__);\n//fix_flaw_line_below:\n//\t\tr = -ENODEV;\n//fix_flaw_line_below:\n//\t\tgoto fail1;\n//fix_flaw_line_below:\n//\t}\n \tar2->intf[0] = interface;\n \tar2->ep[0] = &alt->endpoint[0].desc;\n \n//fix_flaw_line_below:\n//\t/* Sanity check, the device must have two interfaces */\n \tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n//fix_flaw_line_below:\n//\tif ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {\n//fix_flaw_line_below:\n//\t\tdev_err(&interface->dev, \"%s(): need 2 interfaces, found %d\\n\",\n//fix_flaw_line_below:\n//\t\t\t__func__, udev->actconfig->desc.bNumInterfaces);\n//fix_flaw_line_below:\n//\t\tr = -ENODEV;\n//fix_flaw_line_below:\n//\t\tgoto fail1;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n \tif (r)\n \t\tgoto fail1;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* Sanity check, second interface must have an endpoint */\n \talt = ar2->intf[1]->cur_altsetting;\n//fix_flaw_line_below:\n//\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n//fix_flaw_line_below:\n//\t\tdev_err(&interface->dev,\n//fix_flaw_line_below:\n//\t\t\t\"%s(): interface 1 must have an endpoint\\n\", __func__);\n//fix_flaw_line_below:\n//\t\tr = -ENODEV;\n//fix_flaw_line_below:\n//\t\tgoto fail2;\n//fix_flaw_line_below:\n//\t}\n \tar2->ep[1] = &alt->endpoint[0].desc;\n \n \tr = ati_remote2_urb_init(ar2);\n \tif (r)\n//flaw_line_below:\n\t\tgoto fail2;\n//fix_flaw_line_below:\n//\t\tgoto fail3;\n \n \tar2->channel_mask = channel_mask;\n \tar2->mode_mask = mode_mask;\n \n \tr = ati_remote2_setup(ar2, ar2->channel_mask);\n \tif (r)\n//flaw_line_below:\n\t\tgoto fail2;\n//fix_flaw_line_below:\n//\t\tgoto fail3;\n \n \tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n \tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n \n \tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n \tif (r)\n//flaw_line_below:\n\t\tgoto fail2;\n//fix_flaw_line_below:\n//\t\tgoto fail3;\n \n \tr = ati_remote2_input_init(ar2);\n \tif (r)\n//flaw_line_below:\n\t\tgoto fail3;\n//fix_flaw_line_below:\n//\t\tgoto fail4;\n \n \tusb_set_intfdata(interface, ar2);\n \n \tinterface->needs_remote_wakeup = 1;\n \n \treturn 0;\n \n//flaw_line_below:\n fail3:\n//fix_flaw_line_below:\n// fail4:\n \tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n//flaw_line_below:\n fail2:\n//fix_flaw_line_below:\n// fail3:\n \tati_remote2_urb_cleanup(ar2);\n//fix_flaw_line_below:\n// fail2:\n \tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n  fail1:\n \tkfree(ar2);\n\n\treturn r;\n}\n",
        "linevul": 0.999697208404541,
        "sysevr": 0.19834215939044952,
        "devign": 0.9801673293113708
    },
    {
        "code": "static int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n \n\t\tif (perf_event_overflow(event, 1, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n \n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\t/*\n\t * Some chipsets need to unmask the LVTPC in a particular spot\n\t * inside the nmi handler.  As a result, the unmasking was pushed\n\t * into all the nmi handlers.\n\t *\n\t * This generic handler doesn't seem to have any issues where the\n\t * unmasking occurs so it was left at the top.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/*\n\t\t\t * Though we deactivated the counter some cpus\n\t\t\t * might still deliver spurious interrupts still\n\t\t\t * in flight. Catch them:\n\t\t\t */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n \n//flaw_line_below:\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n//fix_flaw_line_below:\n//\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n \n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}\n",
        "linevul": 5.690238322131336e-05,
        "sysevr": 0.15596559643745422,
        "devign": 0.9999285936355591
    },
    {
        "code": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n \trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n \tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n \tnl_table[NETLINK_USERSOCK].registered = 1;\n \n \tnetlink_table_ungrab();\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/20e1db19db5d6b9e4e83021595eab0dc8f107bef",
        "vul_func_with_fix": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n \trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n \tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n \tnl_table[NETLINK_USERSOCK].registered = 1;\n//fix_flaw_line_below:\n//\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n \n \tnetlink_table_ungrab();\n }\n",
        "linevul": 0.9995042085647583,
        "sysevr": 0.1360623836517334,
        "devign": 0.5444035530090332
    },
    {
        "code": "static struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\tstruct mr6_table *mrt;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (mrt->id == id)\n\t\t\treturn mrt;\n\t}\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/99253eb750fda6a644d5188fb26c43bad8d5a745",
        "vul_func_with_fix": "static struct mr6_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\tstruct mr6_table *mrt;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (mrt->id == id)\n\t\t\treturn mrt;\n\t}\n\treturn NULL;\n}\n",
        "linevul": 5.5823886214056984e-05,
        "sysevr": 0.1269168257713318,
        "devign": 1.204518818020972e-09
    },
    {
        "code": "static inline struct mempolicy *shmem_get_sbmpol(struct shmem_sb_info *sbinfo)\n{\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "static inline struct mempolicy *shmem_get_sbmpol(struct shmem_sb_info *sbinfo)\n{\n\treturn NULL;\n}\n",
        "linevul": 0.00010114497854374349,
        "sysevr": 0.1295439451932907,
        "devign": 4.1125766681027187e-10
    },
    {
        "code": "int utf8_to_utf32(const u8 *s, int len, unicode_t *pu)\n{\n\tunsigned long l;\n\tint c0, c, nc;\n\tconst struct utf8_table *t;\n  \n\tnc = 0;\n\tc0 = *s;\n\tl = c0;\n\tfor (t = utf8_table; t->cmask; t++) {\n\t\tnc++;\n\t\tif ((c0 & t->cmask) == t->cval) {\n\t\t\tl &= t->lmask;\n\t\t\tif (l < t->lval || l > UNICODE_MAX ||\n\t\t\t\t\t(l & SURROGATE_MASK) == SURROGATE_PAIR)\n\t\t\t\treturn -1;\n\t\t\t*pu = (unicode_t) l;\n\t\t\treturn nc;\n\t\t}\n\t\tif (len <= nc)\n\t\t\treturn -1;\n\t\ts++;\n\t\tc = (*s ^ 0x80) & 0xFF;\n\t\tif (c & 0xC0)\n\t\t\treturn -1;\n\t\tl = (l << 6) | c;\n\t}\n\treturn -1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd",
        "vul_func_with_fix": "int utf8_to_utf32(const u8 *s, int len, unicode_t *pu)\n{\n\tunsigned long l;\n\tint c0, c, nc;\n\tconst struct utf8_table *t;\n  \n\tnc = 0;\n\tc0 = *s;\n\tl = c0;\n\tfor (t = utf8_table; t->cmask; t++) {\n\t\tnc++;\n\t\tif ((c0 & t->cmask) == t->cval) {\n\t\t\tl &= t->lmask;\n\t\t\tif (l < t->lval || l > UNICODE_MAX ||\n\t\t\t\t\t(l & SURROGATE_MASK) == SURROGATE_PAIR)\n\t\t\t\treturn -1;\n\t\t\t*pu = (unicode_t) l;\n\t\t\treturn nc;\n\t\t}\n\t\tif (len <= nc)\n\t\t\treturn -1;\n\t\ts++;\n\t\tc = (*s ^ 0x80) & 0xFF;\n\t\tif (c & 0xC0)\n\t\t\treturn -1;\n\t\tl = (l << 6) | c;\n\t}\n\treturn -1;\n}\n",
        "linevul": 6.43903695163317e-05,
        "sysevr": 0.19711534678936005,
        "devign": 2.0737989103736254e-10
    },
    {
        "code": "static void loop_queue_work(struct kthread_work *work)\n{\n\tstruct loop_cmd *cmd =\n\t\tcontainer_of(work, struct loop_cmd, work);\n\n\tloop_handle_cmd(cmd);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
        "vul_func_with_fix": "static void loop_queue_work(struct kthread_work *work)\n{\n\tstruct loop_cmd *cmd =\n\t\tcontainer_of(work, struct loop_cmd, work);\n\n\tloop_handle_cmd(cmd);\n}\n",
        "linevul": 7.85461234045215e-05,
        "sysevr": 0.12925608456134796,
        "devign": 0.00011725720105459914
    },
    {
        "code": "__be32 inet_confirm_addr(struct net *net, struct in_device *in_dev,\n\t\t\t __be32 dst, __be32 local, int scope)\n{\n\t__be32 addr = 0;\n\tstruct net_device *dev;\n\n\tif (in_dev)\n\t\treturn confirm_addr_indev(in_dev, dst, local, scope);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\taddr = confirm_addr_indev(in_dev, dst, local, scope);\n\t\t\tif (addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn addr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2",
        "vul_func_with_fix": "__be32 inet_confirm_addr(struct net *net, struct in_device *in_dev,\n\t\t\t __be32 dst, __be32 local, int scope)\n{\n\t__be32 addr = 0;\n\tstruct net_device *dev;\n\n\tif (in_dev)\n\t\treturn confirm_addr_indev(in_dev, dst, local, scope);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\taddr = confirm_addr_indev(in_dev, dst, local, scope);\n\t\t\tif (addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn addr;\n}\n",
        "linevul": 5.223532934905961e-05,
        "sysevr": 0.13456450402736664,
        "devign": 3.4896059972850876e-14
    },
    {
        "code": "static bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d",
        "vul_func_with_fix": "static bool nested_svm_vmrun_msrpm(struct vcpu_svm *svm)\n{\n\t/*\n\t * This function merges the msr permission bitmaps of kvm and the\n\t * nested vmcb. It is optimized in that it only merges the parts where\n\t * the kvm msr permission bitmap may contain zero bits\n\t */\n\tint i;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_MSR_PROT)))\n\t\treturn true;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; i++) {\n\t\tu32 value, p;\n\t\tu64 offset;\n\n\t\tif (msrpm_offsets[i] == 0xffffffff)\n\t\t\tbreak;\n\n\t\tp      = msrpm_offsets[i];\n\t\toffset = svm->nested.vmcb_msrpm + (p * 4);\n\n\t\tif (kvm_vcpu_read_guest(&svm->vcpu, offset, &value, 4))\n\t\t\treturn false;\n\n\t\tsvm->nested.msrpm[p] = svm->msrpm[p] | value;\n\t}\n\n\tsvm->vmcb->control.msrpm_base_pa = __pa(svm->nested.msrpm);\n\n\treturn true;\n}\n",
        "linevul": 6.026219125487842e-05,
        "sysevr": 0.15080758929252625,
        "devign": 8.122189444452477e-13
    },
    {
        "code": "void __exit hidp_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"hidp\");\n\tbt_sock_unregister(BTPROTO_HIDP);\n\tproto_unregister(&hidp_proto);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a1616a5ac99ede5d605047a9012481ce7ff18b16",
        "vul_func_with_fix": "void __exit hidp_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"hidp\");\n\tbt_sock_unregister(BTPROTO_HIDP);\n\tproto_unregister(&hidp_proto);\n}\n",
        "linevul": 0.0001663715811446309,
        "sysevr": 0.15732428431510925,
        "devign": 0.5100881457328796
    },
    {
        "code": "int __init init_hw_perf_events(void)\n{\n\tpr_info(\"Performance events: \");\n\n\tif (!supported_pmu()) {\n\t\tpr_cont(\"No support for PMU type '%s'\\n\", sparc_pmu_type);\n\t\treturn 0;\n\t}\n\n\tpr_cont(\"Supported PMU type is '%s'\\n\", sparc_pmu_type);\n\n\tperf_pmu_register(&pmu, \"cpu\", PERF_TYPE_RAW);\n\tregister_die_notifier(&perf_event_nmi_notifier);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "int __init init_hw_perf_events(void)\n{\n\tpr_info(\"Performance events: \");\n\n\tif (!supported_pmu()) {\n\t\tpr_cont(\"No support for PMU type '%s'\\n\", sparc_pmu_type);\n\t\treturn 0;\n\t}\n\n\tpr_cont(\"Supported PMU type is '%s'\\n\", sparc_pmu_type);\n\n\tperf_pmu_register(&pmu, \"cpu\", PERF_TYPE_RAW);\n\tregister_die_notifier(&perf_event_nmi_notifier);\n\n\treturn 0;\n}\n",
        "linevul": 4.9251011660089716e-05,
        "sysevr": 0.14812761545181274,
        "devign": 0.4741024076938629
    },
    {
        "code": "static void btrfs_release_delalloc_bytes(struct btrfs_root *root,\n\t\t\t\t\t u64 start, u64 len)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, start);\n\tASSERT(cache);\n\n\tspin_lock(&cache->lock);\n\tcache->delalloc_bytes -= len;\n\tspin_unlock(&cache->lock);\n\n\tbtrfs_put_block_group(cache);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7",
        "vul_func_with_fix": "static void btrfs_release_delalloc_bytes(struct btrfs_root *root,\n\t\t\t\t\t u64 start, u64 len)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, start);\n\tASSERT(cache);\n\n\tspin_lock(&cache->lock);\n\tcache->delalloc_bytes -= len;\n\tspin_unlock(&cache->lock);\n\n\tbtrfs_put_block_group(cache);\n}\n",
        "linevul": 5.963040530332364e-05,
        "sysevr": 0.13559512794017792,
        "devign": 6.224986583874045e-15
    },
    {
        "code": " static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs, int nmi)\n {\n \tu64 period = event->hw.sample_period;\n \ts64 prev, delta, left;\n\tint record = 0;\n\n\tif (event->hw.state & PERF_HES_STOPPED) {\n\t\twrite_pmc(event->hw.idx, 0);\n\t\treturn;\n\t}\n\n\t/* we don't have to worry about interrupts here */\n\tprev = local64_read(&event->hw.prev_count);\n\tdelta = (val - prev) & 0xfffffffful;\n\tlocal64_add(delta, &event->count);\n\n\t/*\n\t * See if the total period for this event has expired,\n\t * and update for the next period.\n\t */\n\tval = 0;\n\tleft = local64_read(&event->hw.period_left) - delta;\n\tif (period) {\n\t\tif (left <= 0) {\n\t\t\tleft += period;\n\t\t\tif (left <= 0)\n\t\t\t\tleft = period;\n\t\t\trecord = 1;\n\t\t\tevent->hw.last_period = event->hw.sample_period;\n\t\t}\n\t\tif (left < 0x80000000LL)\n\t\t\tval = 0x80000000LL - left;\n\t}\n\n\twrite_pmc(event->hw.idx, val);\n\tlocal64_set(&event->hw.prev_count, val);\n\tlocal64_set(&event->hw.period_left, left);\n\tperf_event_update_userpage(event);\n\n\t/*\n\t * Finally record data if requested.\n\t */\n\tif (record) {\n\t\tstruct perf_sample_data data;\n\n \t\tperf_sample_data_init(&data, 0);\n \t\tdata.period = event->hw.last_period;\n \n\t\tif (perf_event_overflow(event, nmi, &data, regs))\n \t\t\tfsl_emb_pmu_stop(event, 0);\n \t}\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": " static void record_and_restart(struct perf_event *event, unsigned long val,\n//flaw_line_below:\n\t\t\t       struct pt_regs *regs, int nmi)\n//fix_flaw_line_below:\n//\t\t\t       struct pt_regs *regs)\n {\n \tu64 period = event->hw.sample_period;\n \ts64 prev, delta, left;\n\tint record = 0;\n\n\tif (event->hw.state & PERF_HES_STOPPED) {\n\t\twrite_pmc(event->hw.idx, 0);\n\t\treturn;\n\t}\n\n\t/* we don't have to worry about interrupts here */\n\tprev = local64_read(&event->hw.prev_count);\n\tdelta = (val - prev) & 0xfffffffful;\n\tlocal64_add(delta, &event->count);\n\n\t/*\n\t * See if the total period for this event has expired,\n\t * and update for the next period.\n\t */\n\tval = 0;\n\tleft = local64_read(&event->hw.period_left) - delta;\n\tif (period) {\n\t\tif (left <= 0) {\n\t\t\tleft += period;\n\t\t\tif (left <= 0)\n\t\t\t\tleft = period;\n\t\t\trecord = 1;\n\t\t\tevent->hw.last_period = event->hw.sample_period;\n\t\t}\n\t\tif (left < 0x80000000LL)\n\t\t\tval = 0x80000000LL - left;\n\t}\n\n\twrite_pmc(event->hw.idx, val);\n\tlocal64_set(&event->hw.prev_count, val);\n\tlocal64_set(&event->hw.period_left, left);\n\tperf_event_update_userpage(event);\n\n\t/*\n\t * Finally record data if requested.\n\t */\n\tif (record) {\n\t\tstruct perf_sample_data data;\n\n \t\tperf_sample_data_init(&data, 0);\n \t\tdata.period = event->hw.last_period;\n \n//flaw_line_below:\n\t\tif (perf_event_overflow(event, nmi, &data, regs))\n//fix_flaw_line_below:\n//\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tfsl_emb_pmu_stop(event, 0);\n \t}\n }\n",
        "linevul": 0.998488187789917,
        "sysevr": 0.16435843706130981,
        "devign": 0.9999202489852905
    },
    {
        "code": "static int whiteheat_port_remove(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = usb_get_serial_port_data(port);\n\tkfree(info);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6817ae225cd650fb1c3295d769298c38b1eba818",
        "vul_func_with_fix": "static int whiteheat_port_remove(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = usb_get_serial_port_data(port);\n\tkfree(info);\n\n\treturn 0;\n}\n",
        "linevul": 5.298344694892876e-05,
        "sysevr": 0.1285877227783203,
        "devign": 6.919081351952627e-05
    },
    {
        "code": " static int digi_startup(struct usb_serial *serial)\n {\n \tstruct digi_serial *serial_priv;\n \tint ret;\n \n \tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n \tif (!serial_priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\n\tusb_set_serial_data(serial, serial_priv);\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/5a07975ad0a36708c6b0a5b9fea1ff811d0b0c1f",
        "vul_func_with_fix": " static int digi_startup(struct usb_serial *serial)\n {\n//fix_flaw_line_below:\n//\tstruct device *dev = &serial->interface->dev;\n \tstruct digi_serial *serial_priv;\n \tint ret;\n//fix_flaw_line_below:\n//\tint i;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* check whether the device has the expected number of endpoints */\n//fix_flaw_line_below:\n//\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n//fix_flaw_line_below:\n//\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n//fix_flaw_line_below:\n//\t\treturn -ENODEV;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n//fix_flaw_line_below:\n//\t\tif (!serial->port[i]->read_urb) {\n//fix_flaw_line_below:\n//\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n//fix_flaw_line_below:\n//\t\t\treturn -ENODEV;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tif (!serial->port[i]->write_urb) {\n//fix_flaw_line_below:\n//\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n//fix_flaw_line_below:\n//\t\t\treturn -ENODEV;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t}\n \n \tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n \tif (!serial_priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\n\tusb_set_serial_data(serial, serial_priv);\n\n\treturn 0;\n}\n",
        "linevul": 0.9997016787528992,
        "sysevr": 0.13996635377407074,
        "devign": 0.9789999723434448
    },
    {
        "code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n \t\t}\n \t}\n \n \tif (table->total == table->max) {\n \t\t/* No free vlan entries */\n \t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db",
        "vul_func_with_fix": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n \t\t}\n \t}\n \n//fix_flaw_line_below:\n//\tif (free < 0) {\n//fix_flaw_line_below:\n//\t\terr = -ENOMEM;\n//fix_flaw_line_below:\n//\t\tgoto out;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \tif (table->total == table->max) {\n \t\t/* No free vlan entries */\n \t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\n",
        "linevul": 8.625829650554806e-05,
        "sysevr": 0.1758347749710083,
        "devign": 6.402577525050948e-38
    },
    {
        "code": "static int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tint ret;\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tclear_buffer_meta(bh);\n\tclear_buffer_prio(bh);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tint ret;\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tclear_buffer_meta(bh);\n\tclear_buffer_prio(bh);\n\treturn ret;\n}\n",
        "linevul": 0.00010099945211550221,
        "sysevr": 0.12690480053424835,
        "devign": 0.00014593171363230795
    },
    {
        "code": "static int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f",
        "vul_func_with_fix": "static int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (FDCS->address != -1)\n\t\t\tuser_reset_fdc(-1, FD_RESET_ALWAYS, false);\n\n\treturn 0;\n}\n",
        "linevul": 4.763242759509012e-05,
        "sysevr": 0.1260737180709839,
        "devign": 1.8645833875221195e-18
    },
    {
        "code": " midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n {\n \tint             orig_dev = synth_devs[dev]->midi_dev;\n \n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n \tif (!prefix_cmd(orig_dev, 0xf0))\n \t\treturn 0;\n \n \tif (format != SYSEX_PATCH)\n\t{\n/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/\n \t\t  return -EINVAL;\n\t}\n \tif (count < hdr_size)\n\t{\n/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/\n \t\treturn -EINVAL;\n\t}\n \tcount -= hdr_size;\n \n \t/*\n\t * Copy the header from user space but ignore the first bytes which have\n\t * been transferred already.\n \t */\n \n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n \t\treturn -EFAULT;\n \tif (count < sysex.len)\n\t{\n/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/\n \t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n \n \tfor (i = 0; i < left && !signal_pending(current); i++)\n \t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9",
        "vul_func_with_fix": " midi_synth_load_patch(int dev, int format, const char __user *addr,\n//flaw_line_below:\n\t\t      int offs, int count, int pmgr_flag)\n//fix_flaw_line_below:\n//\t\t      int count, int pmgr_flag)\n {\n \tint             orig_dev = synth_devs[dev]->midi_dev;\n \n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n \tif (!prefix_cmd(orig_dev, 0xf0))\n \t\treturn 0;\n \n//fix_flaw_line_below:\n//\t/* Invalid patch format */\n \tif (format != SYSEX_PATCH)\n//flaw_line_below:\n\t{\n//flaw_line_below:\n/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*/\n \t\t  return -EINVAL;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* Patch header too short */\n \tif (count < hdr_size)\n//flaw_line_below:\n\t{\n//flaw_line_below:\n/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*/\n \t\treturn -EINVAL;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\n \tcount -= hdr_size;\n \n \t/*\n//flaw_line_below:\n\t * Copy the header from user space but ignore the first bytes which have\n//flaw_line_below:\n\t * been transferred already.\n//fix_flaw_line_below:\n//\t * Copy the header from user space\n \t */\n \n//flaw_line_below:\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n//fix_flaw_line_below:\n//\tif (copy_from_user(&sysex, addr, hdr_size))\n \t\treturn -EFAULT;\n//flaw_line_below:\n \n//flaw_line_below:\n \tif (count < sysex.len)\n//flaw_line_below:\n\t{\n//flaw_line_below:\n/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*/\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* Sysex record too short */\n//fix_flaw_line_below:\n//\tif ((unsigned)count < (unsigned)sysex.len)\n \t\tsysex.len = count;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n  \tleft = sysex.len;\n//flaw_line_below:\n  \tsrc_offs = 0;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tleft = sysex.len;\n//fix_flaw_line_below:\n//\tsrc_offs = 0;\n \n \tfor (i = 0; i < left && !signal_pending(current); i++)\n \t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t/* End of sysex */\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}\n",
        "linevul": 0.9995457530021667,
        "sysevr": 0.2433527261018753,
        "devign": 0.6119067072868347
    },
    {
        "code": "static void enqueue_first(irda_queue_t **queue, irda_queue_t* element)\n{\n\n\t/*\n\t * Check if queue is empty.\n\t */\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue is empty.  Insert one element into the queue.\n\t\t */\n\t\telement->q_next = element->q_prev = *queue = element;\n\n\t} else {\n\t\t/*\n\t\t * Queue is not empty.  Insert element into front of queue.\n\t\t */\n\t\telement->q_next          = (*queue);\n\t\t(*queue)->q_prev->q_next = element;\n\t\telement->q_prev          = (*queue)->q_prev;\n\t\t(*queue)->q_prev         = element;\n\t\t(*queue)                 = element;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4c03b862b12f980456f9de92db6d508a4999b788",
        "vul_func_with_fix": "static void enqueue_first(irda_queue_t **queue, irda_queue_t* element)\n{\n\n\t/*\n\t * Check if queue is empty.\n\t */\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue is empty.  Insert one element into the queue.\n\t\t */\n\t\telement->q_next = element->q_prev = *queue = element;\n\n\t} else {\n\t\t/*\n\t\t * Queue is not empty.  Insert element into front of queue.\n\t\t */\n\t\telement->q_next          = (*queue);\n\t\t(*queue)->q_prev->q_next = element;\n\t\telement->q_prev          = (*queue)->q_prev;\n\t\t(*queue)->q_prev         = element;\n\t\t(*queue)                 = element;\n\t}\n}\n",
        "linevul": 4.7847952373558655e-05,
        "sysevr": 0.14601600170135498,
        "devign": 7.698689602486652e-11
    },
    {
        "code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n \t\tgoto exit;\n \t}\n \n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \t/* Only copy data to userland if data was received. */\n \tif (ret < 0)\n \t\tgoto exit;\n \n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/096cdc6f52225835ff503f987a0d68ef770bb78e",
        "vul_func_with_fix": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n \t\tgoto exit;\n \t}\n \n//fix_flaw_line_below:\n//\tif (u_cmd.outsize != s_cmd->outsize ||\n//fix_flaw_line_below:\n//\t    u_cmd.insize != s_cmd->insize) {\n//fix_flaw_line_below:\n//\t\tret = -EINVAL;\n//fix_flaw_line_below:\n//\t\tgoto exit;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \t/* Only copy data to userland if data was received. */\n \tif (ret < 0)\n \t\tgoto exit;\n \n//flaw_line_below:\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n//fix_flaw_line_below:\n//\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);\n\treturn ret;\n}\n",
        "linevul": 0.00011075736256316304,
        "sysevr": 0.15461072325706482,
        "devign": 0.6722798347473145
    },
    {
        "code": "static void write_pmc(int idx, unsigned long val)\n{\n\tswitch (idx) {\n\tcase 0:\n\t\tmtpmr(PMRN_PMC0, val);\n\t\tbreak;\n\tcase 1:\n\t\tmtpmr(PMRN_PMC1, val);\n\t\tbreak;\n\tcase 2:\n\t\tmtpmr(PMRN_PMC2, val);\n\t\tbreak;\n\tcase 3:\n\t\tmtpmr(PMRN_PMC3, val);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"oops trying to write PMC%d\\n\", idx);\n\t}\n\n\tisync();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void write_pmc(int idx, unsigned long val)\n{\n\tswitch (idx) {\n\tcase 0:\n\t\tmtpmr(PMRN_PMC0, val);\n\t\tbreak;\n\tcase 1:\n\t\tmtpmr(PMRN_PMC1, val);\n\t\tbreak;\n\tcase 2:\n\t\tmtpmr(PMRN_PMC2, val);\n\t\tbreak;\n\tcase 3:\n\t\tmtpmr(PMRN_PMC3, val);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"oops trying to write PMC%d\\n\", idx);\n\t}\n\n\tisync();\n}\n",
        "linevul": 4.7038971388246864e-05,
        "sysevr": 0.12520134449005127,
        "devign": 3.752341172003071e-06
    },
    {
        "code": "static int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\tbtrfs_write_dirty_block_groups(trans, root);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t\tret = btrfs_write_dirty_block_groups(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (root != root->fs_info->extent_root)\n\t\tswitch_commit_root(root);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "vul_func_with_fix": "static int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\tbtrfs_write_dirty_block_groups(trans, root);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t\tret = btrfs_write_dirty_block_groups(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (root != root->fs_info->extent_root)\n\t\tswitch_commit_root(root);\n\n\treturn 0;\n}\n",
        "linevul": 5.74957302887924e-05,
        "sysevr": 0.1483510434627533,
        "devign": 3.2741493181622687e-15
    },
    {
        "code": "static int __net_init sctp_net_init(struct net *net)\n {\n \tint status;\n \n\t/*\n\t * 14. Suggested SCTP Protocol Parameter Values\n\t */\n\t/* The following protocol parameters are RECOMMENDED:  */\n\t/* RTO.Initial              - 3  seconds */\n\tnet->sctp.rto_initial\t\t\t= SCTP_RTO_INITIAL;\n\t/* RTO.Min                  - 1  second */\n\tnet->sctp.rto_min\t \t\t= SCTP_RTO_MIN;\n\t/* RTO.Max                 -  60 seconds */\n\tnet->sctp.rto_max \t\t\t= SCTP_RTO_MAX;\n\t/* RTO.Alpha                - 1/8 */\n\tnet->sctp.rto_alpha\t\t\t= SCTP_RTO_ALPHA;\n\t/* RTO.Beta                 - 1/4 */\n\tnet->sctp.rto_beta\t\t\t= SCTP_RTO_BETA;\n\n\t/* Valid.Cookie.Life        - 60  seconds */\n\tnet->sctp.valid_cookie_life\t\t= SCTP_DEFAULT_COOKIE_LIFE;\n\n\t/* Whether Cookie Preservative is enabled(1) or not(0) */\n\tnet->sctp.cookie_preserve_enable \t= 1;\n\n\t/* Default sctp sockets to use md5 as their hmac alg */\n#if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"md5\";\n#elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"sha1\";\n#else\n\tnet->sctp.sctp_hmac_alg\t\t\t= NULL;\n#endif\n\n\t/* Max.Burst\t\t    - 4 */\n\tnet->sctp.max_burst\t\t\t= SCTP_DEFAULT_MAX_BURST;\n\n\t/* Association.Max.Retrans  - 10 attempts\n\t * Path.Max.Retrans         - 5  attempts (per destination address)\n\t * Max.Init.Retransmits     - 8  attempts\n\t */\n\tnet->sctp.max_retrans_association\t= 10;\n\tnet->sctp.max_retrans_path\t\t= 5;\n\tnet->sctp.max_retrans_init\t\t= 8;\n\n\t/* Sendbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.sndbuf_policy\t\t\t= 0;\n\n\t/* Rcvbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.rcvbuf_policy\t\t\t= 0;\n\n\t/* HB.interval              - 30 seconds */\n\tnet->sctp.hb_interval\t\t\t= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;\n\n\t/* delayed SACK timeout */\n\tnet->sctp.sack_timeout\t\t\t= SCTP_DEFAULT_TIMEOUT_SACK;\n\n\t/* Disable ADDIP by default. */\n\tnet->sctp.addip_enable = 0;\n\tnet->sctp.addip_noauth = 0;\n\tnet->sctp.default_auto_asconf = 0;\n\n\t/* Enable PR-SCTP by default. */\n\tnet->sctp.prsctp_enable = 1;\n\n\t/* Disable AUTH by default. */\n\tnet->sctp.auth_enable = 0;\n\n\t/* Set SCOPE policy to enabled */\n\tnet->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;\n\n\t/* Set the default rwnd update threshold */\n\tnet->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;\n\n\t/* Initialize maximum autoclose timeout. */\n\tnet->sctp.max_autoclose\t\t= INT_MAX / HZ;\n\n\tstatus = sctp_sysctl_net_register(net);\n\tif (status)\n\t\tgoto err_sysctl_register;\n\n\t/* Allocate and initialise sctp mibs.  */\n\tstatus = init_sctp_mibs(net);\n\tif (status)\n\t\tgoto err_init_mibs;\n\n\t/* Initialize proc fs directory.  */\n\tstatus = sctp_proc_init(net);\n\tif (status)\n\t\tgoto err_init_proc;\n \n \tsctp_dbg_objcnt_init(net);\n \n\t/* Initialize the control inode/socket for handling OOTB packets.  */\n\tif ((status = sctp_ctl_sock_init(net))) {\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\t\tgoto err_ctl_sock_init;\n\t}\n \t/* Initialize the local address list. */\n \tINIT_LIST_HEAD(&net->sctp.local_addr_list);\n \tspin_lock_init(&net->sctp.local_addr_lock);\n\tsctp_get_local_addr_list(net);\n\n\t/* Initialize the address event list */\n\tINIT_LIST_HEAD(&net->sctp.addr_waitq);\n\tINIT_LIST_HEAD(&net->sctp.auto_asconf_splist);\n\tspin_lock_init(&net->sctp.addr_wq_lock);\n\tnet->sctp.addr_wq_timer.expires = 0;\n\tsetup_timer(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler,\n\t\t    (unsigned long)net);\n \n \treturn 0;\n \nerr_ctl_sock_init:\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n err_init_proc:\n \tcleanup_sctp_mibs(net);\n err_init_mibs:\n\tsctp_sysctl_net_unregister(net);\nerr_sysctl_register:\n \treturn status;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/8e2d61e0aed2b7c4ecb35844fe07e0b2b762dee4",
        "vul_func_with_fix": "static int __net_init sctp_net_init(struct net *net)\n//fix_flaw_line_below:\n//static int __net_init sctp_defaults_init(struct net *net)\n {\n \tint status;\n \n\t/*\n\t * 14. Suggested SCTP Protocol Parameter Values\n\t */\n\t/* The following protocol parameters are RECOMMENDED:  */\n\t/* RTO.Initial              - 3  seconds */\n\tnet->sctp.rto_initial\t\t\t= SCTP_RTO_INITIAL;\n\t/* RTO.Min                  - 1  second */\n\tnet->sctp.rto_min\t \t\t= SCTP_RTO_MIN;\n\t/* RTO.Max                 -  60 seconds */\n\tnet->sctp.rto_max \t\t\t= SCTP_RTO_MAX;\n\t/* RTO.Alpha                - 1/8 */\n\tnet->sctp.rto_alpha\t\t\t= SCTP_RTO_ALPHA;\n\t/* RTO.Beta                 - 1/4 */\n\tnet->sctp.rto_beta\t\t\t= SCTP_RTO_BETA;\n\n\t/* Valid.Cookie.Life        - 60  seconds */\n\tnet->sctp.valid_cookie_life\t\t= SCTP_DEFAULT_COOKIE_LIFE;\n\n\t/* Whether Cookie Preservative is enabled(1) or not(0) */\n\tnet->sctp.cookie_preserve_enable \t= 1;\n\n\t/* Default sctp sockets to use md5 as their hmac alg */\n#if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"md5\";\n#elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"sha1\";\n#else\n\tnet->sctp.sctp_hmac_alg\t\t\t= NULL;\n#endif\n\n\t/* Max.Burst\t\t    - 4 */\n\tnet->sctp.max_burst\t\t\t= SCTP_DEFAULT_MAX_BURST;\n\n\t/* Association.Max.Retrans  - 10 attempts\n\t * Path.Max.Retrans         - 5  attempts (per destination address)\n\t * Max.Init.Retransmits     - 8  attempts\n\t */\n\tnet->sctp.max_retrans_association\t= 10;\n\tnet->sctp.max_retrans_path\t\t= 5;\n\tnet->sctp.max_retrans_init\t\t= 8;\n\n\t/* Sendbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.sndbuf_policy\t\t\t= 0;\n\n\t/* Rcvbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.rcvbuf_policy\t\t\t= 0;\n\n\t/* HB.interval              - 30 seconds */\n\tnet->sctp.hb_interval\t\t\t= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;\n\n\t/* delayed SACK timeout */\n\tnet->sctp.sack_timeout\t\t\t= SCTP_DEFAULT_TIMEOUT_SACK;\n\n\t/* Disable ADDIP by default. */\n\tnet->sctp.addip_enable = 0;\n\tnet->sctp.addip_noauth = 0;\n\tnet->sctp.default_auto_asconf = 0;\n\n\t/* Enable PR-SCTP by default. */\n\tnet->sctp.prsctp_enable = 1;\n\n\t/* Disable AUTH by default. */\n\tnet->sctp.auth_enable = 0;\n\n\t/* Set SCOPE policy to enabled */\n\tnet->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;\n\n\t/* Set the default rwnd update threshold */\n\tnet->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;\n\n\t/* Initialize maximum autoclose timeout. */\n\tnet->sctp.max_autoclose\t\t= INT_MAX / HZ;\n\n\tstatus = sctp_sysctl_net_register(net);\n\tif (status)\n\t\tgoto err_sysctl_register;\n\n\t/* Allocate and initialise sctp mibs.  */\n\tstatus = init_sctp_mibs(net);\n\tif (status)\n\t\tgoto err_init_mibs;\n\n\t/* Initialize proc fs directory.  */\n\tstatus = sctp_proc_init(net);\n\tif (status)\n\t\tgoto err_init_proc;\n \n \tsctp_dbg_objcnt_init(net);\n \n//flaw_line_below:\n\t/* Initialize the control inode/socket for handling OOTB packets.  */\n//flaw_line_below:\n\tif ((status = sctp_ctl_sock_init(net))) {\n//flaw_line_below:\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n//flaw_line_below:\n\t\tgoto err_ctl_sock_init;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n \t/* Initialize the local address list. */\n \tINIT_LIST_HEAD(&net->sctp.local_addr_list);\n \tspin_lock_init(&net->sctp.local_addr_lock);\n\tsctp_get_local_addr_list(net);\n\n\t/* Initialize the address event list */\n\tINIT_LIST_HEAD(&net->sctp.addr_waitq);\n\tINIT_LIST_HEAD(&net->sctp.auto_asconf_splist);\n\tspin_lock_init(&net->sctp.addr_wq_lock);\n\tnet->sctp.addr_wq_timer.expires = 0;\n\tsetup_timer(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler,\n\t\t    (unsigned long)net);\n \n \treturn 0;\n \n//flaw_line_below:\nerr_ctl_sock_init:\n//flaw_line_below:\n\tsctp_dbg_objcnt_exit(net);\n//flaw_line_below:\n\tsctp_proc_exit(net);\n err_init_proc:\n \tcleanup_sctp_mibs(net);\n err_init_mibs:\n\tsctp_sysctl_net_unregister(net);\nerr_sysctl_register:\n \treturn status;\n }\n",
        "linevul": 0.0007663374417461455,
        "sysevr": 0.1522214412689209,
        "devign": 0.7130993604660034
    },
    {
        "code": "static void fm10k_tx_csum(struct fm10k_ring *tx_ring,\n\t\t\t  struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tu8 *raw;\n\t} network_hdr;\n\tu8 *transport_hdr;\n\t__be16 frag_off;\n\t__be16 protocol;\n\tu8 l4_hdr = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto no_csum;\n\n\tif (skb->encapsulation) {\n\t\tprotocol = fm10k_tx_encap_offload(skb);\n\t\tif (!protocol) {\n\t\t\tif (skb_checksum_help(skb)) {\n\t\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t\t \"failed to offload encap csum!\\n\");\n\t\t\t\ttx_ring->tx_stats.csum_err++;\n\t\t\t}\n\t\t\tgoto no_csum;\n\t\t}\n\t\tnetwork_hdr.raw = skb_inner_network_header(skb);\n\t\ttransport_hdr = skb_inner_transport_header(skb);\n\t} else {\n\t\tprotocol = vlan_get_protocol(skb);\n\t\tnetwork_hdr.raw = skb_network_header(skb);\n\t\ttransport_hdr = skb_transport_header(skb);\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = network_hdr.ipv4->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = network_hdr.ipv6->nexthdr;\n\t\tif (likely((transport_hdr - network_hdr.raw) ==\n\t\t\t   sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\tipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\n\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t &l4_hdr, &frag_off);\n\t\tif (unlikely(frag_off))\n\t\t\tl4_hdr = NEXTHDR_FRAGMENT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tif (skb->encapsulation)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tif (unlikely(net_ratelimit())) {\n\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t \"partial checksum, version=%d l4 proto=%x\\n\",\n\t\t\t\t protocol, l4_hdr);\n\t\t}\n\t\tskb_checksum_help(skb);\n\t\ttx_ring->tx_stats.csum_err++;\n\t\tgoto no_csum;\n\t}\n\n\t/* update TX checksum flag */\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\ttx_ring->tx_stats.csum_good++;\n\nno_csum:\n\t/* populate Tx descriptor header size and mss */\n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = 0;\n\ttx_desc->mss = 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f",
        "vul_func_with_fix": "static void fm10k_tx_csum(struct fm10k_ring *tx_ring,\n\t\t\t  struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tu8 *raw;\n\t} network_hdr;\n\tu8 *transport_hdr;\n\t__be16 frag_off;\n\t__be16 protocol;\n\tu8 l4_hdr = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto no_csum;\n\n\tif (skb->encapsulation) {\n\t\tprotocol = fm10k_tx_encap_offload(skb);\n\t\tif (!protocol) {\n\t\t\tif (skb_checksum_help(skb)) {\n\t\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t\t \"failed to offload encap csum!\\n\");\n\t\t\t\ttx_ring->tx_stats.csum_err++;\n\t\t\t}\n\t\t\tgoto no_csum;\n\t\t}\n\t\tnetwork_hdr.raw = skb_inner_network_header(skb);\n\t\ttransport_hdr = skb_inner_transport_header(skb);\n\t} else {\n\t\tprotocol = vlan_get_protocol(skb);\n\t\tnetwork_hdr.raw = skb_network_header(skb);\n\t\ttransport_hdr = skb_transport_header(skb);\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = network_hdr.ipv4->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = network_hdr.ipv6->nexthdr;\n\t\tif (likely((transport_hdr - network_hdr.raw) ==\n\t\t\t   sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\tipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\n\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t &l4_hdr, &frag_off);\n\t\tif (unlikely(frag_off))\n\t\t\tl4_hdr = NEXTHDR_FRAGMENT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tif (skb->encapsulation)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tif (unlikely(net_ratelimit())) {\n\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t \"partial checksum, version=%d l4 proto=%x\\n\",\n\t\t\t\t protocol, l4_hdr);\n\t\t}\n\t\tskb_checksum_help(skb);\n\t\ttx_ring->tx_stats.csum_err++;\n\t\tgoto no_csum;\n\t}\n\n\t/* update TX checksum flag */\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\ttx_ring->tx_stats.csum_good++;\n\nno_csum:\n\t/* populate Tx descriptor header size and mss */\n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = 0;\n\ttx_desc->mss = 0;\n}\n",
        "linevul": 0.00037454560515470803,
        "sysevr": 0.1724957674741745,
        "devign": 1.4692553619040789e-27
    },
    {
        "code": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054",
        "vul_func_with_fix": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n//fix_flaw_line_below:\n//\tsize_t\t\t\tlen;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n//flaw_line_below:\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n//fix_flaw_line_below:\n//\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n//fix_flaw_line_below:\n//\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n",
        "linevul": 0.999291181564331,
        "sysevr": 0.45833277702331543,
        "devign": 0.9961519837379456
    },
    {
        "code": "void br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64",
        "vul_func_with_fix": "void br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n",
        "linevul": 5.398976645665243e-05,
        "sysevr": 0.17248520255088806,
        "devign": 1.6094325525073394e-11
    },
    {
        "code": "netlink_update_subscriptions(struct sock *sk, unsigned int subscriptions)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tif (nlk->subscriptions && !subscriptions)\n\t\t__sk_del_bind_node(sk);\n\telse if (!nlk->subscriptions && subscriptions)\n\t\tsk_add_bind_node(sk, &nl_table[sk->sk_protocol].mc_list);\n\tnlk->subscriptions = subscriptions;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "vul_func_with_fix": "netlink_update_subscriptions(struct sock *sk, unsigned int subscriptions)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\n\tif (nlk->subscriptions && !subscriptions)\n\t\t__sk_del_bind_node(sk);\n\telse if (!nlk->subscriptions && subscriptions)\n\t\tsk_add_bind_node(sk, &nl_table[sk->sk_protocol].mc_list);\n\tnlk->subscriptions = subscriptions;\n}\n",
        "linevul": 5.2644696552306414e-05,
        "sysevr": 0.14656393229961395,
        "devign": 2.3110093394507203e-08
    },
    {
        "code": "int iscsi_check_negotiated_keys(struct iscsi_param_list *param_list)\n{\n\tint ret = 0;\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    IS_PSTATE_PROPOSER(param) &&\n\t\t    !IS_PSTATE_RESPONSE_GOT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    !IS_PHASE_DECLARATIVE(param)) {\n\t\t\tpr_err(\"No response for proposed key \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cea4dcfdad926a27a18e188720efe0f2c9403456",
        "vul_func_with_fix": "int iscsi_check_negotiated_keys(struct iscsi_param_list *param_list)\n{\n\tint ret = 0;\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    IS_PSTATE_PROPOSER(param) &&\n\t\t    !IS_PSTATE_RESPONSE_GOT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    !IS_PHASE_DECLARATIVE(param)) {\n\t\t\tpr_err(\"No response for proposed key \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 4.9266138375969604e-05,
        "sysevr": 0.15681219100952148,
        "devign": 5.975916337774834e-06
    },
    {
        "code": "static void nfs4_xdr_enc_link(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t     const struct nfs4_link_arg *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_link(xdr, args->name, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_restorefh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static void nfs4_xdr_enc_link(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t     const struct nfs4_link_arg *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_savefh(xdr, &hdr);\n\tencode_putfh(xdr, args->dir_fh, &hdr);\n\tencode_link(xdr, args->name, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_restorefh(xdr, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n",
        "linevul": 8.920367690734565e-05,
        "sysevr": 0.13952307403087616,
        "devign": 3.164484223816544e-05
    },
    {
        "code": "static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint err;\n\tu8 bootresponse[0x12];\n\tint fwsize;\n\tint count;\n\n\tfwsize = le16_to_cpu(get_cfg_desc(config)->wTotalLength);\n\n\tif (fwsize != MBOX2_FIRMWARE_SIZE) {\n\t\tdev_err(&dev->dev, \"Invalid firmware size=%d.\\n\", fwsize);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"Sending Digidesign Mbox 2 boot sequence...\\n\");\n\n\tcount = 0;\n\tbootresponse[0] = MBOX2_BOOT_LOADING;\n\twhile ((bootresponse[0] == MBOX2_BOOT_LOADING) && (count < 10)) {\n\t\tmsleep(500); /* 0.5 second delay */\n\t\tsnd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t/* Control magic - load onboard firmware */\n\t\t\t0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);\n\t\tif (bootresponse[0] == MBOX2_BOOT_READY)\n\t\t\tbreak;\n\t\tdev_dbg(&dev->dev, \"device not ready, resending boot sequence...\\n\");\n\t\tcount++;\n\t}\n\n\tif (bootresponse[0] != MBOX2_BOOT_READY) {\n\t\tdev_err(&dev->dev, \"Unknown bootresponse=%d, or timed out, ignoring device.\\n\", bootresponse[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"device initialised!\\n\");\n\n\terr = usb_get_descriptor(dev, USB_DT_DEVICE, 0,\n\t\t&dev->descriptor, sizeof(dev->descriptor));\n\tconfig = dev->actconfig;\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_get_descriptor: %d\\n\", err);\n\n\terr = usb_reset_configuration(dev);\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_reset_configuration: %d\\n\", err);\n\tdev_dbg(&dev->dev, \"mbox2_boot: new boot length = %d\\n\",\n\t\tle16_to_cpu(get_cfg_desc(config)->wTotalLength));\n\n\tmbox2_setup_48_24_magic(dev);\n\n\tdev_info(&dev->dev, \"Digidesign Mbox 2: 24bit 48kHz\");\n\n\treturn 0; /* Successful boot */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0f886ca12765d20124bd06291c82951fd49a33be",
        "vul_func_with_fix": "static int snd_usb_mbox2_boot_quirk(struct usb_device *dev)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint err;\n\tu8 bootresponse[0x12];\n\tint fwsize;\n\tint count;\n\n\tfwsize = le16_to_cpu(get_cfg_desc(config)->wTotalLength);\n\n\tif (fwsize != MBOX2_FIRMWARE_SIZE) {\n\t\tdev_err(&dev->dev, \"Invalid firmware size=%d.\\n\", fwsize);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"Sending Digidesign Mbox 2 boot sequence...\\n\");\n\n\tcount = 0;\n\tbootresponse[0] = MBOX2_BOOT_LOADING;\n\twhile ((bootresponse[0] == MBOX2_BOOT_LOADING) && (count < 10)) {\n\t\tmsleep(500); /* 0.5 second delay */\n\t\tsnd_usb_ctl_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t/* Control magic - load onboard firmware */\n\t\t\t0x85, 0xc0, 0x0001, 0x0000, &bootresponse, 0x0012);\n\t\tif (bootresponse[0] == MBOX2_BOOT_READY)\n\t\t\tbreak;\n\t\tdev_dbg(&dev->dev, \"device not ready, resending boot sequence...\\n\");\n\t\tcount++;\n\t}\n\n\tif (bootresponse[0] != MBOX2_BOOT_READY) {\n\t\tdev_err(&dev->dev, \"Unknown bootresponse=%d, or timed out, ignoring device.\\n\", bootresponse[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&dev->dev, \"device initialised!\\n\");\n\n\terr = usb_get_descriptor(dev, USB_DT_DEVICE, 0,\n\t\t&dev->descriptor, sizeof(dev->descriptor));\n\tconfig = dev->actconfig;\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_get_descriptor: %d\\n\", err);\n\n\terr = usb_reset_configuration(dev);\n\tif (err < 0)\n\t\tdev_dbg(&dev->dev, \"error usb_reset_configuration: %d\\n\", err);\n\tdev_dbg(&dev->dev, \"mbox2_boot: new boot length = %d\\n\",\n\t\tle16_to_cpu(get_cfg_desc(config)->wTotalLength));\n\n\tmbox2_setup_48_24_magic(dev);\n\n\tdev_info(&dev->dev, \"Digidesign Mbox 2: 24bit 48kHz\");\n\n\treturn 0; /* Successful boot */\n}\n",
        "linevul": 4.941246152156964e-05,
        "sysevr": 0.13809962570667267,
        "devign": 1.983603924320537e-19
    },
    {
        "code": "static void init_reg_state(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tmark_reg_not_init(env, regs, i);\n\t\tregs[i].live = REG_LIVE_NONE;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = PTR_TO_STACK;\n\tmark_reg_known_zero(env, regs, BPF_REG_FP);\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n\tmark_reg_known_zero(env, regs, BPF_REG_1);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
        "vul_func_with_fix": "static void init_reg_state(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tmark_reg_not_init(env, regs, i);\n\t\tregs[i].live = REG_LIVE_NONE;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = PTR_TO_STACK;\n\tmark_reg_known_zero(env, regs, BPF_REG_FP);\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n\tmark_reg_known_zero(env, regs, BPF_REG_1);\n}\n",
        "linevul": 4.546671698335558e-05,
        "sysevr": 0.14432653784751892,
        "devign": 1.0914927163601607e-32
    },
    {
        "code": "misdn_sock_init(u_int *deb)\n{\n\tint err;\n\n\tdebug = deb;\n\terr = sock_register(&mISDN_sock_family_ops);\n\tif (err)\n\t\tprintk(KERN_ERR \"%s: error(%d)\\n\", __func__, err);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "misdn_sock_init(u_int *deb)\n{\n\tint err;\n\n\tdebug = deb;\n\terr = sock_register(&mISDN_sock_family_ops);\n\tif (err)\n\t\tprintk(KERN_ERR \"%s: error(%d)\\n\", __func__, err);\n\treturn err;\n}\n",
        "linevul": 5.29888020537328e-05,
        "sysevr": 0.16070742905139923,
        "devign": 3.3018233807524666e-05
    },
    {
        "code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2",
        "vul_func_with_fix": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n//fix_flaw_line_below:\n//\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n//fix_flaw_line_below:\n//\t\t\tret = -EINVAL;\n//fix_flaw_line_below:\n//\t\t\tgoto out_err1;\n//fix_flaw_line_below:\n//\t\t}\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n",
        "linevul": 0.00013813283294439316,
        "sysevr": 0.1953708678483963,
        "devign": 2.8568507694053114e-13
    },
    {
        "code": "static void intel_pmu_pebs_enable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (cpuc->pebs_enabled)\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, cpuc->pebs_enabled);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static void intel_pmu_pebs_enable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tif (cpuc->pebs_enabled)\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, cpuc->pebs_enabled);\n}\n",
        "linevul": 5.0630907935556024e-05,
        "sysevr": 0.12817102670669556,
        "devign": 1.6462798138605628e-11
    },
    {
        "code": "void vhost_ubuf_put_and_wait(struct vhost_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n\tkfree(ubufs);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bd97120fc3d1a11f3124c7c9ba1d91f51829eb85",
        "vul_func_with_fix": "void vhost_ubuf_put_and_wait(struct vhost_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n\tkfree(ubufs);\n}\n",
        "linevul": 0.00015039020217955112,
        "sysevr": 0.15830755233764648,
        "devign": 0.9388710260391235
    },
    {
        "code": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n\tif (np->opt)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n \n \ttcp_ca_openreq_child(newsk, dst);\n \n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "vul_func_with_fix": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n//fix_flaw_line_below:\n//\tstruct ipv6_txoptions *opt;\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n//flaw_line_below:\n\tif (np->opt)\n//flaw_line_below:\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n//flaw_line_below:\n\n//fix_flaw_line_below:\n//\topt = rcu_dereference(np->opt);\n//fix_flaw_line_below:\n//\tif (opt) {\n//fix_flaw_line_below:\n//\t\topt = ipv6_dup_options(newsk, opt);\n//fix_flaw_line_below:\n//\t\tRCU_INIT_POINTER(newnp->opt, opt);\n//fix_flaw_line_below:\n//\t}\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n//flaw_line_below:\n\tif (newnp->opt)\n//flaw_line_below:\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n//flaw_line_below:\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n//fix_flaw_line_below:\n//\tif (opt)\n//fix_flaw_line_below:\n//\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    opt->opt_flen;\n \n \ttcp_ca_openreq_child(newsk, dst);\n \n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "linevul": 0.9971515536308289,
        "sysevr": 0.26217120885849,
        "devign": 1.4786769031438496e-11
    },
    {
        "code": "static inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,\n\t\t\t\t\t     struct net *net, unsigned int num)\n{\n\treturn &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cf970c002d270c36202bd5b9c2804d3097a52da0",
        "vul_func_with_fix": "static inline struct hlist_nulls_head *ping_hashslot(struct ping_table *table,\n\t\t\t\t\t     struct net *net, unsigned int num)\n{\n\treturn &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];\n}\n",
        "linevul": 9.715338819660246e-05,
        "sysevr": 0.1248319000005722,
        "devign": 7.399316619485785e-13
    },
    {
        "code": "static int udf_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\tstruct inode *inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\terr = -EIO;\n\tinode = udf_new_inode(dir, mode, &err);\n\tif (!inode)\n\t\tgoto out;\n\n\tiinfo = UDF_I(inode);\n\tinit_special_inode(inode, mode, rdev);\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tinode_dec_link_count(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\td_instantiate(dentry, inode);\n\terr = 0;\n\nout:\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0143fc5e9f6f5aad4764801015bc8d4b4a278200",
        "vul_func_with_fix": "static int udf_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t     dev_t rdev)\n{\n\tstruct inode *inode;\n\tstruct udf_fileident_bh fibh;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\terr = -EIO;\n\tinode = udf_new_inode(dir, mode, &err);\n\tif (!inode)\n\t\tgoto out;\n\n\tiinfo = UDF_I(inode);\n\tinit_special_inode(inode, mode, rdev);\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tinode_dec_link_count(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tmark_inode_dirty(inode);\n\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\td_instantiate(dentry, inode);\n\terr = 0;\n\nout:\n\treturn err;\n}\n",
        "linevul": 6.490483065135777e-05,
        "sysevr": 0.1225971207022667,
        "devign": 0.0
    },
    {
        "code": "static int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn siocdevprivate_ioctl(net, cmd, argp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn old_bridge_ioctl(argp);\n\tcase SIOCGIFNAME:\n\t\treturn dev_ifname32(net, argp);\n\tcase SIOCGIFCONF:\n\t\treturn dev_ifconf(net, argp);\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(net, argp);\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\t\treturn compat_sioc_ifmap(net, cmd, argp);\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\treturn bond_ioctl(net, cmd, argp);\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn routing_ioctl(net, sock, cmd, argp);\n\tcase SIOCGSTAMP:\n\t\treturn do_siocgstamp(net, sock, cmd, argp);\n\tcase SIOCGSTAMPNS:\n\t\treturn do_siocgstampns(net, sock, cmd, argp);\n\tcase SIOCSHWTSTAMP:\n\t\treturn compat_siocshwtstamp(net, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCADDDLCI:\n\tcase SIOCDELDLCI:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn dev_ifsioc(net, sock, cmd, argp);\n\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCATMARK:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\t/* Prevent warning from compat_sys_ioctl, these always\n\t * result in -EINVAL in the native case anyway. */\n\tswitch (cmd) {\n\tcase SIOCRTMSG:\n\tcase SIOCGIFCOUNT:\n\tcase SIOCSRARP:\n\tcase SIOCGRARP:\n\tcase SIOCDRARP:\n\tcase SIOCSIFLINK:\n\tcase SIOCGIFSLAVE:\n\tcase SIOCSIFSLAVE:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c",
        "vul_func_with_fix": "static int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn siocdevprivate_ioctl(net, cmd, argp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn old_bridge_ioctl(argp);\n\tcase SIOCGIFNAME:\n\t\treturn dev_ifname32(net, argp);\n\tcase SIOCGIFCONF:\n\t\treturn dev_ifconf(net, argp);\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(net, argp);\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\t\treturn compat_sioc_ifmap(net, cmd, argp);\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\treturn bond_ioctl(net, cmd, argp);\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn routing_ioctl(net, sock, cmd, argp);\n\tcase SIOCGSTAMP:\n\t\treturn do_siocgstamp(net, sock, cmd, argp);\n\tcase SIOCGSTAMPNS:\n\t\treturn do_siocgstampns(net, sock, cmd, argp);\n\tcase SIOCSHWTSTAMP:\n\t\treturn compat_siocshwtstamp(net, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCADDDLCI:\n\tcase SIOCDELDLCI:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn dev_ifsioc(net, sock, cmd, argp);\n\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCATMARK:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\t/* Prevent warning from compat_sys_ioctl, these always\n\t * result in -EINVAL in the native case anyway. */\n\tswitch (cmd) {\n\tcase SIOCRTMSG:\n\tcase SIOCGIFCOUNT:\n\tcase SIOCSRARP:\n\tcase SIOCGRARP:\n\tcase SIOCDRARP:\n\tcase SIOCSIFLINK:\n\tcase SIOCGIFSLAVE:\n\tcase SIOCSIFSLAVE:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n",
        "linevul": 5.833608884131536e-05,
        "sysevr": 0.13421404361724854,
        "devign": 1.1621134598545874e-33
    },
    {
        "code": "static int need_fallback(unsigned int key_len)\n{\n\tswitch (key_len) {\n\tcase 16:\n\t\tif (!(keylen_flag & AES_KEYLEN_128))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 24:\n\t\tif (!(keylen_flag & AES_KEYLEN_192))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 32:\n\t\tif (!(keylen_flag & AES_KEYLEN_256))\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int need_fallback(unsigned int key_len)\n{\n\tswitch (key_len) {\n\tcase 16:\n\t\tif (!(keylen_flag & AES_KEYLEN_128))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 24:\n\t\tif (!(keylen_flag & AES_KEYLEN_192))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 32:\n\t\tif (!(keylen_flag & AES_KEYLEN_256))\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "linevul": 0.00033420693944208324,
        "sysevr": 0.15679413080215454,
        "devign": 6.388246875932424e-11
    },
    {
        "code": "static gro_result_t napi_skb_finish(gro_result_t ret, struct sk_buff *skb)\n{\n\tswitch (ret) {\n\tcase GRO_NORMAL:\n\t\tif (netif_receive_skb_internal(skb))\n\t\t\tret = GRO_DROP;\n\t\tbreak;\n\n\tcase GRO_DROP:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\n\tcase GRO_MERGED_FREE:\n\t\tif (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD) {\n\t\t\tskb_dst_drop(skb);\n\t\t\tkmem_cache_free(skbuff_head_cache, skb);\n\t\t} else {\n\t\t\t__kfree_skb(skb);\n\t\t}\n\t\tbreak;\n\n\tcase GRO_HELD:\n\tcase GRO_MERGED:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
        "vul_func_with_fix": "static gro_result_t napi_skb_finish(gro_result_t ret, struct sk_buff *skb)\n{\n\tswitch (ret) {\n\tcase GRO_NORMAL:\n\t\tif (netif_receive_skb_internal(skb))\n\t\t\tret = GRO_DROP;\n\t\tbreak;\n\n\tcase GRO_DROP:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\n\tcase GRO_MERGED_FREE:\n\t\tif (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD) {\n\t\t\tskb_dst_drop(skb);\n\t\t\tkmem_cache_free(skbuff_head_cache, skb);\n\t\t} else {\n\t\t\t__kfree_skb(skb);\n\t\t}\n\t\tbreak;\n\n\tcase GRO_HELD:\n\tcase GRO_MERGED:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 4.8826856072992086e-05,
        "sysevr": 0.12609344720840454,
        "devign": 2.657340184585182e-22
    },
    {
        "code": "void md_wakeup_thread(struct md_thread *thread)\n{\n\tif (thread) {\n\t\tpr_debug(\"md: waking up MD thread %s.\\n\", thread->tsk->comm);\n\t\tset_bit(THREAD_WAKEUP, &thread->flags);\n\t\twake_up(&thread->wqueue);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b6878d9e03043695dbf3fa1caa6dfc09db225b16",
        "vul_func_with_fix": "void md_wakeup_thread(struct md_thread *thread)\n{\n\tif (thread) {\n\t\tpr_debug(\"md: waking up MD thread %s.\\n\", thread->tsk->comm);\n\t\tset_bit(THREAD_WAKEUP, &thread->flags);\n\t\twake_up(&thread->wqueue);\n\t}\n}\n",
        "linevul": 5.867485742783174e-05,
        "sysevr": 0.15566590428352356,
        "devign": 1.4645530654888717e-06
    },
    {
        "code": "static void __prog_put_common(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tfree_used_maps(aux);\n\tbpf_prog_uncharge_memlock(aux->prog);\n\tbpf_prog_free(aux->prog);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e",
        "vul_func_with_fix": "static void __prog_put_common(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tfree_used_maps(aux);\n\tbpf_prog_uncharge_memlock(aux->prog);\n\tbpf_prog_free(aux->prog);\n}\n",
        "linevul": 6.153630965854973e-05,
        "sysevr": 0.1275424063205719,
        "devign": 2.1061774546637935e-08
    },
    {
        "code": "static bool is_imm8(int value)\n{\n\treturn value <= 127 && value >= -128;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3f7352bf21f8fd7ba3e2fcef9488756f188e12be",
        "vul_func_with_fix": "static bool is_imm8(int value)\n{\n\treturn value <= 127 && value >= -128;\n}\n",
        "linevul": 5.0061498768627644e-05,
        "sysevr": 0.12958762049674988,
        "devign": 0.000472996907774359
    },
    {
        "code": "int kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tiov_iter_kvec(&msg->msg_iter, READ | ITER_KVEC, vec, num, size);\n\tset_fs(KERNEL_DS);\n\tresult = sock_recvmsg(sock, msg, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8605330aac5a5785630aec8f64378a54891937cc",
        "vul_func_with_fix": "int kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tiov_iter_kvec(&msg->msg_iter, READ | ITER_KVEC, vec, num, size);\n\tset_fs(KERNEL_DS);\n\tresult = sock_recvmsg(sock, msg, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\n",
        "linevul": 5.3503474191529676e-05,
        "sysevr": 0.18011324107646942,
        "devign": 2.8311411341111394e-15
    },
    {
        "code": "static int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd,\n\t\tpgoff_t pgoff, unsigned int flags, pte_t orig_pte)\n{\n\tpte_t *page_table;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct page *cow_page;\n\tpte_t entry;\n\tint anon = 0;\n\tstruct page *dirty_page = NULL;\n\tstruct vm_fault vmf;\n\tint ret;\n\tint page_mkwrite = 0;\n\n\t/*\n\t * If we do COW later, allocate page befor taking lock_page()\n\t * on the file cache page. This will reduce lock holding time.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\n\t\tif (unlikely(anon_vma_prepare(vma)))\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tcow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!cow_page)\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tif (mem_cgroup_newpage_charge(cow_page, mm, GFP_KERNEL)) {\n\t\t\tpage_cache_release(cow_page);\n\t\t\treturn VM_FAULT_OOM;\n\t\t}\n\t} else\n\t\tcow_page = NULL;\n\n\tvmf.virtual_address = (void __user *)(address & PAGE_MASK);\n\tvmf.pgoff = pgoff;\n\tvmf.flags = flags;\n\tvmf.page = NULL;\n\n\tret = vma->vm_ops->fault(vma, &vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t    VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\n\tif (unlikely(PageHWPoison(vmf.page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf.page);\n\t\tret = VM_FAULT_HWPOISON;\n\t\tgoto uncharge_out;\n\t}\n\n\t/*\n\t * For consistency in subsequent calls, make the faulted page always\n\t * locked.\n\t */\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf.page);\n\telse\n\t\tVM_BUG_ON(!PageLocked(vmf.page));\n\n\t/*\n\t * Should we do an early C-O-W break?\n\t */\n\tpage = vmf.page;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\t\tpage = cow_page;\n\t\t\tanon = 1;\n\t\t\tcopy_user_highpage(page, vmf.page, address, vma);\n\t\t\t__SetPageUptodate(page);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If the page will be shareable, see if the backing\n\t\t\t * address space wants to know that the page is about\n\t\t\t * to become writable\n\t\t\t */\n\t\t\tif (vma->vm_ops->page_mkwrite) {\n\t\t\t\tint tmp;\n\n\t\t\t\tunlock_page(page);\n\t\t\t\tvmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\t\t\t\ttmp = vma->vm_ops->page_mkwrite(vma, &vmf);\n\t\t\t\tif (unlikely(tmp &\n\t\t\t\t\t  (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\t\t\tret = tmp;\n\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t}\n\t\t\t\tif (unlikely(!(tmp & VM_FAULT_LOCKED))) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\tif (!page->mapping) {\n\t\t\t\t\t\tret = 0; /* retry the fault */\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tVM_BUG_ON(!PageLocked(page));\n\t\t\t\tpage_mkwrite = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/*\n\t * This silly early PAGE_DIRTY setting removes a race\n\t * due to the bad i386 page protection. But it's valid\n\t * for other architectures too.\n\t *\n\t * Note that if FAULT_FLAG_WRITE is set, we either now have\n\t * an exclusive copy of the page, or this is a shared mapping,\n\t * so we can make it writable and dirty to avoid having to\n\t * handle that later.\n\t */\n\t/* Only go through if we didn't race with anybody else... */\n\tif (likely(pte_same(*page_table, orig_pte))) {\n\t\tflush_icache_page(vma, page);\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tif (anon) {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\tpage_add_new_anon_rmap(page, vma, address);\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_FILEPAGES);\n\t\t\tpage_add_file_rmap(page);\n\t\t\tif (flags & FAULT_FLAG_WRITE) {\n\t\t\t\tdirty_page = page;\n\t\t\t\tget_page(dirty_page);\n\t\t\t}\n\t\t}\n\t\tset_pte_at(mm, address, page_table, entry);\n\n\t\t/* no need to invalidate: a not-present page won't be cached */\n\t\tupdate_mmu_cache(vma, address, page_table);\n\t} else {\n\t\tif (cow_page)\n\t\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tif (anon)\n\t\t\tpage_cache_release(page);\n\t\telse\n\t\t\tanon = 1; /* no anon but release faulted_page */\n\t}\n\n\tpte_unmap_unlock(page_table, ptl);\n\n\tif (dirty_page) {\n\t\tstruct address_space *mapping = page->mapping;\n\n\t\tif (set_page_dirty(dirty_page))\n\t\t\tpage_mkwrite = 1;\n\t\tunlock_page(dirty_page);\n\t\tput_page(dirty_page);\n\t\tif (page_mkwrite && mapping) {\n\t\t\t/*\n\t\t\t * Some device drivers do not set page.mapping but still\n\t\t\t * dirty their pages\n\t\t\t */\n\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t}\n\n\t\t/* file_update_time outside page_lock */\n\t\tif (vma->vm_file)\n\t\t\tfile_update_time(vma->vm_file);\n\t} else {\n\t\tunlock_page(vmf.page);\n\t\tif (anon)\n\t\t\tpage_cache_release(vmf.page);\n\t}\n\n\treturn ret;\n\nunwritable_page:\n\tpage_cache_release(page);\n\treturn ret;\nuncharge_out:\n\t/* fs's fault handler get error */\n\tif (cow_page) {\n\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tpage_cache_release(cow_page);\n\t}\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pmd_t *pmd,\n\t\tpgoff_t pgoff, unsigned int flags, pte_t orig_pte)\n{\n\tpte_t *page_table;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct page *cow_page;\n\tpte_t entry;\n\tint anon = 0;\n\tstruct page *dirty_page = NULL;\n\tstruct vm_fault vmf;\n\tint ret;\n\tint page_mkwrite = 0;\n\n\t/*\n\t * If we do COW later, allocate page befor taking lock_page()\n\t * on the file cache page. This will reduce lock holding time.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {\n\n\t\tif (unlikely(anon_vma_prepare(vma)))\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tcow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n\t\tif (!cow_page)\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tif (mem_cgroup_newpage_charge(cow_page, mm, GFP_KERNEL)) {\n\t\t\tpage_cache_release(cow_page);\n\t\t\treturn VM_FAULT_OOM;\n\t\t}\n\t} else\n\t\tcow_page = NULL;\n\n\tvmf.virtual_address = (void __user *)(address & PAGE_MASK);\n\tvmf.pgoff = pgoff;\n\tvmf.flags = flags;\n\tvmf.page = NULL;\n\n\tret = vma->vm_ops->fault(vma, &vmf);\n\tif (unlikely(ret & (VM_FAULT_ERROR | VM_FAULT_NOPAGE |\n\t\t\t    VM_FAULT_RETRY)))\n\t\tgoto uncharge_out;\n\n\tif (unlikely(PageHWPoison(vmf.page))) {\n\t\tif (ret & VM_FAULT_LOCKED)\n\t\t\tunlock_page(vmf.page);\n\t\tret = VM_FAULT_HWPOISON;\n\t\tgoto uncharge_out;\n\t}\n\n\t/*\n\t * For consistency in subsequent calls, make the faulted page always\n\t * locked.\n\t */\n\tif (unlikely(!(ret & VM_FAULT_LOCKED)))\n\t\tlock_page(vmf.page);\n\telse\n\t\tVM_BUG_ON(!PageLocked(vmf.page));\n\n\t/*\n\t * Should we do an early C-O-W break?\n\t */\n\tpage = vmf.page;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!(vma->vm_flags & VM_SHARED)) {\n\t\t\tpage = cow_page;\n\t\t\tanon = 1;\n\t\t\tcopy_user_highpage(page, vmf.page, address, vma);\n\t\t\t__SetPageUptodate(page);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If the page will be shareable, see if the backing\n\t\t\t * address space wants to know that the page is about\n\t\t\t * to become writable\n\t\t\t */\n\t\t\tif (vma->vm_ops->page_mkwrite) {\n\t\t\t\tint tmp;\n\n\t\t\t\tunlock_page(page);\n\t\t\t\tvmf.flags = FAULT_FLAG_WRITE|FAULT_FLAG_MKWRITE;\n\t\t\t\ttmp = vma->vm_ops->page_mkwrite(vma, &vmf);\n\t\t\t\tif (unlikely(tmp &\n\t\t\t\t\t  (VM_FAULT_ERROR | VM_FAULT_NOPAGE))) {\n\t\t\t\t\tret = tmp;\n\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t}\n\t\t\t\tif (unlikely(!(tmp & VM_FAULT_LOCKED))) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\tif (!page->mapping) {\n\t\t\t\t\t\tret = 0; /* retry the fault */\n\t\t\t\t\t\tunlock_page(page);\n\t\t\t\t\t\tgoto unwritable_page;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tVM_BUG_ON(!PageLocked(page));\n\t\t\t\tpage_mkwrite = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/*\n\t * This silly early PAGE_DIRTY setting removes a race\n\t * due to the bad i386 page protection. But it's valid\n\t * for other architectures too.\n\t *\n\t * Note that if FAULT_FLAG_WRITE is set, we either now have\n\t * an exclusive copy of the page, or this is a shared mapping,\n\t * so we can make it writable and dirty to avoid having to\n\t * handle that later.\n\t */\n\t/* Only go through if we didn't race with anybody else... */\n\tif (likely(pte_same(*page_table, orig_pte))) {\n\t\tflush_icache_page(vma, page);\n\t\tentry = mk_pte(page, vma->vm_page_prot);\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tif (anon) {\n\t\t\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\t\t\tpage_add_new_anon_rmap(page, vma, address);\n\t\t} else {\n\t\t\tinc_mm_counter_fast(mm, MM_FILEPAGES);\n\t\t\tpage_add_file_rmap(page);\n\t\t\tif (flags & FAULT_FLAG_WRITE) {\n\t\t\t\tdirty_page = page;\n\t\t\t\tget_page(dirty_page);\n\t\t\t}\n\t\t}\n\t\tset_pte_at(mm, address, page_table, entry);\n\n\t\t/* no need to invalidate: a not-present page won't be cached */\n\t\tupdate_mmu_cache(vma, address, page_table);\n\t} else {\n\t\tif (cow_page)\n\t\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tif (anon)\n\t\t\tpage_cache_release(page);\n\t\telse\n\t\t\tanon = 1; /* no anon but release faulted_page */\n\t}\n\n\tpte_unmap_unlock(page_table, ptl);\n\n\tif (dirty_page) {\n\t\tstruct address_space *mapping = page->mapping;\n\n\t\tif (set_page_dirty(dirty_page))\n\t\t\tpage_mkwrite = 1;\n\t\tunlock_page(dirty_page);\n\t\tput_page(dirty_page);\n\t\tif (page_mkwrite && mapping) {\n\t\t\t/*\n\t\t\t * Some device drivers do not set page.mapping but still\n\t\t\t * dirty their pages\n\t\t\t */\n\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t}\n\n\t\t/* file_update_time outside page_lock */\n\t\tif (vma->vm_file)\n\t\t\tfile_update_time(vma->vm_file);\n\t} else {\n\t\tunlock_page(vmf.page);\n\t\tif (anon)\n\t\t\tpage_cache_release(vmf.page);\n\t}\n\n\treturn ret;\n\nunwritable_page:\n\tpage_cache_release(page);\n\treturn ret;\nuncharge_out:\n\t/* fs's fault handler get error */\n\tif (cow_page) {\n\t\tmem_cgroup_uncharge_page(cow_page);\n\t\tpage_cache_release(cow_page);\n\t}\n\treturn ret;\n}\n",
        "linevul": 0.01504555530846119,
        "sysevr": 0.18925637006759644,
        "devign": 0.0
    },
    {
        "code": "static struct crypto_instance *crypto_rfc4543_alloc(struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct crypto_instance *inst;\n\tstruct crypto_aead_spawn *spawn;\n\tstruct crypto_alg *alg;\n\tstruct crypto_rfc4543_instance_ctx *ctx;\n\tconst char *ccm_name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn ERR_CAST(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tccm_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ccm_name))\n\t\treturn ERR_CAST(ccm_name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx = crypto_instance_ctx(inst);\n\tspawn = &ctx->aead;\n\tcrypto_set_aead_spawn(spawn, inst);\n\terr = crypto_grab_aead(spawn, ccm_name, 0,\n\t\t\t       crypto_requires_sync(algt->type, algt->mask));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\talg = crypto_aead_spawn_alg(spawn);\n\n\tcrypto_set_skcipher_spawn(&ctx->null, inst);\n\terr = crypto_grab_skcipher(&ctx->null, \"ecb(cipher_null)\", 0,\n\t\t\t\t   CRYPTO_ALG_ASYNC);\n\tif (err)\n\t\tgoto out_drop_alg;\n\n\tcrypto_skcipher_spawn_alg(&ctx->null);\n\n\terr = -EINVAL;\n\n\t/* We only support 16-byte blocks. */\n\tif (alg->cra_aead.ivsize != 16)\n\t\tgoto out_drop_ecbnull;\n\n\t/* Not a stream cipher? */\n\tif (alg->cra_blocksize != 1)\n\t\tgoto out_drop_ecbnull;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4543(%s)\", alg->cra_name) >= CRYPTO_MAX_ALG_NAME ||\n\t    snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4543(%s)\", alg->cra_driver_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_drop_ecbnull;\n\n\tinst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\n\tinst->alg.cra_flags |= alg->cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.cra_priority = alg->cra_priority;\n\tinst->alg.cra_blocksize = 1;\n\tinst->alg.cra_alignmask = alg->cra_alignmask;\n\tinst->alg.cra_type = &crypto_nivaead_type;\n\n\tinst->alg.cra_aead.ivsize = 8;\n\tinst->alg.cra_aead.maxauthsize = 16;\n\n\tinst->alg.cra_ctxsize = sizeof(struct crypto_rfc4543_ctx);\n\n\tinst->alg.cra_init = crypto_rfc4543_init_tfm;\n\tinst->alg.cra_exit = crypto_rfc4543_exit_tfm;\n\n\tinst->alg.cra_aead.setkey = crypto_rfc4543_setkey;\n\tinst->alg.cra_aead.setauthsize = crypto_rfc4543_setauthsize;\n\tinst->alg.cra_aead.encrypt = crypto_rfc4543_encrypt;\n\tinst->alg.cra_aead.decrypt = crypto_rfc4543_decrypt;\n\n\tinst->alg.cra_aead.geniv = \"seqiv\";\n\nout:\n\treturn inst;\n\nout_drop_ecbnull:\n\tcrypto_drop_skcipher(&ctx->null);\nout_drop_alg:\n\tcrypto_drop_aead(spawn);\nout_free_inst:\n\tkfree(inst);\n\tinst = ERR_PTR(err);\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "static struct crypto_instance *crypto_rfc4543_alloc(struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct crypto_instance *inst;\n\tstruct crypto_aead_spawn *spawn;\n\tstruct crypto_alg *alg;\n\tstruct crypto_rfc4543_instance_ctx *ctx;\n\tconst char *ccm_name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn ERR_CAST(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tccm_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ccm_name))\n\t\treturn ERR_CAST(ccm_name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx = crypto_instance_ctx(inst);\n\tspawn = &ctx->aead;\n\tcrypto_set_aead_spawn(spawn, inst);\n\terr = crypto_grab_aead(spawn, ccm_name, 0,\n\t\t\t       crypto_requires_sync(algt->type, algt->mask));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\talg = crypto_aead_spawn_alg(spawn);\n\n\tcrypto_set_skcipher_spawn(&ctx->null, inst);\n\terr = crypto_grab_skcipher(&ctx->null, \"ecb(cipher_null)\", 0,\n\t\t\t\t   CRYPTO_ALG_ASYNC);\n\tif (err)\n\t\tgoto out_drop_alg;\n\n\tcrypto_skcipher_spawn_alg(&ctx->null);\n\n\terr = -EINVAL;\n\n\t/* We only support 16-byte blocks. */\n\tif (alg->cra_aead.ivsize != 16)\n\t\tgoto out_drop_ecbnull;\n\n\t/* Not a stream cipher? */\n\tif (alg->cra_blocksize != 1)\n\t\tgoto out_drop_ecbnull;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4543(%s)\", alg->cra_name) >= CRYPTO_MAX_ALG_NAME ||\n\t    snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4543(%s)\", alg->cra_driver_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_drop_ecbnull;\n\n\tinst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\n\tinst->alg.cra_flags |= alg->cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.cra_priority = alg->cra_priority;\n\tinst->alg.cra_blocksize = 1;\n\tinst->alg.cra_alignmask = alg->cra_alignmask;\n\tinst->alg.cra_type = &crypto_nivaead_type;\n\n\tinst->alg.cra_aead.ivsize = 8;\n\tinst->alg.cra_aead.maxauthsize = 16;\n\n\tinst->alg.cra_ctxsize = sizeof(struct crypto_rfc4543_ctx);\n\n\tinst->alg.cra_init = crypto_rfc4543_init_tfm;\n\tinst->alg.cra_exit = crypto_rfc4543_exit_tfm;\n\n\tinst->alg.cra_aead.setkey = crypto_rfc4543_setkey;\n\tinst->alg.cra_aead.setauthsize = crypto_rfc4543_setauthsize;\n\tinst->alg.cra_aead.encrypt = crypto_rfc4543_encrypt;\n\tinst->alg.cra_aead.decrypt = crypto_rfc4543_decrypt;\n\n\tinst->alg.cra_aead.geniv = \"seqiv\";\n\nout:\n\treturn inst;\n\nout_drop_ecbnull:\n\tcrypto_drop_skcipher(&ctx->null);\nout_drop_alg:\n\tcrypto_drop_aead(spawn);\nout_free_inst:\n\tkfree(inst);\n\tinst = ERR_PTR(err);\n\tgoto out;\n}\n",
        "linevul": 5.164895992493257e-05,
        "sysevr": 0.19097428023815155,
        "devign": 2.2481895339669283e-19
    },
    {
        "code": "static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trc->rca_one_fs = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trc->rca_one_fs = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}\n",
        "linevul": 5.24950519320555e-05,
        "sysevr": 0.1258070021867752,
        "devign": 0.0006852278020232916
    },
    {
        "code": "void camellia_decrypt_cbc_2way(void *ctx, u128 *dst, const u128 *src)\n{\n\tu128 iv = *src;\n\n\tcamellia_dec_blk_2way(ctx, (u8 *)dst, (u8 *)src);\n\n\tu128_xor(&dst[1], &dst[1], &iv);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "void camellia_decrypt_cbc_2way(void *ctx, u128 *dst, const u128 *src)\n{\n\tu128 iv = *src;\n\n\tcamellia_dec_blk_2way(ctx, (u8 *)dst, (u8 *)src);\n\n\tu128_xor(&dst[1], &dst[1], &iv);\n}\n",
        "linevul": 4.844140858040191e-05,
        "sysevr": 0.16078045964241028,
        "devign": 0.0008114398224279284
    },
    {
        "code": "static int nci_add_new_protocol(struct nci_dev *ndev,\n\t\t\t\tstruct nfc_target *target,\n\t\t\t\t__u8 rf_protocol,\n\t\t\t\t__u8 rf_tech_and_mode,\n\t\t\t\tvoid *params)\n{\n\tstruct rf_tech_specific_params_nfca_poll *nfca_poll;\n\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll;\n\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll;\n\t__u32 protocol;\n\n\tif (rf_protocol == NCI_RF_PROTOCOL_T2T)\n\t\tprotocol = NFC_PROTO_MIFARE_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_ISO_DEP)\n\t\tprotocol = NFC_PROTO_ISO14443_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_T3T)\n\t\tprotocol = NFC_PROTO_FELICA_MASK;\n\telse\n\t\tprotocol = 0;\n\n\tif (!(protocol & ndev->poll_prots)) {\n\t\tpr_err(\"the target found does not have the desired protocol\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE) {\n\t\tnfca_poll = (struct rf_tech_specific_params_nfca_poll *)params;\n\n\t\ttarget->sens_res = nfca_poll->sens_res;\n\t\ttarget->sel_res = nfca_poll->sel_res;\n\t\ttarget->nfcid1_len = nfca_poll->nfcid1_len;\n\t\tif (target->nfcid1_len > 0) {\n\t\t\tmemcpy(target->nfcid1, nfca_poll->nfcid1,\n\t\t\t       target->nfcid1_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_B_PASSIVE_POLL_MODE) {\n\t\tnfcb_poll = (struct rf_tech_specific_params_nfcb_poll *)params;\n\n\t\ttarget->sensb_res_len = nfcb_poll->sensb_res_len;\n\t\tif (target->sensb_res_len > 0) {\n\t\t\tmemcpy(target->sensb_res, nfcb_poll->sensb_res,\n\t\t\t       target->sensb_res_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_F_PASSIVE_POLL_MODE) {\n\t\tnfcf_poll = (struct rf_tech_specific_params_nfcf_poll *)params;\n\n\t\ttarget->sensf_res_len = nfcf_poll->sensf_res_len;\n\t\tif (target->sensf_res_len > 0) {\n\t\t\tmemcpy(target->sensf_res, nfcf_poll->sensf_res,\n\t\t\t       target->sensf_res_len);\n\t\t}\n\t} else {\n\t\tpr_err(\"unsupported rf_tech_and_mode 0x%x\\n\", rf_tech_and_mode);\n\t\treturn -EPROTO;\n\t}\n\n\ttarget->supported_protocols |= protocol;\n\n\tpr_debug(\"protocol 0x%x\\n\", protocol);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
        "vul_func_with_fix": "static int nci_add_new_protocol(struct nci_dev *ndev,\n\t\t\t\tstruct nfc_target *target,\n\t\t\t\t__u8 rf_protocol,\n\t\t\t\t__u8 rf_tech_and_mode,\n\t\t\t\tvoid *params)\n{\n\tstruct rf_tech_specific_params_nfca_poll *nfca_poll;\n\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll;\n\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll;\n\t__u32 protocol;\n\n\tif (rf_protocol == NCI_RF_PROTOCOL_T2T)\n\t\tprotocol = NFC_PROTO_MIFARE_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_ISO_DEP)\n\t\tprotocol = NFC_PROTO_ISO14443_MASK;\n\telse if (rf_protocol == NCI_RF_PROTOCOL_T3T)\n\t\tprotocol = NFC_PROTO_FELICA_MASK;\n\telse\n\t\tprotocol = 0;\n\n\tif (!(protocol & ndev->poll_prots)) {\n\t\tpr_err(\"the target found does not have the desired protocol\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE) {\n\t\tnfca_poll = (struct rf_tech_specific_params_nfca_poll *)params;\n\n\t\ttarget->sens_res = nfca_poll->sens_res;\n\t\ttarget->sel_res = nfca_poll->sel_res;\n\t\ttarget->nfcid1_len = nfca_poll->nfcid1_len;\n\t\tif (target->nfcid1_len > 0) {\n\t\t\tmemcpy(target->nfcid1, nfca_poll->nfcid1,\n\t\t\t       target->nfcid1_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_B_PASSIVE_POLL_MODE) {\n\t\tnfcb_poll = (struct rf_tech_specific_params_nfcb_poll *)params;\n\n\t\ttarget->sensb_res_len = nfcb_poll->sensb_res_len;\n\t\tif (target->sensb_res_len > 0) {\n\t\t\tmemcpy(target->sensb_res, nfcb_poll->sensb_res,\n\t\t\t       target->sensb_res_len);\n\t\t}\n\t} else if (rf_tech_and_mode == NCI_NFC_F_PASSIVE_POLL_MODE) {\n\t\tnfcf_poll = (struct rf_tech_specific_params_nfcf_poll *)params;\n\n\t\ttarget->sensf_res_len = nfcf_poll->sensf_res_len;\n\t\tif (target->sensf_res_len > 0) {\n\t\t\tmemcpy(target->sensf_res, nfcf_poll->sensf_res,\n\t\t\t       target->sensf_res_len);\n\t\t}\n\t} else {\n\t\tpr_err(\"unsupported rf_tech_and_mode 0x%x\\n\", rf_tech_and_mode);\n\t\treturn -EPROTO;\n\t}\n\n\ttarget->supported_protocols |= protocol;\n\n\tpr_debug(\"protocol 0x%x\\n\", protocol);\n\n\treturn 0;\n}\n",
        "linevul": 4.9308153393212706e-05,
        "sysevr": 0.1394786536693573,
        "devign": 1.3543585333647107e-18
    },
    {
        "code": "static int f2fs_set_context(struct inode *inode, const void *ctx, size_t len,\n\t\t\t\t\t\t\tvoid *fs_data)\n{\n\treturn f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\n\t\t\t\tF2FS_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\tctx, len, fs_data, XATTR_CREATE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/15d3042a937c13f5d9244241c7a9c8416ff6e82a",
        "vul_func_with_fix": "static int f2fs_set_context(struct inode *inode, const void *ctx, size_t len,\n\t\t\t\t\t\t\tvoid *fs_data)\n{\n\treturn f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\n\t\t\t\tF2FS_XATTR_NAME_ENCRYPTION_CONTEXT,\n\t\t\t\tctx, len, fs_data, XATTR_CREATE);\n}\n",
        "linevul": 7.970529986778274e-05,
        "sysevr": 0.12881672382354736,
        "devign": 5.120784685175295e-09
    },
    {
        "code": "static ssize_t ucma_join_ip_multicast(struct ucma_file *file,\n\t\t\t\t      const char __user *inbuf,\n\t\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_ip_mcast cmd;\n\tstruct rdma_ucm_join_mcast join_cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tjoin_cmd.response = cmd.response;\n\tjoin_cmd.uid = cmd.uid;\n\tjoin_cmd.id = cmd.id;\n\tjoin_cmd.addr_size = rdma_addr_size((struct sockaddr *) &cmd.addr);\n\tjoin_cmd.reserved = 0;\n\tmemcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);\n\n\treturn ucma_process_join(file, &join_cmd, out_len);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static ssize_t ucma_join_ip_multicast(struct ucma_file *file,\n\t\t\t\t      const char __user *inbuf,\n\t\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_ip_mcast cmd;\n\tstruct rdma_ucm_join_mcast join_cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tjoin_cmd.response = cmd.response;\n\tjoin_cmd.uid = cmd.uid;\n\tjoin_cmd.id = cmd.id;\n\tjoin_cmd.addr_size = rdma_addr_size((struct sockaddr *) &cmd.addr);\n\tjoin_cmd.reserved = 0;\n\tmemcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);\n\n\treturn ucma_process_join(file, &join_cmd, out_len);\n}\n",
        "linevul": 6.283818220254034e-05,
        "sysevr": 0.13021008670330048,
        "devign": 0.5821024775505066
    },
    {
        "code": "void __init acpi_initrd_override(void *data, size_t size)\n{\n\tint sig, no, table_nr = 0, total_offset = 0;\n\tlong offset = 0;\n\tstruct acpi_table_header *table;\n\tchar cpio_path[32] = \"kernel/firmware/acpi/\";\n\tstruct cpio_data file;\n\n\tif (data == NULL || size == 0)\n\t\treturn;\n\n\tfor (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {\n\t\tfile = find_cpio_data(cpio_path, data, size, &offset);\n\t\tif (!file.data)\n\t\t\tbreak;\n\n\t\tdata += offset;\n\t\tsize -= offset;\n\n\t\tif (file.size < sizeof(struct acpi_table_header)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttable = file.data;\n\n\t\tfor (sig = 0; table_sigs[sig]; sig++)\n\t\t\tif (!memcmp(table->signature, table_sigs[sig], 4))\n\t\t\t\tbreak;\n\n\t\tif (!table_sigs[sig]) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Unknown signature [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (file.size != table->length) {\n\t\t\tpr_err(\"ACPI OVERRIDE: File length does not match table length [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (acpi_table_checksum(file.data, table->length)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Bad table checksum [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"%4.4s ACPI table found in initrd [%s%s][0x%x]\\n\",\n\t\t\ttable->signature, cpio_path, file.name, table->length);\n\n\t\tall_tables_size += table->length;\n\t\tacpi_initrd_files[table_nr].data = file.data;\n\t\tacpi_initrd_files[table_nr].size = file.size;\n\t\ttable_nr++;\n\t}\n \tif (table_nr == 0)\n \t\treturn;\n \n \tacpi_tables_addr =\n \t\tmemblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,\n \t\t\t\t       all_tables_size, PAGE_SIZE);\n\tif (!acpi_tables_addr) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\t/*\n\t * Only calling e820_add_reserve does not work and the\n\t * tables are invalid (memory got used) later.\n\t * memblock_reserve works as expected and the tables won't get modified.\n\t * But it's not enough on X86 because ioremap will\n\t * complain later (used by acpi_os_map_memory) that the pages\n\t * that should get mapped are not marked \"reserved\".\n\t * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)\n\t * works fine.\n\t */\n\tmemblock_reserve(acpi_tables_addr, all_tables_size);\n\tarch_reserve_mem_area(acpi_tables_addr, all_tables_size);\n\n\t/*\n\t * early_ioremap only can remap 256k one time. If we map all\n\t * tables one time, we will hit the limit. Need to map chunks\n\t * one by one during copying the same as that in relocate_initrd().\n\t */\n\tfor (no = 0; no < table_nr; no++) {\n\t\tunsigned char *src_p = acpi_initrd_files[no].data;\n\t\tphys_addr_t size = acpi_initrd_files[no].size;\n\t\tphys_addr_t dest_addr = acpi_tables_addr + total_offset;\n\t\tphys_addr_t slop, clen;\n\t\tchar *dest_p;\n\n\t\ttotal_offset += size;\n\n\t\twhile (size) {\n\t\t\tslop = dest_addr & ~PAGE_MASK;\n\t\t\tclen = size;\n\t\t\tif (clen > MAP_CHUNK_SIZE - slop)\n\t\t\t\tclen = MAP_CHUNK_SIZE - slop;\n\t\t\tdest_p = early_ioremap(dest_addr & PAGE_MASK,\n\t\t\t\t\t\t clen + slop);\n\t\t\tmemcpy(dest_p + slop, src_p, clen);\n\t\t\tearly_iounmap(dest_p, clen + slop);\n\t\t\tsrc_p += clen;\n\t\t\tdest_addr += clen;\n\t\t\tsize -= clen;\n\t\t}\n\t}\n}\n",
        "label": "1",
        "addr": "https://github.com/mjg59/linux/commit/a4a5ed2835e8ea042868b7401dced3f517cafa76",
        "vul_func_with_fix": "void __init acpi_initrd_override(void *data, size_t size)\n{\n\tint sig, no, table_nr = 0, total_offset = 0;\n\tlong offset = 0;\n\tstruct acpi_table_header *table;\n\tchar cpio_path[32] = \"kernel/firmware/acpi/\";\n\tstruct cpio_data file;\n\n\tif (data == NULL || size == 0)\n\t\treturn;\n\n\tfor (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {\n\t\tfile = find_cpio_data(cpio_path, data, size, &offset);\n\t\tif (!file.data)\n\t\t\tbreak;\n\n\t\tdata += offset;\n\t\tsize -= offset;\n\n\t\tif (file.size < sizeof(struct acpi_table_header)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttable = file.data;\n\n\t\tfor (sig = 0; table_sigs[sig]; sig++)\n\t\t\tif (!memcmp(table->signature, table_sigs[sig], 4))\n\t\t\t\tbreak;\n\n\t\tif (!table_sigs[sig]) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Unknown signature [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (file.size != table->length) {\n\t\t\tpr_err(\"ACPI OVERRIDE: File length does not match table length [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (acpi_table_checksum(file.data, table->length)) {\n\t\t\tpr_err(\"ACPI OVERRIDE: Bad table checksum [%s%s]\\n\",\n\t\t\t\tcpio_path, file.name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"%4.4s ACPI table found in initrd [%s%s][0x%x]\\n\",\n\t\t\ttable->signature, cpio_path, file.name, table->length);\n\n\t\tall_tables_size += table->length;\n\t\tacpi_initrd_files[table_nr].data = file.data;\n\t\tacpi_initrd_files[table_nr].size = file.size;\n\t\ttable_nr++;\n\t}\n \tif (table_nr == 0)\n \t\treturn;\n \n//fix_flaw_line_below:\n//\tif (get_securelevel() > 0) {\n//fix_flaw_line_below:\n//\t\tpr_notice(PREFIX\n//fix_flaw_line_below:\n//\t\t\t\"securelevel enabled, ignoring table override\\n\");\n//fix_flaw_line_below:\n//\t\treturn;\n//fix_flaw_line_below:\n//\t}\n//fix_flaw_line_below:\n//\n \tacpi_tables_addr =\n \t\tmemblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,\n \t\t\t\t       all_tables_size, PAGE_SIZE);\n\tif (!acpi_tables_addr) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\t/*\n\t * Only calling e820_add_reserve does not work and the\n\t * tables are invalid (memory got used) later.\n\t * memblock_reserve works as expected and the tables won't get modified.\n\t * But it's not enough on X86 because ioremap will\n\t * complain later (used by acpi_os_map_memory) that the pages\n\t * that should get mapped are not marked \"reserved\".\n\t * Both memblock_reserve and e820_add_region (via arch_reserve_mem_area)\n\t * works fine.\n\t */\n\tmemblock_reserve(acpi_tables_addr, all_tables_size);\n\tarch_reserve_mem_area(acpi_tables_addr, all_tables_size);\n\n\t/*\n\t * early_ioremap only can remap 256k one time. If we map all\n\t * tables one time, we will hit the limit. Need to map chunks\n\t * one by one during copying the same as that in relocate_initrd().\n\t */\n\tfor (no = 0; no < table_nr; no++) {\n\t\tunsigned char *src_p = acpi_initrd_files[no].data;\n\t\tphys_addr_t size = acpi_initrd_files[no].size;\n\t\tphys_addr_t dest_addr = acpi_tables_addr + total_offset;\n\t\tphys_addr_t slop, clen;\n\t\tchar *dest_p;\n\n\t\ttotal_offset += size;\n\n\t\twhile (size) {\n\t\t\tslop = dest_addr & ~PAGE_MASK;\n\t\t\tclen = size;\n\t\t\tif (clen > MAP_CHUNK_SIZE - slop)\n\t\t\t\tclen = MAP_CHUNK_SIZE - slop;\n\t\t\tdest_p = early_ioremap(dest_addr & PAGE_MASK,\n\t\t\t\t\t\t clen + slop);\n\t\t\tmemcpy(dest_p + slop, src_p, clen);\n\t\t\tearly_iounmap(dest_p, clen + slop);\n\t\t\tsrc_p += clen;\n\t\t\tdest_addr += clen;\n\t\t\tsize -= clen;\n\t\t}\n\t}\n}\n",
        "linevul": 0.02308696322143078,
        "sysevr": 0.2588023841381073,
        "devign": 0.544924259185791
    },
    {
        "code": "static ssize_t uvesafb_show_oem_string(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_string_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t(char *)(&par->vbe_ib) + par->vbe_ib.oem_string_ptr);\n\telse\n\t\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713",
        "vul_func_with_fix": "static ssize_t uvesafb_show_oem_string(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fb_info *info = platform_get_drvdata(to_platform_device(dev));\n\tstruct uvesafb_par *par = info->par;\n\n\tif (par->vbe_ib.oem_string_ptr)\n\t\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t(char *)(&par->vbe_ib) + par->vbe_ib.oem_string_ptr);\n\telse\n\t\treturn 0;\n}\n",
        "linevul": 5.3834039135836065e-05,
        "sysevr": 0.12708529829978943,
        "devign": 1.0663813446642675e-13
    },
    {
        "code": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n \tclear_ptrace_hw_breakpoint(p);\n \n \tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n \n \tthread_notify(THREAD_NOTIFY_COPY, thread);\n \n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760",
        "vul_func_with_fix": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n \tclear_ptrace_hw_breakpoint(p);\n \n \tif (clone_flags & CLONE_SETTLS)\n//flaw_line_below:\n\t\tthread->tp_value = childregs->ARM_r3;\n//fix_flaw_line_below:\n//\t\tthread->tp_value[0] = childregs->ARM_r3;\n//fix_flaw_line_below:\n//\tthread->tp_value[1] = get_tpuser();\n \n \tthread_notify(THREAD_NOTIFY_COPY, thread);\n \n\treturn 0;\n}\n",
        "linevul": 0.00016206633881665766,
        "sysevr": 0.2463480681180954,
        "devign": 0.9881412982940674
    },
    {
        "code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n \tstruct waitid_info info = {.status = 0};\n \tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n \tint signo = 0;\n \tif (err > 0) {\n \t\tsigno = SIGCHLD;\n \t\terr = 0;\n\t}\n\tif (!err) {\n \t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n \t\t\treturn -EFAULT;\n \t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6c85501f2fabcfc4fc6ed976543d252c4eaf4be9",
        "vul_func_with_fix": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n \tstruct waitid_info info = {.status = 0};\n \tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n \tint signo = 0;\n//fix_flaw_line_below:\n//\n \tif (err > 0) {\n \t\tsigno = SIGCHLD;\n \t\terr = 0;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (!err) {\n \t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n \t\t\treturn -EFAULT;\n \t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n",
        "linevul": 0.9983766078948975,
        "sysevr": 0.17197029292583466,
        "devign": 0.6145539283752441
    },
    {
        "code": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\n\tBUG_ON(!ns);\n\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\n\told = ns->root;\n\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\n\tnamespace_lock();\n\t/* First pass: copy the tree topology */\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\n\t/*\n\t * Second pass: switch the tsk->fs->* elements and mark new vfsmounts\n\t * as belonging to new namespace.  We have already acquired a private\n\t * fs_struct, so tsk->fs->lock is not needed.\n\t */\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\n\treturn new_ns;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9566d6742852c527bf5af38af5cbb878dad75705",
        "vul_func_with_fix": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\n\tBUG_ON(!ns);\n\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\n\told = ns->root;\n\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\n\tnamespace_lock();\n\t/* First pass: copy the tree topology */\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\n\t/*\n\t * Second pass: switch the tsk->fs->* elements and mark new vfsmounts\n\t * as belonging to new namespace.  We have already acquired a private\n\t * fs_struct, so tsk->fs->lock is not needed.\n\t */\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\n\treturn new_ns;\n}\n",
        "linevul": 0.00018357370572630316,
        "sysevr": 0.21925406157970428,
        "devign": 0.848137378692627
    },
    {
        "code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n \tu32 mask = 0;\n \tint err;\n \n\tmcryptd_check_internal(tb, &type, &mask);\n \n \thalg = ahash_attr_alg(tb[1], type, mask);\n \tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/48a992727d82cb7db076fa15d372178743b1f4cd",
        "vul_func_with_fix": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n \tu32 mask = 0;\n \tint err;\n \n//flaw_line_below:\n\tmcryptd_check_internal(tb, &type, &mask);\n//fix_flaw_line_below:\n//\tif (!mcryptd_check_internal(tb, &type, &mask))\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n \n \thalg = ahash_attr_alg(tb[1], type, mask);\n \tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n",
        "linevul": 0.9994888305664062,
        "sysevr": 0.2181478589773178,
        "devign": 0.8952422738075256
    },
    {
        "code": "static int nfs4_realloc_slot_table(struct nfs4_slot_table *tbl, u32 max_reqs,\n\t\t\t\t u32 ivalue)\n{\n\tstruct nfs4_slot *new = NULL;\n\tint ret = -ENOMEM;\n\n\tdprintk(\"--> %s: max_reqs=%u, tbl->max_slots %d\\n\", __func__,\n\t\tmax_reqs, tbl->max_slots);\n\n\t/* Does the newly negotiated max_reqs match the existing slot table? */\n\tif (max_reqs != tbl->max_slots) {\n\t\tnew = nfs4_alloc_slots(max_reqs, GFP_NOFS);\n\t\tif (!new)\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\n\tnfs4_add_and_init_slots(tbl, new, max_reqs, ivalue);\n\tdprintk(\"%s: tbl=%p slots=%p max_slots=%d\\n\", __func__,\n\t\ttbl, tbl->slots, tbl->max_slots);\nout:\n\tdprintk(\"<-- %s: return %d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "vul_func_with_fix": "static int nfs4_realloc_slot_table(struct nfs4_slot_table *tbl, u32 max_reqs,\n\t\t\t\t u32 ivalue)\n{\n\tstruct nfs4_slot *new = NULL;\n\tint ret = -ENOMEM;\n\n\tdprintk(\"--> %s: max_reqs=%u, tbl->max_slots %d\\n\", __func__,\n\t\tmax_reqs, tbl->max_slots);\n\n\t/* Does the newly negotiated max_reqs match the existing slot table? */\n\tif (max_reqs != tbl->max_slots) {\n\t\tnew = nfs4_alloc_slots(max_reqs, GFP_NOFS);\n\t\tif (!new)\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\n\tnfs4_add_and_init_slots(tbl, new, max_reqs, ivalue);\n\tdprintk(\"%s: tbl=%p slots=%p max_slots=%d\\n\", __func__,\n\t\ttbl, tbl->slots, tbl->max_slots);\nout:\n\tdprintk(\"<-- %s: return %d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "linevul": 5.7521392591297626e-05,
        "sysevr": 0.1319519579410553,
        "devign": 2.410877275593748e-09
    },
    {
        "code": "int regulator_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\tret = _regulator_disable(rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (ret == 0 && rdev->supply)\n\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "vul_func_with_fix": "int regulator_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (regulator->always_on)\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\tret = _regulator_disable(rdev);\n\tmutex_unlock(&rdev->mutex);\n\n\tif (ret == 0 && rdev->supply)\n\t\tregulator_disable(rdev->supply);\n\n\treturn ret;\n}\n",
        "linevul": 4.531318336375989e-05,
        "sysevr": 0.15061414241790771,
        "devign": 5.058584662265275e-10
    },
    {
        "code": "ar6000_unavail_ev(void *context, void *hif_handle)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)context;\n        /* NULL out it's entry in the global list */\n    ar6000_devices[ar->arDeviceIndex] = NULL;\n    ar6000_destroy(ar->arNetDev, 1);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "ar6000_unavail_ev(void *context, void *hif_handle)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)context;\n        /* NULL out it's entry in the global list */\n    ar6000_devices[ar->arDeviceIndex] = NULL;\n    ar6000_destroy(ar->arNetDev, 1);\n\n    return 0;\n}\n",
        "linevul": 4.5941305870655924e-05,
        "sysevr": 0.1588616520166397,
        "devign": 4.657939030039415e-07
    },
    {
        "code": "static int sctp_getsockopt_connectx3(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (is_compat_task()) {\n\t\tstruct compat_sctp_getaddrs_old param32;\n\n\t\tif (len < sizeof(param32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param32, optval, sizeof(param32)))\n\t\t\treturn -EFAULT;\n\n\t\tparam.assoc_id = param32.assoc_id;\n\t\tparam.addr_num = param32.addr_num;\n\t\tparam.addrs = compat_ptr(param32.addrs);\n\t} else\n#endif\n\t{\n\t\tif (len < sizeof(param))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = __sctp_setsockopt_connectx(sk, (struct sockaddr __user *)\n\t\t\t\t\t param.addrs, param.addr_num,\n\t\t\t\t\t &assoc_id);\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4",
        "vul_func_with_fix": "static int sctp_getsockopt_connectx3(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (is_compat_task()) {\n\t\tstruct compat_sctp_getaddrs_old param32;\n\n\t\tif (len < sizeof(param32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param32, optval, sizeof(param32)))\n\t\t\treturn -EFAULT;\n\n\t\tparam.assoc_id = param32.assoc_id;\n\t\tparam.addr_num = param32.addr_num;\n\t\tparam.addrs = compat_ptr(param32.addrs);\n\t} else\n#endif\n\t{\n\t\tif (len < sizeof(param))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\terr = __sctp_setsockopt_connectx(sk, (struct sockaddr __user *)\n\t\t\t\t\t param.addrs, param.addr_num,\n\t\t\t\t\t &assoc_id);\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n",
        "linevul": 5.197941936785355e-05,
        "sysevr": 0.11720152199268341,
        "devign": 0.5964556336402893
    },
    {
        "code": "nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n \targs->verf   = p; p += 2;\n \targs->dircount = ~0;\n \targs->count  = ntohl(*p++);\n \targs->count  = min_t(u32, args->count, PAGE_SIZE);\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n\treturn xdr_argsize_check(rqstp, p);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n \targs->verf   = p; p += 2;\n \targs->dircount = ~0;\n \targs->count  = ntohl(*p++);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (!xdr_argsize_check(rqstp, p))\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\n \targs->count  = min_t(u32, args->count, PAGE_SIZE);\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n//flaw_line_below:\n\treturn xdr_argsize_check(rqstp, p);\n//fix_flaw_line_below:\n//\treturn 1;\n }\n",
        "linevul": 0.9992701411247253,
        "sysevr": 0.19495117664337158,
        "devign": 1.0
    },
    {
        "code": "void kvm_register_irq_ack_notifier(struct kvm *kvm,\n\t\t\t\t   struct kvm_irq_ack_notifier *kian)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n\tkvm_arch_post_irq_ack_notifier_list_update(kvm);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/36ae3c0a36b7456432fedce38ae2f7bd3e01a563",
        "vul_func_with_fix": "void kvm_register_irq_ack_notifier(struct kvm *kvm,\n\t\t\t\t   struct kvm_irq_ack_notifier *kian)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n\tkvm_arch_post_irq_ack_notifier_list_update(kvm);\n}\n",
        "linevul": 5.852296817465685e-05,
        "sysevr": 0.15646381676197052,
        "devign": 1.512432540318187e-11
    },
    {
        "code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n \n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n \n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9",
        "vul_func_with_fix": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n \n//fix_flaw_line_below:\n//\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n//fix_flaw_line_below:\n//\t\treturn -EINVAL;\n//fix_flaw_line_below:\n//\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n \n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}\n",
        "linevul": 0.999409556388855,
        "sysevr": 0.1465194821357727,
        "devign": 0.9973379969596863
    },
    {
        "code": "int netif_rx(struct sk_buff *skb)\n{\n\tint ret;\n\n\t/* if netpoll wants it, pretend we never saw it */\n\tif (netpoll_rx(skb))\n\t\treturn NET_RX_DROP;\n\n\tif (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);\n\n#ifdef CONFIG_RPS\n\t{\n\t\tstruct rps_dev_flow voidflow, *rflow = &voidflow;\n\t\tint cpu;\n\n\t\trcu_read_lock();\n\n\t\tcpu = get_rps_cpu(skb->dev, skb, &rflow);\n\t\tif (cpu < 0)\n\t\t\tcpu = smp_processor_id();\n\n\t\tret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);\n\n\t\trcu_read_unlock();\n\t}\n#else\n\t{\n\t\tunsigned int qtail;\n\t\tret = enqueue_to_backlog(skb, get_cpu(), &qtail);\n\t\tput_cpu();\n\t}\n#endif\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/256df2f3879efdb2e9808bdb1b54b16fbb11fa38",
        "vul_func_with_fix": "int netif_rx(struct sk_buff *skb)\n{\n\tint ret;\n\n\t/* if netpoll wants it, pretend we never saw it */\n\tif (netpoll_rx(skb))\n\t\treturn NET_RX_DROP;\n\n\tif (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);\n\n#ifdef CONFIG_RPS\n\t{\n\t\tstruct rps_dev_flow voidflow, *rflow = &voidflow;\n\t\tint cpu;\n\n\t\trcu_read_lock();\n\n\t\tcpu = get_rps_cpu(skb->dev, skb, &rflow);\n\t\tif (cpu < 0)\n\t\t\tcpu = smp_processor_id();\n\n\t\tret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);\n\n\t\trcu_read_unlock();\n\t}\n#else\n\t{\n\t\tunsigned int qtail;\n\t\tret = enqueue_to_backlog(skb, get_cpu(), &qtail);\n\t\tput_cpu();\n\t}\n#endif\n\treturn ret;\n}\n",
        "linevul": 4.9664398829918355e-05,
        "sysevr": 0.15870079398155212,
        "devign": 2.2658079856796576e-09
    },
    {
        "code": "int walk_page_vma(struct vm_area_struct *vma, struct mm_walk *walk)\n{\n\tint err;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON(!rwsem_is_locked(&walk->mm->mmap_sem));\n\tVM_BUG_ON(!vma);\n\twalk->vma = vma;\n\terr = walk_page_test(vma->vm_start, vma->vm_end, walk);\n\tif (err > 0)\n\t\treturn 0;\n\tif (err < 0)\n\t\treturn err;\n\treturn __walk_page_range(vma->vm_start, vma->vm_end, walk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/373c4557d2aa362702c4c2d41288fb1e54990b7c",
        "vul_func_with_fix": "int walk_page_vma(struct vm_area_struct *vma, struct mm_walk *walk)\n{\n\tint err;\n\n\tif (!walk->mm)\n\t\treturn -EINVAL;\n\n\tVM_BUG_ON(!rwsem_is_locked(&walk->mm->mmap_sem));\n\tVM_BUG_ON(!vma);\n\twalk->vma = vma;\n\terr = walk_page_test(vma->vm_start, vma->vm_end, walk);\n\tif (err > 0)\n\t\treturn 0;\n\tif (err < 0)\n\t\treturn err;\n\treturn __walk_page_range(vma->vm_start, vma->vm_end, walk);\n}\n",
        "linevul": 9.83450809144415e-05,
        "sysevr": 0.15486790239810944,
        "devign": 5.772712527160479e-25
    },
    {
        "code": "static inline void free_copy(struct msg_msg *copy)\n{\n\tif (copy)\n\t\tfree_msg(copy);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": "static inline void free_copy(struct msg_msg *copy)\n{\n\tif (copy)\n\t\tfree_msg(copy);\n}\n",
        "linevul": 0.00011473167251097038,
        "sysevr": 0.12563268840312958,
        "devign": 0.007537189871072769
    },
    {
        "code": "static void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(DRS->maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tDRS->maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\tDRWE->write_errors++;\n\t\t\tif (DRWE->write_errors == 1) {\n\t\t\t\tDRWE->first_error_sector = blk_rq_pos(req);\n\t\t\t\tDRWE->first_error_generation = DRS->generation;\n\t\t\t}\n\t\t\tDRWE->last_error_sector = blk_rq_pos(req);\n\t\t\tDRWE->last_error_generation = DRS->generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32",
        "vul_func_with_fix": "static void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(DRS->maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tDRS->maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\tDRWE->write_errors++;\n\t\t\tif (DRWE->write_errors == 1) {\n\t\t\t\tDRWE->first_error_sector = blk_rq_pos(req);\n\t\t\t\tDRWE->first_error_generation = DRS->generation;\n\t\t\t}\n\t\t\tDRWE->last_error_sector = blk_rq_pos(req);\n\t\t\tDRWE->last_error_generation = DRS->generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n",
        "linevul": 8.023125701583922e-05,
        "sysevr": 0.1367364376783371,
        "devign": 3.2599404946320742e-12
    },
    {
        "code": "static int tipc_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct sk_buff *skb;\n\tu32 dnode = tsk_peer_node(tsk);\n\tu32 dport = tsk_peer_port(tsk);\n\tu32 onode = tipc_own_addr(net);\n\tu32 oport = tsk->portid;\n\tint res;\n\n\tif (how != SHUT_RDWR)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (sock->state) {\n\tcase SS_CONNECTING:\n\tcase SS_CONNECTED:\n\nrestart:\n\t\tdnode = tsk_peer_node(tsk);\n\n\t\t/* Disconnect and send a 'FIN+' or 'FIN-' message to peer */\n\t\tskb = __skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\tif (TIPC_SKB_CB(skb)->handle != NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\ttipc_sk_respond(sk, skb, TIPC_CONN_SHUTDOWN);\n\t\t} else {\n\t\t\tskb = tipc_msg_create(TIPC_CRITICAL_IMPORTANCE,\n\t\t\t\t\t      TIPC_CONN_MSG, SHORT_H_SIZE,\n\t\t\t\t\t      0, dnode, onode, dport, oport,\n\t\t\t\t\t      TIPC_CONN_SHUTDOWN);\n\t\t\ttipc_node_xmit_skb(net, skb, dnode, tsk->portid);\n\t\t}\n\t\ttsk->connected = 0;\n\t\tsock->state = SS_DISCONNECTING;\n\t\ttipc_node_remove_conn(net, dnode, tsk->portid);\n\t\t/* fall through */\n\n\tcase SS_DISCONNECTING:\n\n\t\t/* Discard any unreceived messages */\n\t\t__skb_queue_purge(&sk->sk_receive_queue);\n\n\t\t/* Wake up anyone sleeping in poll */\n\t\tsk->sk_state_change(sk);\n\t\tres = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOTCONN;\n\t}\n\n\trelease_sock(sk);\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/45e093ae2830cd1264677d47ff9a95a71f5d9f9c",
        "vul_func_with_fix": "static int tipc_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct sk_buff *skb;\n\tu32 dnode = tsk_peer_node(tsk);\n\tu32 dport = tsk_peer_port(tsk);\n\tu32 onode = tipc_own_addr(net);\n\tu32 oport = tsk->portid;\n\tint res;\n\n\tif (how != SHUT_RDWR)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (sock->state) {\n\tcase SS_CONNECTING:\n\tcase SS_CONNECTED:\n\nrestart:\n\t\tdnode = tsk_peer_node(tsk);\n\n\t\t/* Disconnect and send a 'FIN+' or 'FIN-' message to peer */\n\t\tskb = __skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb) {\n\t\t\tif (TIPC_SKB_CB(skb)->handle != NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\ttipc_sk_respond(sk, skb, TIPC_CONN_SHUTDOWN);\n\t\t} else {\n\t\t\tskb = tipc_msg_create(TIPC_CRITICAL_IMPORTANCE,\n\t\t\t\t\t      TIPC_CONN_MSG, SHORT_H_SIZE,\n\t\t\t\t\t      0, dnode, onode, dport, oport,\n\t\t\t\t\t      TIPC_CONN_SHUTDOWN);\n\t\t\ttipc_node_xmit_skb(net, skb, dnode, tsk->portid);\n\t\t}\n\t\ttsk->connected = 0;\n\t\tsock->state = SS_DISCONNECTING;\n\t\ttipc_node_remove_conn(net, dnode, tsk->portid);\n\t\t/* fall through */\n\n\tcase SS_DISCONNECTING:\n\n\t\t/* Discard any unreceived messages */\n\t\t__skb_queue_purge(&sk->sk_receive_queue);\n\n\t\t/* Wake up anyone sleeping in poll */\n\t\tsk->sk_state_change(sk);\n\t\tres = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tres = -ENOTCONN;\n\t}\n\n\trelease_sock(sk);\n\treturn res;\n}\n",
        "linevul": 0.00026624754536896944,
        "sysevr": 0.1551826000213623,
        "devign": 0.0
    },
    {
        "code": "    void unmap_descbuffer(struct b43_dmaring *ring,\n\t\t\t  dma_addr_t addr, size_t len, int tx)\n{\n\tif (tx) {\n\t\tdma_unmap_single(ring->dev->dev->dma_dev,\n\t\t\t\t addr, len, DMA_TO_DEVICE);\n\t} else {\n\t\tdma_unmap_single(ring->dev->dev->dma_dev,\n\t\t\t\t addr, len, DMA_FROM_DEVICE);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a",
        "vul_func_with_fix": "    void unmap_descbuffer(struct b43_dmaring *ring,\n\t\t\t  dma_addr_t addr, size_t len, int tx)\n{\n\tif (tx) {\n\t\tdma_unmap_single(ring->dev->dev->dma_dev,\n\t\t\t\t addr, len, DMA_TO_DEVICE);\n\t} else {\n\t\tdma_unmap_single(ring->dev->dev->dma_dev,\n\t\t\t\t addr, len, DMA_FROM_DEVICE);\n\t}\n}\n",
        "linevul": 5.109742778586224e-05,
        "sysevr": 0.1904410719871521,
        "devign": 1.8635146759038435e-09
    },
    {
        "code": "static int packet_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po;\n\tstruct net *net;\n\tunion tpacket_req_u req_u;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tpo = pkt_sk(sk);\n\n\tmutex_lock(&net->packet.sklist_lock);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&net->packet.sklist_lock);\n\n\tpreempt_disable();\n\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\tpreempt_enable();\n\n\tspin_lock(&po->bind_lock);\n\tunregister_prot_hook(sk, false);\n\tif (po->prot_hook.dev) {\n\t\tdev_put(po->prot_hook.dev);\n\t\tpo->prot_hook.dev = NULL;\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tpacket_flush_mclist(sk);\n\n\tif (po->rx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 0);\n\t}\n\n\tif (po->tx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 1);\n\t}\n\n\tfanout_release(sk);\n\n\tsynchronize_net();\n\t/*\n\t *\tNow the socket is dead. No more input will appear.\n\t */\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\t/* Purge queues */\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tsk_refcnt_debug_release(sk);\n\n\tsock_put(sk);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int packet_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po;\n\tstruct net *net;\n\tunion tpacket_req_u req_u;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tnet = sock_net(sk);\n\tpo = pkt_sk(sk);\n\n\tmutex_lock(&net->packet.sklist_lock);\n\tsk_del_node_init_rcu(sk);\n\tmutex_unlock(&net->packet.sklist_lock);\n\n\tpreempt_disable();\n\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\tpreempt_enable();\n\n\tspin_lock(&po->bind_lock);\n\tunregister_prot_hook(sk, false);\n\tif (po->prot_hook.dev) {\n\t\tdev_put(po->prot_hook.dev);\n\t\tpo->prot_hook.dev = NULL;\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tpacket_flush_mclist(sk);\n\n\tif (po->rx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 0);\n\t}\n\n\tif (po->tx_ring.pg_vec) {\n\t\tmemset(&req_u, 0, sizeof(req_u));\n\t\tpacket_set_ring(sk, &req_u, 1, 1);\n\t}\n\n\tfanout_release(sk);\n\n\tsynchronize_net();\n\t/*\n\t *\tNow the socket is dead. No more input will appear.\n\t */\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\t/* Purge queues */\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tsk_refcnt_debug_release(sk);\n\n\tsock_put(sk);\n\treturn 0;\n}\n",
        "linevul": 9.418631088919938e-05,
        "sysevr": 0.12572702765464783,
        "devign": 0.38388094305992126
    },
    {
        "code": "static int ec_status(struct t3cdev *tdev, struct sk_buff *skb, void *ctx)\n{\n\tstruct cpl_rdma_ec_status *rep = cplhdr(skb);\n\tstruct iwch_ep *ep = ctx;\n\n\tPDBG(\"%s ep %p tid %u status %d\\n\", __func__, ep, ep->hwtid,\n\t     rep->status);\n\tif (rep->status) {\n\t\tstruct iwch_qp_attributes attrs;\n\n\t\tprintk(KERN_ERR MOD \"%s BAD CLOSE - Aborting tid %u\\n\",\n\t\t       __func__, ep->hwtid);\n\t\tstop_ep_timer(ep);\n\t\tattrs.next_state = IWCH_QP_STATE_ERROR;\n\t\tiwch_modify_qp(ep->com.qp->rhp,\n\t\t\t       ep->com.qp, IWCH_QP_ATTR_NEXT_STATE,\n\t\t\t       &attrs, 1);\n\t\tabort_connection(ep, NULL, GFP_KERNEL);\n\t}\n\treturn CPL_RET_BUF_DONE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3",
        "vul_func_with_fix": "static int ec_status(struct t3cdev *tdev, struct sk_buff *skb, void *ctx)\n{\n\tstruct cpl_rdma_ec_status *rep = cplhdr(skb);\n\tstruct iwch_ep *ep = ctx;\n\n\tPDBG(\"%s ep %p tid %u status %d\\n\", __func__, ep, ep->hwtid,\n\t     rep->status);\n\tif (rep->status) {\n\t\tstruct iwch_qp_attributes attrs;\n\n\t\tprintk(KERN_ERR MOD \"%s BAD CLOSE - Aborting tid %u\\n\",\n\t\t       __func__, ep->hwtid);\n\t\tstop_ep_timer(ep);\n\t\tattrs.next_state = IWCH_QP_STATE_ERROR;\n\t\tiwch_modify_qp(ep->com.qp->rhp,\n\t\t\t       ep->com.qp, IWCH_QP_ATTR_NEXT_STATE,\n\t\t\t       &attrs, 1);\n\t\tabort_connection(ep, NULL, GFP_KERNEL);\n\t}\n\treturn CPL_RET_BUF_DONE;\n}\n",
        "linevul": 4.695077586802654e-05,
        "sysevr": 0.12052766978740692,
        "devign": 6.225037710790818e-29
    },
    {
        "code": "static inline u32 get_mask(int size)\n{\n\tif (size == 1)\n\t\treturn 0xff;\n\telse if (size == 2)\n\t\treturn 0xffff;\n\telse\n\t\treturn 0xffffffff;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/af6fc858a35b90e89ea7a7ee58e66628c55c776b",
        "vul_func_with_fix": "static inline u32 get_mask(int size)\n{\n\tif (size == 1)\n\t\treturn 0xff;\n\telse if (size == 2)\n\t\treturn 0xffff;\n\telse\n\t\treturn 0xffffffff;\n}\n",
        "linevul": 0.0001471145369578153,
        "sysevr": 0.12535198032855988,
        "devign": 0.0002885836292989552
    },
    {
        "code": " static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n {\n \tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd",
        "vul_func_with_fix": " static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n {\n \tint max_irr, tpr;\n\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}\n",
        "linevul": 4.8388541472377256e-05,
        "sysevr": 0.12941136956214905,
        "devign": 3.186232424923219e-05
    },
    {
        "code": "static void announce_device(struct usb_device *udev)\n{\n\tu16 bcdDevice = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\tdev_info(&udev->dev,\n\t\t\"New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tbcdDevice >> 8, bcdDevice & 0xff);\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf",
        "vul_func_with_fix": "static void announce_device(struct usb_device *udev)\n{\n\tu16 bcdDevice = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\tdev_info(&udev->dev,\n\t\t\"New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tbcdDevice >> 8, bcdDevice & 0xff);\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n",
        "linevul": 6.159130862215534e-05,
        "sysevr": 0.1228465661406517,
        "devign": 0.44123387336730957
    },
    {
        "code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n \t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n \t\t\tsvm->vmcb->save.rflags &=\n \t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n \t}\n \n \tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d",
        "vul_func_with_fix": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n \t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n \t\t\tsvm->vmcb->save.rflags &=\n \t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n//flaw_line_below:\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n \t}\n \n \tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n",
        "linevul": 0.9990905523300171,
        "sysevr": 0.13851779699325562,
        "devign": 0.9970097541809082
    },
    {
        "code": "static int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea",
        "vul_func_with_fix": "static int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}\n",
        "linevul": 6.176582246553153e-05,
        "sysevr": 0.12921863794326782,
        "devign": 6.782420580601668e-21
    },
    {
        "code": "static void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_run->ready_for_interrupt_injection = 1;\n\telse\n\t\tkvm_run->ready_for_interrupt_injection =\n\t\t\tkvm_arch_interrupt_allowed(vcpu) &&\n\t\t\t!kvm_cpu_has_interrupt(vcpu) &&\n \t\t\t!kvm_event_needs_reinjection(vcpu);\n }\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd",
        "vul_func_with_fix": "static void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = (kvm_get_rflags(vcpu) & X86_EFLAGS_IF) != 0;\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\tif (irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_run->ready_for_interrupt_injection = 1;\n\telse\n\t\tkvm_run->ready_for_interrupt_injection =\n\t\t\tkvm_arch_interrupt_allowed(vcpu) &&\n\t\t\t!kvm_cpu_has_interrupt(vcpu) &&\n \t\t\t!kvm_event_needs_reinjection(vcpu);\n }\n",
        "linevul": 5.4219057346927e-05,
        "sysevr": 0.130924254655838,
        "devign": 4.799193526817742e-36
    },
    {
        "code": "int try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint nr = nr_shrink;\n\n\tif (!down_write_trylock(&nm_i->nat_tree_lock))\n\t\treturn 0;\n\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr - nr_shrink;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3",
        "vul_func_with_fix": "int try_to_free_nats(struct f2fs_sb_info *sbi, int nr_shrink)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tint nr = nr_shrink;\n\n\tif (!down_write_trylock(&nm_i->nat_tree_lock))\n\t\treturn 0;\n\n\twhile (nr_shrink && !list_empty(&nm_i->nat_entries)) {\n\t\tstruct nat_entry *ne;\n\t\tne = list_first_entry(&nm_i->nat_entries,\n\t\t\t\t\tstruct nat_entry, list);\n\t\t__del_from_nat_cache(nm_i, ne);\n\t\tnr_shrink--;\n\t}\n\tup_write(&nm_i->nat_tree_lock);\n\treturn nr - nr_shrink;\n}\n",
        "linevul": 9.364198194816709e-05,
        "sysevr": 0.1481100171804428,
        "devign": 3.787681350630481e-20
    },
    {
        "code": "static void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->xfrm.nlsk_stash);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->xfrm.nlsk_stash);\n}\n",
        "linevul": 5.534249794436619e-05,
        "sysevr": 0.12278709560632706,
        "devign": 0.47729095816612244
    },
    {
        "code": "static int decode_write(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_WRITE);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tREAD32(res->count);\n\tREAD32(res->verf->committed);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int decode_write(struct xdr_stream *xdr, struct nfs_writeres *res)\n{\n\t__be32 *p;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_WRITE);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tREAD32(res->count);\n\tREAD32(res->verf->committed);\n\tCOPYMEM(res->verf->verifier, 8);\n\treturn 0;\n}\n",
        "linevul": 6.277577631408349e-05,
        "sysevr": 0.12710170447826385,
        "devign": 1.3733784285231018e-27
    },
    {
        "code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\t/*\n\t * When tmpfs swaps out a page from a file, any process mapping that\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n\t * any other file mapping (ie. marked !present and faulted in with\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n\t */\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t/*\n\t\t * shmem/tmpfs may return swap: account for swapcache\n\t\t * page too.\n\t\t */\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e",
        "vul_func_with_fix": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tunsigned char present = 0;\n//flaw_line_below:\n\tstruct page *page;\n//flaw_line_below:\n\n//flaw_line_below:\n\t/*\n//flaw_line_below:\n\t * When tmpfs swaps out a page from a file, any process mapping that\n//flaw_line_below:\n\t * file will not get a swp_entry_t in its pte, but rather it is like\n//flaw_line_below:\n\t * any other file mapping (ie. marked !present and faulted in with\n//flaw_line_below:\n\t * tmpfs's .fault). So swapped out tmpfs mappings are tested here.\n//flaw_line_below:\n\t */\n//flaw_line_below:\n#ifdef CONFIG_SWAP\n//flaw_line_below:\n\tif (shmem_mapping(mapping)) {\n//flaw_line_below:\n\t\tpage = find_get_entry(mapping, pgoff);\n//flaw_line_below:\n\t\t/*\n//flaw_line_below:\n\t\t * shmem/tmpfs may return swap: account for swapcache\n//flaw_line_below:\n\t\t * page too.\n//flaw_line_below:\n\t\t */\n//flaw_line_below:\n\t\tif (xa_is_value(page)) {\n//flaw_line_below:\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n//flaw_line_below:\n\t\t\tpage = find_get_page(swap_address_space(swp),\n//flaw_line_below:\n\t\t\t\t\t     swp_offset(swp));\n//flaw_line_below:\n\t\t}\n//flaw_line_below:\n\t} else\n//flaw_line_below:\n\t\tpage = find_get_page(mapping, pgoff);\n//flaw_line_below:\n#else\n//flaw_line_below:\n\tpage = find_get_page(mapping, pgoff);\n//flaw_line_below:\n#endif\n//flaw_line_below:\n\tif (page) {\n//flaw_line_below:\n\t\tpresent = PageUptodate(page);\n//flaw_line_below:\n\t\tput_page(page);\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\n//flaw_line_below:\n\treturn present;\n//flaw_line_below:\n}\n",
        "linevul": 0.00103663036134094,
        "sysevr": 0.128109410405159,
        "devign": 0.9831352233886719
    },
    {
        "code": "static struct ppp *ppp_create_interface(struct net *net, int unit,\n\t\t\t\t\tstruct file *file, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", NET_NAME_ENUM, ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\n\tpn = ppp_pernet(net);\n\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t/* don't count proto bytes */\n\tppp->owner = file;\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif /* CONFIG_PPP_MULTILINK */\n#ifdef CONFIG_PPP_FILTER\n\tppp->pass_filter = NULL;\n\tppp->active_filter = NULL;\n#endif /* CONFIG_PPP_FILTER */\n\n\t/*\n\t * drum roll: don't forget to set\n\t * the net device is belong to\n\t */\n\tdev_net_set(dev, net);\n\n\trtnl_lock();\n\tmutex_lock(&pn->all_ppp_mutex);\n\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\tret = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; /* unit already exists */\n\t\t/*\n\t\t * if caller need a specified unit number\n\t\t * lets try to satisfy him, otherwise --\n\t\t * he should better ask us for new unit number\n\t\t *\n\t\t * NOTE: yes I know that returning EEXIST it's not\n\t\t * fair but at least pppd will ask us to allocate\n\t\t * new unit in this case so user is happy :)\n\t\t */\n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\n\t/* Initialize the new ppp unit */\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\n\tret = register_netdevice(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tnetdev_err(ppp->dev, \"PPP: couldn't register device %s (%d)\\n\",\n\t\t\t   dev->name, ret);\n\t\tgoto out2;\n\t}\n\n\tppp->ppp_net = net;\n\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\trtnl_unlock();\n\n\t*retp = 0;\n\treturn ppp;\n\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\trtnl_unlock();\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "vul_func_with_fix": "static struct ppp *ppp_create_interface(struct net *net, int unit,\n\t\t\t\t\tstruct file *file, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", NET_NAME_ENUM, ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\n\tpn = ppp_pernet(net);\n\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t/* don't count proto bytes */\n\tppp->owner = file;\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif /* CONFIG_PPP_MULTILINK */\n#ifdef CONFIG_PPP_FILTER\n\tppp->pass_filter = NULL;\n\tppp->active_filter = NULL;\n#endif /* CONFIG_PPP_FILTER */\n\n\t/*\n\t * drum roll: don't forget to set\n\t * the net device is belong to\n\t */\n\tdev_net_set(dev, net);\n\n\trtnl_lock();\n\tmutex_lock(&pn->all_ppp_mutex);\n\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\tret = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tret = -EEXIST;\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; /* unit already exists */\n\t\t/*\n\t\t * if caller need a specified unit number\n\t\t * lets try to satisfy him, otherwise --\n\t\t * he should better ask us for new unit number\n\t\t *\n\t\t * NOTE: yes I know that returning EEXIST it's not\n\t\t * fair but at least pppd will ask us to allocate\n\t\t * new unit in this case so user is happy :)\n\t\t */\n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\n\t/* Initialize the new ppp unit */\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\n\tret = register_netdevice(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tnetdev_err(ppp->dev, \"PPP: couldn't register device %s (%d)\\n\",\n\t\t\t   dev->name, ret);\n\t\tgoto out2;\n\t}\n\n\tppp->ppp_net = net;\n\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\trtnl_unlock();\n\n\t*retp = 0;\n\treturn ppp;\n\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\trtnl_unlock();\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}\n",
        "linevul": 0.007170089986175299,
        "sysevr": 0.16402944922447205,
        "devign": 1.9483107618553652e-13
    },
    {
        "code": "static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n \t\tcond_resched();\n \n \t\tBUG_ON(!vma_can_userfault(vma));\n \n \t\t/*\n \t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/29ec90660d68bbdd69507c1c8b4e33aa299278b1",
        "vul_func_with_fix": "static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n \t\tcond_resched();\n \n \t\tBUG_ON(!vma_can_userfault(vma));\n//fix_flaw_line_below:\n//\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n \n \t\t/*\n \t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}\n",
        "linevul": 0.4304715692996979,
        "sysevr": 0.18232107162475586,
        "devign": 0.9987727999687195
    },
    {
        "code": "static int cifs_ci_hash(const struct dentry *dentry, const struct inode *inode,\n\t\tstruct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash();\n\tfor (i = 0; i < q->len; i++)\n\t\thash = partial_name_hash(nls_tolower(codepage, q->name[i]),\n\t\t\t\t\t hash);\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08",
        "vul_func_with_fix": "static int cifs_ci_hash(const struct dentry *dentry, const struct inode *inode,\n\t\tstruct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash();\n\tfor (i = 0; i < q->len; i++)\n\t\thash = partial_name_hash(nls_tolower(codepage, q->name[i]),\n\t\t\t\t\t hash);\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n",
        "linevul": 4.9130077968584374e-05,
        "sysevr": 0.12692981958389282,
        "devign": 1.0780960770688286e-20
    },
    {
        "code": "static void ucma_cleanup_mc_events(struct ucma_multicast *mc)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\tlist_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {\n\t\tif (uevent->mc != mc)\n\t\t\tcontinue;\n\n\t\tlist_del(&uevent->list);\n\t\tkfree(uevent);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static void ucma_cleanup_mc_events(struct ucma_multicast *mc)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\tlist_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {\n\t\tif (uevent->mc != mc)\n\t\t\tcontinue;\n\n\t\tlist_del(&uevent->list);\n\t\tkfree(uevent);\n\t}\n}\n",
        "linevul": 5.213381155044772e-05,
        "sysevr": 0.12749095261096954,
        "devign": 1.929731524796807e-06
    },
    {
        "code": "static int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static int parse_sec_desc(struct cifs_sb_info *cifs_sb,\n\t\tstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\n{\n\tint rc = 0;\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_acl *dacl_ptr; /* no need for SACL ptr */\n\tchar *end_of_acl = ((char *)pntsd) + acl_len;\n\t__u32 dacloffset;\n\n\tif (pntsd == NULL)\n\t\treturn -EIO;\n\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tdacloffset = le32_to_cpu(pntsd->dacloffset);\n\tdacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\n\tcifs_dbg(NOISY, \"revision %d type 0x%x ooffset 0x%x goffset 0x%x sacloffset 0x%x dacloffset 0x%x\\n\",\n\t\t pntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\n\t\t le32_to_cpu(pntsd->gsidoffset),\n\t\t le32_to_cpu(pntsd->sacloffset), dacloffset);\n/*\tcifs_dump_mem(\"owner_sid: \", owner_sid_ptr, 64); */\n\trc = parse_sid(owner_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d parsing Owner SID\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to uid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = parse_sid(group_sid_ptr, end_of_acl);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Owner SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\trc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s: Error %d mapping Group SID to gid\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (dacloffset)\n\t\tparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\n\t\t\t   group_sid_ptr, fattr);\n\telse\n\t\tcifs_dbg(FYI, \"no ACL\\n\"); /* BB grant all or default perms? */\n\n\treturn rc;\n}\n",
        "linevul": 5.178567880648188e-05,
        "sysevr": 0.1647360771894455,
        "devign": 6.5051615946186835e-24
    },
    {
        "code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n \t\treturn -EOPNOTSUPP;\n \n \taddr &= KVM_PIT_CHANNEL_MASK;\n \ts = &pit_state->channels[addr];\n \n \tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/ee73f656a604d5aa9df86a97102e4e462dd79924",
        "vul_func_with_fix": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n \t\treturn -EOPNOTSUPP;\n \n \taddr &= KVM_PIT_CHANNEL_MASK;\n//fix_flaw_line_below:\n//\tif (addr == 3)\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\n \ts = &pit_state->channels[addr];\n \n \tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}\n",
        "linevul": 0.999698281288147,
        "sysevr": 0.1514202356338501,
        "devign": 0.9861057996749878
    },
    {
        "code": "static ssize_t portio_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tstruct uio_port *port = portio->port;\n\tstruct portio_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct portio_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(port, buf);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
        "vul_func_with_fix": "static ssize_t portio_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tstruct uio_port *port = portio->port;\n\tstruct portio_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct portio_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(port, buf);\n}\n",
        "linevul": 5.8598358009476215e-05,
        "sysevr": 0.13119159638881683,
        "devign": 0.31727346777915955
    },
    {
        "code": "static int tg3_poll_msix(struct napi_struct *napi, int budget)\n{\n\tstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\n\tstruct tg3 *tp = tnapi->tp;\n\tint work_done = 0;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\twhile (1) {\n\t\twork_done = tg3_poll_work(tnapi, work_done, budget);\n\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\tgoto tx_recovery;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\t/* tp->last_tag is used in tg3_int_reenable() below\n\t\t * to tell the hw how much work has been processed,\n\t\t * so we must read it before checking for more work.\n\t\t */\n\t\ttnapi->last_tag = sblk->status_tag;\n\t\ttnapi->last_irq_tag = tnapi->last_tag;\n\t\trmb();\n\n\t\t/* check for RX/TX work to do */\n\t\tif (likely(sblk->idx[0].tx_consumer == tnapi->tx_cons &&\n\t\t\t   *(tnapi->rx_rcb_prod_idx) == tnapi->rx_rcb_ptr)) {\n\n\t\t\t/* This test here is not race free, but will reduce\n\t\t\t * the number of interrupts by looping again.\n\t\t\t */\n\t\t\tif (tnapi == &tp->napi[1] && tp->rx_refill)\n\t\t\t\tcontinue;\n\n\t\t\tnapi_complete(napi);\n\t\t\t/* Reenable interrupts. */\n\t\t\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\n\n\t\t\t/* This test here is synchronized by napi_schedule()\n\t\t\t * and napi_complete() to close the race condition.\n\t\t\t */\n\t\t\tif (unlikely(tnapi == &tp->napi[1] && tp->rx_refill)) {\n\t\t\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t\t\t\t\t  HOSTCC_MODE_ENABLE |\n\t\t\t\t\t\t  tnapi->coal_now);\n\t\t\t}\n\t\t\tmmiowb();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn work_done;\n\ntx_recovery:\n\t/* work_done is guaranteed to be less than budget. */\n\tnapi_complete(napi);\n\ttg3_reset_task_schedule(tp);\n\treturn work_done;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
        "vul_func_with_fix": "static int tg3_poll_msix(struct napi_struct *napi, int budget)\n{\n\tstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\n\tstruct tg3 *tp = tnapi->tp;\n\tint work_done = 0;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\twhile (1) {\n\t\twork_done = tg3_poll_work(tnapi, work_done, budget);\n\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\tgoto tx_recovery;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\t/* tp->last_tag is used in tg3_int_reenable() below\n\t\t * to tell the hw how much work has been processed,\n\t\t * so we must read it before checking for more work.\n\t\t */\n\t\ttnapi->last_tag = sblk->status_tag;\n\t\ttnapi->last_irq_tag = tnapi->last_tag;\n\t\trmb();\n\n\t\t/* check for RX/TX work to do */\n\t\tif (likely(sblk->idx[0].tx_consumer == tnapi->tx_cons &&\n\t\t\t   *(tnapi->rx_rcb_prod_idx) == tnapi->rx_rcb_ptr)) {\n\n\t\t\t/* This test here is not race free, but will reduce\n\t\t\t * the number of interrupts by looping again.\n\t\t\t */\n\t\t\tif (tnapi == &tp->napi[1] && tp->rx_refill)\n\t\t\t\tcontinue;\n\n\t\t\tnapi_complete(napi);\n\t\t\t/* Reenable interrupts. */\n\t\t\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\n\n\t\t\t/* This test here is synchronized by napi_schedule()\n\t\t\t * and napi_complete() to close the race condition.\n\t\t\t */\n\t\t\tif (unlikely(tnapi == &tp->napi[1] && tp->rx_refill)) {\n\t\t\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t\t\t\t\t  HOSTCC_MODE_ENABLE |\n\t\t\t\t\t\t  tnapi->coal_now);\n\t\t\t}\n\t\t\tmmiowb();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn work_done;\n\ntx_recovery:\n\t/* work_done is guaranteed to be less than budget. */\n\tnapi_complete(napi);\n\ttg3_reset_task_schedule(tp);\n\treturn work_done;\n}\n",
        "linevul": 5.42191082786303e-05,
        "sysevr": 0.1540144979953766,
        "devign": 1.931782208156041e-12
    },
    {
        "code": "static void addrconf_gre_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\tidev = ipv6_find_idev(dev);\n\tif (idev == NULL) {\n\t\tpr_debug(\"%s: add_dev failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\taddrconf_addr_gen(idev, true);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77751427a1ff25b27d47a4c36b12c3c8667855ac",
        "vul_func_with_fix": "static void addrconf_gre_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\tidev = ipv6_find_idev(dev);\n\tif (idev == NULL) {\n\t\tpr_debug(\"%s: add_dev failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\taddrconf_addr_gen(idev, true);\n}\n",
        "linevul": 4.623445056495257e-05,
        "sysevr": 0.12426190078258514,
        "devign": 6.827347931448458e-08
    },
    {
        "code": "static void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tpath_put(&calldata->path);\n\tkfree(calldata);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tpath_put(&calldata->path);\n\tkfree(calldata);\n}\n",
        "linevul": 7.108133286237717e-05,
        "sysevr": 0.12832613289356232,
        "devign": 0.0012529166415333748
    },
    {
        "code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n {\n \tstruct wl_private *lp = wl_priv(dev);\n \tunsigned long flags;\n \tint         ret = 0;\n \t/*------------------------------------------------------------------------*/\n \n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n \twl_lock(lp, &flags);\n \n \tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n \n \t/* Commit the adapter parameters */\n \twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b5e2f339865fb443107e5b10603e53bbc92dc054",
        "vul_func_with_fix": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n {\n \tstruct wl_private *lp = wl_priv(dev);\n \tunsigned long flags;\n//fix_flaw_line_below:\n//\tsize_t len;\n \tint         ret = 0;\n \t/*------------------------------------------------------------------------*/\n \n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n \twl_lock(lp, &flags);\n \n \tmemset(lp->StationName, 0, sizeof(lp->StationName));\n//flaw_line_below:\n\n//flaw_line_below:\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n//fix_flaw_line_below:\n//\tlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\n//fix_flaw_line_below:\n//\tstrlcpy(lp->StationName, extra, len);\n \n \t/* Commit the adapter parameters */\n \twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} /* wvlan_set_station_nickname */\n",
        "linevul": 0.9996539354324341,
        "sysevr": 0.142581969499588,
        "devign": 0.9998558759689331
    },
    {
        "code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81",
        "vul_func_with_fix": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data;\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n",
        "linevul": 0.0002644770429469645,
        "sysevr": 0.13107559084892273,
        "devign": 1.1542603713323106e-29
    },
    {
        "code": "static int ecb_aes_decrypt(struct blkcipher_desc *desc,\n\t\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t\t   unsigned int nbytes)\n{\n\tstruct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct blkcipher_walk walk;\n\n\tif (unlikely(need_fallback(sctx->key_len)))\n\t\treturn fallback_blk_dec(desc, dst, src, nbytes);\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\treturn ecb_aes_crypt(desc, sctx->dec, sctx->key, &walk);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int ecb_aes_decrypt(struct blkcipher_desc *desc,\n\t\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t\t   unsigned int nbytes)\n{\n\tstruct s390_aes_ctx *sctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct blkcipher_walk walk;\n\n\tif (unlikely(need_fallback(sctx->key_len)))\n\t\treturn fallback_blk_dec(desc, dst, src, nbytes);\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\treturn ecb_aes_crypt(desc, sctx->dec, sctx->key, &walk);\n}\n",
        "linevul": 5.323901496012695e-05,
        "sysevr": 0.12203386425971985,
        "devign": 5.991569906882432e-08
    },
    {
        "code": "static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))\n\t\treturn -EINVAL;\n\n\tif (len < 4 || len > HCI_MAX_FRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\t\tbreak;\n\tcase HCI_CHANNEL_CONTROL:\n\t\terr = mgmt_control(sk, msg, len);\n\t\tgoto done;\n\tcase HCI_CHANNEL_MONITOR:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\thdev = hci_pi(sk)->hdev;\n\tif (!hdev) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = -ENETDOWN;\n\t\tgoto done;\n\t}\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\terr = -EFAULT;\n\t\tgoto drop;\n\t}\n\n\tbt_cb(skb)->pkt_type = *((unsigned char *) skb->data);\n\tskb_pull(skb, 1);\n\n\tif (hci_pi(sk)->channel == HCI_CHANNEL_RAW &&\n\t    bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {\n\t\tu16 opcode = get_unaligned_le16(skb->data);\n\t\tu16 ogf = hci_opcode_ogf(opcode);\n\t\tu16 ocf = hci_opcode_ocf(opcode);\n\n\t\tif (((ogf > HCI_SFLT_MAX_OGF) ||\n\t\t     !hci_test_bit(ocf & HCI_FLT_OCF_BITS,\n\t\t\t\t   &hci_sec_filter.ocf_mask[ogf])) &&\n\t\t    !capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {\n\t\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t\t} else {\n\t\t\t/* Stand-alone HCI commands must be flaged as\n\t\t\t * single-command requests.\n\t\t\t */\n\t\t\tbt_cb(skb)->req.start = true;\n\n\t\t\tskb_queue_tail(&hdev->cmd_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n\t\t}\n\t} else {\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (hci_pi(sk)->channel == HCI_CHANNEL_USER &&\n\t\t    bt_cb(skb)->pkt_type != HCI_COMMAND_PKT &&\n\t\t    bt_cb(skb)->pkt_type != HCI_ACLDATA_PKT &&\n\t\t    bt_cb(skb)->pkt_type != HCI_SCODATA_PKT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t}\n\n\terr = len;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n\ndrop:\n\tkfree_skb(skb);\n\tgoto done;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))\n\t\treturn -EINVAL;\n\n\tif (len < 4 || len > HCI_MAX_FRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\tcase HCI_CHANNEL_USER:\n\t\tbreak;\n\tcase HCI_CHANNEL_CONTROL:\n\t\terr = mgmt_control(sk, msg, len);\n\t\tgoto done;\n\tcase HCI_CHANNEL_MONITOR:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\thdev = hci_pi(sk)->hdev;\n\tif (!hdev) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (!test_bit(HCI_UP, &hdev->flags)) {\n\t\terr = -ENETDOWN;\n\t\tgoto done;\n\t}\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto done;\n\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\terr = -EFAULT;\n\t\tgoto drop;\n\t}\n\n\tbt_cb(skb)->pkt_type = *((unsigned char *) skb->data);\n\tskb_pull(skb, 1);\n\n\tif (hci_pi(sk)->channel == HCI_CHANNEL_RAW &&\n\t    bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {\n\t\tu16 opcode = get_unaligned_le16(skb->data);\n\t\tu16 ogf = hci_opcode_ogf(opcode);\n\t\tu16 ocf = hci_opcode_ocf(opcode);\n\n\t\tif (((ogf > HCI_SFLT_MAX_OGF) ||\n\t\t     !hci_test_bit(ocf & HCI_FLT_OCF_BITS,\n\t\t\t\t   &hci_sec_filter.ocf_mask[ogf])) &&\n\t\t    !capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {\n\t\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t\t} else {\n\t\t\t/* Stand-alone HCI commands must be flaged as\n\t\t\t * single-command requests.\n\t\t\t */\n\t\t\tbt_cb(skb)->req.start = true;\n\n\t\t\tskb_queue_tail(&hdev->cmd_q, skb);\n\t\t\tqueue_work(hdev->workqueue, &hdev->cmd_work);\n\t\t}\n\t} else {\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (hci_pi(sk)->channel == HCI_CHANNEL_USER &&\n\t\t    bt_cb(skb)->pkt_type != HCI_COMMAND_PKT &&\n\t\t    bt_cb(skb)->pkt_type != HCI_ACLDATA_PKT &&\n\t\t    bt_cb(skb)->pkt_type != HCI_SCODATA_PKT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_queue_tail(&hdev->raw_q, skb);\n\t\tqueue_work(hdev->workqueue, &hdev->tx_work);\n\t}\n\n\terr = len;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n\ndrop:\n\tkfree_skb(skb);\n\tgoto done;\n}\n",
        "linevul": 8.389693539356813e-05,
        "sysevr": 0.18365459144115448,
        "devign": 6.901575656859261e-33
    },
    {
        "code": "static int encode_rename(struct xdr_stream *xdr, const struct qstr *oldname, const struct qstr *newname)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + oldname->len);\n\tWRITE32(OP_RENAME);\n\tWRITE32(oldname->len);\n\tWRITEMEM(oldname->name, oldname->len);\n\t\n\tRESERVE_SPACE(4 + newname->len);\n\tWRITE32(newname->len);\n\tWRITEMEM(newname->name, newname->len);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int encode_rename(struct xdr_stream *xdr, const struct qstr *oldname, const struct qstr *newname)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + oldname->len);\n\tWRITE32(OP_RENAME);\n\tWRITE32(oldname->len);\n\tWRITEMEM(oldname->name, oldname->len);\n\t\n\tRESERVE_SPACE(4 + newname->len);\n\tWRITE32(newname->len);\n\tWRITEMEM(newname->name, newname->len);\n\n\treturn 0;\n}\n",
        "linevul": 5.794996104668826e-05,
        "sysevr": 0.1416872888803482,
        "devign": 1.431648133376484e-10
    },
    {
        "code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t/*\n\t * We take the read lock around doing both checks to close a\n\t * possible race where someone else was tracing our child and\n\t * detached between these two checks.  After this locked check,\n\t * we are sure that this is our traced child and that can only\n \t * be changed by us so it's not changing right after this.\n \t */\n \tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n \t\t/*\n \t\t * child->sighand can't be NULL, release_task()\n \t\t * does ptrace_unlink() before __exit_signal().\n \t\t */\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n \t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n \t}\n \tread_unlock(&tasklist_lock);\n \n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n \n\t/* All systems go.. */\n \treturn ret;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9899d11f654474d2d54ea52ceaa2a1f4db3abd68",
        "vul_func_with_fix": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t/*\n\t * We take the read lock around doing both checks to close a\n\t * possible race where someone else was tracing our child and\n\t * detached between these two checks.  After this locked check,\n\t * we are sure that this is our traced child and that can only\n \t * be changed by us so it's not changing right after this.\n \t */\n \tread_lock(&tasklist_lock);\n//flaw_line_below:\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n//fix_flaw_line_below:\n//\tif (child->ptrace && child->parent == current) {\n//fix_flaw_line_below:\n//\t\tWARN_ON(child->state == __TASK_TRACED);\n \t\t/*\n \t\t * child->sighand can't be NULL, release_task()\n \t\t * does ptrace_unlink() before __exit_signal().\n \t\t */\n//flaw_line_below:\n\t\tspin_lock_irq(&child->sighand->siglock);\n//flaw_line_below:\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n//flaw_line_below:\n\t\tif (ignore_state || (task_is_traced(child) &&\n//flaw_line_below:\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n//fix_flaw_line_below:\n//\t\tif (ignore_state || ptrace_freeze_traced(child))\n \t\t\tret = 0;\n//flaw_line_below:\n\t\tspin_unlock_irq(&child->sighand->siglock);\n \t}\n \tread_unlock(&tasklist_lock);\n \n//flaw_line_below:\n\tif (!ret && !ignore_state)\n//flaw_line_below:\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n//fix_flaw_line_below:\n//\tif (!ret && !ignore_state) {\n//fix_flaw_line_below:\n//\t\tif (!wait_task_inactive(child, __TASK_TRACED)) {\n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * This can only happen if may_ptrace_stop() fails and\n//fix_flaw_line_below:\n//\t\t\t * ptrace_stop() changes ->state back to TASK_RUNNING,\n//fix_flaw_line_below:\n//\t\t\t * so we should not worry about leaking __TASK_TRACED.\n//fix_flaw_line_below:\n//\t\t\t */\n//fix_flaw_line_below:\n//\t\t\tWARN_ON(child->state == __TASK_TRACED);\n//fix_flaw_line_below:\n//\t\t\tret = -ESRCH;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t}\n \n//flaw_line_below:\n\t/* All systems go.. */\n \treturn ret;\n }\n",
        "linevul": 0.9954234957695007,
        "sysevr": 0.15847738087177277,
        "devign": 0.9995597004890442
    },
    {
        "code": "static int s_show(struct seq_file *m, void *v)\n{\n\tstruct trace_iterator *iter = v;\n\tint ret;\n\n\tif (iter->ent == NULL) {\n\t\tif (iter->tr) {\n\t\t\tseq_printf(m, \"# tracer: %s\\n\", iter->trace->name);\n\t\t\tseq_puts(m, \"#\\n\");\n\t\t\ttest_ftrace_alive(m);\n\t\t}\n\t\tif (iter->snapshot && trace_empty(iter))\n\t\t\tprint_snapshot_help(m, iter);\n\t\telse if (iter->trace && iter->trace->print_header)\n\t\t\titer->trace->print_header(m);\n\t\telse\n\t\t\ttrace_default_header(m);\n\n\t} else if (iter->leftover) {\n\t\t/*\n\t\t * If we filled the seq_file buffer earlier, we\n\t\t * want to just show it now.\n\t\t */\n\t\tret = trace_print_seq(m, &iter->seq);\n\n\t\t/* ret should this time be zero, but you never know */\n\t\titer->leftover = ret;\n\n\t} else {\n\t\tprint_trace_line(iter);\n\t\tret = trace_print_seq(m, &iter->seq);\n\t\t/*\n\t\t * If we overflow the seq_file buffer, then it will\n\t\t * ask us for this data again at start up.\n\t\t * Use that instead.\n\t\t *  ret is 0 if seq_file write succeeded.\n\t\t *        -1 otherwise.\n\t\t */\n\t\titer->leftover = ret;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "static int s_show(struct seq_file *m, void *v)\n{\n\tstruct trace_iterator *iter = v;\n\tint ret;\n\n\tif (iter->ent == NULL) {\n\t\tif (iter->tr) {\n\t\t\tseq_printf(m, \"# tracer: %s\\n\", iter->trace->name);\n\t\t\tseq_puts(m, \"#\\n\");\n\t\t\ttest_ftrace_alive(m);\n\t\t}\n\t\tif (iter->snapshot && trace_empty(iter))\n\t\t\tprint_snapshot_help(m, iter);\n\t\telse if (iter->trace && iter->trace->print_header)\n\t\t\titer->trace->print_header(m);\n\t\telse\n\t\t\ttrace_default_header(m);\n\n\t} else if (iter->leftover) {\n\t\t/*\n\t\t * If we filled the seq_file buffer earlier, we\n\t\t * want to just show it now.\n\t\t */\n\t\tret = trace_print_seq(m, &iter->seq);\n\n\t\t/* ret should this time be zero, but you never know */\n\t\titer->leftover = ret;\n\n\t} else {\n\t\tprint_trace_line(iter);\n\t\tret = trace_print_seq(m, &iter->seq);\n\t\t/*\n\t\t * If we overflow the seq_file buffer, then it will\n\t\t * ask us for this data again at start up.\n\t\t * Use that instead.\n\t\t *  ret is 0 if seq_file write succeeded.\n\t\t *        -1 otherwise.\n\t\t */\n\t\titer->leftover = ret;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 6.468096398748457e-05,
        "sysevr": 0.13172611594200134,
        "devign": 8.001288733794354e-07
    },
    {
        "code": "static int alloc_callchain_buffers(void)\n{\n\tint cpu;\n\tint size;\n\tstruct callchain_cpus_entries *entries;\n\n\t/*\n\t * We can't use the percpu allocation API for data that can be\n\t * accessed from NMI. Use a temporary manual per cpu allocation\n\t * until that gets sorted out.\n\t */\n\tsize = offsetof(struct callchain_cpus_entries, cpu_entries[nr_cpu_ids]);\n\n\tentries = kzalloc(size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tsize = sizeof(struct perf_callchain_entry) * PERF_NR_CONTEXTS;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tentries->cpu_entries[cpu] = kmalloc_node(size, GFP_KERNEL,\n\t\t\t\t\t\t\t cpu_to_node(cpu));\n\t\tif (!entries->cpu_entries[cpu])\n\t\t\tgoto fail;\n\t}\n\n\trcu_assign_pointer(callchain_cpus_entries, entries);\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\tkfree(entries);\n\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int alloc_callchain_buffers(void)\n{\n\tint cpu;\n\tint size;\n\tstruct callchain_cpus_entries *entries;\n\n\t/*\n\t * We can't use the percpu allocation API for data that can be\n\t * accessed from NMI. Use a temporary manual per cpu allocation\n\t * until that gets sorted out.\n\t */\n\tsize = offsetof(struct callchain_cpus_entries, cpu_entries[nr_cpu_ids]);\n\n\tentries = kzalloc(size, GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tsize = sizeof(struct perf_callchain_entry) * PERF_NR_CONTEXTS;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tentries->cpu_entries[cpu] = kmalloc_node(size, GFP_KERNEL,\n\t\t\t\t\t\t\t cpu_to_node(cpu));\n\t\tif (!entries->cpu_entries[cpu])\n\t\t\tgoto fail;\n\t}\n\n\trcu_assign_pointer(callchain_cpus_entries, entries);\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(cpu)\n\t\tkfree(entries->cpu_entries[cpu]);\n\tkfree(entries);\n\n\treturn -ENOMEM;\n}\n",
        "linevul": 7.581874524476007e-05,
        "sysevr": 0.1408006101846695,
        "devign": 0.00013269262854009867
    },
    {
        "code": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n \tINIT_LIST_HEAD(&ei->i_orphan);\n \tinit_rwsem(&ei->xattr_sem);\n \tinit_rwsem(&ei->i_data_sem);\n \tinode_init_once(&ei->vfs_inode);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/ea3d7209ca01da209cda6f0dea8be9cc4b7a933b",
        "vul_func_with_fix": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n \tINIT_LIST_HEAD(&ei->i_orphan);\n \tinit_rwsem(&ei->xattr_sem);\n \tinit_rwsem(&ei->i_data_sem);\n//fix_flaw_line_below:\n//\tinit_rwsem(&ei->i_mmap_sem);\n \tinode_init_once(&ei->vfs_inode);\n }\n",
        "linevul": 0.9985055923461914,
        "sysevr": 0.12838609516620636,
        "devign": 0.9929846525192261
    },
    {
        "code": "static __net_init int pppoe_init_net(struct net *net)\n{\n\tstruct pppoe_net *pn = pppoe_pernet(net);\n\tstruct proc_dir_entry *pde;\n\n\trwlock_init(&pn->hash_lock);\n\n\tpde = proc_create(\"pppoe\", S_IRUGO, net->proc_net, &pppoe_seq_fops);\n#ifdef CONFIG_PROC_FS\n\tif (!pde)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static __net_init int pppoe_init_net(struct net *net)\n{\n\tstruct pppoe_net *pn = pppoe_pernet(net);\n\tstruct proc_dir_entry *pde;\n\n\trwlock_init(&pn->hash_lock);\n\n\tpde = proc_create(\"pppoe\", S_IRUGO, net->proc_net, &pppoe_seq_fops);\n#ifdef CONFIG_PROC_FS\n\tif (!pde)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n",
        "linevul": 5.664099444402382e-05,
        "sysevr": 0.12776102125644684,
        "devign": 0.6447258591651917
    },
    {
        "code": "int btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7",
        "vul_func_with_fix": "int btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}\n",
        "linevul": 7.424596697092056e-05,
        "sysevr": 0.17619439959526062,
        "devign": 1.1726688081258057e-16
    },
    {
        "code": "static int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t/* xfrm6_tunnel native err handling */\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMPV6_NOROUTE:\n\t\tcase ICMPV6_ADM_PROHIBITED:\n\t\tcase ICMPV6_NOT_NEIGHBOUR:\n\t\tcase ICMPV6_ADDR_UNREACH:\n\t\tcase ICMPV6_PORT_UNREACH:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tswitch (code) {\n\t\tcase ICMPV6_EXC_HOPLIMIT:\n\t\t\tbreak;\n\t\tcase ICMPV6_EXC_FRAGTIME:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tswitch (code) {\n\t\tcase ICMPV6_HDR_FIELD: break;\n\t\tcase ICMPV6_UNK_NEXTHDR: break;\n\t\tcase ICMPV6_UNK_OPTION: break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d5aa407f59f5b83d2c50ec88f5bf56d40f1f8978",
        "vul_func_with_fix": "static int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t/* xfrm6_tunnel native err handling */\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMPV6_NOROUTE:\n\t\tcase ICMPV6_ADM_PROHIBITED:\n\t\tcase ICMPV6_NOT_NEIGHBOUR:\n\t\tcase ICMPV6_ADDR_UNREACH:\n\t\tcase ICMPV6_PORT_UNREACH:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tswitch (code) {\n\t\tcase ICMPV6_EXC_HOPLIMIT:\n\t\t\tbreak;\n\t\tcase ICMPV6_EXC_FRAGTIME:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tswitch (code) {\n\t\tcase ICMPV6_HDR_FIELD: break;\n\t\tcase ICMPV6_UNK_NEXTHDR: break;\n\t\tcase ICMPV6_UNK_OPTION: break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 7.657756941625848e-05,
        "sysevr": 0.12224587798118591,
        "devign": 0.03231115639209747
    },
    {
        "code": "static int compat_calc_entry(const struct arpt_entry *e,\n\t\t\t     const struct xt_table_info *info,\n\t\t\t     const void *base, struct xt_table_info *newinfo)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int entry_offset;\n\tint off, i, ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - base;\n\n\tt = arpt_get_target_c(e);\n\toff += xt_compat_target_offset(t->u.kernel.target);\n\tnewinfo->size -= off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tif (info->hook_entry[i] &&\n\t\t    (e < (struct arpt_entry *)(base + info->hook_entry[i])))\n\t\t\tnewinfo->hook_entry[i] -= off;\n\t\tif (info->underflow[i] &&\n\t\t    (e < (struct arpt_entry *)(base + info->underflow[i])))\n\t\t\tnewinfo->underflow[i] -= off;\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
        "vul_func_with_fix": "static int compat_calc_entry(const struct arpt_entry *e,\n\t\t\t     const struct xt_table_info *info,\n\t\t\t     const void *base, struct xt_table_info *newinfo)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int entry_offset;\n\tint off, i, ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - base;\n\n\tt = arpt_get_target_c(e);\n\toff += xt_compat_target_offset(t->u.kernel.target);\n\tnewinfo->size -= off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tif (info->hook_entry[i] &&\n\t\t    (e < (struct arpt_entry *)(base + info->hook_entry[i])))\n\t\t\tnewinfo->hook_entry[i] -= off;\n\t\tif (info->underflow[i] &&\n\t\t    (e < (struct arpt_entry *)(base + info->underflow[i])))\n\t\t\tnewinfo->underflow[i] -= off;\n\t}\n\treturn 0;\n}\n",
        "linevul": 5.504658111021854e-05,
        "sysevr": 0.18070679903030396,
        "devign": 2.3214501290861826e-18
    },
    {
        "code": "void netif_schedule_queue(struct netdev_queue *txq)\n{\n\trcu_read_lock();\n\tif (!(txq->state & QUEUE_STATE_ANY_XOFF)) {\n\t\tstruct Qdisc *q = rcu_dereference(txq->qdisc);\n\n\t\t__netif_schedule(q);\n\t}\n\trcu_read_unlock();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971",
        "vul_func_with_fix": "void netif_schedule_queue(struct netdev_queue *txq)\n{\n\trcu_read_lock();\n\tif (!(txq->state & QUEUE_STATE_ANY_XOFF)) {\n\t\tstruct Qdisc *q = rcu_dereference(txq->qdisc);\n\n\t\t__netif_schedule(q);\n\t}\n\trcu_read_unlock();\n}\n",
        "linevul": 6.604949885513633e-05,
        "sysevr": 0.16931696236133575,
        "devign": 1.8574704274687548e-10
    },
    {
        "code": " static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n {\n \tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n \tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n \tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/7b789836f434c87168eab067cfbed1ec4783dffd",
        "vul_func_with_fix": " static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n {\n//fix_flaw_line_below:\n//\tmemset(p, 0, sizeof(*p));\n \tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n \tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n \tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}\n",
        "linevul": 0.999265730381012,
        "sysevr": 0.15357445180416107,
        "devign": 0.9931772947311401
    },
    {
        "code": "static void btrfs_submit_direct(int rw, struct bio *bio, struct inode *inode,\n\t\t\t\tloff_t file_offset)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_dio_private *dip;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint skip_sum;\n\tint write = rw & REQ_WRITE;\n\tint ret = 0;\n\n\tskip_sum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\n\tdip = kmalloc(sizeof(*dip), GFP_NOFS);\n\tif (!dip) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ordered;\n\t}\n\n\tdip->private = bio->bi_private;\n\tdip->inode = inode;\n\tdip->logical_offset = file_offset;\n\n\tdip->bytes = 0;\n\tdo {\n\t\tdip->bytes += bvec->bv_len;\n\t\tbvec++;\n\t} while (bvec <= (bio->bi_io_vec + bio->bi_vcnt - 1));\n\n\tdip->disk_bytenr = (u64)bio->bi_sector << 9;\n\tbio->bi_private = dip;\n\tdip->errors = 0;\n\tdip->orig_bio = bio;\n\tatomic_set(&dip->pending_bios, 0);\n\n\tif (write)\n\t\tbio->bi_end_io = btrfs_endio_direct_write;\n\telse\n\t\tbio->bi_end_io = btrfs_endio_direct_read;\n\n\tret = btrfs_submit_direct_hook(rw, dip, skip_sum);\n\tif (!ret)\n\t\treturn;\nfree_ordered:\n\t/*\n\t * If this is a write, we need to clean up the reserved space and kill\n\t * the ordered extent.\n\t */\n\tif (write) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tordered = btrfs_lookup_ordered_extent(inode, file_offset);\n\t\tif (!test_bit(BTRFS_ORDERED_PREALLOC, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_NOCOW, &ordered->flags))\n\t\t\tbtrfs_free_reserved_extent(root, ordered->start,\n\t\t\t\t\t\t   ordered->disk_len);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\tbio_endio(bio, ret);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "vul_func_with_fix": "static void btrfs_submit_direct(int rw, struct bio *bio, struct inode *inode,\n\t\t\t\tloff_t file_offset)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_dio_private *dip;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint skip_sum;\n\tint write = rw & REQ_WRITE;\n\tint ret = 0;\n\n\tskip_sum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\n\tdip = kmalloc(sizeof(*dip), GFP_NOFS);\n\tif (!dip) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ordered;\n\t}\n\n\tdip->private = bio->bi_private;\n\tdip->inode = inode;\n\tdip->logical_offset = file_offset;\n\n\tdip->bytes = 0;\n\tdo {\n\t\tdip->bytes += bvec->bv_len;\n\t\tbvec++;\n\t} while (bvec <= (bio->bi_io_vec + bio->bi_vcnt - 1));\n\n\tdip->disk_bytenr = (u64)bio->bi_sector << 9;\n\tbio->bi_private = dip;\n\tdip->errors = 0;\n\tdip->orig_bio = bio;\n\tatomic_set(&dip->pending_bios, 0);\n\n\tif (write)\n\t\tbio->bi_end_io = btrfs_endio_direct_write;\n\telse\n\t\tbio->bi_end_io = btrfs_endio_direct_read;\n\n\tret = btrfs_submit_direct_hook(rw, dip, skip_sum);\n\tif (!ret)\n\t\treturn;\nfree_ordered:\n\t/*\n\t * If this is a write, we need to clean up the reserved space and kill\n\t * the ordered extent.\n\t */\n\tif (write) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tordered = btrfs_lookup_ordered_extent(inode, file_offset);\n\t\tif (!test_bit(BTRFS_ORDERED_PREALLOC, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_NOCOW, &ordered->flags))\n\t\t\tbtrfs_free_reserved_extent(root, ordered->start,\n\t\t\t\t\t\t   ordered->disk_len);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\tbio_endio(bio, ret);\n}\n",
        "linevul": 6.0273512644926086e-05,
        "sysevr": 0.19832642376422882,
        "devign": 7.51264672702233e-27
    },
    {
        "code": "static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)\n{\n\tstruct task_struct *new_owner;\n\tstruct futex_pi_state *pi_state = this->pi_state;\n\tu32 uninitialized_var(curval), newval;\n\n\tif (!pi_state)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If current does not own the pi_state then the futex is\n\t * inconsistent and user space fiddled with the futex value.\n\t */\n\tif (pi_state->owner != current)\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&pi_state->pi_mutex.wait_lock);\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\n\t/*\n\t * It is possible that the next waiter (the one that brought\n\t * this owner to the kernel) timed out and is no longer\n\t * waiting on the lock.\n\t */\n\tif (!new_owner)\n\t\tnew_owner = this->task;\n\n\t/*\n\t * We pass it to the next owner. (The WAITERS bit is always\n\t * kept enabled while there is PI state around. We must also\n\t * preserve the owner died bit.)\n\t */\n\tif (!(uval & FUTEX_OWNER_DIED)) {\n\t\tint ret = 0;\n\n\t\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tret = -EFAULT;\n\t\telse if (curval != uval)\n\t\t\tret = -EINVAL;\n\t\tif (ret) {\n\t\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\tWARN_ON(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\n\traw_spin_lock_irq(&new_owner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock_irq(&new_owner->pi_lock);\n\n\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\trt_mutex_unlock(&pi_state->pi_mutex);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8",
        "vul_func_with_fix": "static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)\n{\n\tstruct task_struct *new_owner;\n\tstruct futex_pi_state *pi_state = this->pi_state;\n\tu32 uninitialized_var(curval), newval;\n\n\tif (!pi_state)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If current does not own the pi_state then the futex is\n\t * inconsistent and user space fiddled with the futex value.\n\t */\n\tif (pi_state->owner != current)\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&pi_state->pi_mutex.wait_lock);\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\n\t/*\n\t * It is possible that the next waiter (the one that brought\n\t * this owner to the kernel) timed out and is no longer\n\t * waiting on the lock.\n\t */\n\tif (!new_owner)\n\t\tnew_owner = this->task;\n\n\t/*\n\t * We pass it to the next owner. (The WAITERS bit is always\n\t * kept enabled while there is PI state around. We must also\n\t * preserve the owner died bit.)\n\t */\n\tif (!(uval & FUTEX_OWNER_DIED)) {\n\t\tint ret = 0;\n\n\t\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tret = -EFAULT;\n\t\telse if (curval != uval)\n\t\t\tret = -EINVAL;\n\t\tif (ret) {\n\t\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\tWARN_ON(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\n\traw_spin_lock_irq(&new_owner->pi_lock);\n\tWARN_ON(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock_irq(&new_owner->pi_lock);\n\n\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\trt_mutex_unlock(&pi_state->pi_mutex);\n\n\treturn 0;\n}\n",
        "linevul": 8.686814544489607e-05,
        "sysevr": 0.16548001766204834,
        "devign": 0.7139401435852051
    },
    {
        "code": "xfs_vm_bmap(\n\tstruct address_space\t*mapping,\n\tsector_t\t\tblock)\n{\n\tstruct inode\t\t*inode = (struct inode *)mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_vm_bmap(XFS_I(inode));\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\n\t/*\n\t * The swap code (ab-)uses ->bmap to get a block mapping and then\n\t * bypasse the file system for actual I/O.  We really can't allow\n\t * that on reflinks inodes, so we have to skip out here.  And yes,\n\t * 0 is the magic code for a bmap error..\n\t */\n\tif (xfs_is_reflink_inode(ip)) {\n\t\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\t\treturn 0;\n\t}\n\tfilemap_write_and_wait(mapping);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn generic_block_bmap(mapping, block, xfs_get_blocks);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04197b341f23b908193308b8d63d17ff23232598",
        "vul_func_with_fix": "xfs_vm_bmap(\n\tstruct address_space\t*mapping,\n\tsector_t\t\tblock)\n{\n\tstruct inode\t\t*inode = (struct inode *)mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\n\ttrace_xfs_vm_bmap(XFS_I(inode));\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\n\t/*\n\t * The swap code (ab-)uses ->bmap to get a block mapping and then\n\t * bypasse the file system for actual I/O.  We really can't allow\n\t * that on reflinks inodes, so we have to skip out here.  And yes,\n\t * 0 is the magic code for a bmap error..\n\t */\n\tif (xfs_is_reflink_inode(ip)) {\n\t\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\t\treturn 0;\n\t}\n\tfilemap_write_and_wait(mapping);\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\treturn generic_block_bmap(mapping, block, xfs_get_blocks);\n}\n",
        "linevul": 0.028668800368905067,
        "sysevr": 0.18994729220867157,
        "devign": 1.0679666502255714e-06
    },
    {
        "code": "static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1e3921471354244f70fe268586ff94a97a6dd4df",
        "vul_func_with_fix": "static int hugetlb_sysfs_add_hstate(struct hstate *h, struct kobject *parent,\n\t\t\t\t    struct kobject **hstate_kobjs,\n\t\t\t\t    const struct attribute_group *hstate_attr_group)\n{\n\tint retval;\n\tint hi = hstate_index(h);\n\n\thstate_kobjs[hi] = kobject_create_and_add(h->name, parent);\n\tif (!hstate_kobjs[hi])\n\t\treturn -ENOMEM;\n\n\tretval = sysfs_create_group(hstate_kobjs[hi], hstate_attr_group);\n\tif (retval)\n\t\tkobject_put(hstate_kobjs[hi]);\n\n\treturn retval;\n}\n",
        "linevul": 7.333312532864511e-05,
        "sysevr": 0.13790957629680634,
        "devign": 2.3503174775320324e-13
    },
    {
        "code": "int lz4_decompress_unknownoutputsize(const unsigned char *src, size_t src_len,\n\t\tunsigned char *dest, size_t *dest_len)\n{\n\tint ret = -1;\n\tint out_len = 0;\n\n\tout_len = lz4_uncompress_unknownoutputsize(src, dest, src_len,\n\t\t\t\t\t*dest_len);\n\tif (out_len < 0)\n\t\tgoto exit_0;\n\t*dest_len = out_len;\n\n\treturn 0;\nexit_0:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/206204a1162b995e2185275167b22468c00d6b36",
        "vul_func_with_fix": "int lz4_decompress_unknownoutputsize(const unsigned char *src, size_t src_len,\n\t\tunsigned char *dest, size_t *dest_len)\n{\n\tint ret = -1;\n\tint out_len = 0;\n\n\tout_len = lz4_uncompress_unknownoutputsize(src, dest, src_len,\n\t\t\t\t\t*dest_len);\n\tif (out_len < 0)\n\t\tgoto exit_0;\n\t*dest_len = out_len;\n\n\treturn 0;\nexit_0:\n\treturn ret;\n}\n",
        "linevul": 4.674090087064542e-05,
        "sysevr": 0.15334944427013397,
        "devign": 7.491818715963175e-14
    },
    {
        "code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n \tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n \tunsigned int assoclen = req->assoclen;\n \tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n \tint ilen, err;\n \n \t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/3b30460c5b0ed762be75a004e924ec3f8711e032",
        "vul_func_with_fix": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n \tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n \tunsigned int assoclen = req->assoclen;\n \tstruct scatterlist sg[3];\n//flaw_line_below:\n\tu8 odata[16];\n//flaw_line_below:\n\tu8 idata[16];\n//fix_flaw_line_below:\n//\tu8 *odata = pctx->odata;\n//fix_flaw_line_below:\n//\tu8 *idata = pctx->idata;\n \tint ilen, err;\n \n \t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n",
        "linevul": 0.9996306896209717,
        "sysevr": 0.1783376932144165,
        "devign": 1.0690942575664053e-09
    },
    {
        "code": "static u32 crc32c_intel_le_hw_byte(u32 crc, unsigned char const *data, size_t length)\n{\n\twhile (length--) {\n\t\t__asm__ __volatile__(\n\t\t\t\".byte 0xf2, 0xf, 0x38, 0xf0, 0xf1\"\n\t\t\t:\"=S\"(crc)\n\t\t\t:\"0\"(crc), \"c\"(*data)\n\t\t);\n\t\tdata++;\n\t}\n\n\treturn crc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static u32 crc32c_intel_le_hw_byte(u32 crc, unsigned char const *data, size_t length)\n{\n\twhile (length--) {\n\t\t__asm__ __volatile__(\n\t\t\t\".byte 0xf2, 0xf, 0x38, 0xf0, 0xf1\"\n\t\t\t:\"=S\"(crc)\n\t\t\t:\"0\"(crc), \"c\"(*data)\n\t\t);\n\t\tdata++;\n\t}\n\n\treturn crc;\n}\n",
        "linevul": 5.515424345503561e-05,
        "sysevr": 0.12423756718635559,
        "devign": 0.0018968477379530668
    },
    {
        "code": "static void tg3_int_reenable(struct tg3_napi *tnapi)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\n\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\n\tmmiowb();\n\n\t/* When doing tagged status, this work check is unnecessary.\n\t * The last_tag we write above tells the chip which piece of\n\t * work we've completed.\n\t */\n\tif (!tg3_flag(tp, TAGGED_STATUS) && tg3_has_work(tnapi))\n\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t     HOSTCC_MODE_ENABLE | tnapi->coal_now);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/715230a44310a8cf66fbfb5a46f9a62a9b2de424",
        "vul_func_with_fix": "static void tg3_int_reenable(struct tg3_napi *tnapi)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\n\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\n\tmmiowb();\n\n\t/* When doing tagged status, this work check is unnecessary.\n\t * The last_tag we write above tells the chip which piece of\n\t * work we've completed.\n\t */\n\tif (!tg3_flag(tp, TAGGED_STATUS) && tg3_has_work(tnapi))\n\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t     HOSTCC_MODE_ENABLE | tnapi->coal_now);\n}\n",
        "linevul": 4.641239138436504e-05,
        "sysevr": 0.11934380233287811,
        "devign": 1.1421839070656662e-15
    },
    {
        "code": "struct rds_ib_device *rds_ib_get_client_data(struct ib_device *device)\n{\n\tstruct rds_ib_device *rds_ibdev;\n\n\trcu_read_lock();\n\trds_ibdev = ib_get_client_data(device, &rds_ib_client);\n\tif (rds_ibdev)\n\t\tatomic_inc(&rds_ibdev->refcount);\n\trcu_read_unlock();\n\treturn rds_ibdev;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c2349758acf1874e4c2b93fe41d072336f1a31d0",
        "vul_func_with_fix": "struct rds_ib_device *rds_ib_get_client_data(struct ib_device *device)\n{\n\tstruct rds_ib_device *rds_ibdev;\n\n\trcu_read_lock();\n\trds_ibdev = ib_get_client_data(device, &rds_ib_client);\n\tif (rds_ibdev)\n\t\tatomic_inc(&rds_ibdev->refcount);\n\trcu_read_unlock();\n\treturn rds_ibdev;\n}\n",
        "linevul": 0.00010083258530357853,
        "sysevr": 0.14143162965774536,
        "devign": 5.225912411144229e-11
    },
    {
        "code": "int nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/385097a3675749cbc9e97c085c0e5dfe4269ca51",
        "vul_func_with_fix": "int nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n",
        "linevul": 5.27907395735383e-05,
        "sysevr": 0.14562010765075684,
        "devign": 8.802878842799778e-16
    },
    {
        "code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n \n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd",
        "vul_func_with_fix": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n//fix_flaw_line_below:\n//\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n//fix_flaw_line_below:\n//\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n \n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n",
        "linevul": 0.9996792078018188,
        "sysevr": 0.13107559084892273,
        "devign": 0.9600701332092285
    },
    {
        "code": "static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\n\treturn r;\n}\n",
        "linevul": 4.869294207310304e-05,
        "sysevr": 0.11739661544561386,
        "devign": 0.36156249046325684
    },
    {
        "code": "static struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    __be32 group)\n{\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\n\t\t\t\t\t\t sizeof(*ih) + 4);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_dest[0] = 1;\n\teth->h_dest[1] = 0;\n\teth->h_dest[2] = 0x5e;\n\teth->h_dest[3] = 0;\n\teth->h_dest[4] = 0;\n\teth->h_dest[5] = 1;\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = 0;\n\tiph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\tih = igmp_hdr(skb);\n\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\tih->code = (group ? br->multicast_last_member_interval :\n\t\t\t    br->multicast_query_response_interval) /\n\t\t   (HZ / IGMP_TIMER_SCALE);\n\tih->group = group;\n\tih->csum = 0;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\tskb_put(skb, sizeof(*ih));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b0d6a9b4296fa16a28d10d416db7a770fc03287",
        "vul_func_with_fix": "static struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\n\t\t\t\t\t\t    __be32 group)\n{\n\tstruct sk_buff *skb;\n\tstruct igmphdr *ih;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\n\t\t\t\t\t\t sizeof(*ih) + 4);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\n\tmemcpy(eth->h_source, br->dev->dev_addr, 6);\n\teth->h_dest[0] = 1;\n\teth->h_dest[1] = 0;\n\teth->h_dest[2] = 0x5e;\n\teth->h_dest[3] = 0;\n\teth->h_dest[4] = 0;\n\teth->h_dest[5] = 1;\n\teth->h_proto = htons(ETH_P_IP);\n\tskb_put(skb, sizeof(*eth));\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = ip_hdr(skb);\n\n\tiph->version = 4;\n\tiph->ihl = 6;\n\tiph->tos = 0xc0;\n\tiph->tot_len = htons(sizeof(*iph) + sizeof(*ih) + 4);\n\tiph->id = 0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl = 1;\n\tiph->protocol = IPPROTO_IGMP;\n\tiph->saddr = 0;\n\tiph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\tip_send_check(iph);\n\tskb_put(skb, 24);\n\n\tskb_set_transport_header(skb, skb->len);\n\tih = igmp_hdr(skb);\n\tih->type = IGMP_HOST_MEMBERSHIP_QUERY;\n\tih->code = (group ? br->multicast_last_member_interval :\n\t\t\t    br->multicast_query_response_interval) /\n\t\t   (HZ / IGMP_TIMER_SCALE);\n\tih->group = group;\n\tih->csum = 0;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\tskb_put(skb, sizeof(*ih));\n\n\t__skb_pull(skb, sizeof(*eth));\n\nout:\n\treturn skb;\n}\n",
        "linevul": 5.409562072600238e-05,
        "sysevr": 0.27321523427963257,
        "devign": 4.9539619411132375e-18
    },
    {
        "code": "int sys_rt_sigreturn(unsigned long r3, unsigned long r4, unsigned long r5,\n\t\t     unsigned long r6, unsigned long r7, unsigned long r8,\n\t\t     struct pt_regs *regs)\n{\n\tstruct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tunsigned long msr;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (!access_ok(VERIFY_READ, uc, sizeof(*uc)))\n\t\tgoto badframe;\n\n\tif (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tset_current_blocked(&set);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* We recheckpoint on return. */\n\t\tstruct ucontext __user *uc_transact;\n\t\tif (__get_user(uc_transact, &uc->uc_link))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_sigcontexts(regs, &uc->uc_mcontext,\n\t\t\t\t\t   &uc_transact->uc_mcontext))\n\t\t\tgoto badframe;\n\t}\n\telse\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (restore_sigcontext(regs, NULL, 1, &uc->uc_mcontext))\n\t\tgoto badframe;\n\n\tif (restore_altstack(&uc->uc_stack))\n\t\tgoto badframe;\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"rt_sigreturn\",\n\t\t\t\t   (long)uc, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55",
        "vul_func_with_fix": "int sys_rt_sigreturn(unsigned long r3, unsigned long r4, unsigned long r5,\n\t\t     unsigned long r6, unsigned long r7, unsigned long r8,\n\t\t     struct pt_regs *regs)\n{\n\tstruct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tunsigned long msr;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (!access_ok(VERIFY_READ, uc, sizeof(*uc)))\n\t\tgoto badframe;\n\n\tif (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tset_current_blocked(&set);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* We recheckpoint on return. */\n\t\tstruct ucontext __user *uc_transact;\n\t\tif (__get_user(uc_transact, &uc->uc_link))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_sigcontexts(regs, &uc->uc_mcontext,\n\t\t\t\t\t   &uc_transact->uc_mcontext))\n\t\t\tgoto badframe;\n\t}\n\telse\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (restore_sigcontext(regs, NULL, 1, &uc->uc_mcontext))\n\t\tgoto badframe;\n\n\tif (restore_altstack(&uc->uc_stack))\n\t\tgoto badframe;\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"rt_sigreturn\",\n\t\t\t\t   (long)uc, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}\n",
        "linevul": 6.147260864963755e-05,
        "sysevr": 0.2076040357351303,
        "devign": 5.529063228257144e-22
    },
    {
        "code": "static struct mfc6_cache *ip6mr_cache_find_any(struct mr6_table *mrt,\n\t\t\t\t\t       struct in6_addr *mcastgrp,\n\t\t\t\t\t       mifi_t mifi)\n{\n\tint line = MFC6_HASH(mcastgrp, &in6addr_any);\n\tstruct mfc6_cache *c, *proxy;\n\n\tif (ipv6_addr_any(mcastgrp))\n\t\tgoto skip;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\n\t\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp)) {\n\t\t\tif (c->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\n\t\t\t/* It's ok if the mifi is part of the static tree */\n\t\t\tproxy = ip6mr_cache_find_any_parent(mrt,\n\t\t\t\t\t\t\t    c->mf6c_parent);\n\t\t\tif (proxy && proxy->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\t\t}\n\nskip:\n\treturn ip6mr_cache_find_any_parent(mrt, mifi);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/99253eb750fda6a644d5188fb26c43bad8d5a745",
        "vul_func_with_fix": "static struct mfc6_cache *ip6mr_cache_find_any(struct mr6_table *mrt,\n\t\t\t\t\t       struct in6_addr *mcastgrp,\n\t\t\t\t\t       mifi_t mifi)\n{\n\tint line = MFC6_HASH(mcastgrp, &in6addr_any);\n\tstruct mfc6_cache *c, *proxy;\n\n\tif (ipv6_addr_any(mcastgrp))\n\t\tgoto skip;\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list)\n\t\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp, mcastgrp)) {\n\t\t\tif (c->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\n\t\t\t/* It's ok if the mifi is part of the static tree */\n\t\t\tproxy = ip6mr_cache_find_any_parent(mrt,\n\t\t\t\t\t\t\t    c->mf6c_parent);\n\t\t\tif (proxy && proxy->mfc_un.res.ttls[mifi] < 255)\n\t\t\t\treturn c;\n\t\t}\n\nskip:\n\treturn ip6mr_cache_find_any_parent(mrt, mifi);\n}\n",
        "linevul": 0.00013369470252655447,
        "sysevr": 0.13161547482013702,
        "devign": 0.00039946037577465177
    },
    {
        "code": "nfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsstatres *resp)\n{\n\tstruct kstatfs\t*s = &resp->stats;\n\tu64\t\tbs = s->f_bsize;\n\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t/* total bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t/* free bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t/* user available bytes */\n\t\tp = xdr_encode_hyper(p, s->f_files);\t/* total inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* free inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* user available inodes */\n\t\t*p++ = htonl(resp->invarsec);\t/* mean unchanged time */\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "nfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsstatres *resp)\n{\n\tstruct kstatfs\t*s = &resp->stats;\n\tu64\t\tbs = s->f_bsize;\n\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t/* total bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t/* free bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t/* user available bytes */\n\t\tp = xdr_encode_hyper(p, s->f_files);\t/* total inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* free inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* user available inodes */\n\t\t*p++ = htonl(resp->invarsec);\t/* mean unchanged time */\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n",
        "linevul": 6.352673517540097e-05,
        "sysevr": 0.17723004519939423,
        "devign": 3.9112955162593924e-30
    },
    {
        "code": "static void sync_child_event(struct perf_event *child_event,\n\t\t\t       struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\tu64 child_val;\n\n\tif (child_event->attr.inherit_stat)\n\t\tperf_event_read_event(child_event, child);\n\n\tchild_val = perf_event_count(child_event);\n\n\t/*\n\t * Add back the child's count to the parent's count:\n\t */\n\tatomic64_add(child_val, &parent_event->child_count);\n\tatomic64_add(child_event->total_time_enabled,\n\t\t     &parent_event->child_total_time_enabled);\n\tatomic64_add(child_event->total_time_running,\n\t\t     &parent_event->child_total_time_running);\n\n\t/*\n\t * Remove this event from the parent's list\n\t */\n\tWARN_ON_ONCE(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_del_init(&child_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\t/*\n\t * Make sure user/parent get notified, that we just\n\t * lost one event.\n\t */\n\tperf_event_wakeup(parent_event);\n\n\t/*\n\t * Release the parent event, if this was the last\n\t * reference to it.\n\t */\n\tput_event(parent_event);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
        "vul_func_with_fix": "static void sync_child_event(struct perf_event *child_event,\n\t\t\t       struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\tu64 child_val;\n\n\tif (child_event->attr.inherit_stat)\n\t\tperf_event_read_event(child_event, child);\n\n\tchild_val = perf_event_count(child_event);\n\n\t/*\n\t * Add back the child's count to the parent's count:\n\t */\n\tatomic64_add(child_val, &parent_event->child_count);\n\tatomic64_add(child_event->total_time_enabled,\n\t\t     &parent_event->child_total_time_enabled);\n\tatomic64_add(child_event->total_time_running,\n\t\t     &parent_event->child_total_time_running);\n\n\t/*\n\t * Remove this event from the parent's list\n\t */\n\tWARN_ON_ONCE(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_del_init(&child_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\t/*\n\t * Make sure user/parent get notified, that we just\n\t * lost one event.\n\t */\n\tperf_event_wakeup(parent_event);\n\n\t/*\n\t * Release the parent event, if this was the last\n\t * reference to it.\n\t */\n\tput_event(parent_event);\n}\n",
        "linevul": 5.645645796903409e-05,
        "sysevr": 0.15097717940807343,
        "devign": 5.647297030009213e-07
    },
    {
        "code": "static inline int sctp_wspace(struct sctp_association *asoc)\n{\n\tint amt;\n\n\tif (asoc->ep->sndbuf_policy)\n\t\tamt = asoc->sndbuf_used;\n\telse\n\t\tamt = sk_wmem_alloc_get(asoc->base.sk);\n\n\tif (amt >= asoc->base.sk->sk_sndbuf) {\n\t\tif (asoc->base.sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\t\tamt = 0;\n\t\telse {\n\t\t\tamt = sk_stream_wspace(asoc->base.sk);\n\t\t\tif (amt < 0)\n\t\t\t\tamt = 0;\n\t\t}\n\t} else {\n\t\tamt = asoc->base.sk->sk_sndbuf - amt;\n\t}\n\treturn amt;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/726bc6b092da4c093eb74d13c07184b18c1af0f1",
        "vul_func_with_fix": "static inline int sctp_wspace(struct sctp_association *asoc)\n{\n\tint amt;\n\n\tif (asoc->ep->sndbuf_policy)\n\t\tamt = asoc->sndbuf_used;\n\telse\n\t\tamt = sk_wmem_alloc_get(asoc->base.sk);\n\n\tif (amt >= asoc->base.sk->sk_sndbuf) {\n\t\tif (asoc->base.sk->sk_userlocks & SOCK_SNDBUF_LOCK)\n\t\t\tamt = 0;\n\t\telse {\n\t\t\tamt = sk_stream_wspace(asoc->base.sk);\n\t\t\tif (amt < 0)\n\t\t\t\tamt = 0;\n\t\t}\n\t} else {\n\t\tamt = asoc->base.sk->sk_sndbuf - amt;\n\t}\n\treturn amt;\n}\n",
        "linevul": 6.209086132002994e-05,
        "sysevr": 0.13436192274093628,
        "devign": 5.561418153963498e-18
    },
    {
        "code": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n \t\treturn 1;\n #endif /* CONFIG_SPE */\n \n \t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n \t * registers, including FP and V[S]Rs.  After recheckpointing, the\n \t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n \tcurrent->thread.tm_texasr |= TEXASR_FS;\n \t/* This loads the checkpointed FP/VEC state, if used */\n \ttm_recheckpoint(&current->thread, msr);\n\t/* Get the top half of the MSR */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* Pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);\n \n \t/* This loads the speculative FP/VEC state, if used */\n \tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55",
        "vul_func_with_fix": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n \t\treturn 1;\n #endif /* CONFIG_SPE */\n \n//fix_flaw_line_below:\n//\t/* Get the top half of the MSR from the user context */\n//fix_flaw_line_below:\n//\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n//fix_flaw_line_below:\n//\t\treturn 1;\n//fix_flaw_line_below:\n//\tmsr_hi <<= 32;\n//fix_flaw_line_below:\n//\t/* If TM bits are set to the reserved value, it's an invalid context */\n//fix_flaw_line_below:\n//\tif (MSR_TM_RESV(msr_hi))\n//fix_flaw_line_below:\n//\t\treturn 1;\n//fix_flaw_line_below:\n//\t/* Pull in the MSR TM bits from the user context */\n//fix_flaw_line_below:\n//\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n \t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n \t * registers, including FP and V[S]Rs.  After recheckpointing, the\n \t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n \tcurrent->thread.tm_texasr |= TEXASR_FS;\n \t/* This loads the checkpointed FP/VEC state, if used */\n \ttm_recheckpoint(&current->thread, msr);\n//flaw_line_below:\n\t/* Get the top half of the MSR */\n//flaw_line_below:\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n//flaw_line_below:\n\t\treturn 1;\n//flaw_line_below:\n\t/* Pull in MSR TM from user context */\n//flaw_line_below:\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);\n \n \t/* This loads the speculative FP/VEC state, if used */\n \tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}\n",
        "linevul": 5.96239187871106e-05,
        "sysevr": 0.26487278938293457,
        "devign": 0.6981041431427002
    },
    {
        "code": "SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[6];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t/* copy_from_user should be SMP safe. */\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\taudit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = sys_send(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = sys_recv(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4],\n\t\t\t\t   (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t   (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\terr = sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3],\n\t\t\t\t   (struct timespec __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "vul_func_with_fix": "SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[6];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t/* copy_from_user should be SMP safe. */\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\taudit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = sys_send(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = sys_recv(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4],\n\t\t\t\t   (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t   (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\terr = sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3],\n\t\t\t\t   (struct timespec __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n",
        "linevul": 5.386212797020562e-05,
        "sysevr": 0.19967861473560333,
        "devign": 0.5651865005493164
    },
    {
        "code": "static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)\n{\n\tint err = 0;\n\n\tUNIXCB(skb).pid  = get_pid(scm->pid);\n\tUNIXCB(skb).uid = scm->creds.uid;\n\tUNIXCB(skb).gid = scm->creds.gid;\n\tUNIXCB(skb).fp = NULL;\n\tunix_get_secdata(scm, skb);\n\tif (scm->fp && send_fds)\n\t\terr = unix_attach_fds(scm, skb);\n\n\tskb->destructor = unix_destruct_scm;\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7d267278a9ece963d77eefec61630223fce08c6c",
        "vul_func_with_fix": "static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)\n{\n\tint err = 0;\n\n\tUNIXCB(skb).pid  = get_pid(scm->pid);\n\tUNIXCB(skb).uid = scm->creds.uid;\n\tUNIXCB(skb).gid = scm->creds.gid;\n\tUNIXCB(skb).fp = NULL;\n\tunix_get_secdata(scm, skb);\n\tif (scm->fp && send_fds)\n\t\terr = unix_attach_fds(scm, skb);\n\n\tskb->destructor = unix_destruct_scm;\n\treturn err;\n}\n",
        "linevul": 5.2777802920900285e-05,
        "sysevr": 0.15412171185016632,
        "devign": 0.02804594859480858
    },
    {
        "code": "static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    void *accel_priv, select_queue_fallback_t fallback)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_flow_entry *e;\n\tu32 txq = 0;\n\tu32 numqueues = 0;\n\n\trcu_read_lock();\n\tnumqueues = ACCESS_ONCE(tun->numqueues);\n\n\ttxq = __skb_get_hash_symmetric(skb);\n\tif (txq) {\n\t\te = tun_flow_find(&tun->flows[tun_hashfn(txq)], txq);\n\t\tif (e) {\n\t\t\ttun_flow_save_rps_rxhash(e, txq);\n\t\t\ttxq = e->queue_index;\n\t\t} else\n\t\t\t/* use multiply and shift instead of expensive divide */\n\t\t\ttxq = ((u64)txq * numqueues) >> 32;\n\t} else if (likely(skb_rx_queue_recorded(skb))) {\n\t\ttxq = skb_get_rx_queue(skb);\n\t\twhile (unlikely(txq >= numqueues))\n\t\t\ttxq -= numqueues;\n\t}\n\n\trcu_read_unlock();\n\treturn txq;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ad646c81b2182f7fa67ec0c8c825e0ee165696d",
        "vul_func_with_fix": "static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    void *accel_priv, select_queue_fallback_t fallback)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_flow_entry *e;\n\tu32 txq = 0;\n\tu32 numqueues = 0;\n\n\trcu_read_lock();\n\tnumqueues = ACCESS_ONCE(tun->numqueues);\n\n\ttxq = __skb_get_hash_symmetric(skb);\n\tif (txq) {\n\t\te = tun_flow_find(&tun->flows[tun_hashfn(txq)], txq);\n\t\tif (e) {\n\t\t\ttun_flow_save_rps_rxhash(e, txq);\n\t\t\ttxq = e->queue_index;\n\t\t} else\n\t\t\t/* use multiply and shift instead of expensive divide */\n\t\t\ttxq = ((u64)txq * numqueues) >> 32;\n\t} else if (likely(skb_rx_queue_recorded(skb))) {\n\t\ttxq = skb_get_rx_queue(skb);\n\t\twhile (unlikely(txq >= numqueues))\n\t\t\ttxq -= numqueues;\n\t}\n\n\trcu_read_unlock();\n\treturn txq;\n}\n",
        "linevul": 6.909493822604418e-05,
        "sysevr": 0.14054329693317413,
        "devign": 3.663615279068033e-15
    },
    {
        "code": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\n\tif (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\tGFP_TEMPORARY))\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprint_symbol(buf + len, (unsigned long)l->addr);\n\t\telse\n \t\t\tlen += sprintf(buf + len, \"<not-available>\");\n \n \t\tif (l->sum_time != l->min_time) {\n\t\t\tunsigned long remainder;\n \t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n\t\t\tl->min_time,\n\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n\t\t\tl->max_time);\n \t\t} else\n \t\t\tlen += sprintf(buf + len, \" age=%ld\",\n \t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" cpus=\");\n\t\t\tlen += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->cpus);\n\t\t}\n\n\t\tif (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" nodes=\");\n\t\t\tlen += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->nodes);\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static int list_locations(struct kmem_cache *s, char *buf,\n\t\t\t\t\tenum track_item alloc)\n{\n\tint len = 0;\n\tunsigned long i;\n\tstruct loc_track t = { 0, 0, NULL };\n\tint node;\n\n\tif (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),\n\t\t\tGFP_TEMPORARY))\n\t\treturn sprintf(buf, \"Out of memory\\n\");\n\n\t/* Push back cpu slabs */\n\tflush_all(s);\n\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = get_node(s, node);\n\t\tunsigned long flags;\n\t\tstruct page *page;\n\n\t\tif (!atomic_long_read(&n->nr_slabs))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry(page, &n->partial, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tlist_for_each_entry(page, &n->full, lru)\n\t\t\tprocess_slab(&t, s, page, alloc);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t}\n\n\tfor (i = 0; i < t.count; i++) {\n\t\tstruct location *l = &t.loc[i];\n\n\t\tif (len > PAGE_SIZE - 100)\n\t\t\tbreak;\n\t\tlen += sprintf(buf + len, \"%7ld \", l->count);\n\n\t\tif (l->addr)\n\t\t\tlen += sprint_symbol(buf + len, (unsigned long)l->addr);\n\t\telse\n \t\t\tlen += sprintf(buf + len, \"<not-available>\");\n \n \t\tif (l->sum_time != l->min_time) {\n//flaw_line_below:\n\t\t\tunsigned long remainder;\n//flaw_line_below:\n\n \t\t\tlen += sprintf(buf + len, \" age=%ld/%ld/%ld\",\n//flaw_line_below:\n\t\t\tl->min_time,\n//flaw_line_below:\n\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n//flaw_line_below:\n\t\t\tl->max_time);\n//fix_flaw_line_below:\n//\t\t\t\tl->min_time,\n//fix_flaw_line_below:\n//\t\t\t\t(long)div_u64(l->sum_time, l->count),\n//fix_flaw_line_below:\n//\t\t\t\tl->max_time);\n \t\t} else\n \t\t\tlen += sprintf(buf + len, \" age=%ld\",\n \t\t\t\tl->min_time);\n\n\t\tif (l->min_pid != l->max_pid)\n\t\t\tlen += sprintf(buf + len, \" pid=%ld-%ld\",\n\t\t\t\tl->min_pid, l->max_pid);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" pid=%ld\",\n\t\t\t\tl->min_pid);\n\n\t\tif (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" cpus=\");\n\t\t\tlen += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->cpus);\n\t\t}\n\n\t\tif (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&\n\t\t\t\tlen < PAGE_SIZE - 60) {\n\t\t\tlen += sprintf(buf + len, \" nodes=\");\n\t\t\tlen += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,\n\t\t\t\t\tl->nodes);\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"\\n\");\n\t}\n\n\tfree_loc_track(&t);\n\tif (!t.count)\n\t\tlen += sprintf(buf, \"No data\\n\");\n\treturn len;\n}\n",
        "linevul": 8.522272401023656e-05,
        "sysevr": 0.44627106189727783,
        "devign": 0.9996529817581177
    },
    {
        "code": "static void autoconfig(struct mp_port *mtpt, unsigned int probeflags)\n{\n\tunsigned char status1, scratch, scratch2, scratch3;\n\tunsigned char save_lcr, save_mcr;\n\tunsigned long flags;\n\n\tunsigned char u_type;\n\tunsigned char b_ret = 0;\n\n\tif (!mtpt->port.iobase && !mtpt->port.mapbase && !mtpt->port.membase)\n\t\treturn;\n\n\tDEBUG_AUTOCONF(\"ttyMP%d: autoconf (0x%04x, 0x%p): \",\n\t\t\tmtpt->port.line, mtpt->port.iobase, mtpt->port.membase);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tif (!(mtpt->port.flags & UPF_BUGGY_UART)) {\n\t\tscratch = serial_inp(mtpt, UART_IER);\n\t\tserial_outp(mtpt, UART_IER, 0);\n#ifdef __i386__\n\t\toutb(0xff, 0x080);\n#endif\n\t\tscratch2 = serial_inp(mtpt, UART_IER) & 0x0f;\n\t\tserial_outp(mtpt, UART_IER, 0x0F);\n#ifdef __i386__\n\t\toutb(0, 0x080);\n#endif\n\t\tscratch3 = serial_inp(mtpt, UART_IER) & 0x0F;\n\t\tserial_outp(mtpt, UART_IER, scratch);\n\t\tif (scratch2 != 0 || scratch3 != 0x0F) {\n\t\t\tDEBUG_AUTOCONF(\"IER test failed (%02x, %02x) \",\n\t\t\t\t\tscratch2, scratch3);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsave_mcr = serial_in(mtpt, UART_MCR);\n\tsave_lcr = serial_in(mtpt, UART_LCR);\n\n\tif (!(mtpt->port.flags & UPF_SKIP_TEST)) {\n\t\tserial_outp(mtpt, UART_MCR, UART_MCR_LOOP | 0x0A);\n\t\tstatus1 = serial_inp(mtpt, UART_MSR) & 0xF0;\n\t\tserial_outp(mtpt, UART_MCR, save_mcr);\n\t\tif (status1 != 0x90) {\n\t\t\tDEBUG_AUTOCONF(\"LOOP test failed (%02x) \",\n\t\t\t\t\tstatus1);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, 0xBF);\n\tserial_outp(mtpt, UART_EFR, 0);\n\tserial_outp(mtpt, UART_LCR, 0);\n\n\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tscratch = serial_in(mtpt, UART_IIR) >> 6;\n\n\tDEBUG_AUTOCONF(\"iir=%d \", scratch);\n\tif(mtpt->device->nr_ports >= 8)\n\t\tb_ret = read_option_register(mtpt,(MP_OPTR_DIR0 + ((mtpt->port.line)/8)));\n\telse\t\n\t\tb_ret = read_option_register(mtpt,MP_OPTR_DIR0);\n\tu_type = (b_ret & 0xf0) >> 4;\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\n\t\tswitch (u_type)\n\t\t{\n\t\t\tcase DIR_UART_16C550:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050:\n\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050A:\n\t\t\t\tif (mtpt->port.line < 2)\n\t\t\t\t{\n\t\t\t\t\tmtpt->port.type = PORT_16C105XA;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mtpt->device->device_id & 0x50)\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\t\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\nprintk(\"unknow2\\n\");\n\t\tswitch (scratch) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, save_lcr);\n\n\tmtpt->port.fifosize = uart_config[mtpt->port.type].dfl_xmit_fifo_size;\n\tmtpt->capabilities = uart_config[mtpt->port.type].flags;\n\n\tif (mtpt->port.type == PORT_UNKNOWN)\n\t\tgoto out;\n\tserial_outp(mtpt, UART_MCR, save_mcr);\n\tserial_outp(mtpt, UART_FCR, (UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\t\tUART_FCR_CLEAR_XMIT));\n\tserial_outp(mtpt, UART_FCR, 0);\n\t(void)serial_in(mtpt, UART_RX);\n\tserial_outp(mtpt, UART_IER, 0);\n\nout:\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\tDEBUG_AUTOCONF(\"type=%s\\n\", uart_config[mtpt->port.type].name);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b33654b1e3b0c74d4a1fed041c9aae50b3c427",
        "vul_func_with_fix": "static void autoconfig(struct mp_port *mtpt, unsigned int probeflags)\n{\n\tunsigned char status1, scratch, scratch2, scratch3;\n\tunsigned char save_lcr, save_mcr;\n\tunsigned long flags;\n\n\tunsigned char u_type;\n\tunsigned char b_ret = 0;\n\n\tif (!mtpt->port.iobase && !mtpt->port.mapbase && !mtpt->port.membase)\n\t\treturn;\n\n\tDEBUG_AUTOCONF(\"ttyMP%d: autoconf (0x%04x, 0x%p): \",\n\t\t\tmtpt->port.line, mtpt->port.iobase, mtpt->port.membase);\n\n\tspin_lock_irqsave(&mtpt->port.lock, flags);\n\n\tif (!(mtpt->port.flags & UPF_BUGGY_UART)) {\n\t\tscratch = serial_inp(mtpt, UART_IER);\n\t\tserial_outp(mtpt, UART_IER, 0);\n#ifdef __i386__\n\t\toutb(0xff, 0x080);\n#endif\n\t\tscratch2 = serial_inp(mtpt, UART_IER) & 0x0f;\n\t\tserial_outp(mtpt, UART_IER, 0x0F);\n#ifdef __i386__\n\t\toutb(0, 0x080);\n#endif\n\t\tscratch3 = serial_inp(mtpt, UART_IER) & 0x0F;\n\t\tserial_outp(mtpt, UART_IER, scratch);\n\t\tif (scratch2 != 0 || scratch3 != 0x0F) {\n\t\t\tDEBUG_AUTOCONF(\"IER test failed (%02x, %02x) \",\n\t\t\t\t\tscratch2, scratch3);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsave_mcr = serial_in(mtpt, UART_MCR);\n\tsave_lcr = serial_in(mtpt, UART_LCR);\n\n\tif (!(mtpt->port.flags & UPF_SKIP_TEST)) {\n\t\tserial_outp(mtpt, UART_MCR, UART_MCR_LOOP | 0x0A);\n\t\tstatus1 = serial_inp(mtpt, UART_MSR) & 0xF0;\n\t\tserial_outp(mtpt, UART_MCR, save_mcr);\n\t\tif (status1 != 0x90) {\n\t\t\tDEBUG_AUTOCONF(\"LOOP test failed (%02x) \",\n\t\t\t\t\tstatus1);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, 0xBF);\n\tserial_outp(mtpt, UART_EFR, 0);\n\tserial_outp(mtpt, UART_LCR, 0);\n\n\tserial_outp(mtpt, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tscratch = serial_in(mtpt, UART_IIR) >> 6;\n\n\tDEBUG_AUTOCONF(\"iir=%d \", scratch);\n\tif(mtpt->device->nr_ports >= 8)\n\t\tb_ret = read_option_register(mtpt,(MP_OPTR_DIR0 + ((mtpt->port.line)/8)));\n\telse\t\n\t\tb_ret = read_option_register(mtpt,MP_OPTR_DIR0);\n\tu_type = (b_ret & 0xf0) >> 4;\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\n\t\tswitch (u_type)\n\t\t{\n\t\t\tcase DIR_UART_16C550:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050:\n\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\tbreak;\n\t\t\tcase DIR_UART_16C1050A:\n\t\t\t\tif (mtpt->port.line < 2)\n\t\t\t\t{\n\t\t\t\t\tmtpt->port.type = PORT_16C105XA;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (mtpt->device->device_id & 0x50)\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmtpt->port.type = PORT_16C105X;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\t\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(mtpt->port.type == PORT_UNKNOWN )\n\t{\nprintk(\"unknow2\\n\");\n\t\tswitch (scratch) {\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\t\tmtpt->port.type = PORT_UNKNOWN;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\tmtpt->port.type = PORT_16C55X;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tserial_outp(mtpt, UART_LCR, save_lcr);\n\n\tmtpt->port.fifosize = uart_config[mtpt->port.type].dfl_xmit_fifo_size;\n\tmtpt->capabilities = uart_config[mtpt->port.type].flags;\n\n\tif (mtpt->port.type == PORT_UNKNOWN)\n\t\tgoto out;\n\tserial_outp(mtpt, UART_MCR, save_mcr);\n\tserial_outp(mtpt, UART_FCR, (UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR |\n\t\t\t\tUART_FCR_CLEAR_XMIT));\n\tserial_outp(mtpt, UART_FCR, 0);\n\t(void)serial_in(mtpt, UART_RX);\n\tserial_outp(mtpt, UART_IER, 0);\n\nout:\n\tspin_unlock_irqrestore(&mtpt->port.lock, flags);\n\tDEBUG_AUTOCONF(\"type=%s\\n\", uart_config[mtpt->port.type].name);\n}\n",
        "linevul": 7.21257456461899e-05,
        "sysevr": 0.19068877398967743,
        "devign": 0.30728238821029663
    },
    {
        "code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tstruct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tstruct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n",
        "linevul": 8.954868098953739e-05,
        "sysevr": 0.1372799128293991,
        "devign": 4.8631574270919795e-30
    },
    {
        "code": "static void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, bit(X86_FEATURE_TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, bit(X86_FEATURE_DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, bit(X86_FEATURE_PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, bit(X86_FEATURE_PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, bit(X86_FEATURE_MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, bit(X86_FEATURE_PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, bit(X86_FEATURE_FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, bit(X86_FEATURE_XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, bit(X86_FEATURE_VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, bit(X86_FEATURE_SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, bit(X86_FEATURE_PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, bit(X86_FEATURE_XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, bit(X86_FEATURE_FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, bit(X86_FEATURE_SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, bit(X86_FEATURE_SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, bit(X86_FEATURE_PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, bit(X86_FEATURE_UMIP));\n\n#undef cr4_fixed1_update\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, bit(X86_FEATURE_VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, bit(X86_FEATURE_TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, bit(X86_FEATURE_DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, bit(X86_FEATURE_PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, bit(X86_FEATURE_PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, bit(X86_FEATURE_MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, bit(X86_FEATURE_PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, bit(X86_FEATURE_FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, bit(X86_FEATURE_XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, bit(X86_FEATURE_VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, bit(X86_FEATURE_SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, bit(X86_FEATURE_PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, bit(X86_FEATURE_XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, bit(X86_FEATURE_FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, bit(X86_FEATURE_SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, bit(X86_FEATURE_SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, bit(X86_FEATURE_PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, bit(X86_FEATURE_UMIP));\n\n#undef cr4_fixed1_update\n}\n",
        "linevul": 4.9438109272159636e-05,
        "sysevr": 0.12726089358329773,
        "devign": 1.6596628071852138e-08
    },
    {
        "code": "static void rtnl_lock_unregistering_all(void)\n{\n\tstruct net *net;\n\tbool unregistering;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(&netdev_unregistering_wq, &wait);\n\tfor (;;) {\n\t\tunregistering = false;\n\t\trtnl_lock();\n\t\tfor_each_net(net) {\n\t\t\tif (net->dev_unreg_count > 0) {\n\t\t\t\tunregistering = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!unregistering)\n\t\t\tbreak;\n\t\t__rtnl_unlock();\n\n\t\twait_woken(&wait, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&netdev_unregistering_wq, &wait);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f8e44741f9f216e33736ea4ec65ca9ac03036e6",
        "vul_func_with_fix": "static void rtnl_lock_unregistering_all(void)\n{\n\tstruct net *net;\n\tbool unregistering;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(&netdev_unregistering_wq, &wait);\n\tfor (;;) {\n\t\tunregistering = false;\n\t\trtnl_lock();\n\t\tfor_each_net(net) {\n\t\t\tif (net->dev_unreg_count > 0) {\n\t\t\t\tunregistering = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!unregistering)\n\t\t\tbreak;\n\t\t__rtnl_unlock();\n\n\t\twait_woken(&wait, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&netdev_unregistering_wq, &wait);\n}\n",
        "linevul": 4.8223711928585544e-05,
        "sysevr": 0.12577635049819946,
        "devign": 1.4251393712057595e-14
    },
    {
        "code": "static void __propagate_umount(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\n\t\tstruct mount *child = __lookup_mnt_last(&m->mnt,\n\t\t\t\t\t\tmnt->mnt_mountpoint);\n\t\t/*\n\t\t * umount the child only if the child has no children\n\t\t * and the child is marked safe to unmount.\n\t\t */\n\t\tif (!child || !IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\tCLEAR_MNT_MARK(child);\n\t\tif (list_empty(&child->mnt_mounts)) {\n\t\t\tlist_del_init(&child->mnt_child);\n\t\t\tchild->mnt.mnt_flags |= MNT_UMOUNT;\n\t\t\tlist_move_tail(&child->mnt_list, &mnt->mnt_list);\n\t\t}\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498",
        "vul_func_with_fix": "static void __propagate_umount(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\n\t\tstruct mount *child = __lookup_mnt_last(&m->mnt,\n\t\t\t\t\t\tmnt->mnt_mountpoint);\n\t\t/*\n\t\t * umount the child only if the child has no children\n\t\t * and the child is marked safe to unmount.\n\t\t */\n\t\tif (!child || !IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\tCLEAR_MNT_MARK(child);\n\t\tif (list_empty(&child->mnt_mounts)) {\n\t\t\tlist_del_init(&child->mnt_child);\n\t\t\tchild->mnt.mnt_flags |= MNT_UMOUNT;\n\t\t\tlist_move_tail(&child->mnt_list, &mnt->mnt_list);\n\t\t}\n\t}\n}\n",
        "linevul": 6.337897502817214e-05,
        "sysevr": 0.13323773443698883,
        "devign": 7.43281310978247e-24
    },
    {
        "code": "static void au1200_setpanel(struct panel_settings *newpanel,\n\t\t\t    struct au1200fb_platdata *pd)\n{\n\t/*\n\t * Perform global setup/init of LCD controller\n\t */\n\tuint32 winenable;\n\n\t/* Make sure all windows disabled */\n\twinenable = lcd->winenable;\n\tlcd->winenable = 0;\n\tau_sync();\n\t/*\n\t * Ensure everything is disabled before reconfiguring\n\t */\n\tif (lcd->screen & LCD_SCREEN_SEN) {\n\t\t/* Wait for vertical sync period */\n\t\tlcd->intstatus = LCD_INT_SS;\n\t\twhile ((lcd->intstatus & LCD_INT_SS) == 0) {\n\t\t\tau_sync();\n\t\t}\n\n\t\tlcd->screen &= ~LCD_SCREEN_SEN;\t/*disable the controller*/\n\n\t\tdo {\n\t\t\tlcd->intstatus = lcd->intstatus; /*clear interrupts*/\n\t\t\tau_sync();\n\t\t/*wait for controller to shut down*/\n\t\t} while ((lcd->intstatus & LCD_INT_SD) == 0);\n\n\t\t/* Call shutdown of current panel (if up) */\n\t\t/* this must occur last, because if an external clock is driving\n\t\t    the controller, the clock cannot be turned off before first\n\t\t\tshutting down the controller.\n\t\t */\n\t\tif (pd->panel_shutdown)\n\t\t\tpd->panel_shutdown();\n\t}\n\n\t/* Newpanel == NULL indicates a shutdown operation only */\n\tif (newpanel == NULL)\n\t\treturn;\n\n\tpanel = newpanel;\n\n\tprintk(\"Panel(%s), %dx%d\\n\", panel->name, panel->Xres, panel->Yres);\n\n\t/*\n\t * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)\n\t */\n\tif (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))\n\t{\n\t\tuint32 sys_clksrc;\n\t\tau_writel(panel->mode_auxpll, SYS_AUXPLL);\n\t\tsys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f;\n\t\tsys_clksrc |= panel->mode_toyclksrc;\n\t\tau_writel(sys_clksrc, SYS_CLKSRC);\n\t}\n\n\t/*\n\t * Configure panel timings\n\t */\n\tlcd->screen = panel->mode_screen;\n\tlcd->horztiming = panel->mode_horztiming;\n\tlcd->verttiming = panel->mode_verttiming;\n\tlcd->clkcontrol = panel->mode_clkcontrol;\n\tlcd->pwmdiv = panel->mode_pwmdiv;\n\tlcd->pwmhi = panel->mode_pwmhi;\n\tlcd->outmask = panel->mode_outmask;\n\tlcd->fifoctrl = panel->mode_fifoctrl;\n\tau_sync();\n\n\t/* fixme: Check window settings to make sure still valid\n\t * for new geometry */\n#if 0\n\tau1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);\n\tau1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);\n\tau1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);\n\tau1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);\n#endif\n\tlcd->winenable = winenable;\n\n\t/*\n\t * Re-enable screen now that it is configured\n\t */\n\tlcd->screen |= LCD_SCREEN_SEN;\n\tau_sync();\n\n\t/* Call init of panel */\n\tif (pd->panel_init)\n\t\tpd->panel_init();\n\n\t/* FIX!!!! not appropriate on panel change!!! Global setup/init */\n\tlcd->intenable = 0;\n\tlcd->intstatus = ~0;\n\tlcd->backcolor = win->mode_backcolor;\n\n\t/* Setup Color Key - FIX!!! */\n\tlcd->colorkey = win->mode_colorkey;\n\tlcd->colorkeymsk = win->mode_colorkeymsk;\n\n\t/* Setup HWCursor - FIX!!! Need to support this eventually */\n\tlcd->hwc.cursorctrl = 0;\n\tlcd->hwc.cursorpos = 0;\n\tlcd->hwc.cursorcolor0 = 0;\n\tlcd->hwc.cursorcolor1 = 0;\n\tlcd->hwc.cursorcolor2 = 0;\n\tlcd->hwc.cursorcolor3 = 0;\n\n\n#if 0\n#define D(X) printk(\"%25s: %08X\\n\", #X, X)\n\tD(lcd->screen);\n\tD(lcd->horztiming);\n\tD(lcd->verttiming);\n\tD(lcd->clkcontrol);\n\tD(lcd->pwmdiv);\n\tD(lcd->pwmhi);\n\tD(lcd->outmask);\n\tD(lcd->fifoctrl);\n\tD(lcd->window[0].winctrl0);\n\tD(lcd->window[0].winctrl1);\n\tD(lcd->window[0].winctrl2);\n\tD(lcd->window[0].winbuf0);\n\tD(lcd->window[0].winbuf1);\n\tD(lcd->window[0].winbufctrl);\n\tD(lcd->window[1].winctrl0);\n\tD(lcd->window[1].winctrl1);\n\tD(lcd->window[1].winctrl2);\n\tD(lcd->window[1].winbuf0);\n\tD(lcd->window[1].winbuf1);\n\tD(lcd->window[1].winbufctrl);\n\tD(lcd->window[2].winctrl0);\n\tD(lcd->window[2].winctrl1);\n\tD(lcd->window[2].winctrl2);\n\tD(lcd->window[2].winbuf0);\n\tD(lcd->window[2].winbuf1);\n\tD(lcd->window[2].winbufctrl);\n\tD(lcd->window[3].winctrl0);\n\tD(lcd->window[3].winctrl1);\n\tD(lcd->window[3].winctrl2);\n\tD(lcd->window[3].winbuf0);\n\tD(lcd->window[3].winbuf1);\n\tD(lcd->window[3].winbufctrl);\n\tD(lcd->winenable);\n\tD(lcd->intenable);\n\tD(lcd->intstatus);\n\tD(lcd->backcolor);\n\tD(lcd->winenable);\n\tD(lcd->colorkey);\n    D(lcd->colorkeymsk);\n\tD(lcd->hwc.cursorctrl);\n\tD(lcd->hwc.cursorpos);\n\tD(lcd->hwc.cursorcolor0);\n\tD(lcd->hwc.cursorcolor1);\n\tD(lcd->hwc.cursorcolor2);\n\tD(lcd->hwc.cursorcolor3);\n#endif\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1",
        "vul_func_with_fix": "static void au1200_setpanel(struct panel_settings *newpanel,\n\t\t\t    struct au1200fb_platdata *pd)\n{\n\t/*\n\t * Perform global setup/init of LCD controller\n\t */\n\tuint32 winenable;\n\n\t/* Make sure all windows disabled */\n\twinenable = lcd->winenable;\n\tlcd->winenable = 0;\n\tau_sync();\n\t/*\n\t * Ensure everything is disabled before reconfiguring\n\t */\n\tif (lcd->screen & LCD_SCREEN_SEN) {\n\t\t/* Wait for vertical sync period */\n\t\tlcd->intstatus = LCD_INT_SS;\n\t\twhile ((lcd->intstatus & LCD_INT_SS) == 0) {\n\t\t\tau_sync();\n\t\t}\n\n\t\tlcd->screen &= ~LCD_SCREEN_SEN;\t/*disable the controller*/\n\n\t\tdo {\n\t\t\tlcd->intstatus = lcd->intstatus; /*clear interrupts*/\n\t\t\tau_sync();\n\t\t/*wait for controller to shut down*/\n\t\t} while ((lcd->intstatus & LCD_INT_SD) == 0);\n\n\t\t/* Call shutdown of current panel (if up) */\n\t\t/* this must occur last, because if an external clock is driving\n\t\t    the controller, the clock cannot be turned off before first\n\t\t\tshutting down the controller.\n\t\t */\n\t\tif (pd->panel_shutdown)\n\t\t\tpd->panel_shutdown();\n\t}\n\n\t/* Newpanel == NULL indicates a shutdown operation only */\n\tif (newpanel == NULL)\n\t\treturn;\n\n\tpanel = newpanel;\n\n\tprintk(\"Panel(%s), %dx%d\\n\", panel->name, panel->Xres, panel->Yres);\n\n\t/*\n\t * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)\n\t */\n\tif (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))\n\t{\n\t\tuint32 sys_clksrc;\n\t\tau_writel(panel->mode_auxpll, SYS_AUXPLL);\n\t\tsys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f;\n\t\tsys_clksrc |= panel->mode_toyclksrc;\n\t\tau_writel(sys_clksrc, SYS_CLKSRC);\n\t}\n\n\t/*\n\t * Configure panel timings\n\t */\n\tlcd->screen = panel->mode_screen;\n\tlcd->horztiming = panel->mode_horztiming;\n\tlcd->verttiming = panel->mode_verttiming;\n\tlcd->clkcontrol = panel->mode_clkcontrol;\n\tlcd->pwmdiv = panel->mode_pwmdiv;\n\tlcd->pwmhi = panel->mode_pwmhi;\n\tlcd->outmask = panel->mode_outmask;\n\tlcd->fifoctrl = panel->mode_fifoctrl;\n\tau_sync();\n\n\t/* fixme: Check window settings to make sure still valid\n\t * for new geometry */\n#if 0\n\tau1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);\n\tau1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);\n\tau1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);\n\tau1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);\n#endif\n\tlcd->winenable = winenable;\n\n\t/*\n\t * Re-enable screen now that it is configured\n\t */\n\tlcd->screen |= LCD_SCREEN_SEN;\n\tau_sync();\n\n\t/* Call init of panel */\n\tif (pd->panel_init)\n\t\tpd->panel_init();\n\n\t/* FIX!!!! not appropriate on panel change!!! Global setup/init */\n\tlcd->intenable = 0;\n\tlcd->intstatus = ~0;\n\tlcd->backcolor = win->mode_backcolor;\n\n\t/* Setup Color Key - FIX!!! */\n\tlcd->colorkey = win->mode_colorkey;\n\tlcd->colorkeymsk = win->mode_colorkeymsk;\n\n\t/* Setup HWCursor - FIX!!! Need to support this eventually */\n\tlcd->hwc.cursorctrl = 0;\n\tlcd->hwc.cursorpos = 0;\n\tlcd->hwc.cursorcolor0 = 0;\n\tlcd->hwc.cursorcolor1 = 0;\n\tlcd->hwc.cursorcolor2 = 0;\n\tlcd->hwc.cursorcolor3 = 0;\n\n\n#if 0\n#define D(X) printk(\"%25s: %08X\\n\", #X, X)\n\tD(lcd->screen);\n\tD(lcd->horztiming);\n\tD(lcd->verttiming);\n\tD(lcd->clkcontrol);\n\tD(lcd->pwmdiv);\n\tD(lcd->pwmhi);\n\tD(lcd->outmask);\n\tD(lcd->fifoctrl);\n\tD(lcd->window[0].winctrl0);\n\tD(lcd->window[0].winctrl1);\n\tD(lcd->window[0].winctrl2);\n\tD(lcd->window[0].winbuf0);\n\tD(lcd->window[0].winbuf1);\n\tD(lcd->window[0].winbufctrl);\n\tD(lcd->window[1].winctrl0);\n\tD(lcd->window[1].winctrl1);\n\tD(lcd->window[1].winctrl2);\n\tD(lcd->window[1].winbuf0);\n\tD(lcd->window[1].winbuf1);\n\tD(lcd->window[1].winbufctrl);\n\tD(lcd->window[2].winctrl0);\n\tD(lcd->window[2].winctrl1);\n\tD(lcd->window[2].winctrl2);\n\tD(lcd->window[2].winbuf0);\n\tD(lcd->window[2].winbuf1);\n\tD(lcd->window[2].winbufctrl);\n\tD(lcd->window[3].winctrl0);\n\tD(lcd->window[3].winctrl1);\n\tD(lcd->window[3].winctrl2);\n\tD(lcd->window[3].winbuf0);\n\tD(lcd->window[3].winbuf1);\n\tD(lcd->window[3].winbufctrl);\n\tD(lcd->winenable);\n\tD(lcd->intenable);\n\tD(lcd->intstatus);\n\tD(lcd->backcolor);\n\tD(lcd->winenable);\n\tD(lcd->colorkey);\n    D(lcd->colorkeymsk);\n\tD(lcd->hwc.cursorctrl);\n\tD(lcd->hwc.cursorpos);\n\tD(lcd->hwc.cursorcolor0);\n\tD(lcd->hwc.cursorcolor1);\n\tD(lcd->hwc.cursorcolor2);\n\tD(lcd->hwc.cursorcolor3);\n#endif\n}\n",
        "linevul": 8.762298966757953e-05,
        "sysevr": 0.1956736147403717,
        "devign": 8.588129297552446e-19
    },
    {
        "code": "static struct crypto_instance *eseqiv_alloc(struct rtattr **tb)\n{\n\tstruct crypto_instance *inst;\n\tint err;\n\n\terr = crypto_get_default_rng();\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tinst = skcipher_geniv_alloc(&eseqiv_tmpl, tb, 0, 0);\n\tif (IS_ERR(inst))\n\t\tgoto put_rng;\n\n\terr = -EINVAL;\n\tif (inst->alg.cra_ablkcipher.ivsize != inst->alg.cra_blocksize)\n\t\tgoto free_inst;\n\n\tinst->alg.cra_ablkcipher.givencrypt = eseqiv_givencrypt_first;\n\n\tinst->alg.cra_init = eseqiv_init;\n\tinst->alg.cra_exit = skcipher_geniv_exit;\n\n\tinst->alg.cra_ctxsize = sizeof(struct eseqiv_ctx);\n\tinst->alg.cra_ctxsize += inst->alg.cra_ablkcipher.ivsize;\n\nout:\n\treturn inst;\n\nfree_inst:\n\tskcipher_geniv_free(inst);\n\tinst = ERR_PTR(err);\nput_rng:\n\tcrypto_put_default_rng();\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4943ba16bbc2db05115707b3ff7b4874e9e3c560",
        "vul_func_with_fix": "static struct crypto_instance *eseqiv_alloc(struct rtattr **tb)\n{\n\tstruct crypto_instance *inst;\n\tint err;\n\n\terr = crypto_get_default_rng();\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tinst = skcipher_geniv_alloc(&eseqiv_tmpl, tb, 0, 0);\n\tif (IS_ERR(inst))\n\t\tgoto put_rng;\n\n\terr = -EINVAL;\n\tif (inst->alg.cra_ablkcipher.ivsize != inst->alg.cra_blocksize)\n\t\tgoto free_inst;\n\n\tinst->alg.cra_ablkcipher.givencrypt = eseqiv_givencrypt_first;\n\n\tinst->alg.cra_init = eseqiv_init;\n\tinst->alg.cra_exit = skcipher_geniv_exit;\n\n\tinst->alg.cra_ctxsize = sizeof(struct eseqiv_ctx);\n\tinst->alg.cra_ctxsize += inst->alg.cra_ablkcipher.ivsize;\n\nout:\n\treturn inst;\n\nfree_inst:\n\tskcipher_geniv_free(inst);\n\tinst = ERR_PTR(err);\nput_rng:\n\tcrypto_put_default_rng();\n\tgoto out;\n}\n",
        "linevul": 0.0008880553650669754,
        "sysevr": 0.15364190936088562,
        "devign": 1.2283693485125313e-13
    },
    {
        "code": "static void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECT) {\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tstruct l2cap_conn_req req;\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t\t}\n\t\t} else if (sk->sk_state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\trsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);\n\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tif (bt_sk(sk)->defer_setup) {\n\t\t\t\t\tstruct sock *parent = bt_sk(sk)->parent;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tparent->sk_data_ready(parent, 0);\n\n\t\t\t\t} else {\n\t\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t}\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
        "vul_func_with_fix": "static void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan_list *l = &conn->chan_list;\n\tstruct sock *sk;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tread_lock(&l->lock);\n\n\tfor (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {\n\t\tbh_lock_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECT) {\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tstruct l2cap_conn_req req;\n\t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\t\treq.psm  = l2cap_pi(sk)->psm;\n\n\t\t\t\tl2cap_pi(sk)->ident = l2cap_get_ident(conn);\n\n\t\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_REQ, sizeof(req), &req);\n\t\t\t}\n\t\t} else if (sk->sk_state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\trsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\trsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);\n\n\t\t\tif (l2cap_check_security(sk)) {\n\t\t\t\tif (bt_sk(sk)->defer_setup) {\n\t\t\t\t\tstruct sock *parent = bt_sk(sk)->parent;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tparent->sk_data_ready(parent, 0);\n\n\t\t\t\t} else {\n\t\t\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_pi(sk)->ident,\n\t\t\t\t\tL2CAP_CONN_RSP, sizeof(rsp), &rsp);\n\t\t}\n\n\t\tbh_unlock_sock(sk);\n\t}\n\n\tread_unlock(&l->lock);\n}\n",
        "linevul": 5.208540824241936e-05,
        "sysevr": 0.1767149567604065,
        "devign": 5.763262980102446e-21
    },
    {
        "code": "static int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "vul_func_with_fix": "static int mac80211_hwsim_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\thwsim_check_magic(vif);\n\thwsim_check_chanctx_magic(ctx);\n\n\treturn 0;\n}\n",
        "linevul": 4.7431942221010104e-05,
        "sysevr": 0.12821967899799347,
        "devign": 7.282913161432703e-11
    },
    {
        "code": "sctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->peer.zero_window_announced &&\n\t\t    asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf911e985d6bbaa328c20c3e05f4eb03de11fdd6",
        "vul_func_with_fix": "sctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->peer.zero_window_announced &&\n\t\t    asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n",
        "linevul": 8.502993296133354e-05,
        "sysevr": 0.2257397472858429,
        "devign": 4.884054966014517e-11
    },
    {
        "code": "static int dvb_usbv2_adapter_init(struct dvb_usb_device *d)\n{\n\tstruct dvb_usb_adapter *adap;\n\tint ret, i, adapter_count;\n\n\t/* resolve adapter count */\n\tadapter_count = d->props->num_adapters;\n\tif (d->props->get_adapter_count) {\n\t\tret = d->props->get_adapter_count(d);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tadapter_count = ret;\n\t}\n\n\tfor (i = 0; i < adapter_count; i++) {\n\t\tadap = &d->adapter[i];\n\t\tadap->id = i;\n\t\tadap->props = &d->props->adapter[i];\n\n\t\t/* speed - when running at FULL speed we need a HW PID filter */\n\t\tif (d->udev->speed == USB_SPEED_FULL &&\n\t\t\t\t!(adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: this USB2.0 device cannot be run on a USB1.1 port (it lacks a hardware PID filter)\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t} else if ((d->udev->speed == USB_SPEED_FULL &&\n\t\t\t\tadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||\n\t\t\t\t(adap->props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: will use the device's hardware PID filter (table count: %d)\\n\",\n\t\t\t\t\tKBUILD_MODNAME,\n\t\t\t\t\tadap->props->pid_filter_count);\n\t\t\tadap->pid_filtering  = 1;\n\t\t\tadap->max_feed_count = adap->props->pid_filter_count;\n\t\t} else {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: will pass the complete MPEG2 transport stream to the software demuxer\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tadap->pid_filtering  = 0;\n\t\t\tadap->max_feed_count = 255;\n\t\t}\n\n\t\tif (!adap->pid_filtering && dvb_usb_force_pid_filter_usage &&\n\t\t\t\tadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: PID filter enabled by module option\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tadap->pid_filtering  = 1;\n\t\t\tadap->max_feed_count = adap->props->pid_filter_count;\n\t\t}\n\n\t\tret = dvb_usbv2_adapter_stream_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = dvb_usbv2_adapter_dvb_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = dvb_usbv2_adapter_frontend_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* use exclusive FE lock if there is multiple shared FEs */\n\t\tif (adap->fe[1])\n\t\t\tadap->dvb_adap.mfe_shared = 1;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/005145378c9ad7575a01b6ce1ba118fb427f583a",
        "vul_func_with_fix": "static int dvb_usbv2_adapter_init(struct dvb_usb_device *d)\n{\n\tstruct dvb_usb_adapter *adap;\n\tint ret, i, adapter_count;\n\n\t/* resolve adapter count */\n\tadapter_count = d->props->num_adapters;\n\tif (d->props->get_adapter_count) {\n\t\tret = d->props->get_adapter_count(d);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tadapter_count = ret;\n\t}\n\n\tfor (i = 0; i < adapter_count; i++) {\n\t\tadap = &d->adapter[i];\n\t\tadap->id = i;\n\t\tadap->props = &d->props->adapter[i];\n\n\t\t/* speed - when running at FULL speed we need a HW PID filter */\n\t\tif (d->udev->speed == USB_SPEED_FULL &&\n\t\t\t\t!(adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {\n\t\t\tdev_err(&d->udev->dev,\n\t\t\t\t\t\"%s: this USB2.0 device cannot be run on a USB1.1 port (it lacks a hardware PID filter)\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t} else if ((d->udev->speed == USB_SPEED_FULL &&\n\t\t\t\tadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||\n\t\t\t\t(adap->props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: will use the device's hardware PID filter (table count: %d)\\n\",\n\t\t\t\t\tKBUILD_MODNAME,\n\t\t\t\t\tadap->props->pid_filter_count);\n\t\t\tadap->pid_filtering  = 1;\n\t\t\tadap->max_feed_count = adap->props->pid_filter_count;\n\t\t} else {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: will pass the complete MPEG2 transport stream to the software demuxer\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tadap->pid_filtering  = 0;\n\t\t\tadap->max_feed_count = 255;\n\t\t}\n\n\t\tif (!adap->pid_filtering && dvb_usb_force_pid_filter_usage &&\n\t\t\t\tadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) {\n\t\t\tdev_info(&d->udev->dev,\n\t\t\t\t\t\"%s: PID filter enabled by module option\\n\",\n\t\t\t\t\tKBUILD_MODNAME);\n\t\t\tadap->pid_filtering  = 1;\n\t\t\tadap->max_feed_count = adap->props->pid_filter_count;\n\t\t}\n\n\t\tret = dvb_usbv2_adapter_stream_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = dvb_usbv2_adapter_dvb_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = dvb_usbv2_adapter_frontend_init(adap);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* use exclusive FE lock if there is multiple shared FEs */\n\t\tif (adap->fe[1])\n\t\t\tadap->dvb_adap.mfe_shared = 1;\n\t}\n\n\treturn 0;\nerr:\n\tdev_dbg(&d->udev->dev, \"%s: failed=%d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "linevul": 8.664841152494773e-05,
        "sysevr": 0.15217196941375732,
        "devign": 2.4517368658275723e-16
    },
    {
        "code": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n",
        "linevul": 7.364504563156515e-05,
        "sysevr": 0.15065257251262665,
        "devign": 4.721657526768341e-12
    },
    {
        "code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\n \t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n \t\t\tret = -EPERM;\n \t\t\tgoto out;\n \t\t}\n \t\tret = pipe_set_size(pipe, nr_pages);\n \t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52",
        "vul_func_with_fix": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\n \t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n \t\t\tret = -EPERM;\n \t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n//fix_flaw_line_below:\n//\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n//fix_flaw_line_below:\n//\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n//fix_flaw_line_below:\n//\t\t\tret = -EPERM;\n//fix_flaw_line_below:\n//\t\t\tgoto out;\n \t\t}\n \t\tret = pipe_set_size(pipe, nr_pages);\n \t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}\n",
        "linevul": 0.9989535808563232,
        "sysevr": 0.22333934903144836,
        "devign": 5.7249458645936e-11
    },
    {
        "code": "static inline struct inet_timewait_sock *tw_next(struct inet_timewait_sock *tw)\n{\n\treturn !is_a_nulls(tw->tw_node.next) ?\n\t\thlist_nulls_entry(tw->tw_node.next, typeof(*tw), tw_node) : NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static inline struct inet_timewait_sock *tw_next(struct inet_timewait_sock *tw)\n{\n\treturn !is_a_nulls(tw->tw_node.next) ?\n\t\thlist_nulls_entry(tw->tw_node.next, typeof(*tw), tw_node) : NULL;\n}\n",
        "linevul": 6.1016824474791065e-05,
        "sysevr": 0.12735965847969055,
        "devign": 0.40874794125556946
    },
    {
        "code": "static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n{\n\tstruct packet_rollover *rollover = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f, *match;\n\tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&fanout_mutex);\n\n\terr = -EALREADY;\n\tif (po->fanout)\n\t\tgoto out;\n\n\tif (type == PACKET_FANOUT_ROLLOVER ||\n\t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\terr = -ENOMEM;\n\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);\n\t\tif (!rollover)\n\t\t\tgoto out;\n\t\tatomic_long_set(&rollover->num, 0);\n\t\tatomic_long_set(&rollover->num_huge, 0);\n\t\tatomic_long_set(&rollover->num_failed, 0);\n\t\tpo->rollover = rollover;\n\t}\n\n\tif (type_flags & PACKET_FANOUT_FLAG_UNIQUEID) {\n\t\tif (id != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fanout_find_new_id(sk, &id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* ephemeral flag for the first socket in the group: drop it */\n\t\tflags &= ~(PACKET_FANOUT_FLAG_UNIQUEID >> 8);\n\t}\n\n\tmatch = NULL;\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\trefcount_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\n\tspin_lock(&po->bind_lock);\n\tif (po->running &&\n\t    match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (refcount_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\trefcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n\t\t}\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tif (err && !refcount_read(&match->sk_ref)) {\n\t\tlist_del(&match->list);\n\t\tkfree(match);\n\t}\n\nout:\n\tif (err && rollover) {\n\t\tkfree(rollover);\n\t\tpo->rollover = NULL;\n\t}\n\tmutex_unlock(&fanout_mutex);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4971613c1639d8e5f102c4e797c3bf8f83a5a69e",
        "vul_func_with_fix": "static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n{\n\tstruct packet_rollover *rollover = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f, *match;\n\tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&fanout_mutex);\n\n\terr = -EALREADY;\n\tif (po->fanout)\n\t\tgoto out;\n\n\tif (type == PACKET_FANOUT_ROLLOVER ||\n\t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\terr = -ENOMEM;\n\t\trollover = kzalloc(sizeof(*rollover), GFP_KERNEL);\n\t\tif (!rollover)\n\t\t\tgoto out;\n\t\tatomic_long_set(&rollover->num, 0);\n\t\tatomic_long_set(&rollover->num_huge, 0);\n\t\tatomic_long_set(&rollover->num_failed, 0);\n\t\tpo->rollover = rollover;\n\t}\n\n\tif (type_flags & PACKET_FANOUT_FLAG_UNIQUEID) {\n\t\tif (id != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fanout_find_new_id(sk, &id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* ephemeral flag for the first socket in the group: drop it */\n\t\tflags &= ~(PACKET_FANOUT_FLAG_UNIQUEID >> 8);\n\t}\n\n\tmatch = NULL;\n\tlist_for_each_entry(f, &fanout_list, list) {\n\t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\trefcount_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\n\tspin_lock(&po->bind_lock);\n\tif (po->running &&\n\t    match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (refcount_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\trefcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n\t\t}\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tif (err && !refcount_read(&match->sk_ref)) {\n\t\tlist_del(&match->list);\n\t\tkfree(match);\n\t}\n\nout:\n\tif (err && rollover) {\n\t\tkfree(rollover);\n\t\tpo->rollover = NULL;\n\t}\n\tmutex_unlock(&fanout_mutex);\n\treturn err;\n}\n",
        "linevul": 5.736166349379346e-05,
        "sysevr": 0.20921775698661804,
        "devign": 1.1967011180728804e-16
    },
    {
        "code": "static int query_raw_packet_qp_state(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_qp *qp,\n\t\t\t\t     u8 *raw_packet_qp_state)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tint err;\n\tu8 sq_state = MLX5_SQ_STATE_NA;\n\tu8 rq_state = MLX5_RQ_STATE_NA;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_sq_state(dev, sq, &sq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_rq_state(dev, rq, &rq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn sqrq_state_to_qp_state(sq_state, rq_state, qp,\n\t\t\t\t      raw_packet_qp_state);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00",
        "vul_func_with_fix": "static int query_raw_packet_qp_state(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_qp *qp,\n\t\t\t\t     u8 *raw_packet_qp_state)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tint err;\n\tu8 sq_state = MLX5_SQ_STATE_NA;\n\tu8 rq_state = MLX5_RQ_STATE_NA;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_sq_state(dev, sq, &sq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_rq_state(dev, rq, &rq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn sqrq_state_to_qp_state(sq_state, rq_state, qp,\n\t\t\t\t      raw_packet_qp_state);\n}\n",
        "linevul": 6.338936509564519e-05,
        "sysevr": 0.147973895072937,
        "devign": 4.0950551517580144e-27
    },
    {
        "code": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t/* Release rx options */\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\t/* Free flowlabels */\n\tfl6_free_socklist(sk);\n \n \t/* Free tx options */\n \n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "vul_func_with_fix": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t/* Release rx options */\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\t/* Free flowlabels */\n\tfl6_free_socklist(sk);\n \n \t/* Free tx options */\n \n//flaw_line_below:\n\topt = xchg(&np->opt, NULL);\n//flaw_line_below:\n\tif (opt)\n//flaw_line_below:\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n//fix_flaw_line_below:\n//\topt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);\n//fix_flaw_line_below:\n//\tif (opt) {\n//fix_flaw_line_below:\n//\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n//fix_flaw_line_below:\n//\t\ttxopt_put(opt);\n//fix_flaw_line_below:\n//\t}\n }\n",
        "linevul": 0.9932708144187927,
        "sysevr": 0.16838347911834717,
        "devign": 0.9999997615814209
    },
    {
        "code": "static void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & AR_TYPE_MASK) != AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~AR_TYPE_MASK)\n\t\t\t     | AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & AR_TYPE_MASK) != AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~AR_TYPE_MASK)\n\t\t\t     | AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n",
        "linevul": 4.8176003474509344e-05,
        "sysevr": 0.12537828087806702,
        "devign": 8.403020466951627e-12
    },
    {
        "code": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n \tlong i;\n \tint ret;\n \n\tif (rs->rs_bound_addr == 0) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca",
        "vul_func_with_fix": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n \tlong i;\n \tint ret;\n \n//flaw_line_below:\n\tif (rs->rs_bound_addr == 0) {\n//fix_flaw_line_below:\n//\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}\n",
        "linevul": 0.9988183379173279,
        "sysevr": 0.19060629606246948,
        "devign": 0.9981251358985901
    },
    {
        "code": "static unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t/*\n\t * If the stripe width is 1, this makes no sense and\n\t * we set it to 0 to turn off stripe handling code.\n\t */\n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b",
        "vul_func_with_fix": "static unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi)\n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\tint ret;\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\tret = sbi->s_stripe;\n\telse if (stripe_width <= sbi->s_blocks_per_group)\n\t\tret = stripe_width;\n\telse if (stride <= sbi->s_blocks_per_group)\n\t\tret = stride;\n\telse\n\t\tret = 0;\n\n\t/*\n\t * If the stripe width is 1, this makes no sense and\n\t * we set it to 0 to turn off stripe handling code.\n\t */\n\tif (ret <= 1)\n\t\tret = 0;\n\n\treturn ret;\n}\n",
        "linevul": 8.872233593137935e-05,
        "sysevr": 0.12446806579828262,
        "devign": 1.784588873182172e-25
    },
    {
        "code": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8d0207652cbe27d1f962050737848e5ad4671958",
        "vul_func_with_fix": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}\n",
        "linevul": 5.0671675126068294e-05,
        "sysevr": 0.15958523750305176,
        "devign": 1.6844565834617242e-05
    },
    {
        "code": "static int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca",
        "vul_func_with_fix": "static int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n",
        "linevul": 5.224838241701946e-05,
        "sysevr": 0.12341731786727905,
        "devign": 0.5960773825645447
    },
    {
        "code": "static inline void advance(struct pt_regs *regs)\n{\n\tregs->pc   = regs->npc;\n\tregs->npc += 4;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline void advance(struct pt_regs *regs)\n{\n\tregs->pc   = regs->npc;\n\tregs->npc += 4;\n}\n",
        "linevul": 7.105422264430672e-05,
        "sysevr": 0.12739671766757965,
        "devign": 2.2074265871196985e-05
    },
    {
        "code": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n \tpreempt_disable();\n \n \tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n \tlocal_flush_tlb();\n \ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n \tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n \t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/71b3c126e61177eb693423f2e18a1914205b165e",
        "vul_func_with_fix": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n \tpreempt_disable();\n \n \tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/* This is an implicit full barrier that synchronizes with switch_mm. */\n \tlocal_flush_tlb();\n//fix_flaw_line_below:\n//\n \ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n \tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n \t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}\n",
        "linevul": 0.9993532299995422,
        "sysevr": 0.15615877509117126,
        "devign": 0.9528643488883972
    },
    {
        "code": "static inline bool retp_compiler(void)\n{\n\treturn __is_defined(RETPOLINE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fdf82a7856b32d905c39afc85e34364491e46346",
        "vul_func_with_fix": "static inline bool retp_compiler(void)\n{\n\treturn __is_defined(RETPOLINE);\n}\n",
        "linevul": 6.244560063350946e-05,
        "sysevr": 0.13017915189266205,
        "devign": 1.3500053852588678e-10
    },
    {
        "code": "static void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\n\t/* TODO: properly account for control chunks.\n\t * To do it right we'll need:\n\t *  1) endpoint if association isn't known.\n\t *  2) proper memory accounting.\n\t *\n\t *  For now don't do anything for now.\n\t */\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb->destructor = sctp_control_release_owner;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e40607cbe270a9e8360907cb1e62ddf0736e4864",
        "vul_func_with_fix": "static void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\n\t/* TODO: properly account for control chunks.\n\t * To do it right we'll need:\n\t *  1) endpoint if association isn't known.\n\t *  2) proper memory accounting.\n\t *\n\t *  For now don't do anything for now.\n\t */\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb->destructor = sctp_control_release_owner;\n}\n",
        "linevul": 4.79293339594733e-05,
        "sysevr": 0.12729039788246155,
        "devign": 0.0005613308167085052
    },
    {
        "code": "static int try_get_dev_id(struct smi_info *smi_info)\n{\n\tunsigned char         msg[2];\n\tunsigned char         *resp;\n\tunsigned long         resp_len;\n\tint                   rv = 0;\n\n\tresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Do a Get Device ID command, since it comes back with some\n\t * useful info.\n\t */\n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_DEVICE_ID_CMD;\n\tsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\n\n\trv = wait_for_msg_done(smi_info);\n\tif (rv)\n\t\tgoto out;\n\n\tresp_len = smi_info->handlers->get_result(smi_info->si_sm,\n\t\t\t\t\t\t  resp, IPMI_MAX_MSG_LENGTH);\n\n\t/* Check and record info from the get device id, in case we need it. */\n\trv = ipmi_demangle_device_id(resp[0] >> 2, resp[1],\n\t\t\tresp + 2, resp_len - 2, &smi_info->device_id);\n\nout:\n\tkfree(resp);\n\treturn rv;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
        "vul_func_with_fix": "static int try_get_dev_id(struct smi_info *smi_info)\n{\n\tunsigned char         msg[2];\n\tunsigned char         *resp;\n\tunsigned long         resp_len;\n\tint                   rv = 0;\n\n\tresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Do a Get Device ID command, since it comes back with some\n\t * useful info.\n\t */\n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_DEVICE_ID_CMD;\n\tsmi_info->handlers->start_transaction(smi_info->si_sm, msg, 2);\n\n\trv = wait_for_msg_done(smi_info);\n\tif (rv)\n\t\tgoto out;\n\n\tresp_len = smi_info->handlers->get_result(smi_info->si_sm,\n\t\t\t\t\t\t  resp, IPMI_MAX_MSG_LENGTH);\n\n\t/* Check and record info from the get device id, in case we need it. */\n\trv = ipmi_demangle_device_id(resp[0] >> 2, resp[1],\n\t\t\tresp + 2, resp_len - 2, &smi_info->device_id);\n\nout:\n\tkfree(resp);\n\treturn rv;\n}\n",
        "linevul": 6.707151624141261e-05,
        "sysevr": 0.1573449969291687,
        "devign": 2.7912429498666323e-27
    },
    {
        "code": "static void drain_mmlist(void)\n{\n\tstruct list_head *p, *next;\n\tunsigned int type;\n\n\tfor (type = 0; type < nr_swapfiles; type++)\n\t\tif (swap_info[type]->inuse_pages)\n\t\t\treturn;\n\tspin_lock(&mmlist_lock);\n\tlist_for_each_safe(p, next, &init_mm.mmlist)\n\t\tlist_del_init(p);\n\tspin_unlock(&mmlist_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
        "vul_func_with_fix": "static void drain_mmlist(void)\n{\n\tstruct list_head *p, *next;\n\tunsigned int type;\n\n\tfor (type = 0; type < nr_swapfiles; type++)\n\t\tif (swap_info[type]->inuse_pages)\n\t\t\treturn;\n\tspin_lock(&mmlist_lock);\n\tlist_for_each_safe(p, next, &init_mm.mmlist)\n\t\tlist_del_init(p);\n\tspin_unlock(&mmlist_lock);\n}\n",
        "linevul": 6.568844401044771e-05,
        "sysevr": 0.12841835618019104,
        "devign": 0.11158270388841629
    },
    {
        "code": "static int snd_seq_ioctl_set_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tint result = 0;\n\n\tif (timer->type != SNDRV_SEQ_TIMER_ALSA)\n\t\treturn -EINVAL;\n\n\tif (snd_seq_queue_check_access(timer->queue, client->number)) {\n\t\tstruct snd_seq_queue *q;\n\t\tstruct snd_seq_timer *tmr;\n\n\t\tq = queueptr(timer->queue);\n\t\tif (q == NULL)\n\t\t\treturn -ENXIO;\n\t\tif (mutex_lock_interruptible(&q->timer_mutex)) {\n\t\t\tqueuefree(q);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\ttmr = q->timer;\n\t\tsnd_seq_queue_timer_close(timer->queue);\n\t\ttmr->type = timer->type;\n\t\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\t\ttmr->alsa_id = timer->u.alsa.id;\n\t\t\ttmr->preferred_resolution = timer->u.alsa.resolution;\n\t\t}\n\t\tresult = snd_seq_queue_timer_open(timer->queue);\n\t\tmutex_unlock(&q->timer_mutex);\n\t\tqueuefree(q);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\treturn result;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
        "vul_func_with_fix": "static int snd_seq_ioctl_set_queue_timer(struct snd_seq_client *client,\n\t\t\t\t\t void *arg)\n{\n\tstruct snd_seq_queue_timer *timer = arg;\n\tint result = 0;\n\n\tif (timer->type != SNDRV_SEQ_TIMER_ALSA)\n\t\treturn -EINVAL;\n\n\tif (snd_seq_queue_check_access(timer->queue, client->number)) {\n\t\tstruct snd_seq_queue *q;\n\t\tstruct snd_seq_timer *tmr;\n\n\t\tq = queueptr(timer->queue);\n\t\tif (q == NULL)\n\t\t\treturn -ENXIO;\n\t\tif (mutex_lock_interruptible(&q->timer_mutex)) {\n\t\t\tqueuefree(q);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\ttmr = q->timer;\n\t\tsnd_seq_queue_timer_close(timer->queue);\n\t\ttmr->type = timer->type;\n\t\tif (tmr->type == SNDRV_SEQ_TIMER_ALSA) {\n\t\t\ttmr->alsa_id = timer->u.alsa.id;\n\t\t\ttmr->preferred_resolution = timer->u.alsa.resolution;\n\t\t}\n\t\tresult = snd_seq_queue_timer_open(timer->queue);\n\t\tmutex_unlock(&q->timer_mutex);\n\t\tqueuefree(q);\n\t} else {\n\t\treturn -EPERM;\n\t}\t\n\n\treturn result;\n}\n",
        "linevul": 8.495171641698107e-05,
        "sysevr": 0.1459018439054489,
        "devign": 1.9991725289103535e-12
    },
    {
        "code": "static void anon_vma_ctor(void *data)\n{\n\tstruct anon_vma *anon_vma = data;\n\n\tinit_rwsem(&anon_vma->rwsem);\n\tatomic_set(&anon_vma->refcount, 0);\n\tanon_vma->rb_root = RB_ROOT;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c",
        "vul_func_with_fix": "static void anon_vma_ctor(void *data)\n{\n\tstruct anon_vma *anon_vma = data;\n\n\tinit_rwsem(&anon_vma->rwsem);\n\tatomic_set(&anon_vma->refcount, 0);\n\tanon_vma->rb_root = RB_ROOT;\n}\n",
        "linevul": 6.105151260271668e-05,
        "sysevr": 0.12783710658550262,
        "devign": 0.0023150809574872255
    },
    {
        "code": "int __ref register_cu2_notifier(struct notifier_block *nb)\n{\n\treturn raw_notifier_chain_register(&cu2_chain, nb);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "int __ref register_cu2_notifier(struct notifier_block *nb)\n{\n\treturn raw_notifier_chain_register(&cu2_chain, nb);\n}\n",
        "linevul": 9.142413182416931e-05,
        "sysevr": 0.1522955447435379,
        "devign": 0.6263076663017273
    },
    {
        "code": "static int dn_connect(struct socket *sock, struct sockaddr *uaddr, int addrlen, int flags)\n{\n\tstruct sockaddr_dn *addr = (struct sockaddr_dn *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tlong timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\tlock_sock(sk);\n\terr = __dn_connect(sk, addr, addrlen, &timeo, 0);\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9",
        "vul_func_with_fix": "static int dn_connect(struct socket *sock, struct sockaddr *uaddr, int addrlen, int flags)\n{\n\tstruct sockaddr_dn *addr = (struct sockaddr_dn *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tlong timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\tlock_sock(sk);\n\terr = __dn_connect(sk, addr, addrlen, &timeo, 0);\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "linevul": 5.9495105233509094e-05,
        "sysevr": 0.12421625852584839,
        "devign": 3.765377509254532e-29
    },
    {
        "code": "unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->ip;\n\tseg = regs->cs & 0xffff;\n\tif (v8086_mode(regs)) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif ((seg & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc;\n\t\tunsigned long base;\n\n\t\tseg &= ~7UL;\n\n\t\tmutex_lock(&child->mm->context.lock);\n\t\tif (unlikely((seg >> 3) >= child->mm->context.size))\n\t\t\taddr = -1L; /* bogus selector, access would fault */\n\t\telse {\n\t\t\tdesc = child->mm->context.ldt + seg;\n\t\t\tbase = get_desc_base(desc);\n\n\t\t\t/* 16-bit code segment? */\n\t\t\tif (!desc->d)\n\t\t\t\taddr &= 0xffff;\n\t\t\taddr += base;\n\t\t}\n\t\tmutex_unlock(&child->mm->context.lock);\n\t}\n\n\treturn addr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9899d11f654474d2d54ea52ceaa2a1f4db3abd68",
        "vul_func_with_fix": "unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)\n{\n\tunsigned long addr, seg;\n\n\taddr = regs->ip;\n\tseg = regs->cs & 0xffff;\n\tif (v8086_mode(regs)) {\n\t\taddr = (addr & 0xffff) + (seg << 4);\n\t\treturn addr;\n\t}\n\n\t/*\n\t * We'll assume that the code segments in the GDT\n\t * are all zero-based. That is largely true: the\n\t * TLS segments are used for data, and the PNPBIOS\n\t * and APM bios ones we just ignore here.\n\t */\n\tif ((seg & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc;\n\t\tunsigned long base;\n\n\t\tseg &= ~7UL;\n\n\t\tmutex_lock(&child->mm->context.lock);\n\t\tif (unlikely((seg >> 3) >= child->mm->context.size))\n\t\t\taddr = -1L; /* bogus selector, access would fault */\n\t\telse {\n\t\t\tdesc = child->mm->context.ldt + seg;\n\t\t\tbase = get_desc_base(desc);\n\n\t\t\t/* 16-bit code segment? */\n\t\t\tif (!desc->d)\n\t\t\t\taddr &= 0xffff;\n\t\t\taddr += base;\n\t\t}\n\t\tmutex_unlock(&child->mm->context.lock);\n\t}\n\n\treturn addr;\n}\n",
        "linevul": 5.283571226755157e-05,
        "sysevr": 0.20835977792739868,
        "devign": 1.9140390803611216e-15
    },
    {
        "code": "static int lock_request(struct fuse_req *req)\n{\n\tint err = 0;\n\tif (req) {\n\t\tspin_lock(&req->waitq.lock);\n\t\tif (test_bit(FR_ABORTED, &req->flags))\n\t\t\terr = -ENOENT;\n\t\telse\n\t\t\tset_bit(FR_LOCKED, &req->flags);\n\t\tspin_unlock(&req->waitq.lock);\n\t}\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "vul_func_with_fix": "static int lock_request(struct fuse_req *req)\n{\n\tint err = 0;\n\tif (req) {\n\t\tspin_lock(&req->waitq.lock);\n\t\tif (test_bit(FR_ABORTED, &req->flags))\n\t\t\terr = -ENOENT;\n\t\telse\n\t\t\tset_bit(FR_LOCKED, &req->flags);\n\t\tspin_unlock(&req->waitq.lock);\n\t}\n\treturn err;\n}\n",
        "linevul": 7.218374230433255e-05,
        "sysevr": 0.131378173828125,
        "devign": 1.5468361183948454e-13
    },
    {
        "code": "static void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn;\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->soft_vnmi_blocked = 1;\n\t\tvmx->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->nmi_known_unmasked = false;\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn;\n\n\tif (!cpu_has_virtual_nmis()) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->soft_vnmi_blocked = 1;\n\t\tvmx->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->nmi_known_unmasked = false;\n\tif (vmx->rmode.vm86_active) {\n\t\tif (kvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n}\n",
        "linevul": 5.574908573180437e-05,
        "sysevr": 0.1568407267332077,
        "devign": 8.445806720658311e-09
    },
    {
        "code": "static int irda_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct irda_ias_set    *ias_opt;\n\tstruct ias_object      *ias_obj;\n\tstruct ias_attrib *\tias_attr;\t/* Attribute in IAS object */\n\tint opt, free_ias = 0, err = 0;\n\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\n\tif (level != SOL_IRLMP)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IRLMP_IAS_SET:\n\t\t/* The user want to add an attribute to an existing IAS object\n\t\t * (in the IAS database) or to create a new object with this\n\t\t * attribute.\n\t\t * We first query IAS to know if the object exist, and then\n\t\t * create the right attribute...\n\t\t */\n\n\t\tif (optlen != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, optlen)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0') {\n\t\t\tif(self->ias_obj == NULL) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tias_obj = self->ias_obj;\n\t\t} else\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\n\t\t/* Only ROOT can mess with the global IAS database.\n\t\t * Users can only add attributes to the object associated\n\t\t * with the socket they own - Jean II */\n\t\tif((!capable(CAP_NET_ADMIN)) &&\n\t\t   ((ias_obj == NULL) || (ias_obj != self->ias_obj))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If the object doesn't exist, create it */\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\t/* Create a new object */\n\t\t\tias_obj = irias_new_object(ias_opt->irda_class_name,\n\t\t\t\t\t\t   jiffies);\n\t\t\tif (ias_obj == NULL) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree_ias = 1;\n\t\t}\n\n\t\t/* Do we have the attribute already ? */\n\t\tif(irias_find_attrib(ias_obj, ias_opt->irda_attrib_name)) {\n\t\t\tkfree(ias_opt);\n\t\t\tif (free_ias) {\n\t\t\t\tkfree(ias_obj->name);\n\t\t\t\tkfree(ias_obj);\n\t\t\t}\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Look at the type */\n\t\tswitch(ias_opt->irda_attrib_type) {\n\t\tcase IAS_INTEGER:\n\t\t\t/* Add an integer attribute */\n\t\t\tirias_add_integer_attrib(\n\t\t\t\tias_obj,\n\t\t\t\tias_opt->irda_attrib_name,\n\t\t\t\tias_opt->attribute.irda_attrib_int,\n\t\t\t\tIAS_USER_ATTR);\n\t\t\tbreak;\n\t\tcase IAS_OCT_SEQ:\n\t\t\t/* Check length */\n\t\t\tif(ias_opt->attribute.irda_attrib_octet_seq.len >\n\t\t\t   IAS_MAX_OCTET_STRING) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\tif (free_ias) {\n\t\t\t\t\tkfree(ias_obj->name);\n\t\t\t\t\tkfree(ias_obj);\n\t\t\t\t}\n\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Add an octet sequence attribute */\n\t\t\tirias_add_octseq_attrib(\n\t\t\t      ias_obj,\n\t\t\t      ias_opt->irda_attrib_name,\n\t\t\t      ias_opt->attribute.irda_attrib_octet_seq.octet_seq,\n\t\t\t      ias_opt->attribute.irda_attrib_octet_seq.len,\n\t\t\t      IAS_USER_ATTR);\n\t\t\tbreak;\n\t\tcase IAS_STRING:\n\t\t\t/* Should check charset & co */\n\t\t\t/* Check length */\n\t\t\t/* The length is encoded in a __u8, and\n\t\t\t * IAS_MAX_STRING == 256, so there is no way\n\t\t\t * userspace can pass us a string too large.\n\t\t\t * Jean II */\n\t\t\t/* NULL terminate the string (avoid troubles) */\n\t\t\tias_opt->attribute.irda_attrib_string.string[ias_opt->attribute.irda_attrib_string.len] = '\\0';\n\t\t\t/* Add a string attribute */\n\t\t\tirias_add_string_attrib(\n\t\t\t\tias_obj,\n\t\t\t\tias_opt->irda_attrib_name,\n\t\t\t\tias_opt->attribute.irda_attrib_string.string,\n\t\t\t\tIAS_USER_ATTR);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tkfree(ias_opt);\n\t\t\tif (free_ias) {\n\t\t\t\tkfree(ias_obj->name);\n\t\t\t\tkfree(ias_obj);\n\t\t\t}\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tirias_insert_object(ias_obj);\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_IAS_DEL:\n\t\t/* The user want to delete an object from our local IAS\n\t\t * database. We just need to query the IAS, check is the\n\t\t * object is not owned by the kernel and delete it.\n\t\t */\n\n\t\tif (optlen != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, optlen)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0')\n\t\t\tias_obj = self->ias_obj;\n\t\telse\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Only ROOT can mess with the global IAS database.\n\t\t * Users can only del attributes from the object associated\n\t\t * with the socket they own - Jean II */\n\t\tif((!capable(CAP_NET_ADMIN)) &&\n\t\t   ((ias_obj == NULL) || (ias_obj != self->ias_obj))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the attribute (in the object) we target */\n\t\tias_attr = irias_find_attrib(ias_obj,\n\t\t\t\t\t     ias_opt->irda_attrib_name);\n\t\tif(ias_attr == (struct ias_attrib *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check is the user space own the object */\n\t\tif(ias_attr->value->owner != IAS_USER_ATTR) {\n\t\t\tIRDA_DEBUG(1, \"%s(), attempting to delete a kernel attribute\\n\", __func__);\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove the attribute (and maybe the object) */\n\t\tirias_delete_attrib(ias_obj, ias_attr, 1);\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_MAX_SDU_SIZE:\n\t\tif (optlen < sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (get_user(opt, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Only possible for a seqpacket service (TTP with SAR) */\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tIRDA_DEBUG(2, \"%s(), setting max_sdu_size = %d\\n\",\n\t\t\t\t   __func__, opt);\n\t\t\tself->max_sdu_size_rx = opt;\n\t\t} else {\n\t\t\tIRDA_WARNING(\"%s: not allowed to set MAXSDUSIZE for this socket type!\\n\",\n\t\t\t\t     __func__);\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase IRLMP_HINTS_SET:\n\t\tif (optlen < sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The input is really a (__u8 hints[2]), easier as an int */\n\t\tif (get_user(opt, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Unregister any old registration */\n\t\tif (self->skey)\n\t\t\tirlmp_unregister_service(self->skey);\n\n\t\tself->skey = irlmp_register_service((__u16) opt);\n\t\tbreak;\n\tcase IRLMP_HINT_MASK_SET:\n\t\t/* As opposed to the previous case which set the hint bits\n\t\t * that we advertise, this one set the filter we use when\n\t\t * making a discovery (nodes which don't match any hint\n\t\t * bit in the mask are not reported).\n\t\t */\n\t\tif (optlen < sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The input is really a (__u8 hints[2]), easier as an int */\n\t\tif (get_user(opt, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Set the new hint mask */\n\t\tself->mask.word = (__u16) opt;\n\t\t/* Mask out extension bits */\n\t\tself->mask.word &= 0x7f7f;\n\t\t/* Check if no bits */\n\t\tif(!self->mask.word)\n\t\t\tself->mask.word = 0xFFFF;\n\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5ae94c0d2f0bed41d6718be743985d61b7f5c47d",
        "vul_func_with_fix": "static int irda_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct irda_ias_set    *ias_opt;\n\tstruct ias_object      *ias_obj;\n\tstruct ias_attrib *\tias_attr;\t/* Attribute in IAS object */\n\tint opt, free_ias = 0, err = 0;\n\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\n\tif (level != SOL_IRLMP)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IRLMP_IAS_SET:\n\t\t/* The user want to add an attribute to an existing IAS object\n\t\t * (in the IAS database) or to create a new object with this\n\t\t * attribute.\n\t\t * We first query IAS to know if the object exist, and then\n\t\t * create the right attribute...\n\t\t */\n\n\t\tif (optlen != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, optlen)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0') {\n\t\t\tif(self->ias_obj == NULL) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tias_obj = self->ias_obj;\n\t\t} else\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\n\t\t/* Only ROOT can mess with the global IAS database.\n\t\t * Users can only add attributes to the object associated\n\t\t * with the socket they own - Jean II */\n\t\tif((!capable(CAP_NET_ADMIN)) &&\n\t\t   ((ias_obj == NULL) || (ias_obj != self->ias_obj))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If the object doesn't exist, create it */\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\t/* Create a new object */\n\t\t\tias_obj = irias_new_object(ias_opt->irda_class_name,\n\t\t\t\t\t\t   jiffies);\n\t\t\tif (ias_obj == NULL) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree_ias = 1;\n\t\t}\n\n\t\t/* Do we have the attribute already ? */\n\t\tif(irias_find_attrib(ias_obj, ias_opt->irda_attrib_name)) {\n\t\t\tkfree(ias_opt);\n\t\t\tif (free_ias) {\n\t\t\t\tkfree(ias_obj->name);\n\t\t\t\tkfree(ias_obj);\n\t\t\t}\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Look at the type */\n\t\tswitch(ias_opt->irda_attrib_type) {\n\t\tcase IAS_INTEGER:\n\t\t\t/* Add an integer attribute */\n\t\t\tirias_add_integer_attrib(\n\t\t\t\tias_obj,\n\t\t\t\tias_opt->irda_attrib_name,\n\t\t\t\tias_opt->attribute.irda_attrib_int,\n\t\t\t\tIAS_USER_ATTR);\n\t\t\tbreak;\n\t\tcase IAS_OCT_SEQ:\n\t\t\t/* Check length */\n\t\t\tif(ias_opt->attribute.irda_attrib_octet_seq.len >\n\t\t\t   IAS_MAX_OCTET_STRING) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\tif (free_ias) {\n\t\t\t\t\tkfree(ias_obj->name);\n\t\t\t\t\tkfree(ias_obj);\n\t\t\t\t}\n\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* Add an octet sequence attribute */\n\t\t\tirias_add_octseq_attrib(\n\t\t\t      ias_obj,\n\t\t\t      ias_opt->irda_attrib_name,\n\t\t\t      ias_opt->attribute.irda_attrib_octet_seq.octet_seq,\n\t\t\t      ias_opt->attribute.irda_attrib_octet_seq.len,\n\t\t\t      IAS_USER_ATTR);\n\t\t\tbreak;\n\t\tcase IAS_STRING:\n\t\t\t/* Should check charset & co */\n\t\t\t/* Check length */\n\t\t\t/* The length is encoded in a __u8, and\n\t\t\t * IAS_MAX_STRING == 256, so there is no way\n\t\t\t * userspace can pass us a string too large.\n\t\t\t * Jean II */\n\t\t\t/* NULL terminate the string (avoid troubles) */\n\t\t\tias_opt->attribute.irda_attrib_string.string[ias_opt->attribute.irda_attrib_string.len] = '\\0';\n\t\t\t/* Add a string attribute */\n\t\t\tirias_add_string_attrib(\n\t\t\t\tias_obj,\n\t\t\t\tias_opt->irda_attrib_name,\n\t\t\t\tias_opt->attribute.irda_attrib_string.string,\n\t\t\t\tIAS_USER_ATTR);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tkfree(ias_opt);\n\t\t\tif (free_ias) {\n\t\t\t\tkfree(ias_obj->name);\n\t\t\t\tkfree(ias_obj);\n\t\t\t}\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tirias_insert_object(ias_obj);\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_IAS_DEL:\n\t\t/* The user want to delete an object from our local IAS\n\t\t * database. We just need to query the IAS, check is the\n\t\t * object is not owned by the kernel and delete it.\n\t\t */\n\n\t\tif (optlen != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, optlen)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0')\n\t\t\tias_obj = self->ias_obj;\n\t\telse\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Only ROOT can mess with the global IAS database.\n\t\t * Users can only del attributes from the object associated\n\t\t * with the socket they own - Jean II */\n\t\tif((!capable(CAP_NET_ADMIN)) &&\n\t\t   ((ias_obj == NULL) || (ias_obj != self->ias_obj))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the attribute (in the object) we target */\n\t\tias_attr = irias_find_attrib(ias_obj,\n\t\t\t\t\t     ias_opt->irda_attrib_name);\n\t\tif(ias_attr == (struct ias_attrib *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check is the user space own the object */\n\t\tif(ias_attr->value->owner != IAS_USER_ATTR) {\n\t\t\tIRDA_DEBUG(1, \"%s(), attempting to delete a kernel attribute\\n\", __func__);\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remove the attribute (and maybe the object) */\n\t\tirias_delete_attrib(ias_obj, ias_attr, 1);\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_MAX_SDU_SIZE:\n\t\tif (optlen < sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (get_user(opt, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Only possible for a seqpacket service (TTP with SAR) */\n\t\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\t\tIRDA_DEBUG(2, \"%s(), setting max_sdu_size = %d\\n\",\n\t\t\t\t   __func__, opt);\n\t\t\tself->max_sdu_size_rx = opt;\n\t\t} else {\n\t\t\tIRDA_WARNING(\"%s: not allowed to set MAXSDUSIZE for this socket type!\\n\",\n\t\t\t\t     __func__);\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase IRLMP_HINTS_SET:\n\t\tif (optlen < sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The input is really a (__u8 hints[2]), easier as an int */\n\t\tif (get_user(opt, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Unregister any old registration */\n\t\tif (self->skey)\n\t\t\tirlmp_unregister_service(self->skey);\n\n\t\tself->skey = irlmp_register_service((__u16) opt);\n\t\tbreak;\n\tcase IRLMP_HINT_MASK_SET:\n\t\t/* As opposed to the previous case which set the hint bits\n\t\t * that we advertise, this one set the filter we use when\n\t\t * making a discovery (nodes which don't match any hint\n\t\t * bit in the mask are not reported).\n\t\t */\n\t\tif (optlen < sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* The input is really a (__u8 hints[2]), easier as an int */\n\t\tif (get_user(opt, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Set the new hint mask */\n\t\tself->mask.word = (__u16) opt;\n\t\t/* Mask out extension bits */\n\t\tself->mask.word &= 0x7f7f;\n\t\t/* Check if no bits */\n\t\tif(!self->mask.word)\n\t\t\tself->mask.word = 0xFFFF;\n\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}\n",
        "linevul": 7.148032455006614e-05,
        "sysevr": 0.19437812268733978,
        "devign": 0.6282495856285095
    },
    {
        "code": "int shmem_lock(struct file *file, int lock, struct user_struct *user)\n{\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
        "vul_func_with_fix": "int shmem_lock(struct file *file, int lock, struct user_struct *user)\n{\n\treturn 0;\n}\n",
        "linevul": 7.4212126492057e-05,
        "sysevr": 0.14752282202243805,
        "devign": 2.9372627068369184e-06
    },
    {
        "code": "long keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b4a1b4f5047e4f54e194681125c74c0aa64d637d",
        "vul_func_with_fix": "long keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n",
        "linevul": 0.0003186328976880759,
        "sysevr": 0.24921497702598572,
        "devign": 2.0429013480005846e-22
    },
    {
        "code": "static void __init khugepaged_slab_free(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n\tmm_slot_cache = NULL;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/78f11a255749d09025f54d4e2df4fbcb031530e2",
        "vul_func_with_fix": "static void __init khugepaged_slab_free(void)\n{\n\tkmem_cache_destroy(mm_slot_cache);\n\tmm_slot_cache = NULL;\n}\n",
        "linevul": 5.2207342378096655e-05,
        "sysevr": 0.12468361854553223,
        "devign": 0.29803967475891113
    },
    {
        "code": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n \n\tp = (const char __user *)current->mm->arg_start;\n \n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n \n\t/*\n\t * we need some kernel buffer to hold the userspace args.  Just\n\t * allocate one big one rather than allocating one of the right size\n\t * for every single argument inside audit_log_single_execve_arg()\n\t * should be <8k allocation so should be pretty safe.\n\t */\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n \n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c",
        "vul_func_with_fix": "static void audit_log_execve_info(struct audit_context *context,\n//flaw_line_below:\n\t\t\t\t  struct audit_buffer **ab)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tint i, len;\n//flaw_line_below:\n\tsize_t len_sent = 0;\n//flaw_line_below:\n\tconst char __user *p;\n//flaw_line_below:\n\tchar *buf;\n//fix_flaw_line_below:\n//\t\t/* write as much as we can to the audit log */\n//fix_flaw_line_below:\n//\t\tif (len_buf > 0) {\n//fix_flaw_line_below:\n//\t\t\t/* NOTE: some magic numbers here - basically if we\n//fix_flaw_line_below:\n//\t\t\t *       can't fit a reasonable amount of data into the\n//fix_flaw_line_below:\n//\t\t\t *       existing audit buffer, flush it and start with\n//fix_flaw_line_below:\n//\t\t\t *       a new buffer */\n//fix_flaw_line_below:\n//\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n//fix_flaw_line_below:\n//\t\t\t\tlen_rem = len_max;\n//fix_flaw_line_below:\n//\t\t\t\taudit_log_end(*ab);\n//fix_flaw_line_below:\n//\t\t\t\t*ab = audit_log_start(context,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n//fix_flaw_line_below:\n//\t\t\t\tif (!*ab)\n//fix_flaw_line_below:\n//\t\t\t\t\tgoto out;\n//fix_flaw_line_below:\n//\t\t\t}\n \n//flaw_line_below:\n\tp = (const char __user *)current->mm->arg_start;\n//fix_flaw_line_below:\n//\t\t\t/* create the non-arg portion of the arg record */\n//fix_flaw_line_below:\n//\t\t\tlen_tmp = 0;\n//fix_flaw_line_below:\n//\t\t\tif (require_data || (iter > 0) ||\n//fix_flaw_line_below:\n//\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n//fix_flaw_line_below:\n//\t\t\t\tif (iter == 0) {\n//fix_flaw_line_below:\n//\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\t\" a%d_len=%lu\",\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\targ, len_full);\n//fix_flaw_line_below:\n//\t\t\t\t}\n//fix_flaw_line_below:\n//\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n//fix_flaw_line_below:\n//\t\t\t} else\n//fix_flaw_line_below:\n//\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    \" a%d=\", arg);\n//fix_flaw_line_below:\n//\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n//fix_flaw_line_below:\n//\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\t/* log the arg in the audit record */\n//fix_flaw_line_below:\n//\t\t\taudit_log_format(*ab, \"%s\", abuf);\n//fix_flaw_line_below:\n//\t\t\tlen_rem -= len_tmp;\n//fix_flaw_line_below:\n//\t\t\tlen_tmp = len_buf;\n//fix_flaw_line_below:\n//\t\t\tif (encode) {\n//fix_flaw_line_below:\n//\t\t\t\tif (len_abuf > len_rem)\n//fix_flaw_line_below:\n//\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n//fix_flaw_line_below:\n//\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n//fix_flaw_line_below:\n//\t\t\t\tlen_rem -= len_tmp * 2;\n//fix_flaw_line_below:\n//\t\t\t\tlen_abuf -= len_tmp * 2;\n//fix_flaw_line_below:\n//\t\t\t} else {\n//fix_flaw_line_below:\n//\t\t\t\tif (len_abuf > len_rem)\n//fix_flaw_line_below:\n//\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n//fix_flaw_line_below:\n//\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n//fix_flaw_line_below:\n//\t\t\t\tlen_rem -= len_tmp + 2;\n//fix_flaw_line_below:\n//\t\t\t\t/* don't subtract the \"2\" because we still need\n//fix_flaw_line_below:\n//\t\t\t\t * to add quotes to the remaining string */\n//fix_flaw_line_below:\n//\t\t\t\tlen_abuf -= len_tmp;\n//fix_flaw_line_below:\n//\t\t\t}\n//fix_flaw_line_below:\n//\t\t\tlen_buf -= len_tmp;\n//fix_flaw_line_below:\n//\t\t\tbuf += len_tmp;\n//fix_flaw_line_below:\n//\t\t}\n \n//flaw_line_below:\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n//fix_flaw_line_below:\n//\t\t/* ready to move to the next argument? */\n//fix_flaw_line_below:\n//\t\tif ((len_buf == 0) && !require_data) {\n//fix_flaw_line_below:\n//\t\t\targ++;\n//fix_flaw_line_below:\n//\t\t\titer = 0;\n//fix_flaw_line_below:\n//\t\t\tlen_full = 0;\n//fix_flaw_line_below:\n//\t\t\trequire_data = true;\n//fix_flaw_line_below:\n//\t\t\tencode = false;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t} while (arg < context->execve.argc);\n \n//flaw_line_below:\n\t/*\n//flaw_line_below:\n\t * we need some kernel buffer to hold the userspace args.  Just\n//flaw_line_below:\n\t * allocate one big one rather than allocating one of the right size\n//flaw_line_below:\n\t * for every single argument inside audit_log_single_execve_arg()\n//flaw_line_below:\n\t * should be <8k allocation so should be pretty safe.\n//flaw_line_below:\n\t */\n//flaw_line_below:\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n//flaw_line_below:\n\tif (!buf) {\n//flaw_line_below:\n\t\taudit_panic(\"out of memory for argv string\");\n//flaw_line_below:\n\t\treturn;\n//flaw_line_below:\n\t}\n//fix_flaw_line_below:\n//\t/* NOTE: the caller handles the final audit_log_end() call */\n \n//flaw_line_below:\n\tfor (i = 0; i < context->execve.argc; i++) {\n//flaw_line_below:\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n//flaw_line_below:\n\t\t\t\t\t\t  &len_sent, p, buf);\n//flaw_line_below:\n\t\tif (len <= 0)\n//flaw_line_below:\n\t\t\tbreak;\n//flaw_line_below:\n\t\tp += len;\n//flaw_line_below:\n\t}\n//flaw_line_below:\n\tkfree(buf);\n//fix_flaw_line_below:\n//out:\n//fix_flaw_line_below:\n//\tkfree(buf_head);\n }\n",
        "linevul": 0.01699114590883255,
        "sysevr": 0.15561047196388245,
        "devign": 9.5076376283032e-07
    },
    {
        "code": "static unsigned int qib_poll_urgent(struct qib_ctxtdata *rcd,\n\t\t\t\t    struct file *fp,\n\t\t\t\t    struct poll_table_struct *pt)\n{\n\tstruct qib_devdata *dd = rcd->dd;\n\tunsigned pollflag;\n\n\tpoll_wait(fp, &rcd->wait, pt);\n\n\tspin_lock_irq(&dd->uctxt_lock);\n\tif (rcd->urgent != rcd->urgent_poll) {\n\t\tpollflag = POLLIN | POLLRDNORM;\n\t\trcd->urgent_poll = rcd->urgent;\n\t} else {\n\t\tpollflag = 0;\n\t\tset_bit(QIB_CTXT_WAITING_URG, &rcd->flag);\n\t}\n\tspin_unlock_irq(&dd->uctxt_lock);\n\n\treturn pollflag;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static unsigned int qib_poll_urgent(struct qib_ctxtdata *rcd,\n\t\t\t\t    struct file *fp,\n\t\t\t\t    struct poll_table_struct *pt)\n{\n\tstruct qib_devdata *dd = rcd->dd;\n\tunsigned pollflag;\n\n\tpoll_wait(fp, &rcd->wait, pt);\n\n\tspin_lock_irq(&dd->uctxt_lock);\n\tif (rcd->urgent != rcd->urgent_poll) {\n\t\tpollflag = POLLIN | POLLRDNORM;\n\t\trcd->urgent_poll = rcd->urgent;\n\t} else {\n\t\tpollflag = 0;\n\t\tset_bit(QIB_CTXT_WAITING_URG, &rcd->flag);\n\t}\n\tspin_unlock_irq(&dd->uctxt_lock);\n\n\treturn pollflag;\n}\n",
        "linevul": 4.57086025562603e-05,
        "sysevr": 0.12657985091209412,
        "devign": 6.461583712535912e-09
    },
    {
        "code": "static void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n",
        "linevul": 0.00017250115342903882,
        "sysevr": 0.12728570401668549,
        "devign": 0.4320279061794281
    },
    {
        "code": "static inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
        "vul_func_with_fix": "static inline __be64 *metapointer(unsigned int height, const struct metapath *mp)\n{\n\tstruct buffer_head *bh = mp->mp_bh[height];\n\tunsigned int head_size = (height > 0) ?\n\t\tsizeof(struct gfs2_meta_header) : sizeof(struct gfs2_dinode);\n\treturn ((__be64 *)(bh->b_data + head_size)) + mp->mp_list[height];\n}\n",
        "linevul": 0.0007258933619596064,
        "sysevr": 0.13722175359725952,
        "devign": 3.147459515240314e-10
    },
    {
        "code": "static int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->pid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_end(skb, nlh);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836",
        "vul_func_with_fix": "static int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->pid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_end(skb, nlh);\n}\n",
        "linevul": 4.904259549221024e-05,
        "sysevr": 0.12337831407785416,
        "devign": 2.8369188508764465e-12
    },
    {
        "code": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}\n",
        "linevul": 5.4936557717155665e-05,
        "sysevr": 0.13682040572166443,
        "devign": 1.7535576324334556e-09
    },
    {
        "code": "int crypto_get_default_rng(void)\n{\n\tstruct crypto_rng *rng;\n\tint err;\n\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!crypto_default_rng) {\n\t\trng = crypto_alloc_rng(\"stdrng\", 0, 0);\n\t\terr = PTR_ERR(rng);\n\t\tif (IS_ERR(rng))\n\t\t\tgoto unlock;\n\n\t\terr = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\t\tif (err) {\n\t\t\tcrypto_free_rng(rng);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcrypto_default_rng = rng;\n\t}\n\n\tcrypto_default_rng_refcnt++;\n\terr = 0;\n\nunlock:\n\tmutex_unlock(&crypto_default_rng_lock);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "vul_func_with_fix": "int crypto_get_default_rng(void)\n{\n\tstruct crypto_rng *rng;\n\tint err;\n\n\tmutex_lock(&crypto_default_rng_lock);\n\tif (!crypto_default_rng) {\n\t\trng = crypto_alloc_rng(\"stdrng\", 0, 0);\n\t\terr = PTR_ERR(rng);\n\t\tif (IS_ERR(rng))\n\t\t\tgoto unlock;\n\n\t\terr = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n\t\tif (err) {\n\t\t\tcrypto_free_rng(rng);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcrypto_default_rng = rng;\n\t}\n\n\tcrypto_default_rng_refcnt++;\n\terr = 0;\n\nunlock:\n\tmutex_unlock(&crypto_default_rng_lock);\n\n\treturn err;\n}\n",
        "linevul": 0.00027862723800353706,
        "sysevr": 0.16814395785331726,
        "devign": 9.249019247014202e-23
    },
    {
        "code": "static void zlib_comp_exit(struct zlib_ctx *ctx)\n{\n\tstruct z_stream_s *stream = &ctx->comp_stream;\n\n\tif (stream->workspace) {\n\t\tzlib_deflateEnd(stream);\n\t\tvfree(stream->workspace);\n\t\tstream->workspace = NULL;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static void zlib_comp_exit(struct zlib_ctx *ctx)\n{\n\tstruct z_stream_s *stream = &ctx->comp_stream;\n\n\tif (stream->workspace) {\n\t\tzlib_deflateEnd(stream);\n\t\tvfree(stream->workspace);\n\t\tstream->workspace = NULL;\n\t}\n}\n",
        "linevul": 6.925749039510265e-05,
        "sysevr": 0.12828898429870605,
        "devign": 2.668486959178651e-12
    },
    {
        "code": "int sched_setattr(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, true, true);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "int sched_setattr(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, true, true);\n}\n",
        "linevul": 6.700196536257863e-05,
        "sysevr": 0.14663363993167877,
        "devign": 2.6459007131052203e-05
    },
    {
        "code": "static void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)\n{\n\tu32 size = width * height, i;\n\n\tout += size - 1;\n\n\tfor (i = size; i--; )\n\t\t*out-- = *in++;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fc9bbca8f650e5f738af8806317c0a041a48ae4a",
        "vul_func_with_fix": "static void fb_rotate_logo_ud(const u8 *in, u8 *out, u32 width, u32 height)\n{\n\tu32 size = width * height, i;\n\n\tout += size - 1;\n\n\tfor (i = size; i--; )\n\t\t*out-- = *in++;\n}\n",
        "linevul": 4.726901897811331e-05,
        "sysevr": 0.14313830435276031,
        "devign": 1.2246387714673346e-12
    },
    {
        "code": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n\tint points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Shortcut check for a thread sharing p->mm that is OOM_SCORE_ADJ_MIN\n\t * so the entire heuristic doesn't need to be executed for something\n\t * that cannot be killed.\n\t */\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The memory controller may have a limit of 0 bytes, so avoid a divide\n\t * by zero, if necessary.\n\t */\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\n\t/*\n\t * Root processes get 3% bonus, just like the __vm_enough_memory()\n\t * implementation used by LSMs.\n\t */\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\n\t/*\n\t * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may\n\t * either completely disable oom killing or always prefer a certain\n\t * task.\n\t */\n\tpoints += p->signal->oom_score_adj;\n\n\t/*\n\t * Never return 0 for an eligible task that may be killed since it's\n\t * possible that no single user task uses more than 0.1% of memory and\n\t * no single admin tasks uses more than 3.0%.\n\t */\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/56c6a8a4aadca809e04276eabe5552935c51387f",
        "vul_func_with_fix": " unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n//flaw_line_below:\n\tint points;\n//fix_flaw_line_below:\n//\tlong points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Shortcut check for a thread sharing p->mm that is OOM_SCORE_ADJ_MIN\n\t * so the entire heuristic doesn't need to be executed for something\n\t * that cannot be killed.\n\t */\n\tif (atomic_read(&p->mm->oom_disable_count)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The memory controller may have a limit of 0 bytes, so avoid a divide\n\t * by zero, if necessary.\n\t */\n\tif (!totalpages)\n\t\ttotalpages = 1;\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;\n\tpoints += get_mm_counter(p->mm, MM_SWAPENTS);\n\n\tpoints *= 1000;\n\tpoints /= totalpages;\n\ttask_unlock(p);\n\n\t/*\n\t * Root processes get 3% bonus, just like the __vm_enough_memory()\n\t * implementation used by LSMs.\n\t */\n\tif (has_capability_noaudit(p, CAP_SYS_ADMIN))\n\t\tpoints -= 30;\n\n\t/*\n\t * /proc/pid/oom_score_adj ranges from -1000 to +1000 such that it may\n\t * either completely disable oom killing or always prefer a certain\n\t * task.\n\t */\n\tpoints += p->signal->oom_score_adj;\n\n\t/*\n\t * Never return 0 for an eligible task that may be killed since it's\n\t * possible that no single user task uses more than 0.1% of memory and\n\t * no single admin tasks uses more than 3.0%.\n\t */\n\tif (points <= 0)\n\t\treturn 1;\n\treturn (points < 1000) ? points : 1000;\n}\n",
        "linevul": 0.9996757507324219,
        "sysevr": 0.2015809714794159,
        "devign": 0.9828996062278748
    },
    {
        "code": "static void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->pre_pcpu == -1)\n\t\treturn;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\t__pi_post_block(vcpu);\n\tlocal_irq_enable();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8",
        "vul_func_with_fix": "static void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->pre_pcpu == -1)\n\t\treturn;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\t__pi_post_block(vcpu);\n\tlocal_irq_enable();\n}\n",
        "linevul": 4.8642261390341446e-05,
        "sysevr": 0.12708905339241028,
        "devign": 5.781983434457714e-20
    },
    {
        "code": "int sock_no_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,\n\t\t    size_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc",
        "vul_func_with_fix": "int sock_no_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,\n\t\t    size_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n",
        "linevul": 6.478578870883211e-05,
        "sysevr": 0.16753143072128296,
        "devign": 0.00017340453632641584
    },
    {
        "code": "void sctp_v6_protosw_exit(void)\n{\n\tinet6_unregister_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_unregister_protosw(&sctpv6_stream_protosw);\n\tproto_unregister(&sctpv6_prot);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7",
        "vul_func_with_fix": "void sctp_v6_protosw_exit(void)\n{\n\tinet6_unregister_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_unregister_protosw(&sctpv6_stream_protosw);\n\tproto_unregister(&sctpv6_prot);\n}\n",
        "linevul": 8.89797302079387e-05,
        "sysevr": 0.15830755233764648,
        "devign": 4.049636288527836e-07
    },
    {
        "code": "static int param_get_mode(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", profile_mode_names[aa_g_profile_mode]);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a5b2c5b2ad5853591a6cac6134cd0f599a720865",
        "vul_func_with_fix": "static int param_get_mode(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", profile_mode_names[aa_g_profile_mode]);\n}\n",
        "linevul": 5.354757377062924e-05,
        "sysevr": 0.12870392203330994,
        "devign": 2.39357061948553e-10
    },
    {
        "code": "void path_put(struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "vul_func_with_fix": "void path_put(struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\n",
        "linevul": 0.00011207058560103178,
        "sysevr": 0.15612170100212097,
        "devign": 1.7741942359705831e-09
    },
    {
        "code": "static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tsavesegment(fs, vmx->host_state.fs_sel);\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tsavesegment(gs, vmx->host_state.gs_sel);\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, vmx->host_state.ds_sel);\n\tsavesegment(es, vmx->host_state.es_sel);\n#endif\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\tif (is_long_mode(&vmx->vcpu))\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint i;\n\n\tif (vmx->host_state.loaded)\n\t\treturn;\n\n\tvmx->host_state.loaded = 1;\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\tvmx->host_state.ldt_sel = kvm_read_ldt();\n\tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n\tsavesegment(fs, vmx->host_state.fs_sel);\n\tif (!(vmx->host_state.fs_sel & 7)) {\n\t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n\t\tvmx->host_state.fs_reload_needed = 0;\n\t} else {\n\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\tvmx->host_state.fs_reload_needed = 1;\n\t}\n\tsavesegment(gs, vmx->host_state.gs_sel);\n\tif (!(vmx->host_state.gs_sel & 7))\n\t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n\telse {\n\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\tvmx->host_state.gs_ldt_reload_needed = 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, vmx->host_state.ds_sel);\n\tsavesegment(es, vmx->host_state.es_sel);\n#endif\n\n#ifdef CONFIG_X86_64\n\tvmcs_writel(HOST_FS_BASE, read_msr(MSR_FS_BASE));\n\tvmcs_writel(HOST_GS_BASE, read_msr(MSR_GS_BASE));\n#else\n\tvmcs_writel(HOST_FS_BASE, segment_base(vmx->host_state.fs_sel));\n\tvmcs_writel(HOST_GS_BASE, segment_base(vmx->host_state.gs_sel));\n#endif\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\tif (is_long_mode(&vmx->vcpu))\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t   vmx->guest_msrs[i].mask);\n}\n",
        "linevul": 8.375776087632403e-05,
        "sysevr": 0.1285407543182373,
        "devign": 8.814122278732293e-19
    },
    {
        "code": "static void seq_startplay(void)\n{\n\tint this_one, action;\n\tunsigned long flags;\n\n\twhile (qlen > 0)\n\t{\n\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tqhead = ((this_one = qhead) + 1) % SEQ_MAX_QUEUE;\n\t\tqlen--;\n\t\tspin_unlock_irqrestore(&lock,flags);\n\n\t\tseq_playing = 1;\n\n\t\tif ((action = play_event(&queue[this_one * EV_SZ])))\n\t\t{\t\t/* Suspend playback. Next timer routine invokes this routine again */\n\t\t\tif (action == 2)\n\t\t\t{\n\t\t\t\tqlen++;\n\t\t\t\tqhead = this_one;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tseq_playing = 0;\n\n\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\twake_up(&seq_sleeper);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/b769f49463711205d57286e64cf535ed4daf59e9",
        "vul_func_with_fix": "static void seq_startplay(void)\n{\n\tint this_one, action;\n\tunsigned long flags;\n\n\twhile (qlen > 0)\n\t{\n\n\t\tspin_lock_irqsave(&lock,flags);\n\t\tqhead = ((this_one = qhead) + 1) % SEQ_MAX_QUEUE;\n\t\tqlen--;\n\t\tspin_unlock_irqrestore(&lock,flags);\n\n\t\tseq_playing = 1;\n\n\t\tif ((action = play_event(&queue[this_one * EV_SZ])))\n\t\t{\t\t/* Suspend playback. Next timer routine invokes this routine again */\n\t\t\tif (action == 2)\n\t\t\t{\n\t\t\t\tqlen++;\n\t\t\t\tqhead = this_one;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tseq_playing = 0;\n\n\tif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\n\t\twake_up(&seq_sleeper);\n}\n",
        "linevul": 5.006168794352561e-05,
        "sysevr": 0.14053115248680115,
        "devign": 9.797415695675718e-17
    },
    {
        "code": "static struct tcp_md5sig_key *tcp_v4_reqsk_md5_lookup(struct sock *sk,\n\t\t\t\t\t\t      struct request_sock *req)\n{\n\treturn tcp_v4_md5_do_lookup(sk, inet_rsk(req)->rmt_addr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static struct tcp_md5sig_key *tcp_v4_reqsk_md5_lookup(struct sock *sk,\n\t\t\t\t\t\t      struct request_sock *req)\n{\n\treturn tcp_v4_md5_do_lookup(sk, inet_rsk(req)->rmt_addr);\n}\n",
        "linevul": 6.65372863295488e-05,
        "sysevr": 0.12523634731769562,
        "devign": 1.0072038776343106e-06
    },
    {
        "code": "static int hwsim_unicast_netgroup(struct mac80211_hwsim_data *data,\n\t\t\t\t  struct sk_buff *skb, int portid)\n{\n\tstruct net *net;\n\tbool found = false;\n\tint res = -ENOENT;\n\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net)) {\n\t\t\tres = genlmsg_unicast(net, skb, portid);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found)\n\t\tnlmsg_free(skb);\n\n\treturn res;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "vul_func_with_fix": "static int hwsim_unicast_netgroup(struct mac80211_hwsim_data *data,\n\t\t\t\t  struct sk_buff *skb, int portid)\n{\n\tstruct net *net;\n\tbool found = false;\n\tint res = -ENOENT;\n\n\trcu_read_lock();\n\tfor_each_net_rcu(net) {\n\t\tif (data->netgroup == hwsim_net_get_netgroup(net)) {\n\t\t\tres = genlmsg_unicast(net, skb, portid);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found)\n\t\tnlmsg_free(skb);\n\n\treturn res;\n}\n",
        "linevul": 4.714207898359746e-05,
        "sysevr": 0.12300017476081848,
        "devign": 1.4908078980185185e-16
    },
    {
        "code": "static void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, &data->res->lr_seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\tdprintk(\"%s Retry: tk_status %d\\n\", __func__, task->tk_status);\n\t\trpc_delay(task, NFS4_POLL_RETRY_MIN);\n\t\ttask->tk_status = 0;\n\t\t/* fall through */\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "vul_func_with_fix": "static void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, &data->res->lr_seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\tdprintk(\"%s Retry: tk_status %d\\n\", __func__, task->tk_status);\n\t\trpc_delay(task, NFS4_POLL_RETRY_MIN);\n\t\ttask->tk_status = 0;\n\t\t/* fall through */\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n",
        "linevul": 5.913569839322008e-05,
        "sysevr": 0.12378472834825516,
        "devign": 3.0274002055241667e-11
    },
    {
        "code": "update_stats_wait_start(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 wait_start, prev_wait_start;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\twait_start = rq_clock(rq_of(cfs_rq));\n\tprev_wait_start = schedstat_val(se->statistics.wait_start);\n\n\tif (entity_is_task(se) && task_on_rq_migrating(task_of(se)) &&\n\t    likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(se->statistics.wait_start, wait_start);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "update_stats_wait_start(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 wait_start, prev_wait_start;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\twait_start = rq_clock(rq_of(cfs_rq));\n\tprev_wait_start = schedstat_val(se->statistics.wait_start);\n\n\tif (entity_is_task(se) && task_on_rq_migrating(task_of(se)) &&\n\t    likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(se->statistics.wait_start, wait_start);\n}\n",
        "linevul": 4.745646583614871e-05,
        "sysevr": 0.15242061018943787,
        "devign": 1.6228372260229662e-05
    },
    {
        "code": "event_sched_in(struct perf_event *event,\n\t\t struct perf_cpu_context *cpuctx,\n\t\t struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\n\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tevent->state = PERF_EVENT_STATE_ACTIVE;\n\tevent->oncpu = smp_processor_id();\n\n\t/*\n\t * Unthrottle events, since we scheduled we might have missed several\n\t * ticks already, also for a heavily scheduling task there is little\n\t * guarantee it'll get a tick in a timely manner.\n\t */\n\tif (unlikely(event->hw.interrupts == MAX_INTERRUPTS)) {\n\t\tperf_log_throttle(event, 1);\n\t\tevent->hw.interrupts = 0;\n\t}\n\n\t/*\n\t * The new state must be visible before we turn it on in the hardware:\n\t */\n\tsmp_wmb();\n\n\tif (event->pmu->add(event, PERF_EF_START)) {\n\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\tevent->oncpu = -1;\n\t\treturn -EAGAIN;\n\t}\n\n\tevent->tstamp_running += tstamp - event->tstamp_stopped;\n\n\tperf_set_shadow_time(event, ctx, tstamp);\n\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu++;\n\tctx->nr_active++;\n\n\tif (event->attr.exclusive)\n\t\tcpuctx->exclusive = 1;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "event_sched_in(struct perf_event *event,\n\t\t struct perf_cpu_context *cpuctx,\n\t\t struct perf_event_context *ctx)\n{\n\tu64 tstamp = perf_event_time(event);\n\n\tif (event->state <= PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tevent->state = PERF_EVENT_STATE_ACTIVE;\n\tevent->oncpu = smp_processor_id();\n\n\t/*\n\t * Unthrottle events, since we scheduled we might have missed several\n\t * ticks already, also for a heavily scheduling task there is little\n\t * guarantee it'll get a tick in a timely manner.\n\t */\n\tif (unlikely(event->hw.interrupts == MAX_INTERRUPTS)) {\n\t\tperf_log_throttle(event, 1);\n\t\tevent->hw.interrupts = 0;\n\t}\n\n\t/*\n\t * The new state must be visible before we turn it on in the hardware:\n\t */\n\tsmp_wmb();\n\n\tif (event->pmu->add(event, PERF_EF_START)) {\n\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\tevent->oncpu = -1;\n\t\treturn -EAGAIN;\n\t}\n\n\tevent->tstamp_running += tstamp - event->tstamp_stopped;\n\n\tperf_set_shadow_time(event, ctx, tstamp);\n\n\tif (!is_software_event(event))\n\t\tcpuctx->active_oncpu++;\n\tctx->nr_active++;\n\n\tif (event->attr.exclusive)\n\t\tcpuctx->exclusive = 1;\n\n\treturn 0;\n}\n",
        "linevul": 8.37050611153245e-05,
        "sysevr": 0.20604738593101501,
        "devign": 1.1892547978956086e-33
    },
    {
        "code": "int __mnt_want_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (!(file->f_mode & FMODE_WRITE) || special_file(inode->i_mode))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/132c94e31b8bca8ea921f9f96a57d684fa4ae0a9",
        "vul_func_with_fix": "int __mnt_want_write_file(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tif (!(file->f_mode & FMODE_WRITE) || special_file(inode->i_mode))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}\n",
        "linevul": 8.202947356039658e-05,
        "sysevr": 0.16661007702350616,
        "devign": 1.1565580493311245e-08
    },
    {
        "code": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\n\trc = check_fxsr(ctxt);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->ops->get_fpu(ctxt);\n\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\n\tctxt->ops->put_fpu(ctxt);\n\n\treturn rc;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/129a72a0d3c8e139a04512325384fe5ac119e74d",
        "vul_func_with_fix": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\n\trc = check_fxsr(ctxt);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n//flaw_line_below:\n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n//fix_flaw_line_below:\n//\trc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->ops->get_fpu(ctxt);\n\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\n\tctxt->ops->put_fpu(ctxt);\n\n\treturn rc;\n}\n",
        "linevul": 0.9994221925735474,
        "sysevr": 0.13693588972091675,
        "devign": 3.514901141727081e-30
    },
    {
        "code": "static void udp_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst)\n{\n\tstruct dst_entry *old;\n\n\tdst_hold(dst);\n\told = xchg(&sk->sk_rx_dst, dst);\n\tdst_release(old);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0",
        "vul_func_with_fix": "static void udp_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst)\n{\n\tstruct dst_entry *old;\n\n\tdst_hold(dst);\n\told = xchg(&sk->sk_rx_dst, dst);\n\tdst_release(old);\n}\n",
        "linevul": 5.0120062951464206e-05,
        "sysevr": 0.12107132375240326,
        "devign": 3.903917255654657e-15
    },
    {
        "code": "int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_destroy_dumb *args = data;\n\n\tif (!dev->driver->dumb_destroy)\n\t\treturn -ENOSYS;\n\n\treturn dev->driver->dumb_destroy(file_priv, dev, args->handle);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a5cd335165e31db9dbab636fd29895d41da55dd2",
        "vul_func_with_fix": "int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,\n\t\t\t\tvoid *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_destroy_dumb *args = data;\n\n\tif (!dev->driver->dumb_destroy)\n\t\treturn -ENOSYS;\n\n\treturn dev->driver->dumb_destroy(file_priv, dev, args->handle);\n}\n",
        "linevul": 5.047124795964919e-05,
        "sysevr": 0.15321031212806702,
        "devign": 6.07994792289901e-08
    },
    {
        "code": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n \t\ttu->tstamp = *tstamp;\n \tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n \t\treturn;\n \tr1.event = event;\n \tr1.tstamp = *tstamp;\n \tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/9a47e9cff994f37f7f0dbd9ae23740d0f64f9fe6",
        "vul_func_with_fix": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n \t\ttu->tstamp = *tstamp;\n \tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n \t\treturn;\n//fix_flaw_line_below:\n//\tmemset(&r1, 0, sizeof(r1));\n \tr1.event = event;\n \tr1.tstamp = *tstamp;\n \tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n",
        "linevul": 0.9992055296897888,
        "sysevr": 0.14333541691303253,
        "devign": 3.770511536806324e-20
    },
    {
        "code": "static int airo_set_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\t/* Check the size of the string */\n\tif(dwrq->length > 16) {\n\t\treturn -E2BIG;\n\t}\n\treadConfigRid(local, 1);\n\tmemset(local->config.nodeName, 0, sizeof(local->config.nodeName));\n\tmemcpy(local->config.nodeName, extra, dwrq->length);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "static int airo_set_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\t/* Check the size of the string */\n\tif(dwrq->length > 16) {\n\t\treturn -E2BIG;\n\t}\n\treadConfigRid(local, 1);\n\tmemset(local->config.nodeName, 0, sizeof(local->config.nodeName));\n\tmemcpy(local->config.nodeName, extra, dwrq->length);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n",
        "linevul": 4.808755693375133e-05,
        "sysevr": 0.14336320757865906,
        "devign": 4.608493096558473e-22
    },
    {
        "code": "static bool convert_bpf_extensions(struct sock_filter *fp,\n\t\t\t\t   struct sock_filter_int **insnp)\n{\n\tstruct sock_filter_int *insn = *insnp;\n\n\tswitch (fp->k) {\n\tcase SKF_AD_OFF + SKF_AD_PROTOCOL:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, protocol);\n\t\tinsn++;\n\n\t\t/* A = ntohs(A) [emitting a nop or swap16] */\n\t\tinsn->code = BPF_ALU | BPF_END | BPF_FROM_BE;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = 16;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PKTTYPE:\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_B;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = pkt_type_offset();\n\t\tif (insn->off < 0)\n\t\t\treturn false;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = PKT_TYPE_MAX;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_IFINDEX:\n\tcase SKF_AD_OFF + SKF_AD_HATYPE:\n\t\tif (FIELD_SIZEOF(struct sk_buff, dev) == 8)\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_DW;\n\t\telse\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, dev);\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_JNE | BPF_K;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->imm = 0;\n\t\tinsn->off = 1;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_EXIT;\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);\n\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = TMP_REG;\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_IFINDEX) {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->off = offsetof(struct net_device, ifindex);\n\t\t} else {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\t\tinsn->off = offsetof(struct net_device, type);\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_MARK:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, mark);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_RXHASH:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, hash);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_QUEUE:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, queue_mapping);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG:\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, vlan_tci);\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_VLAN_TAG) {\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = ~VLAN_TAG_PRESENT;\n\t\t} else {\n\t\t\tinsn->code = BPF_ALU | BPF_RSH | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 12;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 1;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t/* arg1 = ctx */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG1_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn++;\n\n\t\t/* arg2 = A */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG2_REG;\n\t\tinsn->x_reg = A_REG;\n\t\tinsn++;\n\n\t\t/* arg3 = X */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG3_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tinsn++;\n\n\t\t/* Emit call(ctx, arg2=A, arg3=X) */\n\t\tinsn->code = BPF_JMP | BPF_CALL;\n\t\tswitch (fp->k) {\n\t\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\t\t\tinsn->imm = __skb_get_pay_offset - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\t\t\tinsn->imm = __skb_get_nlattr - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\t\t\tinsn->imm = __skb_get_nlattr_nest - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t\tinsn->imm = __get_raw_cpu_id - __bpf_call_base;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_ALU_XOR_X:\n\t\tinsn->code = BPF_ALU | BPF_XOR | BPF_X;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tbreak;\n\n\tdefault:\n\t\t/* This is just a dummy call to avoid letting the compiler\n\t\t * evict __bpf_call_base() as an optimization. Placed here\n\t\t * where no-one bothers.\n\t\t */\n\t\tBUG_ON(__bpf_call_base(0, 0, 0, 0, 0) != 0);\n\t\treturn false;\n\t}\n\n\t*insnp = insn;\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3",
        "vul_func_with_fix": "static bool convert_bpf_extensions(struct sock_filter *fp,\n\t\t\t\t   struct sock_filter_int **insnp)\n{\n\tstruct sock_filter_int *insn = *insnp;\n\n\tswitch (fp->k) {\n\tcase SKF_AD_OFF + SKF_AD_PROTOCOL:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, protocol);\n\t\tinsn++;\n\n\t\t/* A = ntohs(A) [emitting a nop or swap16] */\n\t\tinsn->code = BPF_ALU | BPF_END | BPF_FROM_BE;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = 16;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PKTTYPE:\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_B;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = pkt_type_offset();\n\t\tif (insn->off < 0)\n\t\t\treturn false;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->imm = PKT_TYPE_MAX;\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_IFINDEX:\n\tcase SKF_AD_OFF + SKF_AD_HATYPE:\n\t\tif (FIELD_SIZEOF(struct sk_buff, dev) == 8)\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_DW;\n\t\telse\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, dev);\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_JNE | BPF_K;\n\t\tinsn->a_reg = TMP_REG;\n\t\tinsn->imm = 0;\n\t\tinsn->off = 1;\n\t\tinsn++;\n\n\t\tinsn->code = BPF_JMP | BPF_EXIT;\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);\n\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = TMP_REG;\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_IFINDEX) {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\t\tinsn->off = offsetof(struct net_device, ifindex);\n\t\t} else {\n\t\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\t\tinsn->off = offsetof(struct net_device, type);\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_MARK:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, mark);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_RXHASH:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_W;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, hash);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_QUEUE:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, queue_mapping);\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG:\n\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:\n\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);\n\n\t\tinsn->code = BPF_LDX | BPF_MEM | BPF_H;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn->off = offsetof(struct sk_buff, vlan_tci);\n\t\tinsn++;\n\n\t\tBUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);\n\n\t\tif (fp->k == SKF_AD_OFF + SKF_AD_VLAN_TAG) {\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = ~VLAN_TAG_PRESENT;\n\t\t} else {\n\t\t\tinsn->code = BPF_ALU | BPF_RSH | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 12;\n\t\t\tinsn++;\n\n\t\t\tinsn->code = BPF_ALU | BPF_AND | BPF_K;\n\t\t\tinsn->a_reg = A_REG;\n\t\t\tinsn->imm = 1;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t/* arg1 = ctx */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG1_REG;\n\t\tinsn->x_reg = CTX_REG;\n\t\tinsn++;\n\n\t\t/* arg2 = A */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG2_REG;\n\t\tinsn->x_reg = A_REG;\n\t\tinsn++;\n\n\t\t/* arg3 = X */\n\t\tinsn->code = BPF_ALU64 | BPF_MOV | BPF_X;\n\t\tinsn->a_reg = ARG3_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tinsn++;\n\n\t\t/* Emit call(ctx, arg2=A, arg3=X) */\n\t\tinsn->code = BPF_JMP | BPF_CALL;\n\t\tswitch (fp->k) {\n\t\tcase SKF_AD_OFF + SKF_AD_PAY_OFFSET:\n\t\t\tinsn->imm = __skb_get_pay_offset - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR:\n\t\t\tinsn->imm = __skb_get_nlattr - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_NLATTR_NEST:\n\t\t\tinsn->imm = __skb_get_nlattr_nest - __bpf_call_base;\n\t\t\tbreak;\n\t\tcase SKF_AD_OFF + SKF_AD_CPU:\n\t\t\tinsn->imm = __get_raw_cpu_id - __bpf_call_base;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SKF_AD_OFF + SKF_AD_ALU_XOR_X:\n\t\tinsn->code = BPF_ALU | BPF_XOR | BPF_X;\n\t\tinsn->a_reg = A_REG;\n\t\tinsn->x_reg = X_REG;\n\t\tbreak;\n\n\tdefault:\n\t\t/* This is just a dummy call to avoid letting the compiler\n\t\t * evict __bpf_call_base() as an optimization. Placed here\n\t\t * where no-one bothers.\n\t\t */\n\t\tBUG_ON(__bpf_call_base(0, 0, 0, 0, 0) != 0);\n\t\treturn false;\n\t}\n\n\t*insnp = insn;\n\treturn true;\n}\n",
        "linevul": 5.160976797924377e-05,
        "sysevr": 0.20822429656982422,
        "devign": 0.9908334612846375
    },
    {
        "code": "static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n\t\t\t\t  int udfLen, uint8_t *fidName,\n\t\t\t\t  int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n\tunsigned short valueCRC;\n\tuint8_t curr;\n\n\tif (udfName[0] == '.' &&\n\t    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {\n\t\tneedsCRC = 1;\n\t\tnewIndex = udfLen;\n\t\tmemcpy(newName, udfName, udfLen);\n\t} else {\n\t\tfor (index = 0; index < udfLen; index++) {\n\t\t\tcurr = udfName[index];\n\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\tneedsCRC = 1;\n\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\twhile (index + 1 < udfLen &&\n\t\t\t\t\t\t(udfName[index + 1] == '/' ||\n\t\t\t\t\t\t udfName[index + 1] == 0))\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (curr == EXT_MARK &&\n\t\t\t\t\t(udfLen - index - 1) <= EXT_SIZE) {\n\t\t\t\tif (udfLen == index + 1)\n\t\t\t\t\thasExt = 0;\n\t\t\t\telse {\n\t\t\t\t\thasExt = 1;\n\t\t\t\t\textIndex = index;\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n\t\t\tif (newIndex < 256)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n\t\t}\n\t}\n\tif (needsCRC) {\n\t\tuint8_t ext[EXT_SIZE];\n\t\tint localExtIndex = 0;\n\n\t\tif (hasExt) {\n\t\t\tint maxFilenameLen;\n\t\t\tfor (index = 0;\n\t\t\t     index < EXT_SIZE && extIndex + index + 1 < udfLen;\n\t\t\t     index++) {\n\t\t\t\tcurr = udfName[extIndex + index + 1];\n\n\t\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\t\tneedsCRC = 1;\n\t\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\t\twhile (extIndex + index + 2 < udfLen &&\n\t\t\t\t\t      (index + 1 < EXT_SIZE &&\n\t\t\t\t\t\t(udfName[extIndex + index + 2] == '/' ||\n\t\t\t\t\t\t udfName[extIndex + index + 2] == 0)))\n\t\t\t\t\t\tindex++;\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n\t\t\tmaxFilenameLen = 250 - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n\t\t} else if (newIndex > 250)\n\t\t\tnewIndex = 250;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC);\n\n\t\tif (hasExt) {\n\t\t\tnewName[newIndex++] = EXT_MARK;\n\t\t\tfor (index = 0; index < localExtIndex; index++)\n\t\t\t\tnewName[newIndex++] = ext[index];\n\t\t}\n\t}\n\n\treturn newIndex;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14",
        "vul_func_with_fix": "static int udf_translate_to_linux(uint8_t *newName, uint8_t *udfName,\n//flaw_line_below:\n\t\t\t\t  int udfLen, uint8_t *fidName,\n//flaw_line_below:\n\t\t\t\t  int fidNameLen)\n//fix_flaw_line_below:\n//static int udf_translate_to_linux(uint8_t *newName, int newLen,\n//fix_flaw_line_below:\n//\t\t\t\t  uint8_t *udfName, int udfLen,\n//fix_flaw_line_below:\n//\t\t\t\t  uint8_t *fidName, int fidNameLen)\n {\n \tint index, newIndex = 0, needsCRC = 0;\n \tint extIndex = 0, newExtIndex = 0, hasExt = 0;\n\tunsigned short valueCRC;\n\tuint8_t curr;\n\n\tif (udfName[0] == '.' &&\n\t    (udfLen == 1 || (udfLen == 2 && udfName[1] == '.'))) {\n\t\tneedsCRC = 1;\n\t\tnewIndex = udfLen;\n\t\tmemcpy(newName, udfName, udfLen);\n\t} else {\n\t\tfor (index = 0; index < udfLen; index++) {\n\t\t\tcurr = udfName[index];\n\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\tneedsCRC = 1;\n\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\twhile (index + 1 < udfLen &&\n\t\t\t\t\t\t(udfName[index + 1] == '/' ||\n\t\t\t\t\t\t udfName[index + 1] == 0))\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (curr == EXT_MARK &&\n\t\t\t\t\t(udfLen - index - 1) <= EXT_SIZE) {\n\t\t\t\tif (udfLen == index + 1)\n\t\t\t\t\thasExt = 0;\n\t\t\t\telse {\n\t\t\t\t\thasExt = 1;\n\t\t\t\t\textIndex = index;\n \t\t\t\t\tnewExtIndex = newIndex;\n \t\t\t\t}\n \t\t\t}\n//flaw_line_below:\n\t\t\tif (newIndex < 256)\n//fix_flaw_line_below:\n//\t\t\tif (newIndex < newLen)\n \t\t\t\tnewName[newIndex++] = curr;\n \t\t\telse\n \t\t\t\tneedsCRC = 1;\n\t\t}\n\t}\n\tif (needsCRC) {\n\t\tuint8_t ext[EXT_SIZE];\n\t\tint localExtIndex = 0;\n\n\t\tif (hasExt) {\n\t\t\tint maxFilenameLen;\n\t\t\tfor (index = 0;\n\t\t\t     index < EXT_SIZE && extIndex + index + 1 < udfLen;\n\t\t\t     index++) {\n\t\t\t\tcurr = udfName[extIndex + index + 1];\n\n\t\t\t\tif (curr == '/' || curr == 0) {\n\t\t\t\t\tneedsCRC = 1;\n\t\t\t\t\tcurr = ILLEGAL_CHAR_MARK;\n\t\t\t\t\twhile (extIndex + index + 2 < udfLen &&\n\t\t\t\t\t      (index + 1 < EXT_SIZE &&\n\t\t\t\t\t\t(udfName[extIndex + index + 2] == '/' ||\n\t\t\t\t\t\t udfName[extIndex + index + 2] == 0)))\n\t\t\t\t\t\tindex++;\n \t\t\t\t}\n \t\t\t\text[localExtIndex++] = curr;\n \t\t\t}\n//flaw_line_below:\n\t\t\tmaxFilenameLen = 250 - localExtIndex;\n//fix_flaw_line_below:\n//\t\t\tmaxFilenameLen = newLen - CRC_LEN - localExtIndex;\n \t\t\tif (newIndex > maxFilenameLen)\n \t\t\t\tnewIndex = maxFilenameLen;\n \t\t\telse\n \t\t\t\tnewIndex = newExtIndex;\n//flaw_line_below:\n\t\t} else if (newIndex > 250)\n//flaw_line_below:\n\t\t\tnewIndex = 250;\n//fix_flaw_line_below:\n//\t\t} else if (newIndex > newLen - CRC_LEN)\n//fix_flaw_line_below:\n//\t\t\tnewIndex = newLen - CRC_LEN;\n \t\tnewName[newIndex++] = CRC_MARK;\n \t\tvalueCRC = crc_itu_t(0, fidName, fidNameLen);\n \t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC >> 8);\n\t\tnewName[newIndex++] = hex_asc_upper_hi(valueCRC);\n\t\tnewName[newIndex++] = hex_asc_upper_lo(valueCRC);\n\n\t\tif (hasExt) {\n\t\t\tnewName[newIndex++] = EXT_MARK;\n\t\t\tfor (index = 0; index < localExtIndex; index++)\n\t\t\t\tnewName[newIndex++] = ext[index];\n\t\t}\n\t}\n\n\treturn newIndex;\n}\n",
        "linevul": 0.9994128942489624,
        "sysevr": 0.30446335673332214,
        "devign": 1.0496765678880138e-09
    },
    {
        "code": "void bio_set_pages_dirty(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\tif (page && !PageCompound(page))\n\t\t\tset_page_dirty_lock(page);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467",
        "vul_func_with_fix": "void bio_set_pages_dirty(struct bio *bio)\n{\n\tstruct bio_vec *bvec;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\tif (page && !PageCompound(page))\n\t\t\tset_page_dirty_lock(page);\n\t}\n}\n",
        "linevul": 0.0001191541668958962,
        "sysevr": 0.15366506576538086,
        "devign": 1.3421144621009184e-12
    },
    {
        "code": "release_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "release_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}\n",
        "linevul": 5.0787581130862236e-05,
        "sysevr": 0.16827473044395447,
        "devign": 2.7870784859691267e-30
    },
    {
        "code": "static int vhost_update_avail_event(struct vhost_virtqueue *vq, u16 avail_event)\n{\n\tif (__put_user(cpu_to_vhost16(vq, vq->avail_idx), vhost_avail_event(vq)))\n\t\treturn -EFAULT;\n\tif (unlikely(vq->log_used)) {\n\t\tvoid __user *used;\n\t\t/* Make sure the event is seen before log. */\n\t\tsmp_wmb();\n\t\t/* Log avail event write */\n\t\tused = vhost_avail_event(vq);\n\t\tlog_write(vq->log_base, vq->log_addr +\n\t\t\t  (used - (void __user *)vq->used),\n\t\t\t  sizeof *vhost_avail_event(vq));\n\t\tif (vq->log_ctx)\n\t\t\teventfd_signal(vq->log_ctx, 1);\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5",
        "vul_func_with_fix": "static int vhost_update_avail_event(struct vhost_virtqueue *vq, u16 avail_event)\n{\n\tif (__put_user(cpu_to_vhost16(vq, vq->avail_idx), vhost_avail_event(vq)))\n\t\treturn -EFAULT;\n\tif (unlikely(vq->log_used)) {\n\t\tvoid __user *used;\n\t\t/* Make sure the event is seen before log. */\n\t\tsmp_wmb();\n\t\t/* Log avail event write */\n\t\tused = vhost_avail_event(vq);\n\t\tlog_write(vq->log_base, vq->log_addr +\n\t\t\t  (used - (void __user *)vq->used),\n\t\t\t  sizeof *vhost_avail_event(vq));\n\t\tif (vq->log_ctx)\n\t\t\teventfd_signal(vq->log_ctx, 1);\n\t}\n\treturn 0;\n}\n",
        "linevul": 6.149529508547857e-05,
        "sysevr": 0.13523630797863007,
        "devign": 2.596220049442225e-21
    },
    {
        "code": "static int nr_setsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tunsigned long opt;\n\n\tif (level != SOL_NETROM)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (get_user(opt, (unsigned int __user *)optval))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase NETROM_T1:\n\t\tif (opt < 1 || opt > ULONG_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_T2:\n\t\tif (opt < 1 || opt > ULONG_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_N2:\n\t\tif (opt < 1 || opt > 31)\n\t\t\treturn -EINVAL;\n\t\tnr->n2 = opt;\n\t\treturn 0;\n\n\tcase NETROM_T4:\n\t\tif (opt < 1 || opt > ULONG_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t4 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_IDLE:\n\t\tif (opt > ULONG_MAX / (60 * HZ))\n\t\t\treturn -EINVAL;\n\t\tnr->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3ce5efad47b62c57a4f5c54248347085a750ce0e",
        "vul_func_with_fix": "static int nr_setsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr = nr_sk(sk);\n\tunsigned long opt;\n\n\tif (level != SOL_NETROM)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(unsigned int))\n\t\treturn -EINVAL;\n\n\tif (get_user(opt, (unsigned int __user *)optval))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase NETROM_T1:\n\t\tif (opt < 1 || opt > ULONG_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_T2:\n\t\tif (opt < 1 || opt > ULONG_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_N2:\n\t\tif (opt < 1 || opt > 31)\n\t\t\treturn -EINVAL;\n\t\tnr->n2 = opt;\n\t\treturn 0;\n\n\tcase NETROM_T4:\n\t\tif (opt < 1 || opt > ULONG_MAX / HZ)\n\t\t\treturn -EINVAL;\n\t\tnr->t4 = opt * HZ;\n\t\treturn 0;\n\n\tcase NETROM_IDLE:\n\t\tif (opt > ULONG_MAX / (60 * HZ))\n\t\t\treturn -EINVAL;\n\t\tnr->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n",
        "linevul": 6.309295713435858e-05,
        "sysevr": 0.16767612099647522,
        "devign": 0.6361005902290344
    },
    {
        "code": "static inline void ablkcipher_queue_write(struct ablkcipher_walk *walk,\n\t\t\t\t\t  struct ablkcipher_buffer *p)\n{\n\tp->dst = walk->out;\n\tlist_add_tail(&p->entry, &walk->buffers);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9a5467bf7b6e9e02ec9c3da4e23747c05faeaac6",
        "vul_func_with_fix": "static inline void ablkcipher_queue_write(struct ablkcipher_walk *walk,\n\t\t\t\t\t  struct ablkcipher_buffer *p)\n{\n\tp->dst = walk->out;\n\tlist_add_tail(&p->entry, &walk->buffers);\n}\n",
        "linevul": 7.438692409778014e-05,
        "sysevr": 0.1261020004749298,
        "devign": 1.2767094679903574e-14
    },
    {
        "code": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n {\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n \tmsleep(50);\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0x51;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n \t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n \t\t\treturn 0;\n \t\t}\n\t}\n\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n \treturn -EIO;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125",
        "vul_func_with_fix": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n//fix_flaw_line_below:\n//static int t220_frontend_attach(struct dvb_usb_adapter *adap)\n {\n//flaw_line_below:\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n//flaw_line_below:\n\tu8 ibuf[] = { 0 };\n//fix_flaw_line_below:\n//\tstruct dvb_usb_device *d = adap->dev;\n//fix_flaw_line_below:\n//\tstruct dw2102_state *state = d->priv;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tmutex_lock(&d->data_mutex);\n \n//flaw_line_below:\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n//fix_flaw_line_below:\n//\tstate->data[0] = 0xe;\n//fix_flaw_line_below:\n//\tstate->data[1] = 0x87;\n//fix_flaw_line_below:\n//\tstate->data[2] = 0x0;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n//flaw_line_below:\n\tobuf[0] = 0xe;\n//flaw_line_below:\n\tobuf[1] = 0x86;\n//flaw_line_below:\n\tobuf[2] = 1;\n//fix_flaw_line_below:\n//\tstate->data[0] = 0xe;\n//fix_flaw_line_below:\n//\tstate->data[1] = 0x86;\n//fix_flaw_line_below:\n//\tstate->data[2] = 1;\n \n//flaw_line_below:\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n//fix_flaw_line_below:\n//\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n//flaw_line_below:\n\tobuf[0] = 0xe;\n//flaw_line_below:\n\tobuf[1] = 0x80;\n//flaw_line_below:\n\tobuf[2] = 0;\n//fix_flaw_line_below:\n//\tstate->data[0] = 0xe;\n//fix_flaw_line_below:\n//\tstate->data[1] = 0x80;\n//fix_flaw_line_below:\n//\tstate->data[2] = 0;\n \n//flaw_line_below:\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n//fix_flaw_line_below:\n//\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n \tmsleep(50);\n \n//flaw_line_below:\n\tobuf[0] = 0xe;\n//flaw_line_below:\n\tobuf[1] = 0x80;\n//flaw_line_below:\n\tobuf[2] = 1;\n//fix_flaw_line_below:\n//\tstate->data[0] = 0xe;\n//fix_flaw_line_below:\n//\tstate->data[1] = 0x80;\n//fix_flaw_line_below:\n//\tstate->data[2] = 1;\n \n//flaw_line_below:\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n//fix_flaw_line_below:\n//\tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n//flaw_line_below:\n\tobuf[0] = 0x51;\n//fix_flaw_line_below:\n//\tstate->data[0] = 0x51;\n \n//flaw_line_below:\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n//fix_flaw_line_below:\n//\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n//flaw_line_below:\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n//flaw_line_below:\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n//flaw_line_below:\n\tif (d->fe_adap[0].fe != NULL) {\n//flaw_line_below:\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n//flaw_line_below:\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n//fix_flaw_line_below:\n//\tmutex_unlock(&d->data_mutex);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\tadap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n//fix_flaw_line_below:\n//\t\t\t\t\t&d->i2c_adap, NULL);\n//fix_flaw_line_below:\n//\tif (adap->fe_adap[0].fe != NULL) {\n//fix_flaw_line_below:\n//\t\tif (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,\n//fix_flaw_line_below:\n//\t\t\t\t\t&d->i2c_adap, &tda18271_config)) {\n \t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n \t\t\treturn 0;\n \t\t}\n\t}\n\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n \treturn -EIO;\n }\n",
        "linevul": 0.9944435954093933,
        "sysevr": 0.15097664296627045,
        "devign": 0.9986371397972107
    },
    {
        "code": "static bool ndisc_suppress_frag_ndisc(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn true;\n\tif (IP6CB(skb)->flags & IP6SKB_FRAGMENTED &&\n\t    idev->cnf.suppress_frag_ndisc) {\n\t\tnet_warn_ratelimited(\"Received fragmented ndisc packet. Carefully consider disabling suppress_frag_ndisc.\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fd99094de2b83d1d4c8457f2c83483b2828e75a",
        "vul_func_with_fix": "static bool ndisc_suppress_frag_ndisc(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn true;\n\tif (IP6CB(skb)->flags & IP6SKB_FRAGMENTED &&\n\t    idev->cnf.suppress_frag_ndisc) {\n\t\tnet_warn_ratelimited(\"Received fragmented ndisc packet. Carefully consider disabling suppress_frag_ndisc.\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "linevul": 4.740173972095363e-05,
        "sysevr": 0.1224990114569664,
        "devign": 8.955672115007474e-08
    },
    {
        "code": "int kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0185604c2d82c560dab2f2933a18f797e74ab5a8",
        "vul_func_with_fix": "int kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       gva_t addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa =  vcpu->arch.walk_mmu->gva_to_gpa(vcpu, addr,\n\t\t\t\t\t\t\t     PFERR_WRITE_MASK,\n\t\t\t\t\t\t\t     exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\n",
        "linevul": 0.00013698331895284355,
        "sysevr": 0.15598659217357635,
        "devign": 1.1732597001612287e-38
    },
    {
        "code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n \tint ret;\n \n\tspin_lock_irqsave(&dev->lock, flags);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n \tret = 0;\n \n exit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n \treturn ret <= 0 ? ret : -EIO;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654",
        "vul_func_with_fix": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n//flaw_line_below:\n\tunsigned long flags;\n \tint ret;\n \n//flaw_line_below:\n\tspin_lock_irqsave(&dev->lock, flags);\n//fix_flaw_line_below:\n//\tmutex_lock(&dev->lock);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n \tret = 0;\n \n exit:\n//flaw_line_below:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n//fix_flaw_line_below:\n//\tmutex_unlock(&dev->lock);\n \treturn ret <= 0 ? ret : -EIO;\n }\n",
        "linevul": 0.9995675683021545,
        "sysevr": 0.12108021974563599,
        "devign": 0.9957155585289001
    },
    {
        "code": "int virtio_gpu_object_kmap(struct virtio_gpu_object *bo, void **ptr)\n{\n\tbool is_iomem;\n\tint r;\n\n\tif (bo->vmap) {\n\t\tif (ptr)\n\t\t\t*ptr = bo->vmap;\n\t\treturn 0;\n\t}\n\tr = ttm_bo_kmap(&bo->tbo, 0, bo->tbo.num_pages, &bo->kmap);\n\tif (r)\n\t\treturn r;\n\tbo->vmap = ttm_kmap_obj_virtual(&bo->kmap, &is_iomem);\n\tif (ptr)\n\t\t*ptr = bo->vmap;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/385aee965b4e4c36551c362a334378d2985b722a",
        "vul_func_with_fix": "int virtio_gpu_object_kmap(struct virtio_gpu_object *bo, void **ptr)\n{\n\tbool is_iomem;\n\tint r;\n\n\tif (bo->vmap) {\n\t\tif (ptr)\n\t\t\t*ptr = bo->vmap;\n\t\treturn 0;\n\t}\n\tr = ttm_bo_kmap(&bo->tbo, 0, bo->tbo.num_pages, &bo->kmap);\n\tif (r)\n\t\treturn r;\n\tbo->vmap = ttm_kmap_obj_virtual(&bo->kmap, &is_iomem);\n\tif (ptr)\n\t\t*ptr = bo->vmap;\n\treturn 0;\n}\n",
        "linevul": 6.713986658724025e-05,
        "sysevr": 0.1552554965019226,
        "devign": 1.1064365025958978e-05
    },
    {
        "code": "static void trace_packet(struct net *net,\n\t\t\t const struct sk_buff *skb,\n\t\t\t unsigned int hook,\n\t\t\t const struct net_device *in,\n\t\t\t const struct net_device *out,\n\t\t\t const char *tablename,\n\t\t\t const struct xt_table_info *private,\n\t\t\t const struct ip6t_entry *e)\n{\n\tconst struct ip6t_entry *root;\n\tconst char *hookname, *chainname, *comment;\n\tconst struct ip6t_entry *iter;\n\tunsigned int rulenum = 0;\n\n\troot = get_entry(private->entries, private->hook_entry[hook]);\n\n\thookname = chainname = hooknames[hook];\n\tcomment = comments[NF_IP6_TRACE_COMMENT_RULE];\n\n\txt_entry_foreach(iter, root, private->size - private->hook_entry[hook])\n\t\tif (get_chainname_rulenum(iter, e, hookname,\n\t\t    &chainname, &comment, &rulenum) != 0)\n\t\t\tbreak;\n\n\tnf_log_trace(net, AF_INET6, hook, skb, in, out, &trace_loginfo,\n\t\t     \"TRACE: %s:%s:%s:%u \",\n\t\t     tablename, chainname, comment, rulenum);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
        "vul_func_with_fix": "static void trace_packet(struct net *net,\n\t\t\t const struct sk_buff *skb,\n\t\t\t unsigned int hook,\n\t\t\t const struct net_device *in,\n\t\t\t const struct net_device *out,\n\t\t\t const char *tablename,\n\t\t\t const struct xt_table_info *private,\n\t\t\t const struct ip6t_entry *e)\n{\n\tconst struct ip6t_entry *root;\n\tconst char *hookname, *chainname, *comment;\n\tconst struct ip6t_entry *iter;\n\tunsigned int rulenum = 0;\n\n\troot = get_entry(private->entries, private->hook_entry[hook]);\n\n\thookname = chainname = hooknames[hook];\n\tcomment = comments[NF_IP6_TRACE_COMMENT_RULE];\n\n\txt_entry_foreach(iter, root, private->size - private->hook_entry[hook])\n\t\tif (get_chainname_rulenum(iter, e, hookname,\n\t\t    &chainname, &comment, &rulenum) != 0)\n\t\t\tbreak;\n\n\tnf_log_trace(net, AF_INET6, hook, skb, in, out, &trace_loginfo,\n\t\t     \"TRACE: %s:%s:%s:%u \",\n\t\t     tablename, chainname, comment, rulenum);\n}\n",
        "linevul": 7.518788333982229e-05,
        "sysevr": 0.18199214339256287,
        "devign": 1.4881760762364138e-05
    },
    {
        "code": "ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n \tstruct super_block *sb = inode->i_sb;\n \tstruct buffer_head *new_bh = NULL;\n \tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n \tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n #define header(x) ((struct ext4_xattr_header *)(x))\n \n \tif (i->value && i->value_len > sb->s_blocksize)\n \t\treturn -ENOSPC;\n \tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n \t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n \t\terror = ext4_journal_get_write_access(handle, bs->bh);\n \t\tif (error)\n \t\t\tgoto cleanup;\n \t\tlock_buffer(bs->bh);\n \n \t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n \t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n \t\t\terror = ext4_xattr_set_entry(i, s);\n \t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n \t\t\tint offset = (char *)s->here - bs->bh->b_data;\n \n \t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n \t\t\tea_bdebug(bs->bh, \"cloning\");\n \t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n \t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n \t\t\t\tif (error)\n \t\t\t\t\tgoto cleanup_dquot;\n \t\t\t\tlock_buffer(new_bh);\n \t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n \t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n \t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n \t\t\t\tif (error)\n \t\t\t\t\tgoto cleanup_dquot;\n \t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n \t\t\tce = NULL;\n \t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n \t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n \n cleanup:\n \tif (ce)\n\t\tmb_cache_entry_release(ce);\n \tbrelse(new_bh);\n \tif (!(bs->bh && s->base == bs->bh->b_data))\n \t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272",
        "vul_func_with_fix": "ext4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n \tstruct super_block *sb = inode->i_sb;\n \tstruct buffer_head *new_bh = NULL;\n \tstruct ext4_xattr_search *s = &bs->s;\n//flaw_line_below:\n\tstruct mb_cache_entry *ce = NULL;\n//fix_flaw_line_below:\n//\tstruct mb2_cache_entry *ce = NULL;\n \tint error = 0;\n//flaw_line_below:\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n//fix_flaw_line_below:\n//\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n #define header(x) ((struct ext4_xattr_header *)(x))\n \n \tif (i->value && i->value_len > sb->s_blocksize)\n \t\treturn -ENOSPC;\n \tif (s->base) {\n//flaw_line_below:\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n//flaw_line_below:\n\t\t\t\t\tbs->bh->b_blocknr);\n \t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n \t\terror = ext4_journal_get_write_access(handle, bs->bh);\n \t\tif (error)\n \t\t\tgoto cleanup;\n \t\tlock_buffer(bs->bh);\n \n \t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n//flaw_line_below:\n\t\t\tif (ce) {\n//flaw_line_below:\n\t\t\t\tmb_cache_entry_free(ce);\n//flaw_line_below:\n\t\t\t\tce = NULL;\n//flaw_line_below:\n\t\t\t}\n//fix_flaw_line_below:\n//\t\t\t__u32 hash = le32_to_cpu(BHDR(bs->bh)->h_hash);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t * This must happen under buffer lock for\n//fix_flaw_line_below:\n//\t\t\t * ext4_xattr_block_set() to reliably detect modified\n//fix_flaw_line_below:\n//\t\t\t * block\n//fix_flaw_line_below:\n//\t\t\t */\n//fix_flaw_line_below:\n//\t\t\tmb2_cache_entry_delete_block(ext4_mb_cache, hash,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t     bs->bh->b_blocknr);\n \t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n \t\t\terror = ext4_xattr_set_entry(i, s);\n \t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n \t\t\tint offset = (char *)s->here - bs->bh->b_data;\n \n \t\t\tunlock_buffer(bs->bh);\n//flaw_line_below:\n\t\t\tif (ce) {\n//flaw_line_below:\n\t\t\t\tmb_cache_entry_release(ce);\n//flaw_line_below:\n\t\t\t\tce = NULL;\n//flaw_line_below:\n\t\t\t}\n \t\t\tea_bdebug(bs->bh, \"cloning\");\n \t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n \t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n \t\t\t\tif (error)\n \t\t\t\t\tgoto cleanup_dquot;\n \t\t\t\tlock_buffer(new_bh);\n//fix_flaw_line_below:\n//\t\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t\t * We have to be careful about races with\n//fix_flaw_line_below:\n//\t\t\t\t * freeing or rehashing of xattr block. Once we\n//fix_flaw_line_below:\n//\t\t\t\t * hold buffer lock xattr block's state is\n//fix_flaw_line_below:\n//\t\t\t\t * stable so we can check whether the block got\n//fix_flaw_line_below:\n//\t\t\t\t * freed / rehashed or not.  Since we unhash\n//fix_flaw_line_below:\n//\t\t\t\t * mbcache entry under buffer lock when freeing\n//fix_flaw_line_below:\n//\t\t\t\t * / rehashing xattr block, checking whether\n//fix_flaw_line_below:\n//\t\t\t\t * entry is still hashed is reliable.\n//fix_flaw_line_below:\n//\t\t\t\t */\n//fix_flaw_line_below:\n//\t\t\t\tif (hlist_bl_unhashed(&ce->e_hash_list)) {\n//fix_flaw_line_below:\n//\t\t\t\t\t/*\n//fix_flaw_line_below:\n//\t\t\t\t\t * Undo everything and check mbcache\n//fix_flaw_line_below:\n//\t\t\t\t\t * again.\n//fix_flaw_line_below:\n//\t\t\t\t\t */\n//fix_flaw_line_below:\n//\t\t\t\t\tunlock_buffer(new_bh);\n//fix_flaw_line_below:\n//\t\t\t\t\tdquot_free_block(inode,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\t EXT4_C2B(EXT4_SB(sb),\n//fix_flaw_line_below:\n//\t\t\t\t\t\t\t\t  1));\n//fix_flaw_line_below:\n//\t\t\t\t\tbrelse(new_bh);\n//fix_flaw_line_below:\n//\t\t\t\t\tmb2_cache_entry_put(ext4_mb_cache, ce);\n//fix_flaw_line_below:\n//\t\t\t\t\tce = NULL;\n//fix_flaw_line_below:\n//\t\t\t\t\tnew_bh = NULL;\n//fix_flaw_line_below:\n//\t\t\t\t\tgoto inserted;\n//fix_flaw_line_below:\n//\t\t\t\t}\n \t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n \t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n \t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n \t\t\t\tif (error)\n \t\t\t\t\tgoto cleanup_dquot;\n \t\t\t}\n//flaw_line_below:\n\t\t\tmb_cache_entry_release(ce);\n//fix_flaw_line_below:\n//\t\t\tmb2_cache_entry_touch(ext4_mb_cache, ce);\n//fix_flaw_line_below:\n//\t\t\tmb2_cache_entry_put(ext4_mb_cache, ce);\n \t\t\tce = NULL;\n \t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n \t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n \n cleanup:\n \tif (ce)\n//flaw_line_below:\n\t\tmb_cache_entry_release(ce);\n//fix_flaw_line_below:\n//\t\tmb2_cache_entry_put(ext4_mb_cache, ce);\n \tbrelse(new_bh);\n \tif (!(bs->bh && s->base == bs->bh->b_data))\n \t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}\n",
        "linevul": 0.9993571639060974,
        "sysevr": 0.22558967769145966,
        "devign": 0.982154130935669
    },
    {
        "code": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n     \n     ether_setup(dev);\n     init_netdev(dev, ap_ifname);\n \n     if (register_netdev(dev)) {\n         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n\n    /* Copy the MAC address */\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162",
        "vul_func_with_fix": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n     \n     ether_setup(dev);\n     init_netdev(dev, ap_ifname);\n//fix_flaw_line_below:\n//    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n     if (register_netdev(dev)) {\n         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n\n    /* Copy the MAC address */\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n\n    return 0;\n}\n",
        "linevul": 0.9988563060760498,
        "sysevr": 0.16738487780094147,
        "devign": 0.9962788224220276
    },
    {
        "code": "static int tcp_v4_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv4_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv4_specific;\n#endif\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "vul_func_with_fix": "static int tcp_v4_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv4_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv4_specific;\n#endif\n\n\treturn 0;\n}\n",
        "linevul": 5.052228880231269e-05,
        "sysevr": 0.1334610879421234,
        "devign": 0.0003458497812971473
    },
    {
        "code": "struct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6a76f8c0ab19f215af2a3442870eeb5f0e81998d",
        "vul_func_with_fix": "struct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}\n",
        "linevul": 6.68273787596263e-05,
        "sysevr": 0.14692193269729614,
        "devign": 3.367999568126834e-08
    },
    {
        "code": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3",
        "vul_func_with_fix": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n//fix_flaw_line_below:\n//\tif (skb->len < sizeof(struct nlattr))\n//fix_flaw_line_below:\n//\t\treturn 0;\n//fix_flaw_line_below:\n//\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n//flaw_line_below:\n\tif (nla->nla_len > A - skb->len)\n//fix_flaw_line_below:\n//\tif (nla->nla_len > skb->len - A)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}\n",
        "linevul": 0.9996670484542847,
        "sysevr": 0.1659640222787857,
        "devign": 2.0140816007852064e-18
    },
    {
        "code": "void __init ima_init_policy(void)\n{\n\tint i, entries;\n\n\t/* if !ima_use_tcb set entries = 0 so we load NO default rules */\n\tif (ima_use_tcb)\n\t\tentries = ARRAY_SIZE(default_rules);\n\telse\n\t\tentries = 0;\n\n\tfor (i = 0; i < entries; i++)\n\t\tlist_add_tail(&default_rules[i].list, &measure_default_rules);\n\tima_measure = &measure_default_rules;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/867c20265459d30a01b021a9c1e81fb4c5832aa9",
        "vul_func_with_fix": "void __init ima_init_policy(void)\n{\n\tint i, entries;\n\n\t/* if !ima_use_tcb set entries = 0 so we load NO default rules */\n\tif (ima_use_tcb)\n\t\tentries = ARRAY_SIZE(default_rules);\n\telse\n\t\tentries = 0;\n\n\tfor (i = 0; i < entries; i++)\n\t\tlist_add_tail(&default_rules[i].list, &measure_default_rules);\n\tima_measure = &measure_default_rules;\n}\n",
        "linevul": 5.328960469341837e-05,
        "sysevr": 0.1484319269657135,
        "devign": 0.569963276386261
    },
    {
        "code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "vul_func_with_fix": "int fscrypt_get_encryption_info(struct inode *inode)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (!ci ||\n//flaw_line_below:\n\t\t(ci->ci_keyring_key &&\n//flaw_line_below:\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n//flaw_line_below:\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n//flaw_line_below:\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n//flaw_line_below:\n\t\treturn fscrypt_get_crypt_info(inode);\n//flaw_line_below:\n\treturn 0;\n//flaw_line_below:\n}\n",
        "linevul": 0.9947176575660706,
        "sysevr": 0.15352153778076172,
        "devign": 0.00017485267017036676
    },
    {
        "code": " static int __init init_ext2_fs(void)\n {\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n \terr = init_inodecache();\n \tif (err)\n\t\tgoto out1;\n         err = register_filesystem(&ext2_fs_type);\n \tif (err)\n \t\tgoto out;\n \treturn 0;\n out:\n \tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n \treturn err;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
        "vul_func_with_fix": " static int __init init_ext2_fs(void)\n {\n//flaw_line_below:\n\tint err = init_ext2_xattr();\n//flaw_line_below:\n\tif (err)\n//flaw_line_below:\n\t\treturn err;\n//fix_flaw_line_below:\n//\tint err;\n//fix_flaw_line_below:\n//\n \terr = init_inodecache();\n \tif (err)\n//flaw_line_below:\n\t\tgoto out1;\n//fix_flaw_line_below:\n//\t\treturn err;\n         err = register_filesystem(&ext2_fs_type);\n \tif (err)\n \t\tgoto out;\n \treturn 0;\n out:\n \tdestroy_inodecache();\n//flaw_line_below:\nout1:\n//flaw_line_below:\n\texit_ext2_xattr();\n \treturn err;\n }\n",
        "linevul": 0.9993135929107666,
        "sysevr": 0.13585670292377472,
        "devign": 0.6219702363014221
    },
    {
        "code": "static int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn (!to_vmx(vcpu)->nested.nested_run_pending &&\n\t\tvmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a",
        "vul_func_with_fix": "static int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn (!to_vmx(vcpu)->nested.nested_run_pending &&\n\t\tvmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n",
        "linevul": 5.276828596834093e-05,
        "sysevr": 0.1307966411113739,
        "devign": 1.6610274353873189e-12
    },
    {
        "code": "static int rfcomm_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\t__rfcomm_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/951b6a0717db97ce420547222647bcc40bf1eacd",
        "vul_func_with_fix": "static int rfcomm_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\t__rfcomm_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "linevul": 8.128955232677981e-05,
        "sysevr": 0.14108876883983612,
        "devign": 0.0015506758354604244
    },
    {
        "code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n \t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n \t}\n \treturn change;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92",
        "vul_func_with_fix": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n \t\tnew_data = memdup_user(tlv, size);\n \t\tif (IS_ERR(new_data))\n \t\t\treturn PTR_ERR(new_data);\n//fix_flaw_line_below:\n//\t\tmutex_lock(&ue->card->user_ctl_lock);\n \t\tchange = ue->tlv_data_size != size;\n \t\tif (!change)\n \t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n \t\tkfree(ue->tlv_data);\n \t\tue->tlv_data = new_data;\n \t\tue->tlv_data_size = size;\n//fix_flaw_line_below:\n//\t\tmutex_unlock(&ue->card->user_ctl_lock);\n \t} else {\n//flaw_line_below:\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n//flaw_line_below:\n\t\t\treturn -ENXIO;\n//flaw_line_below:\n\t\tif (size < ue->tlv_data_size)\n//flaw_line_below:\n\t\t\treturn -ENOSPC;\n//fix_flaw_line_below:\n//\t\tint ret = 0;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tmutex_lock(&ue->card->user_ctl_lock);\n//fix_flaw_line_below:\n//\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n//fix_flaw_line_below:\n//\t\t\tret = -ENXIO;\n//fix_flaw_line_below:\n//\t\t\tgoto err_unlock;\n//fix_flaw_line_below:\n//\t\t}\n//fix_flaw_line_below:\n//\t\tif (size < ue->tlv_data_size) {\n//fix_flaw_line_below:\n//\t\t\tret = -ENOSPC;\n//fix_flaw_line_below:\n//\t\t\tgoto err_unlock;\n//fix_flaw_line_below:\n//\t\t}\n \t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n//flaw_line_below:\n\t\t\treturn -EFAULT;\n//fix_flaw_line_below:\n//\t\t\tret = -EFAULT;\n//fix_flaw_line_below:\n//err_unlock:\n//fix_flaw_line_below:\n//\t\tmutex_unlock(&ue->card->user_ctl_lock);\n//fix_flaw_line_below:\n//\t\tif (ret)\n//fix_flaw_line_below:\n//\t\t\treturn ret;\n \t}\n \treturn change;\n }\n",
        "linevul": 0.9994199275970459,
        "sysevr": 0.13567595183849335,
        "devign": 0.673372745513916
    },
    {
        "code": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n \t\tif (np->repflow && ireq->pktopts)\n \t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n \n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n \t\terr = net_xmit_eval(err);\n \t}\n \ndone:\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "vul_func_with_fix": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n \t\tif (np->repflow && ireq->pktopts)\n \t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n \n//flaw_line_below:\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n//fix_flaw_line_below:\n//\t\terr = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),\n//fix_flaw_line_below:\n//\t\t\t       np->tclass);\n \t\terr = net_xmit_eval(err);\n \t}\n \ndone:\n\treturn err;\n}\n",
        "linevul": 0.00011691176041495055,
        "sysevr": 0.1655709445476532,
        "devign": 0.9997956156730652
    },
    {
        "code": "static int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, svm->vcpu.arch.regs[VCPU_REGS_RAX]);\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23",
        "vul_func_with_fix": "static int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, svm->vcpu.arch.regs[VCPU_REGS_RAX]);\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}\n",
        "linevul": 4.663369327317923e-05,
        "sysevr": 0.12971067428588867,
        "devign": 0.8296904563903809
    },
    {
        "code": "static void __net_exit arp_tables_net_exit(struct net *net)\n{\n\txt_proto_fini(net, NFPROTO_ARP);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
        "vul_func_with_fix": "static void __net_exit arp_tables_net_exit(struct net *net)\n{\n\txt_proto_fini(net, NFPROTO_ARP);\n}\n",
        "linevul": 5.2334948122734204e-05,
        "sysevr": 0.12367738783359528,
        "devign": 0.25807279348373413
    },
    {
        "code": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9",
        "vul_func_with_fix": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}\n",
        "linevul": 7.685804303037003e-05,
        "sysevr": 0.1299973875284195,
        "devign": 0.20222137868404388
    },
    {
        "code": "static void free_thread_stack(struct task_struct *tsk)\n{\n\tkmem_cache_free(thread_stack_cache, tsk->stack);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a",
        "vul_func_with_fix": "static void free_thread_stack(struct task_struct *tsk)\n{\n\tkmem_cache_free(thread_stack_cache, tsk->stack);\n}\n",
        "linevul": 7.760860171401873e-05,
        "sysevr": 0.12628066539764404,
        "devign": 3.916460968866886e-07
    },
    {
        "code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n \tint error = 0;\n \tstruct sctp_transport *transport = (struct sctp_transport *) data;\n \tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n \n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n \t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n \n \t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n \t\t\t   transport, GFP_ATOMIC);\n \n \tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n \n out_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n \tsctp_transport_put(transport);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e",
        "vul_func_with_fix": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n \tint error = 0;\n \tstruct sctp_transport *transport = (struct sctp_transport *) data;\n \tstruct sctp_association *asoc = transport->asoc;\n//flaw_line_below:\n\tstruct net *net = sock_net(asoc->base.sk);\n//fix_flaw_line_below:\n//\tstruct sock *sk = asoc->base.sk;\n//fix_flaw_line_below:\n//\tstruct net *net = sock_net(sk);\n \n//flaw_line_below:\n\tbh_lock_sock(asoc->base.sk);\n//flaw_line_below:\n\tif (sock_owned_by_user(asoc->base.sk)) {\n//fix_flaw_line_below:\n//\tbh_lock_sock(sk);\n//fix_flaw_line_below:\n//\tif (sock_owned_by_user(sk)) {\n \t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n \n \t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this structure just waiting around for us to actually\n\t * get destroyed?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n \t\t\t   transport, GFP_ATOMIC);\n \n \tif (error)\n//flaw_line_below:\n\t\tasoc->base.sk->sk_err = -error;\n//fix_flaw_line_below:\n//\t\tsk->sk_err = -error;\n \n out_unlock:\n//flaw_line_below:\n\tbh_unlock_sock(asoc->base.sk);\n//fix_flaw_line_below:\n//\tbh_unlock_sock(sk);\n \tsctp_transport_put(transport);\n }\n",
        "linevul": 0.9994311928749084,
        "sysevr": 0.2309204339981079,
        "devign": 0.995860755443573
    },
    {
        "code": "__u32 __skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6)\n{\n\tstruct flow_keys keys;\n\n\tmemset(&keys, 0, sizeof(keys));\n\n\tmemcpy(&keys.addrs.v6addrs.src, &fl6->saddr,\n\t       sizeof(keys.addrs.v6addrs.src));\n\tmemcpy(&keys.addrs.v6addrs.dst, &fl6->daddr,\n\t       sizeof(keys.addrs.v6addrs.dst));\n\tkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tkeys.ports.src = fl6->fl6_sport;\n\tkeys.ports.dst = fl6->fl6_dport;\n\tkeys.keyid.keyid = fl6->fl6_gre_key;\n\tkeys.tags.flow_label = (__force u32)fl6->flowlabel;\n\tkeys.basic.ip_proto = fl6->flowi6_proto;\n\n\t__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\n\t\t\t  flow_keys_have_l4(&keys));\n\n\treturn skb->hash;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
        "vul_func_with_fix": "__u32 __skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6)\n{\n\tstruct flow_keys keys;\n\n\tmemset(&keys, 0, sizeof(keys));\n\n\tmemcpy(&keys.addrs.v6addrs.src, &fl6->saddr,\n\t       sizeof(keys.addrs.v6addrs.src));\n\tmemcpy(&keys.addrs.v6addrs.dst, &fl6->daddr,\n\t       sizeof(keys.addrs.v6addrs.dst));\n\tkeys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tkeys.ports.src = fl6->fl6_sport;\n\tkeys.ports.dst = fl6->fl6_dport;\n\tkeys.keyid.keyid = fl6->fl6_gre_key;\n\tkeys.tags.flow_label = (__force u32)fl6->flowlabel;\n\tkeys.basic.ip_proto = fl6->flowi6_proto;\n\n\t__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),\n\t\t\t  flow_keys_have_l4(&keys));\n\n\treturn skb->hash;\n}\n",
        "linevul": 5.458959276438691e-05,
        "sysevr": 0.18773411214351654,
        "devign": 0.0003683469258248806
    },
    {
        "code": "static void tcp_replace_ts_recent(struct tcp_sock *tp, u32 seq)\n{\n\tif (tp->rx_opt.saw_tstamp && !after(seq, tp->rcv_wup)) {\n\t\t/* PAWS bug workaround wrt. ACK frames, the PAWS discard\n\t\t * extra check below makes sure this can only happen\n\t\t * for pure ACK frames.  -DaveM\n\t\t *\n\t\t * Not only, also it occurs for expired timestamps.\n\t\t */\n\n\t\tif (tcp_paws_check(&tp->rx_opt, 0))\n\t\t\ttcp_store_ts_recent(tp);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758",
        "vul_func_with_fix": "static void tcp_replace_ts_recent(struct tcp_sock *tp, u32 seq)\n{\n\tif (tp->rx_opt.saw_tstamp && !after(seq, tp->rcv_wup)) {\n\t\t/* PAWS bug workaround wrt. ACK frames, the PAWS discard\n\t\t * extra check below makes sure this can only happen\n\t\t * for pure ACK frames.  -DaveM\n\t\t *\n\t\t * Not only, also it occurs for expired timestamps.\n\t\t */\n\n\t\tif (tcp_paws_check(&tp->rx_opt, 0))\n\t\t\ttcp_store_ts_recent(tp);\n\t}\n}\n",
        "linevul": 4.7847264795564115e-05,
        "sysevr": 0.13721007108688354,
        "devign": 1.0143438089471601e-08
    },
    {
        "code": "static int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\tif (mc->pos < mc->end)\n\t\tgoto read_cached;\n\n\tWARN_ON((mc->end + size) >= sizeof(mc->data));\n\n\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,\n\t\t\t\t      &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tmc->end += size;\n\nread_cached:\n\tmemcpy(dest, mc->data + mc->pos, size);\n\tmc->pos += size;\n\treturn X86EMUL_CONTINUE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a430c9166312e1aa3d80bce32374233bdbfeba32",
        "vul_func_with_fix": "static int read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t unsigned long addr, void *dest, unsigned size)\n{\n\tint rc;\n\tstruct read_cache *mc = &ctxt->mem_read;\n\n\tif (mc->pos < mc->end)\n\t\tgoto read_cached;\n\n\tWARN_ON((mc->end + size) >= sizeof(mc->data));\n\n\trc = ctxt->ops->read_emulated(ctxt, addr, mc->data + mc->end, size,\n\t\t\t\t      &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tmc->end += size;\n\nread_cached:\n\tmemcpy(dest, mc->data + mc->pos, size);\n\tmc->pos += size;\n\treturn X86EMUL_CONTINUE;\n}\n",
        "linevul": 6.796336674597114e-05,
        "sysevr": 0.13596409559249878,
        "devign": 1.0100702912962944e-10
    },
    {
        "code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\n\treturn NETDEV_TX_OK;\n\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n \treturn NETDEV_TX_OK;\n \n rx_drop:\n\tkfree_skb(skb);\n \trcv_stats->rx_dropped++;\n \treturn NETDEV_TX_OK;\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6ec82562ffc6f297d0de36d65776cff8e5704867",
        "vul_func_with_fix": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\n\treturn NETDEV_TX_OK;\n\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n \treturn NETDEV_TX_OK;\n \n rx_drop:\n//flaw_line_below:\n\tkfree_skb(skb);\n \trcv_stats->rx_dropped++;\n \treturn NETDEV_TX_OK;\n }\n",
        "linevul": 5.792796946479939e-05,
        "sysevr": 0.14734826982021332,
        "devign": 0.9842877388000488
    },
    {
        "code": "try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\tsmp_mb__before_spinlock();\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\tsuccess = 1; /* we're going to change ->state */\n\tcpu = task_cpu(p);\n\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * If the owning (remote) cpu is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t */\n\twhile (p->on_cpu)\n\t\tcpu_relax();\n\t/*\n\t * Pairs with the smp_wmb() in finish_lock_switch().\n\t */\n\tsmp_rmb();\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->sched_class->task_waking)\n\t\tp->sched_class->task_waking(p);\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tset_task_cpu(p, cpu);\n\t}\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4efbc454ba68def5ef285b26ebfcfdb605b52755",
        "vul_func_with_fix": "try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with mb() in\n\t * set_current_state() the waiting thread does.\n\t */\n\tsmp_mb__before_spinlock();\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tif (!(p->state & state))\n\t\tgoto out;\n\n\tsuccess = 1; /* we're going to change ->state */\n\tcpu = task_cpu(p);\n\n\tif (p->on_rq && ttwu_remote(p, wake_flags))\n\t\tgoto stat;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * If the owning (remote) cpu is still in the middle of schedule() with\n\t * this task as prev, wait until its done referencing the task.\n\t */\n\twhile (p->on_cpu)\n\t\tcpu_relax();\n\t/*\n\t * Pairs with the smp_wmb() in finish_lock_switch().\n\t */\n\tsmp_rmb();\n\n\tp->sched_contributes_to_load = !!task_contributes_to_load(p);\n\tp->state = TASK_WAKING;\n\n\tif (p->sched_class->task_waking)\n\t\tp->sched_class->task_waking(p);\n\n\tcpu = select_task_rq(p, p->wake_cpu, SD_BALANCE_WAKE, wake_flags);\n\tif (task_cpu(p) != cpu) {\n\t\twake_flags |= WF_MIGRATED;\n\t\tset_task_cpu(p, cpu);\n\t}\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu);\nstat:\n\tttwu_stat(p, cpu, wake_flags);\nout:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n\treturn success;\n}\n",
        "linevul": 5.789566057501361e-05,
        "sysevr": 0.1922297179698944,
        "devign": 2.5522345099997015e-31
    },
    {
        "code": "static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\n\ts_idx = cb->args[0];\n\n\trcu_read_lock();\n\n\t/* In theory this could be wrapped to 0... */\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n \t\t\t\tbreak;\n \n \t\t\tbpm = nlmsg_data(nlh);\n \t\t\tbpm->ifindex = dev->ifindex;\n \t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n \t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc",
        "vul_func_with_fix": "static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\n\ts_idx = cb->args[0];\n\n\trcu_read_lock();\n\n\t/* In theory this could be wrapped to 0... */\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n \t\t\t\tbreak;\n \n \t\t\tbpm = nlmsg_data(nlh);\n//fix_flaw_line_below:\n//\t\t\tmemset(bpm, 0, sizeof(*bpm));\n \t\t\tbpm->ifindex = dev->ifindex;\n \t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n \t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n",
        "linevul": 9.878221317194402e-05,
        "sysevr": 0.12709926068782806,
        "devign": 3.6582786538629755e-16
    },
    {
        "code": "static inline int is_valid_mmap(u64 token)\n{\n\treturn (HFI1_MMAP_TOKEN_GET(MAGIC, token) == HFI1_MMAP_MAGIC);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3",
        "vul_func_with_fix": "static inline int is_valid_mmap(u64 token)\n{\n\treturn (HFI1_MMAP_TOKEN_GET(MAGIC, token) == HFI1_MMAP_MAGIC);\n}\n",
        "linevul": 6.274334009503946e-05,
        "sysevr": 0.1278391182422638,
        "devign": 1.739096660458017e-05
    },
    {
        "code": "static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a",
        "vul_func_with_fix": "static inline u64 file_mmap_size_max(struct file *file, struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn MAX_LFS_FILESIZE;\n\n\t/* Special \"we do even unsigned file positions\" case */\n\tif (file->f_mode & FMODE_UNSIGNED_OFFSET)\n\t\treturn 0;\n\n\t/* Yes, random drivers might want more. But I'm tired of buggy drivers */\n\treturn ULONG_MAX;\n}\n",
        "linevul": 6.522790499730036e-05,
        "sysevr": 0.12664254009723663,
        "devign": 5.925364643388775e-10
    },
    {
        "code": "static void qeth_set_single_write_queues(struct qeth_card *card)\n{\n\tif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\n\t    (card->qdio.no_out_queues == 4))\n\t\tqeth_free_qdio_buffers(card);\n\n\tcard->qdio.no_out_queues = 1;\n\tif (card->qdio.default_out_queue != 0)\n\t\tdev_info(&card->gdev->dev, \"Priority Queueing not supported\\n\");\n\n\tcard->qdio.default_out_queue = 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62",
        "vul_func_with_fix": "static void qeth_set_single_write_queues(struct qeth_card *card)\n{\n\tif ((atomic_read(&card->qdio.state) != QETH_QDIO_UNINITIALIZED) &&\n\t    (card->qdio.no_out_queues == 4))\n\t\tqeth_free_qdio_buffers(card);\n\n\tcard->qdio.no_out_queues = 1;\n\tif (card->qdio.default_out_queue != 0)\n\t\tdev_info(&card->gdev->dev, \"Priority Queueing not supported\\n\");\n\n\tcard->qdio.default_out_queue = 0;\n}\n",
        "linevul": 4.731069566332735e-05,
        "sysevr": 0.1262422651052475,
        "devign": 2.944914975126335e-19
    },
    {
        "code": "static int b43_dmacontroller_rx_reset(struct b43_wldev *dev, u16 mmio_base,\n\t\t\t\t      enum b43_dmatype type)\n{\n\tint i;\n\tu32 value;\n\tu16 offset;\n\n\tmight_sleep();\n\n\toffset = (type == B43_DMA_64BIT) ? B43_DMA64_RXCTL : B43_DMA32_RXCTL;\n\tb43_write32(dev, mmio_base + offset, 0);\n\tfor (i = 0; i < 10; i++) {\n\t\toffset = (type == B43_DMA_64BIT) ? B43_DMA64_RXSTATUS :\n\t\t\t\t\t\t   B43_DMA32_RXSTATUS;\n\t\tvalue = b43_read32(dev, mmio_base + offset);\n\t\tif (type == B43_DMA_64BIT) {\n\t\t\tvalue &= B43_DMA64_RXSTAT;\n\t\t\tif (value == B43_DMA64_RXSTAT_DISABLED) {\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue &= B43_DMA32_RXSTATE;\n\t\t\tif (value == B43_DMA32_RXSTAT_DISABLED) {\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmsleep(1);\n\t}\n\tif (i != -1) {\n\t\tb43err(dev->wl, \"DMA RX reset timed out\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c85ce65ecac078ab1a1835c87c4a6319cf74660a",
        "vul_func_with_fix": "static int b43_dmacontroller_rx_reset(struct b43_wldev *dev, u16 mmio_base,\n\t\t\t\t      enum b43_dmatype type)\n{\n\tint i;\n\tu32 value;\n\tu16 offset;\n\n\tmight_sleep();\n\n\toffset = (type == B43_DMA_64BIT) ? B43_DMA64_RXCTL : B43_DMA32_RXCTL;\n\tb43_write32(dev, mmio_base + offset, 0);\n\tfor (i = 0; i < 10; i++) {\n\t\toffset = (type == B43_DMA_64BIT) ? B43_DMA64_RXSTATUS :\n\t\t\t\t\t\t   B43_DMA32_RXSTATUS;\n\t\tvalue = b43_read32(dev, mmio_base + offset);\n\t\tif (type == B43_DMA_64BIT) {\n\t\t\tvalue &= B43_DMA64_RXSTAT;\n\t\t\tif (value == B43_DMA64_RXSTAT_DISABLED) {\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue &= B43_DMA32_RXSTATE;\n\t\t\tif (value == B43_DMA32_RXSTAT_DISABLED) {\n\t\t\t\ti = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmsleep(1);\n\t}\n\tif (i != -1) {\n\t\tb43err(dev->wl, \"DMA RX reset timed out\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 4.6741970436414704e-05,
        "sysevr": 0.13966290652751923,
        "devign": 5.286902887746692e-05
    },
    {
        "code": "void ip_flush_pending_frames(struct sock *sk)\n{\n\t__ip_flush_pending_frames(sk, &sk->sk_write_queue, &inet_sk(sk)->cork);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "void ip_flush_pending_frames(struct sock *sk)\n{\n\t__ip_flush_pending_frames(sk, &sk->sk_write_queue, &inet_sk(sk)->cork);\n}\n",
        "linevul": 8.110031194519252e-05,
        "sysevr": 0.1547582894563675,
        "devign": 8.715451471630331e-09
    },
    {
        "code": "static ssize_t sched_mc_power_savings_store(struct sysdev_class *class,\n\t\t\t\t\t    struct sysdev_class_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\treturn sched_power_savings_store(buf, count, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": "static ssize_t sched_mc_power_savings_store(struct sysdev_class *class,\n\t\t\t\t\t    struct sysdev_class_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\treturn sched_power_savings_store(buf, count, 0);\n}\n",
        "linevul": 5.23782946402207e-05,
        "sysevr": 0.1295299381017685,
        "devign": 1.145320999464941e-15
    },
    {
        "code": "perf_pin_task_context(struct task_struct *task, int ctxn)\n{\n\tstruct perf_event_context *ctx;\n\tunsigned long flags;\n\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\t++ctx->pin_count;\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\treturn ctx;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "perf_pin_task_context(struct task_struct *task, int ctxn)\n{\n\tstruct perf_event_context *ctx;\n\tunsigned long flags;\n\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\t++ctx->pin_count;\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\treturn ctx;\n}\n",
        "linevul": 5.451873585116118e-05,
        "sysevr": 0.15148517489433289,
        "devign": 0.9921160340309143
    },
    {
        "code": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339",
        "vul_func_with_fix": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}\n",
        "linevul": 9.77222080109641e-05,
        "sysevr": 0.17995060980319977,
        "devign": 2.2736388416433329e-07
    },
    {
        "code": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n \tint rc;\n \tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt = NULL;\n \tint connected = 0;\n \t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n \t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n \n \tif (rt == NULL) {\n \t\t/* Use correct destination address if we have options. */\n\t\tif (opt && opt->srr)\n\t\t\tdaddr = opt->faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n \tint rc;\n \tstruct l2tp_ip_sock *lsa = l2tp_ip_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n//flaw_line_below:\n\tstruct ip_options *opt = inet->opt;\n \tstruct rtable *rt = NULL;\n \tint connected = 0;\n \t__be32 daddr;\n\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn -ENOTCONN;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_l2tpip *lip = (struct sockaddr_l2tpip *) msg->msg_name;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\treturn -EINVAL;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (connected)\n \t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n \n \tif (rt == NULL) {\n//fix_flaw_line_below:\n//\t\tstruct ip_options_rcu *inet_opt;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t     sock_owned_by_user(sk));\n//fix_flaw_line_below:\n//\n \t\t/* Use correct destination address if we have options. */\n//flaw_line_below:\n\t\tif (opt && opt->srr)\n//flaw_line_below:\n\t\t\tdaddr = opt->faddr;\n//fix_flaw_line_below:\n//\t\tif (inet_opt && inet_opt->opt.srr)\n//fix_flaw_line_below:\n//\t\t\tdaddr = inet_opt->opt.faddr;\n \n \t\t/* If this fails, retransmit mechanism of transport layer will\n \t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t}\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(skb);\n\nerror:\n\t/* Update stats */\n\tif (rc >= 0) {\n\t\tlsa->tx_packets++;\n\t\tlsa->tx_bytes += len;\n\t\trc = len;\n\t} else {\n\t\tlsa->tx_errors++;\n\t}\n\n\treturn rc;\n\nno_route:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EHOSTUNREACH;\n}\n",
        "linevul": 0.9981170892715454,
        "sysevr": 0.21334439516067505,
        "devign": 0.00012755734496749938
    },
    {
        "code": " ext2_xattr_delete_inode(struct inode *inode)\n {\n \tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n \n \tdown_write(&EXT2_I(inode)->xattr_sem);\n \tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n \t\t\tEXT2_I(inode)->i_file_acl);\n \t\tgoto cleanup;\n \t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n \tlock_buffer(bh);\n \tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n \t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n \t\tget_bh(bh);\n \t\tbforget(bh);\n \t\tunlock_buffer(bh);\n \t} else {\n \t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n \t\tea_bdebug(bh, \"refcount now=%d\",\n \t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n \t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n \tup_write(&EXT2_I(inode)->xattr_sem);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee",
        "vul_func_with_fix": " ext2_xattr_delete_inode(struct inode *inode)\n {\n \tstruct buffer_head *bh = NULL;\n//flaw_line_below:\n\tstruct mb_cache_entry *ce;\n \n \tdown_write(&EXT2_I(inode)->xattr_sem);\n \tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n \t\t\tEXT2_I(inode)->i_file_acl);\n \t\tgoto cleanup;\n \t}\n//flaw_line_below:\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n \tlock_buffer(bh);\n \tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n//flaw_line_below:\n\t\tif (ce)\n//flaw_line_below:\n\t\t\tmb_cache_entry_free(ce);\n//fix_flaw_line_below:\n//\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t\t/*\n//fix_flaw_line_below:\n//\t\t * This must happen under buffer lock for ext2_xattr_set2() to\n//fix_flaw_line_below:\n//\t\t * reliably detect freed block\n//fix_flaw_line_below:\n//\t\t */\n//fix_flaw_line_below:\n//\t\tmb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,\n//fix_flaw_line_below:\n//\t\t\t\t\t     hash, bh->b_blocknr);\n \t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n \t\tget_bh(bh);\n \t\tbforget(bh);\n \t\tunlock_buffer(bh);\n \t} else {\n \t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n//flaw_line_below:\n\t\tif (ce)\n//flaw_line_below:\n\t\t\tmb_cache_entry_release(ce);\n \t\tea_bdebug(bh, \"refcount now=%d\",\n \t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n \t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n \tup_write(&EXT2_I(inode)->xattr_sem);\n }\n",
        "linevul": 0.9996887445449829,
        "sysevr": 0.17129580676555634,
        "devign": 1.5569632512654948e-23
    },
    {
        "code": "find_matching_se(struct sched_entity **se, struct sched_entity **pse)\n{\n\tint se_depth, pse_depth;\n\n\t/*\n\t * preemption test can be made between sibling entities who are in the\n\t * same cfs_rq i.e who have a common parent. Walk up the hierarchy of\n\t * both tasks until we find their ancestors who are siblings of common\n\t * parent.\n\t */\n\n\t/* First walk up until both entities are at same depth */\n\tse_depth = (*se)->depth;\n\tpse_depth = (*pse)->depth;\n\n\twhile (se_depth > pse_depth) {\n\t\tse_depth--;\n\t\t*se = parent_entity(*se);\n\t}\n\n\twhile (pse_depth > se_depth) {\n\t\tpse_depth--;\n\t\t*pse = parent_entity(*pse);\n\t}\n\n\twhile (!is_same_group(*se, *pse)) {\n\t\t*se = parent_entity(*se);\n\t\t*pse = parent_entity(*pse);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "vul_func_with_fix": "find_matching_se(struct sched_entity **se, struct sched_entity **pse)\n{\n\tint se_depth, pse_depth;\n\n\t/*\n\t * preemption test can be made between sibling entities who are in the\n\t * same cfs_rq i.e who have a common parent. Walk up the hierarchy of\n\t * both tasks until we find their ancestors who are siblings of common\n\t * parent.\n\t */\n\n\t/* First walk up until both entities are at same depth */\n\tse_depth = (*se)->depth;\n\tpse_depth = (*pse)->depth;\n\n\twhile (se_depth > pse_depth) {\n\t\tse_depth--;\n\t\t*se = parent_entity(*se);\n\t}\n\n\twhile (pse_depth > se_depth) {\n\t\tpse_depth--;\n\t\t*pse = parent_entity(*pse);\n\t}\n\n\twhile (!is_same_group(*se, *pse)) {\n\t\t*se = parent_entity(*se);\n\t\t*pse = parent_entity(*pse);\n\t}\n}\n",
        "linevul": 5.0073482270818204e-05,
        "sysevr": 0.2120554894208908,
        "devign": 0.0312868133187294
    },
    {
        "code": "int nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_online_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7",
        "vul_func_with_fix": "int nr_processes(void)\n{\n\tint cpu;\n\tint total = 0;\n\n\tfor_each_online_cpu(cpu)\n\t\ttotal += per_cpu(process_counts, cpu);\n\n\treturn total;\n}\n",
        "linevul": 5.977661567158066e-05,
        "sysevr": 0.15411701798439026,
        "devign": 6.40199914414552e-06
    },
    {
        "code": "static ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rdev_get_name(rdev));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "vul_func_with_fix": "static ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rdev_get_name(rdev));\n}\n",
        "linevul": 5.131834404892288e-05,
        "sysevr": 0.12211383879184723,
        "devign": 6.511128858299742e-10
    },
    {
        "code": "void usbnet_pause_rx(struct usbnet *dev)\n{\n\tset_bit(EVENT_RX_PAUSED, &dev->flags);\n\n\tnetif_dbg(dev, rx_status, dev->net, \"paused rx queue enabled\\n\");\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1666984c8625b3db19a9abc298931d35ab7bc64b",
        "vul_func_with_fix": "void usbnet_pause_rx(struct usbnet *dev)\n{\n\tset_bit(EVENT_RX_PAUSED, &dev->flags);\n\n\tnetif_dbg(dev, rx_status, dev->net, \"paused rx queue enabled\\n\");\n}\n",
        "linevul": 4.820403773919679e-05,
        "sysevr": 0.1561371237039566,
        "devign": 0.0002735677408054471
    },
    {
        "code": "static int init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create(\"ext4_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d50f2ab6f050311dbf7b8f5501b25f0bf64a439b",
        "vul_func_with_fix": "static int init_inodecache(void)\n{\n\text4_inode_cachep = kmem_cache_create(\"ext4_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext4_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext4_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n",
        "linevul": 5.5636173783568665e-05,
        "sysevr": 0.127579927444458,
        "devign": 3.8911753390291105e-15
    },
    {
        "code": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n \t\t\t\treturn -ECHILD;\n \t\t\tnd->path.dentry = parent;\n \t\t\tnd->seq = seq;\n \t\t\tbreak;\n \t\t} else {\n \t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\t/* we know that mountpoint was pinned */\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "vul_func_with_fix": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n \t\t\t\treturn -ECHILD;\n \t\t\tnd->path.dentry = parent;\n \t\t\tnd->seq = seq;\n//fix_flaw_line_below:\n//\t\t\tif (unlikely(!path_connected(&nd->path)))\n//fix_flaw_line_below:\n//\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t} else {\n \t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\t/* we know that mountpoint was pinned */\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}\n",
        "linevul": 0.9993534684181213,
        "sysevr": 0.16206806898117065,
        "devign": 0.9955273270606995
    },
    {
        "code": "int xenvif_schedulable(struct xenvif *vif)\n{\n\treturn netif_running(vif->dev) && netif_carrier_ok(vif->dev);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/48856286b64e4b66ec62b94e504d0b29c1ade664",
        "vul_func_with_fix": "int xenvif_schedulable(struct xenvif *vif)\n{\n\treturn netif_running(vif->dev) && netif_carrier_ok(vif->dev);\n}\n",
        "linevul": 5.07287222717423e-05,
        "sysevr": 0.15053847432136536,
        "devign": 1.1532434655237012e-05
    },
    {
        "code": "struct sock *__vsock_create(struct net *net,\n\t\t\t    struct socket *sock,\n\t\t\t    struct sock *parent,\n\t\t\t    gfp_t priority,\n\t\t\t    unsigned short type)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *psk;\n\tstruct vsock_sock *vsk;\n\n\tsk = sk_alloc(net, AF_VSOCK, priority, &vsock_proto);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\n\t/* sk->sk_type is normally set in sock_init_data, but only if sock is\n\t * non-NULL. We make sure that our sockets always have a type by\n\t * setting it here if needed.\n\t */\n\tif (!sock)\n\t\tsk->sk_type = type;\n\n\tvsk = vsock_sk(sk);\n\tvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\tvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\n\tsk->sk_destruct = vsock_sk_destruct;\n\tsk->sk_backlog_rcv = vsock_queue_rcv_skb;\n\tsk->sk_state = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\n\tINIT_LIST_HEAD(&vsk->bound_table);\n\tINIT_LIST_HEAD(&vsk->connected_table);\n\tvsk->listener = NULL;\n\tINIT_LIST_HEAD(&vsk->pending_links);\n\tINIT_LIST_HEAD(&vsk->accept_queue);\n\tvsk->rejected = false;\n\tvsk->sent_request = false;\n\tvsk->ignore_connecting_rst = false;\n\tvsk->peer_shutdown = 0;\n\n\tpsk = parent ? vsock_sk(parent) : NULL;\n\tif (parent) {\n\t\tvsk->trusted = psk->trusted;\n\t\tvsk->owner = get_cred(psk->owner);\n\t\tvsk->connect_timeout = psk->connect_timeout;\n\t} else {\n\t\tvsk->trusted = capable(CAP_NET_ADMIN);\n\t\tvsk->owner = get_current_cred();\n\t\tvsk->connect_timeout = VSOCK_DEFAULT_CONNECT_TIMEOUT;\n\t}\n\n\tif (transport->init(vsk, psk) < 0) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tif (sock)\n\t\tvsock_insert_unbound(vsk);\n\n\treturn sk;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d5e0d0f607a7a029c6563a0470d88255c89a8d11",
        "vul_func_with_fix": "struct sock *__vsock_create(struct net *net,\n\t\t\t    struct socket *sock,\n\t\t\t    struct sock *parent,\n\t\t\t    gfp_t priority,\n\t\t\t    unsigned short type)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *psk;\n\tstruct vsock_sock *vsk;\n\n\tsk = sk_alloc(net, AF_VSOCK, priority, &vsock_proto);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\n\t/* sk->sk_type is normally set in sock_init_data, but only if sock is\n\t * non-NULL. We make sure that our sockets always have a type by\n\t * setting it here if needed.\n\t */\n\tif (!sock)\n\t\tsk->sk_type = type;\n\n\tvsk = vsock_sk(sk);\n\tvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\tvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\n\tsk->sk_destruct = vsock_sk_destruct;\n\tsk->sk_backlog_rcv = vsock_queue_rcv_skb;\n\tsk->sk_state = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\n\tINIT_LIST_HEAD(&vsk->bound_table);\n\tINIT_LIST_HEAD(&vsk->connected_table);\n\tvsk->listener = NULL;\n\tINIT_LIST_HEAD(&vsk->pending_links);\n\tINIT_LIST_HEAD(&vsk->accept_queue);\n\tvsk->rejected = false;\n\tvsk->sent_request = false;\n\tvsk->ignore_connecting_rst = false;\n\tvsk->peer_shutdown = 0;\n\n\tpsk = parent ? vsock_sk(parent) : NULL;\n\tif (parent) {\n\t\tvsk->trusted = psk->trusted;\n\t\tvsk->owner = get_cred(psk->owner);\n\t\tvsk->connect_timeout = psk->connect_timeout;\n\t} else {\n\t\tvsk->trusted = capable(CAP_NET_ADMIN);\n\t\tvsk->owner = get_current_cred();\n\t\tvsk->connect_timeout = VSOCK_DEFAULT_CONNECT_TIMEOUT;\n\t}\n\n\tif (transport->init(vsk, psk) < 0) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tif (sock)\n\t\tvsock_insert_unbound(vsk);\n\n\treturn sk;\n}\n",
        "linevul": 0.00010767106141429394,
        "sysevr": 0.23009447753429413,
        "devign": 0.0
    },
    {
        "code": "int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tstruct bpf_verifier_env *env;\n\tstruct bpf_verifer_log *log;\n\tint ret = -EINVAL;\n\n\t/* no program is valid */\n\tif (ARRAY_SIZE(bpf_verifier_ops) == 0)\n\t\treturn -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\tlog = &env->log;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     (*prog)->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = *prog;\n\tenv->ops = bpf_verifier_ops[env->prog->type];\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = attr->log_level;\n\t\tlog->ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog->len_total = attr->log_size;\n\n\t\tret = -EINVAL;\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf)\n\t\t\tgoto err_unlock;\n\t}\n\n\tenv->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\tenv->strict_alignment = true;\n\n\tif (env->prog->aux->offload) {\n\t\tret = bpf_prog_offload_verifier_prep(env);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\tif (env->cur_state) {\n\t\tfree_verifier_state(env->cur_state, true);\n\t\tenv->cur_state = NULL;\n\t}\n\nskip_full_check:\n \twhile (!pop_stack(env, NULL, NULL));\n \tfree_states(env);\n \n \tif (ret == 0)\n \t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n \t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = fixup_bpf_calls(env);\n\n\tif (log->level && bpf_verifier_log_full(log))\n\t\tret = -ENOSPC;\n\tif (log->level && !log->ubuf) {\n\t\tret = -EFAULT;\n\t\tgoto err_release_maps;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release_maps;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nerr_release_maps:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_bpf_prog_info() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\nerr_unlock:\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
        "vul_func_with_fix": "int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tstruct bpf_verifier_env *env;\n\tstruct bpf_verifer_log *log;\n\tint ret = -EINVAL;\n\n\t/* no program is valid */\n\tif (ARRAY_SIZE(bpf_verifier_ops) == 0)\n\t\treturn -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\tlog = &env->log;\n\n\tenv->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *\n\t\t\t\t     (*prog)->len);\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = *prog;\n\tenv->ops = bpf_verifier_ops[env->prog->type];\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = attr->log_level;\n\t\tlog->ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog->len_total = attr->log_size;\n\n\t\tret = -EINVAL;\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf)\n\t\t\tgoto err_unlock;\n\t}\n\n\tenv->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\tenv->strict_alignment = true;\n\n\tif (env->prog->aux->offload) {\n\t\tret = bpf_prog_offload_verifier_prep(env);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = do_check(env);\n\tif (env->cur_state) {\n\t\tfree_verifier_state(env->cur_state, true);\n\t\tenv->cur_state = NULL;\n\t}\n\nskip_full_check:\n \twhile (!pop_stack(env, NULL, NULL));\n \tfree_states(env);\n \n//fix_flaw_line_below:\n//\tif (ret == 0)\n//fix_flaw_line_below:\n//\t\tsanitize_dead_code(env);\n//fix_flaw_line_below:\n//\n \tif (ret == 0)\n \t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n \t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = fixup_bpf_calls(env);\n\n\tif (log->level && bpf_verifier_log_full(log))\n\t\tret = -ENOSPC;\n\tif (log->level && !log->ubuf) {\n\t\tret = -EFAULT;\n\t\tgoto err_release_maps;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release_maps;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nerr_release_maps:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_bpf_prog_info() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\nerr_unlock:\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}\n",
        "linevul": 0.00020226729975547642,
        "sysevr": 0.20140549540519714,
        "devign": 0.9697101712226868
    },
    {
        "code": "static int proc_keys_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_keys_ops);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76",
        "vul_func_with_fix": "static int proc_keys_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_keys_ops);\n}\n",
        "linevul": 0.00013407399819698185,
        "sysevr": 0.12799862027168274,
        "devign": 0.0003093916748184711
    },
    {
        "code": " static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n\t\tint cmd, void __user *p)\n{\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err, nsems;\n\tushort fast_sem_io[SEMMSL_FAST];\n\tushort* sem_io = fast_sem_io;\n\tstruct list_head tasks;\n\n\tINIT_LIST_HEAD(&tasks);\n\n\trcu_read_lock();\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn PTR_ERR(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm,\n\t\t\tcmd == SETALL ? S_IWUGO : S_IRUGO)) {\n\t\trcu_read_unlock();\n\t\tgoto out_wakeup;\n\t}\n\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_wakeup;\n\t}\n\n\terr = -EACCES;\n\tswitch (cmd) {\n\tcase GETALL:\n\t{\n\t\tushort __user *array = p;\n\t\tint i;\n\n\t\tif(nsems > SEMMSL_FAST) {\n\t\t\tsem_getref(sma);\n\n\t\t\tsem_io = ipc_alloc(sizeof(ushort)*nsems);\n\t\t\tif(sem_io == NULL) {\n\t\t\t\tsem_putref(sma);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n \n \t\t\tsem_lock_and_putref(sma);\n \t\t\tif (sma->sem_perm.deleted) {\n\t\t\t\tsem_unlock(sma);\n \t\t\t\terr = -EIDRM;\n \t\t\t\tgoto out_free;\n \t\t\t}\n\t\t}\n \n\t\tspin_lock(&sma->sem_perm.lock);\n \t\tfor (i = 0; i < sma->sem_nsems; i++)\n \t\t\tsem_io[i] = sma->sem_base[i].semval;\n\t\tsem_unlock(sma);\n \t\terr = 0;\n \t\tif(copy_to_user(array, sem_io, nsems*sizeof(ushort)))\n \t\t\terr = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tcase SETALL:\n\t{\n \t\tint i;\n \t\tstruct sem_undo *un;\n \n\t\tipc_rcu_getref(sma);\n \t\trcu_read_unlock();\n \n \t\tif(nsems > SEMMSL_FAST) {\n\t\t\tsem_io = ipc_alloc(sizeof(ushort)*nsems);\n\t\t\tif(sem_io == NULL) {\n\t\t\t\tsem_putref(sma);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (copy_from_user (sem_io, p, nsems*sizeof(ushort))) {\n\t\t\tsem_putref(sma);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfor (i = 0; i < nsems; i++) {\n\t\t\tif (sem_io[i] > SEMVMX) {\n\t\t\t\tsem_putref(sma);\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out_free;\n\t\t\t}\n \t\t}\n \t\tsem_lock_and_putref(sma);\n \t\tif (sma->sem_perm.deleted) {\n\t\t\tsem_unlock(sma);\n \t\t\terr = -EIDRM;\n \t\t\tgoto out_free;\n \t\t}\n\n\t\tfor (i = 0; i < nsems; i++)\n\t\t\tsma->sem_base[i].semval = sem_io[i];\n\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_for_each_entry(un, &sma->list_id, list_id) {\n\t\t\tfor (i = 0; i < nsems; i++)\n\t\t\t\tun->semadj[i] = 0;\n\t\t}\n\t\tsma->sem_ctime = get_seconds();\n\t\t/* maybe some queued-up processes were waiting for this */\n\t\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\t/* GETVAL, GETPID, GETNCTN, GETZCNT: fall-through */\n\t}\n\terr = -EINVAL;\n\tif (semnum < 0 || semnum >= nsems) {\n\t\trcu_read_unlock();\n \t\tgoto out_wakeup;\n \t}\n \n\tspin_lock(&sma->sem_perm.lock);\n \tcurr = &sma->sem_base[semnum];\n \n \tswitch (cmd) {\n\tcase GETVAL:\n\t\terr = curr->semval;\n\t\tgoto out_unlock;\n\tcase GETPID:\n\t\terr = curr->sempid;\n\t\tgoto out_unlock;\n\tcase GETNCNT:\n\t\terr = count_semncnt(sma,semnum);\n\t\tgoto out_unlock;\n\tcase GETZCNT:\n\t\terr = count_semzcnt(sma,semnum);\n\t\tgoto out_unlock;\n \t}\n \n out_unlock:\n\tsem_unlock(sma);\n out_wakeup:\n \twake_up_sem_queue_do(&tasks);\n out_free:\n\tif(sem_io != fast_sem_io)\n\t\tipc_free(sem_io, sizeof(ushort)*nsems);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": " static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n\t\tint cmd, void __user *p)\n{\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err, nsems;\n\tushort fast_sem_io[SEMMSL_FAST];\n\tushort* sem_io = fast_sem_io;\n\tstruct list_head tasks;\n\n\tINIT_LIST_HEAD(&tasks);\n\n\trcu_read_lock();\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn PTR_ERR(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm,\n\t\t\tcmd == SETALL ? S_IWUGO : S_IRUGO)) {\n\t\trcu_read_unlock();\n\t\tgoto out_wakeup;\n\t}\n\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_wakeup;\n\t}\n\n\terr = -EACCES;\n\tswitch (cmd) {\n\tcase GETALL:\n\t{\n\t\tushort __user *array = p;\n\t\tint i;\n\n\t\tif(nsems > SEMMSL_FAST) {\n\t\t\tsem_getref(sma);\n\n\t\t\tsem_io = ipc_alloc(sizeof(ushort)*nsems);\n\t\t\tif(sem_io == NULL) {\n\t\t\t\tsem_putref(sma);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n \n \t\t\tsem_lock_and_putref(sma);\n \t\t\tif (sma->sem_perm.deleted) {\n//flaw_line_below:\n\t\t\t\tsem_unlock(sma);\n//fix_flaw_line_below:\n//\t\t\t\tsem_unlock(sma, -1);\n \t\t\t\terr = -EIDRM;\n \t\t\t\tgoto out_free;\n \t\t\t}\n//flaw_line_below:\n\t\t}\n//fix_flaw_line_below:\n//\t\t} else\n//fix_flaw_line_below:\n//\t\t\tsem_lock(sma, NULL, -1);\n \n//flaw_line_below:\n\t\tspin_lock(&sma->sem_perm.lock);\n \t\tfor (i = 0; i < sma->sem_nsems; i++)\n \t\t\tsem_io[i] = sma->sem_base[i].semval;\n//flaw_line_below:\n\t\tsem_unlock(sma);\n//fix_flaw_line_below:\n//\t\tsem_unlock(sma, -1);\n \t\terr = 0;\n \t\tif(copy_to_user(array, sem_io, nsems*sizeof(ushort)))\n \t\t\terr = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tcase SETALL:\n\t{\n \t\tint i;\n \t\tstruct sem_undo *un;\n \n//flaw_line_below:\n\t\tipc_rcu_getref(sma);\n//fix_flaw_line_below:\n//\t\tif (!ipc_rcu_getref(sma)) {\n//fix_flaw_line_below:\n//\t\t\trcu_read_unlock();\n//fix_flaw_line_below:\n//\t\t\treturn -EIDRM;\n//fix_flaw_line_below:\n//\t\t}\n \t\trcu_read_unlock();\n \n \t\tif(nsems > SEMMSL_FAST) {\n\t\t\tsem_io = ipc_alloc(sizeof(ushort)*nsems);\n\t\t\tif(sem_io == NULL) {\n\t\t\t\tsem_putref(sma);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (copy_from_user (sem_io, p, nsems*sizeof(ushort))) {\n\t\t\tsem_putref(sma);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfor (i = 0; i < nsems; i++) {\n\t\t\tif (sem_io[i] > SEMVMX) {\n\t\t\t\tsem_putref(sma);\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out_free;\n\t\t\t}\n \t\t}\n \t\tsem_lock_and_putref(sma);\n \t\tif (sma->sem_perm.deleted) {\n//flaw_line_below:\n\t\t\tsem_unlock(sma);\n//fix_flaw_line_below:\n//\t\t\tsem_unlock(sma, -1);\n \t\t\terr = -EIDRM;\n \t\t\tgoto out_free;\n \t\t}\n\n\t\tfor (i = 0; i < nsems; i++)\n\t\t\tsma->sem_base[i].semval = sem_io[i];\n\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_for_each_entry(un, &sma->list_id, list_id) {\n\t\t\tfor (i = 0; i < nsems; i++)\n\t\t\t\tun->semadj[i] = 0;\n\t\t}\n\t\tsma->sem_ctime = get_seconds();\n\t\t/* maybe some queued-up processes were waiting for this */\n\t\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\t/* GETVAL, GETPID, GETNCTN, GETZCNT: fall-through */\n\t}\n\terr = -EINVAL;\n\tif (semnum < 0 || semnum >= nsems) {\n\t\trcu_read_unlock();\n \t\tgoto out_wakeup;\n \t}\n \n//flaw_line_below:\n\tspin_lock(&sma->sem_perm.lock);\n//fix_flaw_line_below:\n//\tsem_lock(sma, NULL, -1);\n \tcurr = &sma->sem_base[semnum];\n \n \tswitch (cmd) {\n\tcase GETVAL:\n\t\terr = curr->semval;\n\t\tgoto out_unlock;\n\tcase GETPID:\n\t\terr = curr->sempid;\n\t\tgoto out_unlock;\n\tcase GETNCNT:\n\t\terr = count_semncnt(sma,semnum);\n\t\tgoto out_unlock;\n\tcase GETZCNT:\n\t\terr = count_semzcnt(sma,semnum);\n\t\tgoto out_unlock;\n \t}\n \n out_unlock:\n//flaw_line_below:\n\tsem_unlock(sma);\n//fix_flaw_line_below:\n//\tsem_unlock(sma, -1);\n out_wakeup:\n \twake_up_sem_queue_do(&tasks);\n out_free:\n\tif(sem_io != fast_sem_io)\n\t\tipc_free(sem_io, sizeof(ushort)*nsems);\n\treturn err;\n}\n",
        "linevul": 0.0029482769314199686,
        "sysevr": 0.17109036445617676,
        "devign": 0.6639441251754761
    },
    {
        "code": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99",
        "vul_func_with_fix": "int huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}\n",
        "linevul": 5.424636401585303e-05,
        "sysevr": 0.15620948374271393,
        "devign": 0.016035502776503563
    },
    {
        "code": "static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\tstruct completion *requests_done)\n{\n\tstruct kioctx_table *table;\n\n\tif (atomic_xchg(&ctx->dead, 1))\n\t\treturn -EINVAL;\n\n\n\tspin_lock(&mm->ioctx_lock);\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tWARN_ON(ctx != table->table[ctx->id]);\n\ttable->table[ctx->id] = NULL;\n\trcu_read_unlock();\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* percpu_ref_kill() will do the necessary call_rcu() */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->requests_done = requests_done;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/edfbbf388f293d70bf4b7c0bc38774d05e6f711a",
        "vul_func_with_fix": "static int kill_ioctx(struct mm_struct *mm, struct kioctx *ctx,\n\t\tstruct completion *requests_done)\n{\n\tstruct kioctx_table *table;\n\n\tif (atomic_xchg(&ctx->dead, 1))\n\t\treturn -EINVAL;\n\n\n\tspin_lock(&mm->ioctx_lock);\n\trcu_read_lock();\n\ttable = rcu_dereference(mm->ioctx_table);\n\n\tWARN_ON(ctx != table->table[ctx->id]);\n\ttable->table[ctx->id] = NULL;\n\trcu_read_unlock();\n\tspin_unlock(&mm->ioctx_lock);\n\n\t/* percpu_ref_kill() will do the necessary call_rcu() */\n\twake_up_all(&ctx->wait);\n\n\t/*\n\t * It'd be more correct to do this in free_ioctx(), after all\n\t * the outstanding kiocbs have finished - but by then io_destroy\n\t * has already returned, so io_setup() could potentially return\n\t * -EAGAIN with no ioctxs actually in use (as far as userspace\n\t *  could tell).\n\t */\n\taio_nr_sub(ctx->max_reqs);\n\n\tif (ctx->mmap_size)\n\t\tvm_munmap(ctx->mmap_base, ctx->mmap_size);\n\n\tctx->requests_done = requests_done;\n\tpercpu_ref_kill(&ctx->users);\n\treturn 0;\n}\n",
        "linevul": 9.359717660117894e-05,
        "sysevr": 0.14425161480903625,
        "devign": 4.1499232571600293e-19
    },
    {
        "code": "nf_tables_chain_type_lookup(const struct nft_af_info *afi,\n\t\t\t    const struct nlattr *nla,\n\t\t\t    bool autoload)\n{\n\tconst struct nf_chain_type *type;\n\n\ttype = __nf_tables_chain_type_lookup(afi->family, nla);\n\tif (type != NULL)\n\t\treturn type;\n#ifdef CONFIG_MODULES\n\tif (autoload) {\n\t\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\t\trequest_module(\"nft-chain-%u-%.*s\", afi->family,\n\t\t\t       nla_len(nla), (const char *)nla_data(nla));\n\t\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\t\ttype = __nf_tables_chain_type_lookup(afi->family, nla);\n\t\tif (type != NULL)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a2f18db0c68fec96631c10cad9384c196e9008ac",
        "vul_func_with_fix": "nf_tables_chain_type_lookup(const struct nft_af_info *afi,\n\t\t\t    const struct nlattr *nla,\n\t\t\t    bool autoload)\n{\n\tconst struct nf_chain_type *type;\n\n\ttype = __nf_tables_chain_type_lookup(afi->family, nla);\n\tif (type != NULL)\n\t\treturn type;\n#ifdef CONFIG_MODULES\n\tif (autoload) {\n\t\tnfnl_unlock(NFNL_SUBSYS_NFTABLES);\n\t\trequest_module(\"nft-chain-%u-%.*s\", afi->family,\n\t\t\t       nla_len(nla), (const char *)nla_data(nla));\n\t\tnfnl_lock(NFNL_SUBSYS_NFTABLES);\n\t\ttype = __nf_tables_chain_type_lookup(afi->family, nla);\n\t\tif (type != NULL)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n",
        "linevul": 4.8331912694266066e-05,
        "sysevr": 0.14974255859851837,
        "devign": 0.11572307348251343
    },
    {
        "code": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b2853fd6c2d0f383dbdf7427e263eb576a633867",
        "vul_func_with_fix": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n//flaw_line_below:\n{\n//flaw_line_below:\n\tstruct cm_id_private *cm_id_priv;\n//flaw_line_below:\n\n//flaw_line_below:\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (smac != NULL)\n//flaw_line_below:\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n//flaw_line_below:\n\n//flaw_line_below:\n\tif (alt_smac != NULL)\n//flaw_line_below:\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n//flaw_line_below:\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n//flaw_line_below:\n\n//flaw_line_below:\n\treturn 0;\n//flaw_line_below:\n}\n",
        "linevul": 0.002457240130752325,
        "sysevr": 0.16330201923847198,
        "devign": 0.9999657869338989
    },
    {
        "code": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n \t\tscm->fp = NULL;\n \t\tfor (i=fpl->count-1; i>=0; i--)\n \t\t\tfput(fpl->fp[i]);\n \t\tkfree(fpl);\n \t}\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6",
        "vul_func_with_fix": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n \t\tscm->fp = NULL;\n \t\tfor (i=fpl->count-1; i>=0; i--)\n \t\t\tfput(fpl->fp[i]);\n//fix_flaw_line_below:\n//\t\tfree_uid(fpl->user);\n \t\tkfree(fpl);\n \t}\n }\n",
        "linevul": 0.9969820380210876,
        "sysevr": 0.15854917466640472,
        "devign": 0.9996767044067383
    },
    {
        "code": "static int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "static int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}\n",
        "linevul": 4.6094588469713926e-05,
        "sysevr": 0.12535643577575684,
        "devign": 8.721485329315744e-17
    },
    {
        "code": "static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t/* Set destination address and psm */\n\tbacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);\n\n\terr = sco_connect(sk);\n\tif (err)\n\t\tgoto done;\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86",
        "vul_func_with_fix": "static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t/* Set destination address and psm */\n\tbacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);\n\n\terr = sco_connect(sk);\n\tif (err)\n\t\tgoto done;\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "linevul": 6.923113687662408e-05,
        "sysevr": 0.12476969510316849,
        "devign": 4.724672801430241e-13
    },
    {
        "code": "static inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\t __be32 saddr, __be16 sport,\n\t\t\t\t __be32 daddr, unsigned int hnum, int dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    ipv6_only_sock(sk))\n\t\treturn -1;\n\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_rcv_saddr != daddr ||\n\t    inet->inet_num != hnum)\n\t\treturn -1;\n\n\tscore = (sk->sk_family == PF_INET) ? 2 : 1;\n\n\tif (inet->inet_daddr) {\n\t\tif (inet->inet_daddr != saddr)\n\t\t\treturn -1;\n\t\tscore += 4;\n\t}\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore += 4;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore += 4;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/197c949e7798fbf28cfadc69d9ca0c2abbf93191",
        "vul_func_with_fix": "static inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\t __be32 saddr, __be16 sport,\n\t\t\t\t __be32 daddr, unsigned int hnum, int dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    ipv6_only_sock(sk))\n\t\treturn -1;\n\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_rcv_saddr != daddr ||\n\t    inet->inet_num != hnum)\n\t\treturn -1;\n\n\tscore = (sk->sk_family == PF_INET) ? 2 : 1;\n\n\tif (inet->inet_daddr) {\n\t\tif (inet->inet_daddr != saddr)\n\t\t\treturn -1;\n\t\tscore += 4;\n\t}\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore += 4;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore += 4;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n",
        "linevul": 6.602903158636764e-05,
        "sysevr": 0.12790735065937042,
        "devign": 0.0015610407572239637
    },
    {
        "code": "static int encode_commit(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n        \n        RESERVE_SPACE(16);\n        WRITE32(OP_COMMIT);\n        WRITE64(args->offset);\n        WRITE32(args->count);\n\n        return 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9",
        "vul_func_with_fix": "static int encode_commit(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n        \n        RESERVE_SPACE(16);\n        WRITE32(OP_COMMIT);\n        WRITE64(args->offset);\n        WRITE32(args->count);\n\n        return 0;\n}\n",
        "linevul": 7.914468733360991e-05,
        "sysevr": 0.12218666076660156,
        "devign": 3.3721407817211e-06
    },
    {
        "code": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct inet_cork *cork;\n \tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen;\n \tint exthdrlen;\n \tint dst_exthdrlen;\n \tint hh_len;\n\tint mtu;\n \tint copy;\n \tint err;\n \tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n \t\t\t/* update mtu and maxfraglen if necessary */\n \t\t\tif (skb == NULL || skb_prev == NULL)\n \t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n \n \t\t\tskb_prev = skb;\n \n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/75a493e60ac4bbe2e977e7129d6d8cbb0dd236be",
        "vul_func_with_fix": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct inet_cork *cork;\n \tstruct sk_buff *skb, *skb_prev = NULL;\n//flaw_line_below:\n\tunsigned int maxfraglen, fragheaderlen;\n//fix_flaw_line_below:\n//\tunsigned int maxfraglen, fragheaderlen, mtu;\n \tint exthdrlen;\n \tint dst_exthdrlen;\n \tint hh_len;\n//flaw_line_below:\n\tint mtu;\n \tint copy;\n \tint err;\n \tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n \t\t\t/* update mtu and maxfraglen if necessary */\n \t\t\tif (skb == NULL || skb_prev == NULL)\n \t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n//flaw_line_below:\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    fragheaderlen, skb, rt,\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    np->pmtudisc ==\n//fix_flaw_line_below:\n//\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n \n \t\t\tskb_prev = skb;\n \n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n",
        "linevul": 0.9983828067779541,
        "sysevr": 0.42322587966918945,
        "devign": 0.9534940719604492
    },
    {
        "code": "int is_hwpoison_pfn(pfn_t pfn)\n{\n\treturn pfn == hwpoison_pfn;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/09ca8e1173bcb12e2a449698c9ae3b86a8a10195",
        "vul_func_with_fix": "int is_hwpoison_pfn(pfn_t pfn)\n{\n\treturn pfn == hwpoison_pfn;\n}\n",
        "linevul": 6.915664562257007e-05,
        "sysevr": 0.15108740329742432,
        "devign": 0.0002047492453129962
    },
    {
        "code": "static int crc32_digest(struct shash_desc *desc, const u8 *data,\n\t\t\tunsigned int len, u8 *out)\n{\n\treturn __crc32_finup(crypto_shash_ctx(desc->tfm), data, len,\n\t\t\t     out);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int crc32_digest(struct shash_desc *desc, const u8 *data,\n\t\t\tunsigned int len, u8 *out)\n{\n\treturn __crc32_finup(crypto_shash_ctx(desc->tfm), data, len,\n\t\t\t     out);\n}\n",
        "linevul": 6.0634225519606844e-05,
        "sysevr": 0.13200904428958893,
        "devign": 1.1366155376890674e-05
    },
    {
        "code": "static inline __be32 sk_extract_addr(struct sockaddr *addr)\n{\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2",
        "vul_func_with_fix": "static inline __be32 sk_extract_addr(struct sockaddr *addr)\n{\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n",
        "linevul": 8.788156992523e-05,
        "sysevr": 0.12701770663261414,
        "devign": 2.494141153874807e-05
    },
    {
        "code": "static void update_cpu_load(struct rq *this_rq)\n{\n\tunsigned long this_load = this_rq->load.weight;\n\tunsigned long curr_jiffies = jiffies;\n\tunsigned long pending_updates;\n\tint i, scale;\n\n\tthis_rq->nr_load_updates++;\n\n\t/* Avoid repeated calls on same jiffy, when moving in and out of idle */\n\tif (curr_jiffies == this_rq->last_load_update_tick)\n\t\treturn;\n\n\tpending_updates = curr_jiffies - this_rq->last_load_update_tick;\n\tthis_rq->last_load_update_tick = curr_jiffies;\n\n\t/* Update our load: */\n\tthis_rq->cpu_load[0] = this_load; /* Fasttrack for idx 0 */\n\tfor (i = 1, scale = 2; i < CPU_LOAD_IDX_MAX; i++, scale += scale) {\n\t\tunsigned long old_load, new_load;\n\n\t\t/* scale is effectively 1 << i now, and >> i divides by scale */\n\n\t\told_load = this_rq->cpu_load[i];\n\t\told_load = decay_load_missed(old_load, pending_updates - 1, i);\n\t\tnew_load = this_load;\n\t\t/*\n\t\t * Round up the averaging division if load is increasing. This\n\t\t * prevents us from getting stuck on 9 if the load is 10, for\n\t\t * example.\n\t\t */\n\t\tif (new_load > old_load)\n\t\t\tnew_load += scale - 1;\n\n\t\tthis_rq->cpu_load[i] = (old_load * (scale - 1) + new_load) >> i;\n\t}\n\n\tsched_avg_update(this_rq);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "vul_func_with_fix": "static void update_cpu_load(struct rq *this_rq)\n{\n\tunsigned long this_load = this_rq->load.weight;\n\tunsigned long curr_jiffies = jiffies;\n\tunsigned long pending_updates;\n\tint i, scale;\n\n\tthis_rq->nr_load_updates++;\n\n\t/* Avoid repeated calls on same jiffy, when moving in and out of idle */\n\tif (curr_jiffies == this_rq->last_load_update_tick)\n\t\treturn;\n\n\tpending_updates = curr_jiffies - this_rq->last_load_update_tick;\n\tthis_rq->last_load_update_tick = curr_jiffies;\n\n\t/* Update our load: */\n\tthis_rq->cpu_load[0] = this_load; /* Fasttrack for idx 0 */\n\tfor (i = 1, scale = 2; i < CPU_LOAD_IDX_MAX; i++, scale += scale) {\n\t\tunsigned long old_load, new_load;\n\n\t\t/* scale is effectively 1 << i now, and >> i divides by scale */\n\n\t\told_load = this_rq->cpu_load[i];\n\t\told_load = decay_load_missed(old_load, pending_updates - 1, i);\n\t\tnew_load = this_load;\n\t\t/*\n\t\t * Round up the averaging division if load is increasing. This\n\t\t * prevents us from getting stuck on 9 if the load is 10, for\n\t\t * example.\n\t\t */\n\t\tif (new_load > old_load)\n\t\t\tnew_load += scale - 1;\n\n\t\tthis_rq->cpu_load[i] = (old_load * (scale - 1) + new_load) >> i;\n\t}\n\n\tsched_avg_update(this_rq);\n}\n",
        "linevul": 5.381849405239336e-05,
        "sysevr": 0.13764941692352295,
        "devign": 0.9197788238525391
    },
    {
        "code": "static ssize_t store_read_buffer_kb(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct comedi_device_file_info *info = dev_get_drvdata(dev);\n\tunsigned long new_size_kb;\n\tuint64_t new_size;\n\tint retval;\n\tstruct comedi_subdevice *const read_subdevice =\n\t    comedi_get_read_subdevice(info);\n\n\tif (strict_strtoul(buf, 10, &new_size_kb))\n\t\treturn -EINVAL;\n\tif (new_size_kb != (uint32_t) new_size_kb)\n\t\treturn -EINVAL;\n\tnew_size = ((uint64_t) new_size_kb) * bytes_per_kibi;\n\tif (new_size != (uint32_t) new_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&info->device->mutex);\n\tif (read_subdevice == NULL ||\n\t    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||\n\t    read_subdevice->async == NULL) {\n\t\tmutex_unlock(&info->device->mutex);\n\t\treturn -EINVAL;\n\t}\n\tretval = resize_async_buffer(info->device, read_subdevice,\n\t\t\t\t     read_subdevice->async, new_size);\n\tmutex_unlock(&info->device->mutex);\n\n\tif (retval < 0)\n\t\treturn retval;\n\treturn count;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/819cbb120eaec7e014e5abd029260db1ca8c5735",
        "vul_func_with_fix": "static ssize_t store_read_buffer_kb(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct comedi_device_file_info *info = dev_get_drvdata(dev);\n\tunsigned long new_size_kb;\n\tuint64_t new_size;\n\tint retval;\n\tstruct comedi_subdevice *const read_subdevice =\n\t    comedi_get_read_subdevice(info);\n\n\tif (strict_strtoul(buf, 10, &new_size_kb))\n\t\treturn -EINVAL;\n\tif (new_size_kb != (uint32_t) new_size_kb)\n\t\treturn -EINVAL;\n\tnew_size = ((uint64_t) new_size_kb) * bytes_per_kibi;\n\tif (new_size != (uint32_t) new_size)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&info->device->mutex);\n\tif (read_subdevice == NULL ||\n\t    (read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||\n\t    read_subdevice->async == NULL) {\n\t\tmutex_unlock(&info->device->mutex);\n\t\treturn -EINVAL;\n\t}\n\tretval = resize_async_buffer(info->device, read_subdevice,\n\t\t\t\t     read_subdevice->async, new_size);\n\tmutex_unlock(&info->device->mutex);\n\n\tif (retval < 0)\n\t\treturn retval;\n\treturn count;\n}\n",
        "linevul": 0.0001648127072257921,
        "sysevr": 0.11468864232301712,
        "devign": 3.1904286994269565e-39
    },
    {
        "code": "int iriap_getvaluebyclass_request(struct iriap_cb *self,\n\t\t\t\t  __u32 saddr, __u32 daddr,\n\t\t\t\t  char *name, char *attr)\n{\n\tstruct sk_buff *tx_skb;\n\tint name_len, attr_len, skb_len;\n\t__u8 *frame;\n\n\tIRDA_ASSERT(self != NULL, return -1;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return -1;);\n\n\t/* Client must supply the destination device address */\n\tif (!daddr)\n\t\treturn -1;\n\n\tself->daddr = daddr;\n\tself->saddr = saddr;\n\n\t/*\n\t *  Save operation, so we know what the later indication is about\n\t */\n\tself->operation = GET_VALUE_BY_CLASS;\n\n\t/* Give ourselves 10 secs to finish this operation */\n\tiriap_start_watchdog_timer(self, 10*HZ);\n\n\tname_len = strlen(name);\t/* Up to IAS_MAX_CLASSNAME = 60 */\n\tattr_len = strlen(attr);\t/* Up to IAS_MAX_ATTRIBNAME = 60 */\n\n\tskb_len = self->max_header_size+2+name_len+1+attr_len+4;\n\ttx_skb = alloc_skb(skb_len, GFP_ATOMIC);\n\tif (!tx_skb)\n\t\treturn -ENOMEM;\n\n\t/* Reserve space for MUX and LAP header */\n\tskb_reserve(tx_skb, self->max_header_size);\n\tskb_put(tx_skb, 3+name_len+attr_len);\n\tframe = tx_skb->data;\n\n\t/* Build frame */\n\tframe[0] = IAP_LST | GET_VALUE_BY_CLASS;\n\tframe[1] = name_len;                       /* Insert length of name */\n\tmemcpy(frame+2, name, name_len);           /* Insert name */\n\tframe[2+name_len] = attr_len;              /* Insert length of attr */\n\tmemcpy(frame+3+name_len, attr, attr_len);  /* Insert attr */\n\n\tiriap_do_client_event(self, IAP_CALL_REQUEST_GVBC, tx_skb);\n\n\t/* Drop reference count - see state_s_disconnect(). */\n\tdev_kfree_skb(tx_skb);\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846",
        "vul_func_with_fix": "int iriap_getvaluebyclass_request(struct iriap_cb *self,\n\t\t\t\t  __u32 saddr, __u32 daddr,\n\t\t\t\t  char *name, char *attr)\n{\n\tstruct sk_buff *tx_skb;\n\tint name_len, attr_len, skb_len;\n\t__u8 *frame;\n\n\tIRDA_ASSERT(self != NULL, return -1;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return -1;);\n\n\t/* Client must supply the destination device address */\n\tif (!daddr)\n\t\treturn -1;\n\n\tself->daddr = daddr;\n\tself->saddr = saddr;\n\n\t/*\n\t *  Save operation, so we know what the later indication is about\n\t */\n\tself->operation = GET_VALUE_BY_CLASS;\n\n\t/* Give ourselves 10 secs to finish this operation */\n\tiriap_start_watchdog_timer(self, 10*HZ);\n\n\tname_len = strlen(name);\t/* Up to IAS_MAX_CLASSNAME = 60 */\n\tattr_len = strlen(attr);\t/* Up to IAS_MAX_ATTRIBNAME = 60 */\n\n\tskb_len = self->max_header_size+2+name_len+1+attr_len+4;\n\ttx_skb = alloc_skb(skb_len, GFP_ATOMIC);\n\tif (!tx_skb)\n\t\treturn -ENOMEM;\n\n\t/* Reserve space for MUX and LAP header */\n\tskb_reserve(tx_skb, self->max_header_size);\n\tskb_put(tx_skb, 3+name_len+attr_len);\n\tframe = tx_skb->data;\n\n\t/* Build frame */\n\tframe[0] = IAP_LST | GET_VALUE_BY_CLASS;\n\tframe[1] = name_len;                       /* Insert length of name */\n\tmemcpy(frame+2, name, name_len);           /* Insert name */\n\tframe[2+name_len] = attr_len;              /* Insert length of attr */\n\tmemcpy(frame+3+name_len, attr, attr_len);  /* Insert attr */\n\n\tiriap_do_client_event(self, IAP_CALL_REQUEST_GVBC, tx_skb);\n\n\t/* Drop reference count - see state_s_disconnect(). */\n\tdev_kfree_skb(tx_skb);\n\n\treturn 0;\n}\n",
        "linevul": 5.518892066902481e-05,
        "sysevr": 0.186712384223938,
        "devign": 6.596828405515221e-30
    },
    {
        "code": "static int atusb_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(interface);\n\tstruct ieee802154_hw *hw;\n\tstruct atusb *atusb = NULL;\n\tint ret = -ENOMEM;\n\n\thw = ieee802154_alloc_hw(sizeof(struct atusb), &atusb_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tatusb = hw->priv;\n\tatusb->hw = hw;\n\tatusb->usb_dev = usb_get_dev(usb_dev);\n\tusb_set_intfdata(interface, atusb);\n\n\tatusb->shutdown = 0;\n\tatusb->err = 0;\n\tINIT_DELAYED_WORK(&atusb->work, atusb_work_urbs);\n\tinit_usb_anchor(&atusb->idle_urbs);\n\tinit_usb_anchor(&atusb->rx_urbs);\n\n\tif (atusb_alloc_urbs(atusb, ATUSB_NUM_RX_URBS))\n\t\tgoto fail;\n\n\tatusb->tx_dr.bRequestType = ATUSB_REQ_TO_DEV;\n\tatusb->tx_dr.bRequest = ATUSB_TX;\n\tatusb->tx_dr.wValue = cpu_to_le16(0);\n\n\tatusb->tx_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!atusb->tx_urb)\n\t\tgoto fail;\n\n\thw->parent = &usb_dev->dev;\n\thw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t    IEEE802154_HW_PROMISCUOUS | IEEE802154_HW_CSMA_PARAMS |\n\t\t    IEEE802154_HW_FRAME_RETRIES;\n\n\thw->phy->flags = WPAN_PHY_FLAG_TXPOWER | WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t WPAN_PHY_FLAG_CCA_MODE;\n\n\thw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\tBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\n\thw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\tBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\thw->phy->supported.cca_ed_levels = atusb_ed_levels;\n\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(atusb_ed_levels);\n\n\thw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\thw->phy->current_page = 0;\n\thw->phy->current_channel = 11;\t/* reset default */\n\thw->phy->supported.channels[0] = 0x7FFF800;\n\thw->phy->supported.tx_powers = atusb_powers;\n\thw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\n\thw->phy->transmit_power = hw->phy->supported.tx_powers[0];\n\thw->phy->cca_ed_level = hw->phy->supported.cca_ed_levels[7];\n\n\tatusb_command(atusb, ATUSB_RF_RESET, 0);\n\tatusb_get_and_show_chip(atusb);\n\tatusb_get_and_show_revision(atusb);\n\tatusb_get_and_show_build(atusb);\n\tatusb_set_extended_addr(atusb);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret) {\n\t\tdev_err(&atusb->usb_dev->dev,\n\t\t\t\"%s: initialization failed, error = %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto fail;\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* If we just powered on, we're now in P_ON and need to enter TRX_OFF\n\t * explicitly. Any resets after that will send us straight to TRX_OFF,\n\t * making the command below redundant.\n\t */\n\tatusb_write_reg(atusb, RG_TRX_STATE, STATE_FORCE_TRX_OFF);\n\tmsleep(1);\t/* reset => TRX_OFF, tTR13 = 37 us */\n\n#if 0\n\t/* Calculating the maximum time available to empty the frame buffer\n\t * on reception:\n\t *\n\t * According to [1], the inter-frame gap is\n\t * R * 20 * 16 us + 128 us\n\t * where R is a random number from 0 to 7. Furthermore, we have 20 bit\n\t * times (80 us at 250 kbps) of SHR of the next frame before the\n\t * transceiver begins storing data in the frame buffer.\n\t *\n\t * This yields a minimum time of 208 us between the last data of a\n\t * frame and the first data of the next frame. This time is further\n\t * reduced by interrupt latency in the atusb firmware.\n\t *\n\t * atusb currently needs about 500 us to retrieve a maximum-sized\n\t * frame. We therefore have to allow reception of a new frame to begin\n\t * while we retrieve the previous frame.\n\t *\n\t * [1] \"JN-AN-1035 Calculating data rates in an IEEE 802.15.4-based\n\t *      network\", Jennic 2006.\n\t *     http://www.jennic.com/download_file.php?supportFile=JN-AN-1035%20Calculating%20802-15-4%20Data%20Rates-1v0.pdf\n\t */\n\n\tatusb_write_subreg(atusb, SR_RX_SAFE_MODE, 1);\n#endif\n\tatusb_write_reg(atusb, RG_IRQ_MASK, 0xff);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(&atusb->usb_dev->dev,\n\t\t\"%s: setup failed, error = %d\\n\",\n\t\t__func__, ret);\n\n\tieee802154_unregister_hw(hw);\nfail:\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tusb_put_dev(usb_dev);\n\tieee802154_free_hw(hw);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655",
        "vul_func_with_fix": "static int atusb_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(interface);\n\tstruct ieee802154_hw *hw;\n\tstruct atusb *atusb = NULL;\n\tint ret = -ENOMEM;\n\n\thw = ieee802154_alloc_hw(sizeof(struct atusb), &atusb_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tatusb = hw->priv;\n\tatusb->hw = hw;\n\tatusb->usb_dev = usb_get_dev(usb_dev);\n\tusb_set_intfdata(interface, atusb);\n\n\tatusb->shutdown = 0;\n\tatusb->err = 0;\n\tINIT_DELAYED_WORK(&atusb->work, atusb_work_urbs);\n\tinit_usb_anchor(&atusb->idle_urbs);\n\tinit_usb_anchor(&atusb->rx_urbs);\n\n\tif (atusb_alloc_urbs(atusb, ATUSB_NUM_RX_URBS))\n\t\tgoto fail;\n\n\tatusb->tx_dr.bRequestType = ATUSB_REQ_TO_DEV;\n\tatusb->tx_dr.bRequest = ATUSB_TX;\n\tatusb->tx_dr.wValue = cpu_to_le16(0);\n\n\tatusb->tx_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!atusb->tx_urb)\n\t\tgoto fail;\n\n\thw->parent = &usb_dev->dev;\n\thw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t    IEEE802154_HW_PROMISCUOUS | IEEE802154_HW_CSMA_PARAMS |\n\t\t    IEEE802154_HW_FRAME_RETRIES;\n\n\thw->phy->flags = WPAN_PHY_FLAG_TXPOWER | WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t WPAN_PHY_FLAG_CCA_MODE;\n\n\thw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\tBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\n\thw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\tBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\thw->phy->supported.cca_ed_levels = atusb_ed_levels;\n\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(atusb_ed_levels);\n\n\thw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\thw->phy->current_page = 0;\n\thw->phy->current_channel = 11;\t/* reset default */\n\thw->phy->supported.channels[0] = 0x7FFF800;\n\thw->phy->supported.tx_powers = atusb_powers;\n\thw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\n\thw->phy->transmit_power = hw->phy->supported.tx_powers[0];\n\thw->phy->cca_ed_level = hw->phy->supported.cca_ed_levels[7];\n\n\tatusb_command(atusb, ATUSB_RF_RESET, 0);\n\tatusb_get_and_show_chip(atusb);\n\tatusb_get_and_show_revision(atusb);\n\tatusb_get_and_show_build(atusb);\n\tatusb_set_extended_addr(atusb);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret) {\n\t\tdev_err(&atusb->usb_dev->dev,\n\t\t\t\"%s: initialization failed, error = %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto fail;\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* If we just powered on, we're now in P_ON and need to enter TRX_OFF\n\t * explicitly. Any resets after that will send us straight to TRX_OFF,\n\t * making the command below redundant.\n\t */\n\tatusb_write_reg(atusb, RG_TRX_STATE, STATE_FORCE_TRX_OFF);\n\tmsleep(1);\t/* reset => TRX_OFF, tTR13 = 37 us */\n\n#if 0\n\t/* Calculating the maximum time available to empty the frame buffer\n\t * on reception:\n\t *\n\t * According to [1], the inter-frame gap is\n\t * R * 20 * 16 us + 128 us\n\t * where R is a random number from 0 to 7. Furthermore, we have 20 bit\n\t * times (80 us at 250 kbps) of SHR of the next frame before the\n\t * transceiver begins storing data in the frame buffer.\n\t *\n\t * This yields a minimum time of 208 us between the last data of a\n\t * frame and the first data of the next frame. This time is further\n\t * reduced by interrupt latency in the atusb firmware.\n\t *\n\t * atusb currently needs about 500 us to retrieve a maximum-sized\n\t * frame. We therefore have to allow reception of a new frame to begin\n\t * while we retrieve the previous frame.\n\t *\n\t * [1] \"JN-AN-1035 Calculating data rates in an IEEE 802.15.4-based\n\t *      network\", Jennic 2006.\n\t *     http://www.jennic.com/download_file.php?supportFile=JN-AN-1035%20Calculating%20802-15-4%20Data%20Rates-1v0.pdf\n\t */\n\n\tatusb_write_subreg(atusb, SR_RX_SAFE_MODE, 1);\n#endif\n\tatusb_write_reg(atusb, RG_IRQ_MASK, 0xff);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(&atusb->usb_dev->dev,\n\t\t\"%s: setup failed, error = %d\\n\",\n\t\t__func__, ret);\n\n\tieee802154_unregister_hw(hw);\nfail:\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tusb_put_dev(usb_dev);\n\tieee802154_free_hw(hw);\n\treturn ret;\n}\n",
        "linevul": 0.0005211119423620403,
        "sysevr": 0.349500447511673,
        "devign": 1.781714227317301e-37
    },
    {
        "code": "static struct inode *new_simple_dir(struct super_block *s,\n\t\t\t\t    struct btrfs_key *key,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct inode *inode = new_inode(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tBTRFS_I(inode)->root = root;\n\tmemcpy(&BTRFS_I(inode)->location, key, sizeof(*key));\n\tset_bit(BTRFS_INODE_DUMMY, &BTRFS_I(inode)->runtime_flags);\n\n\tinode->i_ino = BTRFS_EMPTY_SUBVOL_DIR_OBJECTID;\n\tinode->i_op = &btrfs_dir_ro_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\treturn inode;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9c52057c698fb96f8f07e7a4bcf4801a092bda89",
        "vul_func_with_fix": "static struct inode *new_simple_dir(struct super_block *s,\n\t\t\t\t    struct btrfs_key *key,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct inode *inode = new_inode(s);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tBTRFS_I(inode)->root = root;\n\tmemcpy(&BTRFS_I(inode)->location, key, sizeof(*key));\n\tset_bit(BTRFS_INODE_DUMMY, &BTRFS_I(inode)->runtime_flags);\n\n\tinode->i_ino = BTRFS_EMPTY_SUBVOL_DIR_OBJECTID;\n\tinode->i_op = &btrfs_dir_ro_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_mode = S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\treturn inode;\n}\n",
        "linevul": 0.00021614096476696432,
        "sysevr": 0.15965493023395538,
        "devign": 1.3168109181185828e-12
    },
    {
        "code": "void fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\t/* Hold vfsmount and dentry until release is finished */\n\tpath_get(&file->f_path);\n\treq->misc.release.path = file->f_path;\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t */\n\tfuse_file_put(ff);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16",
        "vul_func_with_fix": "void fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\t/* Hold vfsmount and dentry until release is finished */\n\tpath_get(&file->f_path);\n\treq->misc.release.path = file->f_path;\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t */\n\tfuse_file_put(ff);\n}\n",
        "linevul": 4.863581125391647e-05,
        "sysevr": 0.18968938291072845,
        "devign": 8.506233495353399e-10
    },
    {
        "code": "static int zlib_init(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int zlib_init(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}\n",
        "linevul": 5.475924990605563e-05,
        "sysevr": 0.13003665208816528,
        "devign": 9.5448659826608e-13
    },
    {
        "code": "static inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(dir->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca",
        "vul_func_with_fix": "static inline unsigned dx_root_limit(struct inode *dir, unsigned infosize)\n{\n\tunsigned entry_space = dir->i_sb->s_blocksize - EXT4_DIR_REC_LEN(1) -\n\t\tEXT4_DIR_REC_LEN(2) - infosize;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(dir->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_METADATA_CSUM))\n\t\tentry_space -= sizeof(struct dx_tail);\n\treturn entry_space / sizeof(struct dx_entry);\n}\n",
        "linevul": 6.798320828238502e-05,
        "sysevr": 0.11993509531021118,
        "devign": 3.213657251421864e-08
    },
    {
        "code": "static void ati_remote2_input_mouse(struct ati_remote2 *ar2)\n{\n\tstruct input_dev *idev = ar2->idev;\n\tu8 *data = ar2->buf[0];\n\tint channel, mode;\n\n\tchannel = data[0] >> 4;\n\n\tif (!((1 << channel) & ar2->channel_mask))\n\t\treturn;\n\n\tmode = data[0] & 0x0F;\n\n\tif (mode > ATI_REMOTE2_PC) {\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"Unknown mode byte (%02x %02x %02x %02x)\\n\",\n\t\t\tdata[3], data[2], data[1], data[0]);\n\t\treturn;\n\t}\n\n\tif (!((1 << mode) & ar2->mode_mask))\n\t\treturn;\n\n\tinput_event(idev, EV_REL, REL_X, (s8) data[1]);\n\tinput_event(idev, EV_REL, REL_Y, (s8) data[2]);\n\tinput_sync(idev);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d",
        "vul_func_with_fix": "static void ati_remote2_input_mouse(struct ati_remote2 *ar2)\n{\n\tstruct input_dev *idev = ar2->idev;\n\tu8 *data = ar2->buf[0];\n\tint channel, mode;\n\n\tchannel = data[0] >> 4;\n\n\tif (!((1 << channel) & ar2->channel_mask))\n\t\treturn;\n\n\tmode = data[0] & 0x0F;\n\n\tif (mode > ATI_REMOTE2_PC) {\n\t\tdev_err(&ar2->intf[0]->dev,\n\t\t\t\"Unknown mode byte (%02x %02x %02x %02x)\\n\",\n\t\t\tdata[3], data[2], data[1], data[0]);\n\t\treturn;\n\t}\n\n\tif (!((1 << mode) & ar2->mode_mask))\n\t\treturn;\n\n\tinput_event(idev, EV_REL, REL_X, (s8) data[1]);\n\tinput_event(idev, EV_REL, REL_Y, (s8) data[2]);\n\tinput_sync(idev);\n}\n",
        "linevul": 4.740661825053394e-05,
        "sysevr": 0.13864785432815552,
        "devign": 8.120999154925812e-06
    },
    {
        "code": "void __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_names *n;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c",
        "vul_func_with_fix": "void __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_names *n;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n}\n",
        "linevul": 6.188550469232723e-05,
        "sysevr": 0.18362292647361755,
        "devign": 4.721230953458687e-17
    },
    {
        "code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\n\tunix_remove_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\n\twake_up_interruptible_all(&u->peer_wait);\n\n\tskpair = unix_peer(sk);\n\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); /* It may now die */\n\t\tunix_peer(sk) = NULL;\n\t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock->err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/415e3d3e90ce9e18727e8843ae343eda5a58fad6",
        "vul_func_with_fix": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\n\tunix_remove_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\n\twake_up_interruptible_all(&u->peer_wait);\n\n\tskpair = unix_peer(sk);\n\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); /* It may now die */\n\t\tunix_peer(sk) = NULL;\n\t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock->err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}\n",
        "linevul": 0.00014366136747412384,
        "sysevr": 0.18062104284763336,
        "devign": 5.733755755344544e-14
    },
    {
        "code": "static void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tvfree(info->files.data);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/4e7c22d447bb6d7e37bfe39ff658486ae78e8d77",
        "vul_func_with_fix": "static void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tvfree(info->files.data);\n}\n",
        "linevul": 0.00030135782435536385,
        "sysevr": 0.12937438488006592,
        "devign": 2.038775608569337e-14
    },
    {
        "code": "static void __exit serpent_mod_fini(void)\n{\n\tcrypto_unregister_algs(srp_algs, ARRAY_SIZE(srp_algs));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static void __exit serpent_mod_fini(void)\n{\n\tcrypto_unregister_algs(srp_algs, ARRAY_SIZE(srp_algs));\n}\n",
        "linevul": 5.261819751467556e-05,
        "sysevr": 0.12728570401668549,
        "devign": 0.32382437586784363
    },
    {
        "code": "int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock(&bus->mdio_lock);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb",
        "vul_func_with_fix": "int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tBUG_ON(in_interrupt());\n\n\tmutex_lock(&bus->mdio_lock);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\n",
        "linevul": 4.931944204145111e-05,
        "sysevr": 0.15264274179935455,
        "devign": 5.49942888028454e-06
    },
    {
        "code": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7",
        "vul_func_with_fix": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}\n",
        "linevul": 7.125112460926175e-05,
        "sysevr": 0.20591191947460175,
        "devign": 1.2746277282628924e-20
    },
    {
        "code": "long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t struct page **pages, struct vm_area_struct **vmas,\n\t\t\t unsigned long *position, unsigned long *nr_pages,\n\t\t\t long i, unsigned int flags, int *nonblocking)\n{\n\tunsigned long pfn_offset;\n\tunsigned long vaddr = *position;\n\tunsigned long remainder = *nr_pages;\n\tstruct hstate *h = hstate_vma(vma);\n\tint err = -EFAULT;\n\n\twhile (vaddr < vma->vm_end && remainder) {\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl = NULL;\n\t\tint absent;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some archs (sparc64, sh*) have multiple pte_ts to\n\t\t * each hugepage.  We have to make sure we get the\n\t\t * first, for the page indexing below to work.\n\t\t *\n\t\t * Note that page table lock is not held when pte is null.\n\t\t */\n\t\tpte = huge_pte_offset(mm, vaddr & huge_page_mask(h),\n\t\t\t\t      huge_page_size(h));\n\t\tif (pte)\n\t\t\tptl = huge_pte_lock(h, mm, pte);\n\t\tabsent = !pte || huge_pte_none(huge_ptep_get(pte));\n\n\t\t/*\n\t\t * When coredumping, it suits get_dump_page if we just return\n\t\t * an error where there's an empty slot with no huge pagecache\n\t\t * to back it.  This way, we avoid allocating a hugepage, and\n\t\t * the sparse dumpfile avoids allocating disk blocks, but its\n\t\t * huge holes still show up with zeroes where they need to be.\n\t\t */\n\t\tif (absent && (flags & FOLL_DUMP) &&\n\t\t    !hugetlbfs_pagecache_present(h, vma, vaddr)) {\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need call hugetlb_fault for both hugepages under migration\n\t\t * (in which case hugetlb_fault waits for the migration,) and\n\t\t * hwpoisoned hugepages (in which case we need to prevent the\n\t\t * caller from accessing to them.) In order to do this, we use\n\t\t * here is_swap_pte instead of is_hugetlb_entry_migration and\n\t\t * is_hugetlb_entry_hwpoisoned. This is because it simply covers\n\t\t * both cases, and because we can't follow correct pages\n\t\t * directly from any kind of swap entries.\n\t\t */\n\t\tif (absent || is_swap_pte(huge_ptep_get(pte)) ||\n\t\t    ((flags & FOLL_WRITE) &&\n\t\t      !huge_pte_write(huge_ptep_get(pte)))) {\n\t\t\tint ret;\n\t\t\tunsigned int fault_flags = 0;\n\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tif (flags & FOLL_WRITE)\n\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\tif (nonblocking)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\tif (flags & FOLL_NOWAIT)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY |\n\t\t\t\t\tFAULT_FLAG_RETRY_NOWAIT;\n\t\t\tif (flags & FOLL_TRIED) {\n\t\t\t\tVM_WARN_ON_ONCE(fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY);\n\t\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\t}\n\t\t\tret = hugetlb_fault(mm, vma, vaddr, fault_flags);\n\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\terr = vm_fault_to_errno(ret, flags);\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\tif (nonblocking)\n\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t*nr_pages = 0;\n\t\t\t\t/*\n\t\t\t\t * VM_FAULT_RETRY must not return an\n\t\t\t\t * error, it will return zero\n\t\t\t\t * instead.\n\t\t\t\t *\n\t\t\t\t * No need to update \"position\" as the\n\t\t\t\t * caller will not check it after\n\t\t\t\t * *nr_pages is set to 0.\n\t\t\t\t */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;\n\t\tpage = pte_page(huge_ptep_get(pte));\nsame_page:\n\t\tif (pages) {\n\t\t\tpages[i] = mem_map_offset(page, pfn_offset);\n\t\t\tget_page(pages[i]);\n\t\t}\n\n\t\tif (vmas)\n\t\t\tvmas[i] = vma;\n\n\t\tvaddr += PAGE_SIZE;\n\t\t++pfn_offset;\n\t\t--remainder;\n\t\t++i;\n\t\tif (vaddr < vma->vm_end && remainder &&\n\t\t\t\tpfn_offset < pages_per_huge_page(h)) {\n\t\t\t/*\n\t\t\t * We use pfn_offset to avoid touching the pageframes\n\t\t\t * of this compound page.\n\t\t\t */\n\t\t\tgoto same_page;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t*nr_pages = remainder;\n\t/*\n\t * setting position is actually required only if remainder is\n\t * not zero but it's faster not to add a \"if (remainder)\"\n\t * branch.\n\t */\n\t*position = vaddr;\n\n\treturn i ? i : err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/1e3921471354244f70fe268586ff94a97a6dd4df",
        "vul_func_with_fix": "long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t struct page **pages, struct vm_area_struct **vmas,\n\t\t\t unsigned long *position, unsigned long *nr_pages,\n\t\t\t long i, unsigned int flags, int *nonblocking)\n{\n\tunsigned long pfn_offset;\n\tunsigned long vaddr = *position;\n\tunsigned long remainder = *nr_pages;\n\tstruct hstate *h = hstate_vma(vma);\n\tint err = -EFAULT;\n\n\twhile (vaddr < vma->vm_end && remainder) {\n\t\tpte_t *pte;\n\t\tspinlock_t *ptl = NULL;\n\t\tint absent;\n\t\tstruct page *page;\n\n\t\t/*\n\t\t * If we have a pending SIGKILL, don't keep faulting pages and\n\t\t * potentially allocating memory.\n\t\t */\n\t\tif (unlikely(fatal_signal_pending(current))) {\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Some archs (sparc64, sh*) have multiple pte_ts to\n\t\t * each hugepage.  We have to make sure we get the\n\t\t * first, for the page indexing below to work.\n\t\t *\n\t\t * Note that page table lock is not held when pte is null.\n\t\t */\n\t\tpte = huge_pte_offset(mm, vaddr & huge_page_mask(h),\n\t\t\t\t      huge_page_size(h));\n\t\tif (pte)\n\t\t\tptl = huge_pte_lock(h, mm, pte);\n\t\tabsent = !pte || huge_pte_none(huge_ptep_get(pte));\n\n\t\t/*\n\t\t * When coredumping, it suits get_dump_page if we just return\n\t\t * an error where there's an empty slot with no huge pagecache\n\t\t * to back it.  This way, we avoid allocating a hugepage, and\n\t\t * the sparse dumpfile avoids allocating disk blocks, but its\n\t\t * huge holes still show up with zeroes where they need to be.\n\t\t */\n\t\tif (absent && (flags & FOLL_DUMP) &&\n\t\t    !hugetlbfs_pagecache_present(h, vma, vaddr)) {\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tremainder = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need call hugetlb_fault for both hugepages under migration\n\t\t * (in which case hugetlb_fault waits for the migration,) and\n\t\t * hwpoisoned hugepages (in which case we need to prevent the\n\t\t * caller from accessing to them.) In order to do this, we use\n\t\t * here is_swap_pte instead of is_hugetlb_entry_migration and\n\t\t * is_hugetlb_entry_hwpoisoned. This is because it simply covers\n\t\t * both cases, and because we can't follow correct pages\n\t\t * directly from any kind of swap entries.\n\t\t */\n\t\tif (absent || is_swap_pte(huge_ptep_get(pte)) ||\n\t\t    ((flags & FOLL_WRITE) &&\n\t\t      !huge_pte_write(huge_ptep_get(pte)))) {\n\t\t\tint ret;\n\t\t\tunsigned int fault_flags = 0;\n\n\t\t\tif (pte)\n\t\t\t\tspin_unlock(ptl);\n\t\t\tif (flags & FOLL_WRITE)\n\t\t\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t\t\tif (nonblocking)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\t\t\tif (flags & FOLL_NOWAIT)\n\t\t\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY |\n\t\t\t\t\tFAULT_FLAG_RETRY_NOWAIT;\n\t\t\tif (flags & FOLL_TRIED) {\n\t\t\t\tVM_WARN_ON_ONCE(fault_flags &\n\t\t\t\t\t\tFAULT_FLAG_ALLOW_RETRY);\n\t\t\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t\t\t}\n\t\t\tret = hugetlb_fault(mm, vma, vaddr, fault_flags);\n\t\t\tif (ret & VM_FAULT_ERROR) {\n\t\t\t\terr = vm_fault_to_errno(ret, flags);\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret & VM_FAULT_RETRY) {\n\t\t\t\tif (nonblocking)\n\t\t\t\t\t*nonblocking = 0;\n\t\t\t\t*nr_pages = 0;\n\t\t\t\t/*\n\t\t\t\t * VM_FAULT_RETRY must not return an\n\t\t\t\t * error, it will return zero\n\t\t\t\t * instead.\n\t\t\t\t *\n\t\t\t\t * No need to update \"position\" as the\n\t\t\t\t * caller will not check it after\n\t\t\t\t * *nr_pages is set to 0.\n\t\t\t\t */\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tpfn_offset = (vaddr & ~huge_page_mask(h)) >> PAGE_SHIFT;\n\t\tpage = pte_page(huge_ptep_get(pte));\nsame_page:\n\t\tif (pages) {\n\t\t\tpages[i] = mem_map_offset(page, pfn_offset);\n\t\t\tget_page(pages[i]);\n\t\t}\n\n\t\tif (vmas)\n\t\t\tvmas[i] = vma;\n\n\t\tvaddr += PAGE_SIZE;\n\t\t++pfn_offset;\n\t\t--remainder;\n\t\t++i;\n\t\tif (vaddr < vma->vm_end && remainder &&\n\t\t\t\tpfn_offset < pages_per_huge_page(h)) {\n\t\t\t/*\n\t\t\t * We use pfn_offset to avoid touching the pageframes\n\t\t\t * of this compound page.\n\t\t\t */\n\t\t\tgoto same_page;\n\t\t}\n\t\tspin_unlock(ptl);\n\t}\n\t*nr_pages = remainder;\n\t/*\n\t * setting position is actually required only if remainder is\n\t * not zero but it's faster not to add a \"if (remainder)\"\n\t * branch.\n\t */\n\t*position = vaddr;\n\n\treturn i ? i : err;\n}\n",
        "linevul": 0.004075073637068272,
        "sysevr": 0.3423452079296112,
        "devign": 0.0
    },
    {
        "code": "static int rmap_walk_file(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct address_space *mapping = page->mapping;\n\tpgoff_t pgoff = page->index << compound_order(page);\n\tstruct vm_area_struct *vma;\n\tint ret = SWAP_AGAIN;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_mutex.\n\t */\n\tVM_BUG_ON(!PageLocked(page));\n\n\tif (!mapping)\n\t\treturn ret;\n\tmutex_lock(&mapping->i_mmap_mutex);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tret = rwc->rmap_one(page, vma, address, rwc->arg);\n\t\tif (ret != SWAP_AGAIN)\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\n\tif (!rwc->file_nonlinear)\n\t\tgoto done;\n\n\tif (list_empty(&mapping->i_mmap_nonlinear))\n\t\tgoto done;\n\n\tret = rwc->file_nonlinear(page, mapping, rwc->arg);\n\ndone:\n\tmutex_unlock(&mapping->i_mmap_mutex);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/57e68e9cd65b4b8eb4045a1e0d0746458502554c",
        "vul_func_with_fix": "static int rmap_walk_file(struct page *page, struct rmap_walk_control *rwc)\n{\n\tstruct address_space *mapping = page->mapping;\n\tpgoff_t pgoff = page->index << compound_order(page);\n\tstruct vm_area_struct *vma;\n\tint ret = SWAP_AGAIN;\n\n\t/*\n\t * The page lock not only makes sure that page->mapping cannot\n\t * suddenly be NULLified by truncation, it makes sure that the\n\t * structure at mapping cannot be freed and reused yet,\n\t * so we can safely take mapping->i_mmap_mutex.\n\t */\n\tVM_BUG_ON(!PageLocked(page));\n\n\tif (!mapping)\n\t\treturn ret;\n\tmutex_lock(&mapping->i_mmap_mutex);\n\tvma_interval_tree_foreach(vma, &mapping->i_mmap, pgoff, pgoff) {\n\t\tunsigned long address = vma_address(page, vma);\n\n\t\tif (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))\n\t\t\tcontinue;\n\n\t\tret = rwc->rmap_one(page, vma, address, rwc->arg);\n\t\tif (ret != SWAP_AGAIN)\n\t\t\tgoto done;\n\t\tif (rwc->done && rwc->done(page))\n\t\t\tgoto done;\n\t}\n\n\tif (!rwc->file_nonlinear)\n\t\tgoto done;\n\n\tif (list_empty(&mapping->i_mmap_nonlinear))\n\t\tgoto done;\n\n\tret = rwc->file_nonlinear(page, mapping, rwc->arg);\n\ndone:\n\tmutex_unlock(&mapping->i_mmap_mutex);\n\treturn ret;\n}\n",
        "linevul": 0.0002727754763327539,
        "sysevr": 0.15333040058612823,
        "devign": 4.330955973517899e-18
    },
    {
        "code": "static inline int msg_security(struct kern_ipc_perm *ipcp, int msgflg)\n{\n\tstruct msg_queue *msq = container_of(ipcp, struct msg_queue, q_perm);\n\n\treturn security_msg_queue_associate(msq, msgflg);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6062a8dc0517bce23e3c2f7d2fea5e22411269a3",
        "vul_func_with_fix": "static inline int msg_security(struct kern_ipc_perm *ipcp, int msgflg)\n{\n\tstruct msg_queue *msq = container_of(ipcp, struct msg_queue, q_perm);\n\n\treturn security_msg_queue_associate(msq, msgflg);\n}\n",
        "linevul": 5.182717359275557e-05,
        "sysevr": 0.1262240707874298,
        "devign": 0.05746733024716377
    },
    {
        "code": "static bool quickly_check_mmio_pf(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfd0a56b90005f8c8a004baf407ad90045c2b11e",
        "vul_func_with_fix": "static bool quickly_check_mmio_pf(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}\n",
        "linevul": 4.983685721526854e-05,
        "sysevr": 0.12680338323116302,
        "devign": 7.48058163807172e-14
    },
    {
        "code": "static inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a",
        "vul_func_with_fix": "static inline bool file_mmap_ok(struct file *file, struct inode *inode,\n\t\t\t\tunsigned long pgoff, unsigned long len)\n{\n\tu64 maxsize = file_mmap_size_max(file, inode);\n\n\tif (maxsize && len > maxsize)\n\t\treturn false;\n\tmaxsize -= len;\n\tif (pgoff > maxsize >> PAGE_SHIFT)\n\t\treturn false;\n\treturn true;\n}\n",
        "linevul": 0.000241379821090959,
        "sysevr": 0.12371818721294403,
        "devign": 6.326990685365821e-17
    },
    {
        "code": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214",
        "vul_func_with_fix": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n//flaw_line_below:\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n//fix_flaw_line_below:\n//\tif (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n",
        "linevul": 0.997975766658783,
        "sysevr": 0.1278962343931198,
        "devign": 0.9966768026351929
    },
    {
        "code": "static int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\t/* Ensure arg.off fits in an unsigned long */\n\tif (arg.off > ULONG_MAX)\n\t\treturn 0;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\tunsigned long off = arg.off + i;\n\t\tbool found = false;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tfound = true;\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (!found) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee",
        "vul_func_with_fix": "static int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\t/* Ensure arg.off fits in an unsigned long */\n\tif (arg.off > ULONG_MAX)\n\t\treturn 0;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\tunsigned long off = arg.off + i;\n\t\tbool found = false;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tfound = true;\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (!found) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}\n",
        "linevul": 6.378722173394635e-05,
        "sysevr": 0.15119346976280212,
        "devign": 3.206293468616849e-22
    },
    {
        "code": "static int nfc_genl_dev_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_up(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/385097a3675749cbc9e97c085c0e5dfe4269ca51",
        "vul_func_with_fix": "static int nfc_genl_dev_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_up(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n",
        "linevul": 4.672681825468317e-05,
        "sysevr": 0.12641239166259766,
        "devign": 9.80896458496632e-26
    },
    {
        "code": "static void usbhid_set_leds(struct hid_device *hid)\n{\n\tstruct hid_field *field;\n\tint offset;\n\n\tif ((offset = hid_find_field_early(hid, HID_UP_LED, 0x01, &field)) != -1) {\n\t\thid_set_field(field, offset, 0);\n\t\tusbhid_submit_report(hid, field->report, USB_DIR_OUT);\n\t}\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f043bfc98c193c284e2cd768fefabe18ac2fed9b",
        "vul_func_with_fix": "static void usbhid_set_leds(struct hid_device *hid)\n{\n\tstruct hid_field *field;\n\tint offset;\n\n\tif ((offset = hid_find_field_early(hid, HID_UP_LED, 0x01, &field)) != -1) {\n\t\thid_set_field(field, offset, 0);\n\t\tusbhid_submit_report(hid, field->report, USB_DIR_OUT);\n\t}\n}\n",
        "linevul": 0.00022866400831844658,
        "sysevr": 0.1293308138847351,
        "devign": 2.2217681916458787e-08
    },
    {
        "code": "static struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,\n\t\t\t\t\t   struct page *page,\n\t\t\t\t\t   struct rmap_item *tree_rmap_item,\n\t\t\t\t\t   struct page *tree_page)\n{\n\tint err;\n\n\terr = try_to_merge_with_ksm_page(rmap_item, page, NULL);\n\tif (!err) {\n\t\terr = try_to_merge_with_ksm_page(tree_rmap_item,\n\t\t\t\t\t\t\ttree_page, page);\n\t\t/*\n\t\t * If that fails, we have a ksm page with only one pte\n\t\t * pointing to it: so break it.\n\t\t */\n\t\tif (err)\n\t\t\tbreak_cow(rmap_item);\n\t}\n\treturn err ? NULL : page;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/2b472611a32a72f4a118c069c2d62a1a3f087afd",
        "vul_func_with_fix": "static struct page *try_to_merge_two_pages(struct rmap_item *rmap_item,\n\t\t\t\t\t   struct page *page,\n\t\t\t\t\t   struct rmap_item *tree_rmap_item,\n\t\t\t\t\t   struct page *tree_page)\n{\n\tint err;\n\n\terr = try_to_merge_with_ksm_page(rmap_item, page, NULL);\n\tif (!err) {\n\t\terr = try_to_merge_with_ksm_page(tree_rmap_item,\n\t\t\t\t\t\t\ttree_page, page);\n\t\t/*\n\t\t * If that fails, we have a ksm page with only one pte\n\t\t * pointing to it: so break it.\n\t\t */\n\t\tif (err)\n\t\t\tbreak_cow(rmap_item);\n\t}\n\treturn err ? NULL : page;\n}\n",
        "linevul": 6.441628647735342e-05,
        "sysevr": 0.13525162637233734,
        "devign": 1.1818420570297674e-26
    },
    {
        "code": "static void __vcc_insert_socket(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\tstruct hlist_head *head = &vcc_hash[vcc->vci & (VCC_HTABLE_SIZE - 1)];\n\tsk->sk_hash = vcc->vci & (VCC_HTABLE_SIZE - 1);\n\tsk_add_node(sk, head);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/9b3e617f3df53822345a8573b6d358f6b9e5ed87",
        "vul_func_with_fix": "static void __vcc_insert_socket(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\tstruct hlist_head *head = &vcc_hash[vcc->vci & (VCC_HTABLE_SIZE - 1)];\n\tsk->sk_hash = vcc->vci & (VCC_HTABLE_SIZE - 1);\n\tsk_add_node(sk, head);\n}\n",
        "linevul": 5.4534593800781295e-05,
        "sysevr": 0.12399513274431229,
        "devign": 4.5388920486694184e-13
    },
    {
        "code": "static int addrconf_sysctl_register(struct inet6_dev *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->nd_parms,\n\t\t\t\t    &ndisc_ifinfo_sysctl_change);\n\tif (err)\n\t\treturn err;\n\terr = __addrconf_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\t idev, &idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->nd_parms);\n\n\treturn err;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77751427a1ff25b27d47a4c36b12c3c8667855ac",
        "vul_func_with_fix": "static int addrconf_sysctl_register(struct inet6_dev *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->nd_parms,\n\t\t\t\t    &ndisc_ifinfo_sysctl_change);\n\tif (err)\n\t\treturn err;\n\terr = __addrconf_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\t idev, &idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->nd_parms);\n\n\treturn err;\n}\n",
        "linevul": 4.7154215280897915e-05,
        "sysevr": 0.1297854483127594,
        "devign": 3.2449093325531697e-12
    },
    {
        "code": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d",
        "vul_func_with_fix": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n//fix_flaw_line_below:\n//\t\tspin_lock_irq(&slave_active_lock);\n//fix_flaw_line_below:\n//\t\tspin_lock(&timer->lock);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n//flaw_line_below:\n\t\t\tspin_lock_irq(&slave_active_lock);\n//flaw_line_below:\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n//flaw_line_below:\n\t\t\tspin_unlock_irq(&slave_active_lock);\n//fix_flaw_line_below:\n//\t\t\tlist_del_init(&slave->ack_list);\n//fix_flaw_line_below:\n//\t\t\tlist_del_init(&slave->active_list);\n \t\t}\n//fix_flaw_line_below:\n//\t\tspin_unlock(&timer->lock);\n//fix_flaw_line_below:\n//\t\tspin_unlock_irq(&slave_active_lock);\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n",
        "linevul": 8.745678496779874e-05,
        "sysevr": 0.1582091897726059,
        "devign": 0.9873932600021362
    },
    {
        "code": "static int ip_vs_rs_hash(struct ip_vs_dest *dest)\n{\n\tunsigned hash;\n\n\tif (!list_empty(&dest->d_list)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tHash by proto,addr,port,\n\t *\twhich are the parameters of the real service.\n\t */\n\thash = ip_vs_rs_hashkey(dest->af, &dest->addr, dest->port);\n\n\tlist_add(&dest->d_list, &ip_vs_rtable[hash]);\n\n\treturn 1;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/04bcef2a83f40c6db24222b27a52892cba39dffb",
        "vul_func_with_fix": "static int ip_vs_rs_hash(struct ip_vs_dest *dest)\n{\n\tunsigned hash;\n\n\tif (!list_empty(&dest->d_list)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tHash by proto,addr,port,\n\t *\twhich are the parameters of the real service.\n\t */\n\thash = ip_vs_rs_hashkey(dest->af, &dest->addr, dest->port);\n\n\tlist_add(&dest->d_list, &ip_vs_rtable[hash]);\n\n\treturn 1;\n}\n",
        "linevul": 5.362125739338808e-05,
        "sysevr": 0.143570214509964,
        "devign": 0.9892215728759766
    },
    {
        "code": "static int sctp_getsockopt_pr_streamstatus(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_stream_out *streamout;\n\tstruct sctp_association *asoc;\n\tstruct sctp_prstatus params;\n\tint retval = -EINVAL;\n\tint policy;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc || params.sprstat_sid >= asoc->stream.outcnt)\n\t\tgoto out;\n\n\tstreamout = &asoc->stream.out[params.sprstat_sid];\n\tif (policy == SCTP_PR_SCTP_NONE) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tstreamout->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tstreamout->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tstreamout->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tstreamout->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "vul_func_with_fix": "static int sctp_getsockopt_pr_streamstatus(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_stream_out *streamout;\n\tstruct sctp_association *asoc;\n\tstruct sctp_prstatus params;\n\tint retval = -EINVAL;\n\tint policy;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc || params.sprstat_sid >= asoc->stream.outcnt)\n\t\tgoto out;\n\n\tstreamout = &asoc->stream.out[params.sprstat_sid];\n\tif (policy == SCTP_PR_SCTP_NONE) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tstreamout->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tstreamout->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tstreamout->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tstreamout->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n",
        "linevul": 4.9881178711075336e-05,
        "sysevr": 0.13772261142730713,
        "devign": 0.6438871622085571
    },
    {
        "code": "static void print_func_help_header_irq(struct trace_buffer *buf, struct seq_file *m,\n\t\t\t\t       unsigned int flags)\n{\n\tbool tgid = flags & TRACE_ITER_RECORD_TGID;\n\tconst char tgid_space[] = \"          \";\n\tconst char space[] = \"  \";\n\n\tseq_printf(m, \"#                          %s  _-----=> irqs-off\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s / _----=> need-resched\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s| / _---=> hardirq/softirq\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s|| / _--=> preempt-depth\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s||| /     delay\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#           TASK-PID   CPU#%s||||    TIMESTAMP  FUNCTION\\n\",\n\t\t   tgid ? \"   TGID   \" : space);\n\tseq_printf(m, \"#              | |       | %s||||       |         |\\n\",\n\t\t   tgid ? \"     |    \" : space);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03",
        "vul_func_with_fix": "static void print_func_help_header_irq(struct trace_buffer *buf, struct seq_file *m,\n\t\t\t\t       unsigned int flags)\n{\n\tbool tgid = flags & TRACE_ITER_RECORD_TGID;\n\tconst char tgid_space[] = \"          \";\n\tconst char space[] = \"  \";\n\n\tseq_printf(m, \"#                          %s  _-----=> irqs-off\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s / _----=> need-resched\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s| / _---=> hardirq/softirq\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s|| / _--=> preempt-depth\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#                          %s||| /     delay\\n\",\n\t\t   tgid ? tgid_space : space);\n\tseq_printf(m, \"#           TASK-PID   CPU#%s||||    TIMESTAMP  FUNCTION\\n\",\n\t\t   tgid ? \"   TGID   \" : space);\n\tseq_printf(m, \"#              | |       | %s||||       |         |\\n\",\n\t\t   tgid ? \"     |    \" : space);\n}\n",
        "linevul": 5.055593283032067e-05,
        "sysevr": 0.16217194497585297,
        "devign": 2.395262002860576e-16
    },
    {
        "code": "static int __init sock_init(void)\n{\n\tint err;\n\t/*\n\t *      Initialize the network sysctl infrastructure.\n\t */\n\terr = net_sysctl_init();\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t *      Initialize sock SLAB cache.\n\t */\n\n\tsk_init();\n\n\t/*\n\t *      Initialize skbuff SLAB cache\n\t */\n\tskb_init();\n\n\t/*\n\t *      Initialize the protocols module.\n\t */\n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out_fs;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t/* The real protocol initialization is performed in later initcalls.\n\t */\n\n#ifdef CONFIG_NETFILTER\n\tnetfilter_init();\n#endif\n\n#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING\n\tskb_timestamping_init();\n#endif\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\nout_fs:\n\tgoto out;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d",
        "vul_func_with_fix": "static int __init sock_init(void)\n{\n\tint err;\n\t/*\n\t *      Initialize the network sysctl infrastructure.\n\t */\n\terr = net_sysctl_init();\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t *      Initialize sock SLAB cache.\n\t */\n\n\tsk_init();\n\n\t/*\n\t *      Initialize skbuff SLAB cache\n\t */\n\tskb_init();\n\n\t/*\n\t *      Initialize the protocols module.\n\t */\n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out_fs;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t/* The real protocol initialization is performed in later initcalls.\n\t */\n\n#ifdef CONFIG_NETFILTER\n\tnetfilter_init();\n#endif\n\n#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING\n\tskb_timestamping_init();\n#endif\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\nout_fs:\n\tgoto out;\n}\n",
        "linevul": 9.97988972812891e-05,
        "sysevr": 0.13102732598781586,
        "devign": 0.6748522520065308
    },
    {
        "code": "static void x25_insert_socket(struct sock *sk)\n{\n\twrite_lock_bh(&x25_list_lock);\n\tsk_add_node(sk, &x25_list);\n\twrite_unlock_bh(&x25_list_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
        "vul_func_with_fix": "static void x25_insert_socket(struct sock *sk)\n{\n\twrite_lock_bh(&x25_list_lock);\n\tsk_add_node(sk, &x25_list);\n\twrite_unlock_bh(&x25_list_lock);\n}\n",
        "linevul": 6.247228884603828e-05,
        "sysevr": 0.1243499368429184,
        "devign": 0.026640301570296288
    },
    {
        "code": "static int btrfs_readpage_end_io_hook(struct btrfs_io_bio *io_bio,\n\t\t\t\t      u64 phy_offset, struct page *page,\n\t\t\t\t      u64 start, u64 end, int mirror)\n{\n\tsize_t offset = start - page_offset(page);\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\treturn 0;\n\n\tif (root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID &&\n\t    test_range_bit(io_tree, start, end, EXTENT_NODATASUM, 1, NULL)) {\n\t\tclear_extent_bits(io_tree, start, end, EXTENT_NODATASUM,\n\t\t\t\t  GFP_NOFS);\n\t\treturn 0;\n\t}\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\treturn __readpage_endio_check(inode, io_bio, phy_offset, page, offset,\n\t\t\t\t      start, (size_t)(end - start + 1));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7",
        "vul_func_with_fix": "static int btrfs_readpage_end_io_hook(struct btrfs_io_bio *io_bio,\n\t\t\t\t      u64 phy_offset, struct page *page,\n\t\t\t\t      u64 start, u64 end, int mirror)\n{\n\tsize_t offset = start - page_offset(page);\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tif (PageChecked(page)) {\n\t\tClearPageChecked(page);\n\t\treturn 0;\n\t}\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\treturn 0;\n\n\tif (root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID &&\n\t    test_range_bit(io_tree, start, end, EXTENT_NODATASUM, 1, NULL)) {\n\t\tclear_extent_bits(io_tree, start, end, EXTENT_NODATASUM,\n\t\t\t\t  GFP_NOFS);\n\t\treturn 0;\n\t}\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\treturn __readpage_endio_check(inode, io_bio, phy_offset, page, offset,\n\t\t\t\t      start, (size_t)(end - start + 1));\n}\n",
        "linevul": 0.00012361668632365763,
        "sysevr": 0.1641862988471985,
        "devign": 5.0054942829502735e-12
    },
    {
        "code": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (running)\n\t\tp->sched_class->set_curr_task(rq);\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask);\n\n\tif (running)\n\t\tp->sched_class->set_curr_task(rq);\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE);\n}\n",
        "linevul": 5.569223139900714e-05,
        "sysevr": 0.16827137768268585,
        "devign": 1.4237660431227226e-38
    },
    {
        "code": "static int rt_acct_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rt_acct_proc_show, NULL);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec",
        "vul_func_with_fix": "static int rt_acct_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rt_acct_proc_show, NULL);\n}\n",
        "linevul": 6.271032179938629e-05,
        "sysevr": 0.12799862027168274,
        "devign": 1.6468529793201014e-05
    },
    {
        "code": "static int nfs4_verify_back_channel_attrs(struct nfs41_create_session_args *args, struct nfs4_session *session)\n{\n\tstruct nfs4_channel_attrs *sent = &args->bc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &session->bc_attrs;\n\n\tif (rcvd->max_rqst_sz > sent->max_rqst_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz < sent->max_resp_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz_cached > sent->max_resp_sz_cached)\n\t\treturn -EINVAL;\n\t/* These would render the backchannel useless: */\n\tif (rcvd->max_ops  == 0)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int nfs4_verify_back_channel_attrs(struct nfs41_create_session_args *args, struct nfs4_session *session)\n{\n\tstruct nfs4_channel_attrs *sent = &args->bc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &session->bc_attrs;\n\n\tif (rcvd->max_rqst_sz > sent->max_rqst_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz < sent->max_resp_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz_cached > sent->max_resp_sz_cached)\n\t\treturn -EINVAL;\n\t/* These would render the backchannel useless: */\n\tif (rcvd->max_ops  == 0)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n",
        "linevul": 6.630313146160915e-05,
        "sysevr": 0.13624805212020874,
        "devign": 1.1240280407831538e-11
    },
    {
        "code": "int sctp_v6_add_protocol(void)\n{\n\t/* Register notifier for inet6 address additions/deletions. */\n\tregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n\n\tif (inet6_add_protocol(&sctpv6_protocol, IPPROTO_SCTP) < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/95ee62083cb6453e056562d91f597552021e6ae7",
        "vul_func_with_fix": "int sctp_v6_add_protocol(void)\n{\n\t/* Register notifier for inet6 address additions/deletions. */\n\tregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n\n\tif (inet6_add_protocol(&sctpv6_protocol, IPPROTO_SCTP) < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n",
        "linevul": 5.6985569244716316e-05,
        "sysevr": 0.1497684270143509,
        "devign": 2.9744694529654225e-06
    },
    {
        "code": "static void destroy_qp_user(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_qp *qp, struct mlx5_ib_qp_base *base)\n{\n\tstruct mlx5_ib_ucontext *context;\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tmlx5_ib_db_unmap_user(context, &qp->db);\n\tif (base->ubuffer.umem)\n\t\tib_umem_release(base->ubuffer.umem);\n\n\t/*\n\t * Free only the BFREGs which are handled by the kernel.\n\t * BFREGs of UARs allocated dynamically are handled by user.\n\t */\n\tif (qp->bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, qp->bfregn);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0625b4ba1a5d4703c7fb01c497bd6c156908af00",
        "vul_func_with_fix": "static void destroy_qp_user(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_qp *qp, struct mlx5_ib_qp_base *base)\n{\n\tstruct mlx5_ib_ucontext *context;\n\n\tcontext = to_mucontext(pd->uobject->context);\n\tmlx5_ib_db_unmap_user(context, &qp->db);\n\tif (base->ubuffer.umem)\n\t\tib_umem_release(base->ubuffer.umem);\n\n\t/*\n\t * Free only the BFREGs which are handled by the kernel.\n\t * BFREGs of UARs allocated dynamically are handled by user.\n\t */\n\tif (qp->bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, qp->bfregn);\n}\n",
        "linevul": 4.6460303565254435e-05,
        "sysevr": 0.16430748999118805,
        "devign": 3.830130879123317e-08
    },
    {
        "code": "static int perf_tp_filter_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data)\n{\n\tvoid *record = data->raw->data;\n\n\tif (likely(!event->filter) || filter_match_preds(event->filter, record))\n\t\treturn 1;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int perf_tp_filter_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data)\n{\n\tvoid *record = data->raw->data;\n\n\tif (likely(!event->filter) || filter_match_preds(event->filter, record))\n\t\treturn 1;\n\treturn 0;\n}\n",
        "linevul": 4.886793976766057e-05,
        "sysevr": 0.13148492574691772,
        "devign": 0.01544107124209404
    },
    {
        "code": "static struct xt_counters *alloc_counters(const struct xt_table *table)\n{\n\tunsigned int countersize;\n\tstruct xt_counters *counters;\n\tconst struct xt_table_info *private = table->private;\n\n\t/* We need atomic snapshot of counters: rest doesn't change\n\t   (other than comefrom, which userspace doesn't care\n\t   about). */\n\tcountersize = sizeof(struct xt_counters) * private->number;\n\tcounters = vzalloc(countersize);\n\n\tif (counters == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_counters(private, counters);\n\n\treturn counters;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91",
        "vul_func_with_fix": "static struct xt_counters *alloc_counters(const struct xt_table *table)\n{\n\tunsigned int countersize;\n\tstruct xt_counters *counters;\n\tconst struct xt_table_info *private = table->private;\n\n\t/* We need atomic snapshot of counters: rest doesn't change\n\t   (other than comefrom, which userspace doesn't care\n\t   about). */\n\tcountersize = sizeof(struct xt_counters) * private->number;\n\tcounters = vzalloc(countersize);\n\n\tif (counters == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_counters(private, counters);\n\n\treturn counters;\n}\n",
        "linevul": 5.273232454783283e-05,
        "sysevr": 0.13431154191493988,
        "devign": 0.0014057764783501625
    },
    {
        "code": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n \tstruct timespec ts;\n \t__u32 ts_status;\n \tbool is_drop_n_account = false;\n \n \t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n \t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n \t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n \t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n \t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr)\n \t\t\tnetoff += sizeof(struct virtio_net_hdr);\n \t\tmacoff = netoff - maclen;\n \t}\n \tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n \t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n \t\t\t}\n \t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0)\n \t\t\t\tsnaplen = 0;\n \t\t}\n \t} else if (unlikely(macoff + snaplen >\n \t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n \t\tif (unlikely((int)snaplen < 0)) {\n \t\t\tsnaplen = 0;\n \t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n \t\t}\n \t}\n \tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n \t}\n \tspin_unlock(&sk->sk_receive_queue.lock);\n \n\tif (po->has_vnet_hdr) {\n \t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n \t\t\t\t\t    sizeof(struct virtio_net_hdr),\n \t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/edbd58be15a957f6a760c4a514cd475217eb97fd",
        "vul_func_with_fix": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n \tstruct timespec ts;\n \t__u32 ts_status;\n \tbool is_drop_n_account = false;\n//fix_flaw_line_below:\n//\tbool do_vnet = false;\n \n \t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n \t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n \t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n \t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n \t\t\t\t       po->tp_reserve;\n//flaw_line_below:\n\t\tif (po->has_vnet_hdr)\n//fix_flaw_line_below:\n//\t\tif (po->has_vnet_hdr) {\n \t\t\tnetoff += sizeof(struct virtio_net_hdr);\n//fix_flaw_line_below:\n//\t\t\tdo_vnet = true;\n//fix_flaw_line_below:\n//\t\t}\n \t\tmacoff = netoff - maclen;\n \t}\n \tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n \t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n \t\t\t}\n \t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n//flaw_line_below:\n\t\t\tif ((int)snaplen < 0)\n//fix_flaw_line_below:\n//\t\t\tif ((int)snaplen < 0) {\n \t\t\t\tsnaplen = 0;\n//fix_flaw_line_below:\n//\t\t\t\tdo_vnet = false;\n//fix_flaw_line_below:\n//\t\t\t}\n \t\t}\n \t} else if (unlikely(macoff + snaplen >\n \t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n \t\tif (unlikely((int)snaplen < 0)) {\n \t\t\tsnaplen = 0;\n \t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n//fix_flaw_line_below:\n//\t\t\tdo_vnet = false;\n \t\t}\n \t}\n \tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (po->stats.stats1.tp_drops)\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n \t}\n \tspin_unlock(&sk->sk_receive_queue.lock);\n \n//flaw_line_below:\n\tif (po->has_vnet_hdr) {\n//fix_flaw_line_below:\n//\tif (do_vnet) {\n \t\tif (virtio_net_hdr_from_skb(skb, h.raw + macoff -\n \t\t\t\t\t    sizeof(struct virtio_net_hdr),\n \t\t\t\t\t    vio_le(), true)) {\n\t\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t\tgoto drop_n_account;\n\t\t}\n\t}\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tgetnstimeofday(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\t__packet_set_status(po, h.raw, status);\n\t\tsk->sk_data_ready(sk);\n\t} else {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tis_drop_n_account = true;\n\tpo->stats.stats1.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}\n",
        "linevul": 0.9995332956314087,
        "sysevr": 0.2578929364681244,
        "devign": 0.9901089668273926
    },
    {
        "code": "void __init inode_init_early(void)\n{\n\tunsigned int loop;\n\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1U << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03",
        "vul_func_with_fix": "void __init inode_init_early(void)\n{\n\tunsigned int loop;\n\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\n\tfor (loop = 0; loop < (1U << i_hash_shift); loop++)\n\t\tINIT_HLIST_HEAD(&inode_hashtable[loop]);\n}\n",
        "linevul": 6.107882654760033e-05,
        "sysevr": 0.14975956082344055,
        "devign": 0.681026041507721
    },
    {
        "code": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1",
        "vul_func_with_fix": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}\n",
        "linevul": 5.103621515445411e-05,
        "sysevr": 0.12428689748048782,
        "devign": 2.243852483376288e-13
    },
    {
        "code": "static void fwnet_header_cache_update(struct hh_cache *hh,\n\t\tconst struct net_device *net, const unsigned char *haddr)\n{\n\tmemcpy((u8 *)hh->hh_data + HH_DATA_OFF(FWNET_HLEN), haddr, net->addr_len);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac",
        "vul_func_with_fix": "static void fwnet_header_cache_update(struct hh_cache *hh,\n\t\tconst struct net_device *net, const unsigned char *haddr)\n{\n\tmemcpy((u8 *)hh->hh_data + HH_DATA_OFF(FWNET_HLEN), haddr, net->addr_len);\n}\n",
        "linevul": 5.086396777187474e-05,
        "sysevr": 0.12738585472106934,
        "devign": 1.0809878148165808e-07
    },
    {
        "code": "support_nvme_encapsulation_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_nvme_encapsulation);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "vul_func_with_fix": "support_nvme_encapsulation_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_nvme_encapsulation);\n}\n",
        "linevul": 7.056198955979198e-05,
        "sysevr": 0.16357071697711945,
        "devign": 0.00020907535508740693
    },
    {
        "code": "static int ati_remote2_resume(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (ar2->flags & ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tif (!r)\n\t\tar2->flags &= ~ATI_REMOTE2_SUSPENDED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d",
        "vul_func_with_fix": "static int ati_remote2_resume(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (ar2->flags & ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tif (!r)\n\t\tar2->flags &= ~ATI_REMOTE2_SUSPENDED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}\n",
        "linevul": 4.578315929393284e-05,
        "sysevr": 0.12356191873550415,
        "devign": 1.8049423067267867e-11
    },
    {
        "code": "static u64 efx_get_atomic_stat(void *field)\n{\n\treturn atomic_read((atomic_t *) field);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c",
        "vul_func_with_fix": "static u64 efx_get_atomic_stat(void *field)\n{\n\treturn atomic_read((atomic_t *) field);\n}\n",
        "linevul": 4.94417836307548e-05,
        "sysevr": 0.13372863829135895,
        "devign": 1.0049300271930406e-06
    },
    {
        "code": "static ssize_t f_midi_opts_id_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint ret;\n\tchar *c;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc = kstrndup(page, len, GFP_KERNEL);\n\tif (!c) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\topts->id = c;\n\topts->id_allocated = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f",
        "vul_func_with_fix": "static ssize_t f_midi_opts_id_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint ret;\n\tchar *c;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc = kstrndup(page, len, GFP_KERNEL);\n\tif (!c) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\topts->id = c;\n\topts->id_allocated = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n",
        "linevul": 0.00028882361948490143,
        "sysevr": 0.1381116807460785,
        "devign": 2.2457137196932667e-14
    },
    {
        "code": "static inline struct task_group *task_group(struct task_struct *p)\n{\n\tstruct task_group *tg;\n\tstruct cgroup_subsys_state *css;\n\n\tcss = task_subsys_state_check(p, cpu_cgroup_subsys_id,\n\t\t\tlockdep_is_held(&p->pi_lock) ||\n\t\t\tlockdep_is_held(&task_rq(p)->lock));\n\ttg = container_of(css, struct task_group, css);\n\n\treturn autogroup_task_group(p, tg);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static inline struct task_group *task_group(struct task_struct *p)\n{\n\tstruct task_group *tg;\n\tstruct cgroup_subsys_state *css;\n\n\tcss = task_subsys_state_check(p, cpu_cgroup_subsys_id,\n\t\t\tlockdep_is_held(&p->pi_lock) ||\n\t\t\tlockdep_is_held(&task_rq(p)->lock));\n\ttg = container_of(css, struct task_group, css);\n\n\treturn autogroup_task_group(p, tg);\n}\n",
        "linevul": 5.105037780595012e-05,
        "sysevr": 0.1247808188199997,
        "devign": 2.602163762244203e-10
    },
    {
        "code": "static ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", oo_objects(s->oo));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
        "vul_func_with_fix": "static ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", oo_objects(s->oo));\n}\n",
        "linevul": 9.015031537273899e-05,
        "sysevr": 0.12616269290447235,
        "devign": 6.959864240485558e-09
    },
    {
        "code": "static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t int *valp,\n\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\t*valp = *negp ? -*lvalp : *lvalp;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bfdc0b497faa82a0ba2f9dddcf109231dd519fcc",
        "vul_func_with_fix": "static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t int *valp,\n\t\t\t\t int write, void *data)\n{\n\tif (write) {\n\t\t*valp = *negp ? -*lvalp : *lvalp;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "linevul": 6.169141124701127e-05,
        "sysevr": 0.1259133219718933,
        "devign": 8.477190363009868e-07
    },
    {
        "code": "static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\n\tif (!((ifa->flags&IFA_F_PERMANENT) &&\n\t      (ifa->prefered_lft == INFINITY_LIFE_TIME))) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\n\t\t    nla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\n\t\t\tgoto error;\n\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\n\tif (nla_put_u32(skb, IFA_FLAGS, ifa->flags) < 0)\n\t\tgoto error;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/77751427a1ff25b27d47a4c36b12c3c8667855ac",
        "vul_func_with_fix": "static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\n\tif (!((ifa->flags&IFA_F_PERMANENT) &&\n\t      (ifa->prefered_lft == INFINITY_LIFE_TIME))) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\n\t\t    nla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\n\t\t\tgoto error;\n\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\n\tif (nla_put_u32(skb, IFA_FLAGS, ifa->flags) < 0)\n\t\tgoto error;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n",
        "linevul": 6.469304935308173e-05,
        "sysevr": 0.1783398538827896,
        "devign": 8.82019389030755e-15
    },
    {
        "code": "static int decode_attr_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\tuint32_t bmlen;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tbmlen = be32_to_cpup(p);\n\n\tbitmap[0] = bitmap[1] = bitmap[2] = 0;\n\tp = xdr_inline_decode(xdr, (bmlen << 2));\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tif (bmlen > 0) {\n\t\tbitmap[0] = be32_to_cpup(p++);\n\t\tif (bmlen > 1) {\n\t\t\tbitmap[1] = be32_to_cpup(p++);\n\t\t\tif (bmlen > 2)\n\t\t\t\tbitmap[2] = be32_to_cpup(p);\n\t\t}\n\t}\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int decode_attr_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\tuint32_t bmlen;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tbmlen = be32_to_cpup(p);\n\n\tbitmap[0] = bitmap[1] = bitmap[2] = 0;\n\tp = xdr_inline_decode(xdr, (bmlen << 2));\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tif (bmlen > 0) {\n\t\tbitmap[0] = be32_to_cpup(p++);\n\t\tif (bmlen > 1) {\n\t\t\tbitmap[1] = be32_to_cpup(p++);\n\t\t\tif (bmlen > 2)\n\t\t\t\tbitmap[2] = be32_to_cpup(p);\n\t\t}\n\t}\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n",
        "linevul": 6.609701813431457e-05,
        "sysevr": 0.18394210934638977,
        "devign": 1.3597115100516532e-10
    },
    {
        "code": "static bool find_jump_target(const struct xt_table_info *t,\n\t\t\t     const struct arpt_entry *target)\n{\n\tstruct arpt_entry *iter;\n\n\txt_entry_foreach(iter, t->entries, t->size) {\n\t\t if (iter == target)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c",
        "vul_func_with_fix": "static bool find_jump_target(const struct xt_table_info *t,\n\t\t\t     const struct arpt_entry *target)\n{\n\tstruct arpt_entry *iter;\n\n\txt_entry_foreach(iter, t->entries, t->size) {\n\t\t if (iter == target)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n",
        "linevul": 5.600165241048671e-05,
        "sysevr": 0.1312669962644577,
        "devign": 2.636847784742713e-05
    },
    {
        "code": "static int replace_map_fd_with_map_ptr(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(\"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n \t\t\tif (IS_ERR(map)) {\n \t\t\t\tverbose(\"fd %d is not pointing to valid bpf_map\\n\",\n \t\t\t\t\tinsn->imm);\n\t\t\t\tfdput(f);\n \t\t\t\treturn PTR_ERR(map);\n \t\t\t}\n \n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* remember this map */\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tbpf_map_inc(map, false);\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/8358b02bf67d3a5d8a825070e1aa73f25fb2e4c7",
        "vul_func_with_fix": "static int replace_map_fd_with_map_ptr(struct verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(\"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(\"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n \t\t\tif (IS_ERR(map)) {\n \t\t\t\tverbose(\"fd %d is not pointing to valid bpf_map\\n\",\n \t\t\t\t\tinsn->imm);\n//flaw_line_below:\n\t\t\t\tfdput(f);\n \t\t\t\treturn PTR_ERR(map);\n \t\t\t}\n \n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* remember this map */\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tbpf_map_inc(map, false);\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n",
        "linevul": 0.00021909207862336189,
        "sysevr": 0.1883087456226349,
        "devign": 0.9995414018630981
    },
    {
        "code": "\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mc_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27",
        "vul_func_with_fix": "\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mc_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n",
        "linevul": 8.237114525400102e-05,
        "sysevr": 0.17325247824192047,
        "devign": 0.003604508936405182
    },
    {
        "code": " void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n {\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4",
        "vul_func_with_fix": " void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n {\n//flaw_line_below:\n\tusb_kill_urb(mixer->urb);\n//flaw_line_below:\n\tusb_kill_urb(mixer->rc_urb);\n//fix_flaw_line_below:\n//\tif (mixer->disconnected)\n//fix_flaw_line_below:\n//\t\treturn;\n//fix_flaw_line_below:\n//\tif (mixer->urb)\n//fix_flaw_line_below:\n//\t\tusb_kill_urb(mixer->urb);\n//fix_flaw_line_below:\n//\tif (mixer->rc_urb)\n//fix_flaw_line_below:\n//\t\tusb_kill_urb(mixer->rc_urb);\n//fix_flaw_line_below:\n//\tmixer->disconnected = true;\n }\n",
        "linevul": 0.016873065382242203,
        "sysevr": 0.15841543674468994,
        "devign": 0.7762722969055176
    },
    {
        "code": "static int kvm_debugfs_open(struct inode *inode, struct file *file,\n\t\t\t   int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t\t   const char *fmt)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\t/* The debugfs files are a reference to the kvm struct which\n\t * is still valid when kvm_destroy_vm is called.\n\t * To avoid the race between open and the removal of the debugfs\n\t * directory we test against the users count.\n\t */\n\tif (!refcount_inc_not_zero(&stat_data->kvm->users_count))\n\t\treturn -ENOENT;\n\n\tif (simple_attr_open(inode, file, get, set, fmt)) {\n\t\tkvm_put_kvm(stat_data->kvm);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9",
        "vul_func_with_fix": "static int kvm_debugfs_open(struct inode *inode, struct file *file,\n\t\t\t   int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t\t   const char *fmt)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\t/* The debugfs files are a reference to the kvm struct which\n\t * is still valid when kvm_destroy_vm is called.\n\t * To avoid the race between open and the removal of the debugfs\n\t * directory we test against the users count.\n\t */\n\tif (!refcount_inc_not_zero(&stat_data->kvm->users_count))\n\t\treturn -ENOENT;\n\n\tif (simple_attr_open(inode, file, get, set, fmt)) {\n\t\tkvm_put_kvm(stat_data->kvm);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
        "linevul": 5.1184531912440434e-05,
        "sysevr": 0.1623590886592865,
        "devign": 5.076438521228963e-17
    },
    {
        "code": "static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\n\t\t       void *__user *fault_addr)\n{\n\tmips_instruction ir;\n\tunsigned long emulpc, contpc;\n\tunsigned int cond;\n\n\tif (!access_ok(VERIFY_READ, xcp->cp0_epc, sizeof(mips_instruction))) {\n\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\treturn SIGBUS;\n\t}\n\tif (__get_user(ir, (mips_instruction __user *) xcp->cp0_epc)) {\n\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\treturn SIGSEGV;\n\t}\n\n\t/* XXX NEC Vr54xx bug workaround */\n\tif ((xcp->cp0_cause & CAUSEF_BD) && !isBranchInstr(&ir))\n\t\txcp->cp0_cause &= ~CAUSEF_BD;\n\n\tif (xcp->cp0_cause & CAUSEF_BD) {\n\t\t/*\n\t\t * The instruction to be emulated is in a branch delay slot\n\t\t * which means that we have to  emulate the branch instruction\n\t\t * BEFORE we do the cop1 instruction.\n\t\t *\n\t\t * This branch could be a COP1 branch, but in that case we\n\t\t * would have had a trap for that instruction, and would not\n\t\t * come through this route.\n\t\t *\n\t\t * Linux MIPS branch emulator operates on context, updating the\n\t\t * cp0_epc.\n\t\t */\n\t\temulpc = xcp->cp0_epc + 4;\t/* Snapshot emulation target */\n\n\t\tif (__compute_return_epc(xcp)) {\n#ifdef CP1DBG\n\t\t\tprintk(\"failed to emulate branch at %p\\n\",\n\t\t\t\t(void *) (xcp->cp0_epc));\n#endif\n\t\t\treturn SIGILL;\n\t\t}\n\t\tif (!access_ok(VERIFY_READ, emulpc, sizeof(mips_instruction))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = (mips_instruction __user *)emulpc;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__get_user(ir, (mips_instruction __user *) emulpc)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = (mips_instruction __user *)emulpc;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\t/* __compute_return_epc() will have updated cp0_epc */\n\t\tcontpc = xcp->cp0_epc;\n\t\t/* In order not to confuse ptrace() et al, tweak context */\n\t\txcp->cp0_epc = emulpc - 4;\n\t} else {\n\t\temulpc = xcp->cp0_epc;\n\t\tcontpc = xcp->cp0_epc + 4;\n \t}\n \n       emul:\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t1, 0, xcp, 0);\n \tMIPS_FPU_EMU_INC_STATS(emulated);\n \tswitch (MIPSInst_OPCODE(ir)) {\n \tcase ldc1_op:{\n\t\tu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu64 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(loads);\n\n\t\tif (!access_ok(VERIFY_READ, va, sizeof(u64))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__get_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tDITOREG(val, MIPSInst_RT(ir));\n\t\tbreak;\n\t}\n\n\tcase sdc1_op:{\n\t\tu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu64 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(stores);\n\t\tDIFROMREG(val, MIPSInst_RT(ir));\n\t\tif (!access_ok(VERIFY_WRITE, va, sizeof(u64))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__put_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase lwc1_op:{\n\t\tu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu32 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(loads);\n\t\tif (!access_ok(VERIFY_READ, va, sizeof(u32))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__get_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tSITOREG(val, MIPSInst_RT(ir));\n\t\tbreak;\n\t}\n\n\tcase swc1_op:{\n\t\tu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu32 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(stores);\n\t\tSIFROMREG(val, MIPSInst_RT(ir));\n\t\tif (!access_ok(VERIFY_WRITE, va, sizeof(u32))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__put_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase cop1_op:\n\t\tswitch (MIPSInst_RS(ir)) {\n\n#if defined(__mips64)\n\t\tcase dmfc_op:\n\t\t\t/* copregister fs -> gpr[rt] */\n\t\t\tif (MIPSInst_RT(ir) != 0) {\n\t\t\t\tDIFROMREG(xcp->regs[MIPSInst_RT(ir)],\n\t\t\t\t\tMIPSInst_RD(ir));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase dmtc_op:\n\t\t\t/* copregister fs <- rt */\n\t\t\tDITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\n\t\t\tbreak;\n#endif\n\n\t\tcase mfc_op:\n\t\t\t/* copregister rd -> gpr[rt] */\n\t\t\tif (MIPSInst_RT(ir) != 0) {\n\t\t\t\tSIFROMREG(xcp->regs[MIPSInst_RT(ir)],\n\t\t\t\t\tMIPSInst_RD(ir));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase mtc_op:\n\t\t\t/* copregister rd <- rt */\n\t\t\tSITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\n\t\t\tbreak;\n\n\t\tcase cfc_op:{\n\t\t\t/* cop control register rd -> gpr[rt] */\n\t\t\tu32 value;\n\n\t\t\tif (MIPSInst_RD(ir) == FPCREG_CSR) {\n\t\t\t\tvalue = ctx->fcr31;\n\t\t\t\tvalue = (value & ~FPU_CSR_RM) |\n\t\t\t\t\tmips_rm[modeindex(value)];\n#ifdef CSRTRACE\n\t\t\t\tprintk(\"%p gpr[%d]<-csr=%08x\\n\",\n\t\t\t\t\t(void *) (xcp->cp0_epc),\n\t\t\t\t\tMIPSInst_RT(ir), value);\n#endif\n\t\t\t}\n\t\t\telse if (MIPSInst_RD(ir) == FPCREG_RID)\n\t\t\t\tvalue = 0;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t\tif (MIPSInst_RT(ir))\n\t\t\t\txcp->regs[MIPSInst_RT(ir)] = value;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ctc_op:{\n\t\t\t/* copregister rd <- rt */\n\t\t\tu32 value;\n\n\t\t\tif (MIPSInst_RT(ir) == 0)\n\t\t\t\tvalue = 0;\n\t\t\telse\n\t\t\t\tvalue = xcp->regs[MIPSInst_RT(ir)];\n\n\t\t\t/* we only have one writable control reg\n\t\t\t */\n\t\t\tif (MIPSInst_RD(ir) == FPCREG_CSR) {\n#ifdef CSRTRACE\n\t\t\t\tprintk(\"%p gpr[%d]->csr=%08x\\n\",\n\t\t\t\t\t(void *) (xcp->cp0_epc),\n\t\t\t\t\tMIPSInst_RT(ir), value);\n#endif\n\n\t\t\t\t/*\n\t\t\t\t * Don't write reserved bits,\n\t\t\t\t * and convert to ieee library modes\n\t\t\t\t */\n\t\t\t\tctx->fcr31 = (value &\n\t\t\t\t\t\t~(FPU_CSR_RSVD | FPU_CSR_RM)) |\n\t\t\t\t\t\tieee_rm[modeindex(value)];\n\t\t\t}\n\t\t\tif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\n\t\t\t\treturn SIGFPE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase bc_op:{\n\t\t\tint likely = 0;\n\n\t\t\tif (xcp->cp0_cause & CAUSEF_BD)\n\t\t\t\treturn SIGILL;\n\n#if __mips >= 4\n\t\t\tcond = ctx->fcr31 & fpucondbit[MIPSInst_RT(ir) >> 2];\n#else\n\t\t\tcond = ctx->fcr31 & FPU_CSR_COND;\n#endif\n\t\t\tswitch (MIPSInst_RT(ir) & 3) {\n\t\t\tcase bcfl_op:\n\t\t\t\tlikely = 1;\n\t\t\tcase bcf_op:\n\t\t\t\tcond = !cond;\n\t\t\t\tbreak;\n\t\t\tcase bctl_op:\n\t\t\t\tlikely = 1;\n\t\t\tcase bct_op:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* thats an illegal instruction */\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\n\t\t\txcp->cp0_cause |= CAUSEF_BD;\n\t\t\tif (cond) {\n\t\t\t\t/* branch taken: emulate dslot\n\t\t\t\t * instruction\n\t\t\t\t */\n\t\t\t\txcp->cp0_epc += 4;\n\t\t\t\tcontpc = (xcp->cp0_epc +\n\t\t\t\t\t(MIPSInst_SIMM(ir) << 2));\n\n\t\t\t\tif (!access_ok(VERIFY_READ, xcp->cp0_epc,\n\t\t\t\t\t       sizeof(mips_instruction))) {\n\t\t\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\t\t\t\treturn SIGBUS;\n\t\t\t\t}\n\t\t\t\tif (__get_user(ir,\n\t\t\t\t    (mips_instruction __user *) xcp->cp0_epc)) {\n\t\t\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\t\t\t\treturn SIGSEGV;\n\t\t\t\t}\n\n\t\t\t\tswitch (MIPSInst_OPCODE(ir)) {\n\t\t\t\tcase lwc1_op:\n\t\t\t\tcase swc1_op:\n#if (__mips >= 2 || defined(__mips64))\n\t\t\t\tcase ldc1_op:\n\t\t\t\tcase sdc1_op:\n#endif\n\t\t\t\tcase cop1_op:\n#if __mips >= 4 && __mips != 32\n\t\t\t\tcase cop1x_op:\n#endif\n\t\t\t\t\t/* its one of ours */\n\t\t\t\t\tgoto emul;\n#if __mips >= 4\n\t\t\t\tcase spec_op:\n\t\t\t\t\tif (MIPSInst_FUNC(ir) == movc_op)\n\t\t\t\t\t\tgoto emul;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Single step the non-cp1\n\t\t\t\t * instruction in the dslot\n\t\t\t\t */\n\t\t\t\treturn mips_dsemul(xcp, ir, contpc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* branch not taken */\n\t\t\t\tif (likely) {\n\t\t\t\t\t/*\n\t\t\t\t\t * branch likely nullifies\n\t\t\t\t\t * dslot if not taken\n\t\t\t\t\t */\n\t\t\t\t\txcp->cp0_epc += 4;\n\t\t\t\t\tcontpc += 4;\n\t\t\t\t\t/*\n\t\t\t\t\t * else continue & execute\n\t\t\t\t\t * dslot as normal insn\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tif (!(MIPSInst_RS(ir) & 0x10))\n\t\t\t\treturn SIGILL;\n\t\t\t{\n\t\t\t\tint sig;\n\n\t\t\t\t/* a real fpu computation instruction */\n\t\t\t\tif ((sig = fpu_emu(xcp, ctx, ir)))\n\t\t\t\t\treturn sig;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#if __mips >= 4 && __mips != 32\n\tcase cop1x_op:{\n\t\tint sig = fpux_emu(xcp, ctx, ir, fault_addr);\n\t\tif (sig)\n\t\t\treturn sig;\n\t\tbreak;\n\t}\n#endif\n\n#if __mips >= 4\n\tcase spec_op:\n\t\tif (MIPSInst_FUNC(ir) != movc_op)\n\t\t\treturn SIGILL;\n\t\tcond = fpucondbit[MIPSInst_RT(ir) >> 2];\n\t\tif (((ctx->fcr31 & cond) != 0) == ((MIPSInst_RT(ir) & 1) != 0))\n\t\t\txcp->regs[MIPSInst_RD(ir)] =\n\t\t\t\txcp->regs[MIPSInst_RS(ir)];\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\t/* we did it !! */\n\txcp->cp0_epc = contpc;\n\txcp->cp0_cause &= ~CAUSEF_BD;\n\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\n\t\t       void *__user *fault_addr)\n{\n\tmips_instruction ir;\n\tunsigned long emulpc, contpc;\n\tunsigned int cond;\n\n\tif (!access_ok(VERIFY_READ, xcp->cp0_epc, sizeof(mips_instruction))) {\n\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\treturn SIGBUS;\n\t}\n\tif (__get_user(ir, (mips_instruction __user *) xcp->cp0_epc)) {\n\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\treturn SIGSEGV;\n\t}\n\n\t/* XXX NEC Vr54xx bug workaround */\n\tif ((xcp->cp0_cause & CAUSEF_BD) && !isBranchInstr(&ir))\n\t\txcp->cp0_cause &= ~CAUSEF_BD;\n\n\tif (xcp->cp0_cause & CAUSEF_BD) {\n\t\t/*\n\t\t * The instruction to be emulated is in a branch delay slot\n\t\t * which means that we have to  emulate the branch instruction\n\t\t * BEFORE we do the cop1 instruction.\n\t\t *\n\t\t * This branch could be a COP1 branch, but in that case we\n\t\t * would have had a trap for that instruction, and would not\n\t\t * come through this route.\n\t\t *\n\t\t * Linux MIPS branch emulator operates on context, updating the\n\t\t * cp0_epc.\n\t\t */\n\t\temulpc = xcp->cp0_epc + 4;\t/* Snapshot emulation target */\n\n\t\tif (__compute_return_epc(xcp)) {\n#ifdef CP1DBG\n\t\t\tprintk(\"failed to emulate branch at %p\\n\",\n\t\t\t\t(void *) (xcp->cp0_epc));\n#endif\n\t\t\treturn SIGILL;\n\t\t}\n\t\tif (!access_ok(VERIFY_READ, emulpc, sizeof(mips_instruction))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = (mips_instruction __user *)emulpc;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__get_user(ir, (mips_instruction __user *) emulpc)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = (mips_instruction __user *)emulpc;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\t/* __compute_return_epc() will have updated cp0_epc */\n\t\tcontpc = xcp->cp0_epc;\n\t\t/* In order not to confuse ptrace() et al, tweak context */\n\t\txcp->cp0_epc = emulpc - 4;\n\t} else {\n\t\temulpc = xcp->cp0_epc;\n\t\tcontpc = xcp->cp0_epc + 4;\n \t}\n \n       emul:\n//flaw_line_below:\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n//flaw_line_below:\n\t\t\t1, 0, xcp, 0);\n//fix_flaw_line_below:\n//\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, xcp, 0);\n \tMIPS_FPU_EMU_INC_STATS(emulated);\n \tswitch (MIPSInst_OPCODE(ir)) {\n \tcase ldc1_op:{\n\t\tu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu64 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(loads);\n\n\t\tif (!access_ok(VERIFY_READ, va, sizeof(u64))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__get_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tDITOREG(val, MIPSInst_RT(ir));\n\t\tbreak;\n\t}\n\n\tcase sdc1_op:{\n\t\tu64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu64 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(stores);\n\t\tDIFROMREG(val, MIPSInst_RT(ir));\n\t\tif (!access_ok(VERIFY_WRITE, va, sizeof(u64))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__put_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase lwc1_op:{\n\t\tu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu32 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(loads);\n\t\tif (!access_ok(VERIFY_READ, va, sizeof(u32))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__get_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tSITOREG(val, MIPSInst_RT(ir));\n\t\tbreak;\n\t}\n\n\tcase swc1_op:{\n\t\tu32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +\n\t\t\tMIPSInst_SIMM(ir));\n\t\tu32 val;\n\n\t\tMIPS_FPU_EMU_INC_STATS(stores);\n\t\tSIFROMREG(val, MIPSInst_RT(ir));\n\t\tif (!access_ok(VERIFY_WRITE, va, sizeof(u32))) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGBUS;\n\t\t}\n\t\tif (__put_user(val, va)) {\n\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t*fault_addr = va;\n\t\t\treturn SIGSEGV;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase cop1_op:\n\t\tswitch (MIPSInst_RS(ir)) {\n\n#if defined(__mips64)\n\t\tcase dmfc_op:\n\t\t\t/* copregister fs -> gpr[rt] */\n\t\t\tif (MIPSInst_RT(ir) != 0) {\n\t\t\t\tDIFROMREG(xcp->regs[MIPSInst_RT(ir)],\n\t\t\t\t\tMIPSInst_RD(ir));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase dmtc_op:\n\t\t\t/* copregister fs <- rt */\n\t\t\tDITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\n\t\t\tbreak;\n#endif\n\n\t\tcase mfc_op:\n\t\t\t/* copregister rd -> gpr[rt] */\n\t\t\tif (MIPSInst_RT(ir) != 0) {\n\t\t\t\tSIFROMREG(xcp->regs[MIPSInst_RT(ir)],\n\t\t\t\t\tMIPSInst_RD(ir));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase mtc_op:\n\t\t\t/* copregister rd <- rt */\n\t\t\tSITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));\n\t\t\tbreak;\n\n\t\tcase cfc_op:{\n\t\t\t/* cop control register rd -> gpr[rt] */\n\t\t\tu32 value;\n\n\t\t\tif (MIPSInst_RD(ir) == FPCREG_CSR) {\n\t\t\t\tvalue = ctx->fcr31;\n\t\t\t\tvalue = (value & ~FPU_CSR_RM) |\n\t\t\t\t\tmips_rm[modeindex(value)];\n#ifdef CSRTRACE\n\t\t\t\tprintk(\"%p gpr[%d]<-csr=%08x\\n\",\n\t\t\t\t\t(void *) (xcp->cp0_epc),\n\t\t\t\t\tMIPSInst_RT(ir), value);\n#endif\n\t\t\t}\n\t\t\telse if (MIPSInst_RD(ir) == FPCREG_RID)\n\t\t\t\tvalue = 0;\n\t\t\telse\n\t\t\t\tvalue = 0;\n\t\t\tif (MIPSInst_RT(ir))\n\t\t\t\txcp->regs[MIPSInst_RT(ir)] = value;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ctc_op:{\n\t\t\t/* copregister rd <- rt */\n\t\t\tu32 value;\n\n\t\t\tif (MIPSInst_RT(ir) == 0)\n\t\t\t\tvalue = 0;\n\t\t\telse\n\t\t\t\tvalue = xcp->regs[MIPSInst_RT(ir)];\n\n\t\t\t/* we only have one writable control reg\n\t\t\t */\n\t\t\tif (MIPSInst_RD(ir) == FPCREG_CSR) {\n#ifdef CSRTRACE\n\t\t\t\tprintk(\"%p gpr[%d]->csr=%08x\\n\",\n\t\t\t\t\t(void *) (xcp->cp0_epc),\n\t\t\t\t\tMIPSInst_RT(ir), value);\n#endif\n\n\t\t\t\t/*\n\t\t\t\t * Don't write reserved bits,\n\t\t\t\t * and convert to ieee library modes\n\t\t\t\t */\n\t\t\t\tctx->fcr31 = (value &\n\t\t\t\t\t\t~(FPU_CSR_RSVD | FPU_CSR_RM)) |\n\t\t\t\t\t\tieee_rm[modeindex(value)];\n\t\t\t}\n\t\t\tif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\n\t\t\t\treturn SIGFPE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase bc_op:{\n\t\t\tint likely = 0;\n\n\t\t\tif (xcp->cp0_cause & CAUSEF_BD)\n\t\t\t\treturn SIGILL;\n\n#if __mips >= 4\n\t\t\tcond = ctx->fcr31 & fpucondbit[MIPSInst_RT(ir) >> 2];\n#else\n\t\t\tcond = ctx->fcr31 & FPU_CSR_COND;\n#endif\n\t\t\tswitch (MIPSInst_RT(ir) & 3) {\n\t\t\tcase bcfl_op:\n\t\t\t\tlikely = 1;\n\t\t\tcase bcf_op:\n\t\t\t\tcond = !cond;\n\t\t\t\tbreak;\n\t\t\tcase bctl_op:\n\t\t\t\tlikely = 1;\n\t\t\tcase bct_op:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* thats an illegal instruction */\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\n\t\t\txcp->cp0_cause |= CAUSEF_BD;\n\t\t\tif (cond) {\n\t\t\t\t/* branch taken: emulate dslot\n\t\t\t\t * instruction\n\t\t\t\t */\n\t\t\t\txcp->cp0_epc += 4;\n\t\t\t\tcontpc = (xcp->cp0_epc +\n\t\t\t\t\t(MIPSInst_SIMM(ir) << 2));\n\n\t\t\t\tif (!access_ok(VERIFY_READ, xcp->cp0_epc,\n\t\t\t\t\t       sizeof(mips_instruction))) {\n\t\t\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\t\t\t\treturn SIGBUS;\n\t\t\t\t}\n\t\t\t\tif (__get_user(ir,\n\t\t\t\t    (mips_instruction __user *) xcp->cp0_epc)) {\n\t\t\t\t\tMIPS_FPU_EMU_INC_STATS(errors);\n\t\t\t\t\t*fault_addr = (mips_instruction __user *)xcp->cp0_epc;\n\t\t\t\t\treturn SIGSEGV;\n\t\t\t\t}\n\n\t\t\t\tswitch (MIPSInst_OPCODE(ir)) {\n\t\t\t\tcase lwc1_op:\n\t\t\t\tcase swc1_op:\n#if (__mips >= 2 || defined(__mips64))\n\t\t\t\tcase ldc1_op:\n\t\t\t\tcase sdc1_op:\n#endif\n\t\t\t\tcase cop1_op:\n#if __mips >= 4 && __mips != 32\n\t\t\t\tcase cop1x_op:\n#endif\n\t\t\t\t\t/* its one of ours */\n\t\t\t\t\tgoto emul;\n#if __mips >= 4\n\t\t\t\tcase spec_op:\n\t\t\t\t\tif (MIPSInst_FUNC(ir) == movc_op)\n\t\t\t\t\t\tgoto emul;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Single step the non-cp1\n\t\t\t\t * instruction in the dslot\n\t\t\t\t */\n\t\t\t\treturn mips_dsemul(xcp, ir, contpc);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* branch not taken */\n\t\t\t\tif (likely) {\n\t\t\t\t\t/*\n\t\t\t\t\t * branch likely nullifies\n\t\t\t\t\t * dslot if not taken\n\t\t\t\t\t */\n\t\t\t\t\txcp->cp0_epc += 4;\n\t\t\t\t\tcontpc += 4;\n\t\t\t\t\t/*\n\t\t\t\t\t * else continue & execute\n\t\t\t\t\t * dslot as normal insn\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tif (!(MIPSInst_RS(ir) & 0x10))\n\t\t\t\treturn SIGILL;\n\t\t\t{\n\t\t\t\tint sig;\n\n\t\t\t\t/* a real fpu computation instruction */\n\t\t\t\tif ((sig = fpu_emu(xcp, ctx, ir)))\n\t\t\t\t\treturn sig;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#if __mips >= 4 && __mips != 32\n\tcase cop1x_op:{\n\t\tint sig = fpux_emu(xcp, ctx, ir, fault_addr);\n\t\tif (sig)\n\t\t\treturn sig;\n\t\tbreak;\n\t}\n#endif\n\n#if __mips >= 4\n\tcase spec_op:\n\t\tif (MIPSInst_FUNC(ir) != movc_op)\n\t\t\treturn SIGILL;\n\t\tcond = fpucondbit[MIPSInst_RT(ir) >> 2];\n\t\tif (((ctx->fcr31 & cond) != 0) == ((MIPSInst_RT(ir) & 1) != 0))\n\t\t\txcp->regs[MIPSInst_RD(ir)] =\n\t\t\t\txcp->regs[MIPSInst_RS(ir)];\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\t/* we did it !! */\n\txcp->cp0_epc = contpc;\n\txcp->cp0_cause &= ~CAUSEF_BD;\n\n\treturn 0;\n}\n",
        "linevul": 0.00023771253472659737,
        "sysevr": 0.2793581187725067,
        "devign": 0.6729214787483215
    },
    {
        "code": "void blk_queue_bypass_end(struct request_queue *q)\n{\n\tspin_lock_irq(q->queue_lock);\n\tif (!--q->bypass_depth)\n\t\tqueue_flag_clear(QUEUE_FLAG_BYPASS, q);\n\tWARN_ON_ONCE(q->bypass_depth < 0);\n\tspin_unlock_irq(q->queue_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "vul_func_with_fix": "void blk_queue_bypass_end(struct request_queue *q)\n{\n\tspin_lock_irq(q->queue_lock);\n\tif (!--q->bypass_depth)\n\t\tqueue_flag_clear(QUEUE_FLAG_BYPASS, q);\n\tWARN_ON_ONCE(q->bypass_depth < 0);\n\tspin_unlock_irq(q->queue_lock);\n}\n",
        "linevul": 0.000125810009194538,
        "sysevr": 0.15705005824565887,
        "devign": 7.231272434182756e-07
    },
    {
        "code": "static void hns_gmac_set_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\n\tu32 val = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tu32 sta_addr_en = dsaf_get_bit(val, GMAC_ADDR_EN_B);\n\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_LOW_2_REG, low_val);\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t       high_val | (sta_addr_en << GMAC_ADDR_EN_B));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/412b65d15a7f8a93794653968308fc100f2aa87c",
        "vul_func_with_fix": "static void hns_gmac_set_mac_addr(void *mac_drv, char *mac_addr)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tu32 high_val = mac_addr[1] | (mac_addr[0] << 8);\n\n\tu32 low_val = mac_addr[5] | (mac_addr[4] << 8)\n\t\t| (mac_addr[3] << 16) | (mac_addr[2] << 24);\n\n\tu32 val = dsaf_read_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG);\n\tu32 sta_addr_en = dsaf_get_bit(val, GMAC_ADDR_EN_B);\n\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_LOW_2_REG, low_val);\n\tdsaf_write_dev(drv, GMAC_STATION_ADDR_HIGH_2_REG,\n\t\t       high_val | (sta_addr_en << GMAC_ADDR_EN_B));\n}\n",
        "linevul": 4.753110624733381e-05,
        "sysevr": 0.12781836092472076,
        "devign": 0.9210524559020996
    },
    {
        "code": "void sched_fork(struct task_struct *p)\n{\n\tunsigned long flags;\n\tint cpu = get_cpu();\n\n\t__sched_fork(p);\n\t/*\n\t * We mark the process as running here. This guarantees that\n\t * nobody will actually run it, and a signal or other external\n\t * event cannot wake it up and insert it on the runqueue either.\n\t */\n\tp->state = TASK_RUNNING;\n\n\t/*\n\t * Revert to default priority/policy on fork if requested.\n\t */\n\tif (unlikely(p->sched_reset_on_fork)) {\n\t\tif (p->policy == SCHED_FIFO || p->policy == SCHED_RR) {\n\t\t\tp->policy = SCHED_NORMAL;\n\t\t\tp->normal_prio = p->static_prio;\n\t\t}\n\n\t\tif (PRIO_TO_NICE(p->static_prio) < 0) {\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\t\t\tp->normal_prio = p->static_prio;\n\t\t\tset_load_weight(p);\n\t\t}\n\n\t\t/*\n\t\t * We don't need the reset flag anymore after the fork. It has\n\t\t * fulfilled its duty:\n\t\t */\n\t\tp->sched_reset_on_fork = 0;\n\t}\n\n\t/*\n\t * Make sure we do not leak PI boosting priority to the child.\n\t */\n\tp->prio = current->normal_prio;\n\n\tif (!rt_prio(p->prio))\n\t\tp->sched_class = &fair_sched_class;\n\n\tif (p->sched_class->task_fork)\n\t\tp->sched_class->task_fork(p);\n\n\t/*\n\t * The child is not yet in the pid-hash so no cgroup attach races,\n\t * and the cgroup is pinned to this child due to cgroup_fork()\n\t * is ran before sched_fork().\n\t *\n\t * Silence PROVE_RCU.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tset_task_cpu(p, cpu);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)\n\tif (likely(sched_info_on()))\n\t\tmemset(&p->sched_info, 0, sizeof(p->sched_info));\n#endif\n#if defined(CONFIG_SMP)\n\tp->on_cpu = 0;\n#endif\n#ifdef CONFIG_PREEMPT\n\t/* Want to start with kernel preemption disabled. */\n\ttask_thread_info(p)->preempt_count = 1;\n#endif\n#ifdef CONFIG_SMP\n\tplist_node_init(&p->pushable_tasks, MAX_PRIO);\n#endif\n\n\tput_cpu();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": "void sched_fork(struct task_struct *p)\n{\n\tunsigned long flags;\n\tint cpu = get_cpu();\n\n\t__sched_fork(p);\n\t/*\n\t * We mark the process as running here. This guarantees that\n\t * nobody will actually run it, and a signal or other external\n\t * event cannot wake it up and insert it on the runqueue either.\n\t */\n\tp->state = TASK_RUNNING;\n\n\t/*\n\t * Revert to default priority/policy on fork if requested.\n\t */\n\tif (unlikely(p->sched_reset_on_fork)) {\n\t\tif (p->policy == SCHED_FIFO || p->policy == SCHED_RR) {\n\t\t\tp->policy = SCHED_NORMAL;\n\t\t\tp->normal_prio = p->static_prio;\n\t\t}\n\n\t\tif (PRIO_TO_NICE(p->static_prio) < 0) {\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\t\t\tp->normal_prio = p->static_prio;\n\t\t\tset_load_weight(p);\n\t\t}\n\n\t\t/*\n\t\t * We don't need the reset flag anymore after the fork. It has\n\t\t * fulfilled its duty:\n\t\t */\n\t\tp->sched_reset_on_fork = 0;\n\t}\n\n\t/*\n\t * Make sure we do not leak PI boosting priority to the child.\n\t */\n\tp->prio = current->normal_prio;\n\n\tif (!rt_prio(p->prio))\n\t\tp->sched_class = &fair_sched_class;\n\n\tif (p->sched_class->task_fork)\n\t\tp->sched_class->task_fork(p);\n\n\t/*\n\t * The child is not yet in the pid-hash so no cgroup attach races,\n\t * and the cgroup is pinned to this child due to cgroup_fork()\n\t * is ran before sched_fork().\n\t *\n\t * Silence PROVE_RCU.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tset_task_cpu(p, cpu);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)\n\tif (likely(sched_info_on()))\n\t\tmemset(&p->sched_info, 0, sizeof(p->sched_info));\n#endif\n#if defined(CONFIG_SMP)\n\tp->on_cpu = 0;\n#endif\n#ifdef CONFIG_PREEMPT\n\t/* Want to start with kernel preemption disabled. */\n\ttask_thread_info(p)->preempt_count = 1;\n#endif\n#ifdef CONFIG_SMP\n\tplist_node_init(&p->pushable_tasks, MAX_PRIO);\n#endif\n\n\tput_cpu();\n}\n",
        "linevul": 7.528257992817089e-05,
        "sysevr": 0.22040320932865143,
        "devign": 0.23368613421916962
    },
    {
        "code": "nfs4_free_slot(struct nfs4_slot_table *tbl, u32 slotid)\n{\n\tBUG_ON(slotid >= NFS4_MAX_SLOT_TABLE);\n\t/* clear used bit in bitmap */\n\t__clear_bit(slotid, tbl->used_slots);\n\n\t/* update highest_used_slotid when it is freed */\n\tif (slotid == tbl->highest_used_slotid) {\n\t\tslotid = find_last_bit(tbl->used_slots, tbl->max_slots);\n\t\tif (slotid < tbl->max_slots)\n\t\t\ttbl->highest_used_slotid = slotid;\n\t\telse\n\t\t\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\t}\n\tdprintk(\"%s: slotid %u highest_used_slotid %d\\n\", __func__,\n\t\tslotid, tbl->highest_used_slotid);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/20e0fa98b751facf9a1101edaefbc19c82616a68",
        "vul_func_with_fix": "nfs4_free_slot(struct nfs4_slot_table *tbl, u32 slotid)\n{\n\tBUG_ON(slotid >= NFS4_MAX_SLOT_TABLE);\n\t/* clear used bit in bitmap */\n\t__clear_bit(slotid, tbl->used_slots);\n\n\t/* update highest_used_slotid when it is freed */\n\tif (slotid == tbl->highest_used_slotid) {\n\t\tslotid = find_last_bit(tbl->used_slots, tbl->max_slots);\n\t\tif (slotid < tbl->max_slots)\n\t\t\ttbl->highest_used_slotid = slotid;\n\t\telse\n\t\t\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\t}\n\tdprintk(\"%s: slotid %u highest_used_slotid %d\\n\", __func__,\n\t\tslotid, tbl->highest_used_slotid);\n}\n",
        "linevul": 5.217269790591672e-05,
        "sysevr": 0.17926159501075745,
        "devign": 5.920845480567039e-10
    },
    {
        "code": "static int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876",
        "vul_func_with_fix": "static int fuse_fsync(struct file *file, loff_t start, loff_t end,\n\t\t      int datasync)\n{\n\treturn fuse_fsync_common(file, start, end, datasync, 0);\n}\n",
        "linevul": 6.649364513577893e-05,
        "sysevr": 0.1381760537624359,
        "devign": 6.847253748156965e-14
    },
    {
        "code": "sctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t\t  commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4",
        "vul_func_with_fix": "sctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t\t  commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n",
        "linevul": 7.673325308132917e-05,
        "sysevr": 0.2606387138366699,
        "devign": 0.0004471873107831925
    },
    {
        "code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n \t\t\t\treturn true;\n \t\t}\n \t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also had the approprpiate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/e3211c120a85b792978bcb4be7b2886df18d27f0",
        "vul_func_with_fix": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n//flaw_line_below:\n\t\t\tif (uid_eq(uid, current_fsuid()))\n//fix_flaw_line_below:\n//\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n//flaw_line_below:\n\t\t\tif (gid_eq(gid, current_fsgid()))\n//fix_flaw_line_below:\n//\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n \t\t\t\treturn true;\n \t\t}\n \t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also had the approprpiate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "linevul": 0.9987816214561462,
        "sysevr": 0.16404440999031067,
        "devign": 0.9526617527008057
    },
    {
        "code": "static int nfs4_xdr_dec_getdeviceinfo(struct rpc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      struct nfs4_getdeviceinfo_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_getdeviceinfo(xdr, res->pdev);\nout:\n\treturn status;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
        "vul_func_with_fix": "static int nfs4_xdr_dec_getdeviceinfo(struct rpc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      struct nfs4_getdeviceinfo_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = decode_getdeviceinfo(xdr, res->pdev);\nout:\n\treturn status;\n}\n",
        "linevul": 5.2537016017595306e-05,
        "sysevr": 0.12995393574237823,
        "devign": 1.1620313671091942e-22
    },
    {
        "code": "void kvm_vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tktime_t start, cur;\n\tDECLARE_SWAITQUEUE(wait);\n\tbool waited = false;\n\tu64 block_ns;\n\n\tstart = cur = ktime_get();\n\tif (vcpu->halt_poll_ns) {\n\t\tktime_t stop = ktime_add_ns(ktime_get(), vcpu->halt_poll_ns);\n\n\t\t++vcpu->stat.halt_attempted_poll;\n\t\tdo {\n\t\t\t/*\n\t\t\t * This sets KVM_REQ_UNHALT if an interrupt\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (kvm_vcpu_check_block(vcpu) < 0) {\n\t\t\t\t++vcpu->stat.halt_successful_poll;\n\t\t\t\tif (!vcpu_valid_wakeup(vcpu))\n\t\t\t\t\t++vcpu->stat.halt_poll_invalid;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcur = ktime_get();\n\t\t} while (single_task_running() && ktime_before(cur, stop));\n\t}\n\n\tkvm_arch_vcpu_blocking(vcpu);\n\n\tfor (;;) {\n\t\tprepare_to_swait(&vcpu->wq, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\tbreak;\n\n\t\twaited = true;\n\t\tschedule();\n\t}\n\n\tfinish_swait(&vcpu->wq, &wait);\n\tcur = ktime_get();\n\n\tkvm_arch_vcpu_unblocking(vcpu);\nout:\n\tblock_ns = ktime_to_ns(cur) - ktime_to_ns(start);\n\n\tif (!vcpu_valid_wakeup(vcpu))\n\t\tshrink_halt_poll_ns(vcpu);\n\telse if (halt_poll_ns) {\n\t\tif (block_ns <= vcpu->halt_poll_ns)\n\t\t\t;\n\t\t/* we had a long block, shrink polling */\n\t\telse if (vcpu->halt_poll_ns && block_ns > halt_poll_ns)\n\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t/* we had a short halt and our poll time is too small */\n\t\telse if (vcpu->halt_poll_ns < halt_poll_ns &&\n\t\t\tblock_ns < halt_poll_ns)\n\t\t\tgrow_halt_poll_ns(vcpu);\n\t} else\n\t\tvcpu->halt_poll_ns = 0;\n\n\ttrace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));\n\tkvm_arch_vcpu_block_finish(vcpu);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "vul_func_with_fix": "void kvm_vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tktime_t start, cur;\n\tDECLARE_SWAITQUEUE(wait);\n\tbool waited = false;\n\tu64 block_ns;\n\n\tstart = cur = ktime_get();\n\tif (vcpu->halt_poll_ns) {\n\t\tktime_t stop = ktime_add_ns(ktime_get(), vcpu->halt_poll_ns);\n\n\t\t++vcpu->stat.halt_attempted_poll;\n\t\tdo {\n\t\t\t/*\n\t\t\t * This sets KVM_REQ_UNHALT if an interrupt\n\t\t\t * arrives.\n\t\t\t */\n\t\t\tif (kvm_vcpu_check_block(vcpu) < 0) {\n\t\t\t\t++vcpu->stat.halt_successful_poll;\n\t\t\t\tif (!vcpu_valid_wakeup(vcpu))\n\t\t\t\t\t++vcpu->stat.halt_poll_invalid;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcur = ktime_get();\n\t\t} while (single_task_running() && ktime_before(cur, stop));\n\t}\n\n\tkvm_arch_vcpu_blocking(vcpu);\n\n\tfor (;;) {\n\t\tprepare_to_swait(&vcpu->wq, &wait, TASK_INTERRUPTIBLE);\n\n\t\tif (kvm_vcpu_check_block(vcpu) < 0)\n\t\t\tbreak;\n\n\t\twaited = true;\n\t\tschedule();\n\t}\n\n\tfinish_swait(&vcpu->wq, &wait);\n\tcur = ktime_get();\n\n\tkvm_arch_vcpu_unblocking(vcpu);\nout:\n\tblock_ns = ktime_to_ns(cur) - ktime_to_ns(start);\n\n\tif (!vcpu_valid_wakeup(vcpu))\n\t\tshrink_halt_poll_ns(vcpu);\n\telse if (halt_poll_ns) {\n\t\tif (block_ns <= vcpu->halt_poll_ns)\n\t\t\t;\n\t\t/* we had a long block, shrink polling */\n\t\telse if (vcpu->halt_poll_ns && block_ns > halt_poll_ns)\n\t\t\tshrink_halt_poll_ns(vcpu);\n\t\t/* we had a short halt and our poll time is too small */\n\t\telse if (vcpu->halt_poll_ns < halt_poll_ns &&\n\t\t\tblock_ns < halt_poll_ns)\n\t\t\tgrow_halt_poll_ns(vcpu);\n\t} else\n\t\tvcpu->halt_poll_ns = 0;\n\n\ttrace_kvm_vcpu_wakeup(block_ns, waited, vcpu_valid_wakeup(vcpu));\n\tkvm_arch_vcpu_block_finish(vcpu);\n}\n",
        "linevul": 5.071044506621547e-05,
        "sysevr": 0.19070586562156677,
        "devign": 0.0
    },
    {
        "code": "static ssize_t session_write_kbytes_show(struct ext4_attr *a,\n\t\t\t\t\t struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%lu\\n\",\n\t\t\t(part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t sbi->s_sectors_written_start) >> 1);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
        "vul_func_with_fix": "static ssize_t session_write_kbytes_show(struct ext4_attr *a,\n\t\t\t\t\t struct ext4_sb_info *sbi, char *buf)\n{\n\tstruct super_block *sb = sbi->s_buddy_cache->i_sb;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%lu\\n\",\n\t\t\t(part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t sbi->s_sectors_written_start) >> 1);\n}\n",
        "linevul": 7.329564687097445e-05,
        "sysevr": 0.12839911878108978,
        "devign": 0.004044810775667429
    },
    {
        "code": "struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,\n\t\t\t\t\tstruct rtnl_link_stats64 *storage)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (ops->ndo_get_stats64) {\n\t\tmemset(storage, 0, sizeof(*storage));\n\t\tops->ndo_get_stats64(dev, storage);\n\t} else if (ops->ndo_get_stats) {\n\t\tnetdev_stats_to_stats64(storage, ops->ndo_get_stats(dev));\n\t} else {\n\t\tnetdev_stats_to_stats64(storage, &dev->stats);\n\t}\n\tstorage->rx_dropped += atomic_long_read(&dev->rx_dropped);\n\treturn storage;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b",
        "vul_func_with_fix": "struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,\n\t\t\t\t\tstruct rtnl_link_stats64 *storage)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (ops->ndo_get_stats64) {\n\t\tmemset(storage, 0, sizeof(*storage));\n\t\tops->ndo_get_stats64(dev, storage);\n\t} else if (ops->ndo_get_stats) {\n\t\tnetdev_stats_to_stats64(storage, ops->ndo_get_stats(dev));\n\t} else {\n\t\tnetdev_stats_to_stats64(storage, &dev->stats);\n\t}\n\tstorage->rx_dropped += atomic_long_read(&dev->rx_dropped);\n\treturn storage;\n}\n",
        "linevul": 4.71798557555303e-05,
        "sysevr": 0.13966487348079681,
        "devign": 1.4073778600853792e-11
    },
    {
        "code": "sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/3e0097499839e0fe3af380410eababe5a47c4cf9",
        "vul_func_with_fix": "sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}\n",
        "linevul": 0.0006831383798271418,
        "sysevr": 0.1876242607831955,
        "devign": 0.9306056499481201
    },
    {
        "code": "asmlinkage void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/09ca8e1173bcb12e2a449698c9ae3b86a8a10195",
        "vul_func_with_fix": "asmlinkage void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG();\n}\n",
        "linevul": 5.30978650203906e-05,
        "sysevr": 0.1586747169494629,
        "devign": 1.5094256108548402e-20
    },
    {
        "code": "static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct sock *sk;\n\tint len;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);\n\tif (!sk)\n\t\treturn -ENOENT;\n\n\tif (sk->sk_state == BT_DISCONN)\n\t\tgoto unlock;\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);\n\tl2cap_pi(sk)->conf_len += len;\n\n\tif (flags & 0x0001) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_SUCCESS, 0x0001), rsp);\n\t\tgoto unlock;\n\t}\n \n \t/* Complete config. */\n \tlen = l2cap_parse_conf_req(sk, rsp);\n\tif (len < 0)\n \t\tgoto unlock;\n \n \tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n \n \t/* Reset config buffer. */\n \tl2cap_pi(sk)->conf_len = 0;\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))\n\t\tgoto unlock;\n\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {\n \t\tu8 buf[64];\n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n \t\t\t\t\tl2cap_build_conf_req(sk, buf), buf);\n \t}\n \n unlock:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
        "vul_func_with_fix": "static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct sock *sk;\n\tint len;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);\n\tif (!sk)\n\t\treturn -ENOENT;\n\n\tif (sk->sk_state == BT_DISCONN)\n\t\tgoto unlock;\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);\n\tl2cap_pi(sk)->conf_len += len;\n\n\tif (flags & 0x0001) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(sk, rsp,\n\t\t\t\t\tL2CAP_CONF_SUCCESS, 0x0001), rsp);\n\t\tgoto unlock;\n\t}\n \n \t/* Complete config. */\n \tlen = l2cap_parse_conf_req(sk, rsp);\n//flaw_line_below:\n\tif (len < 0)\n//fix_flaw_line_below:\n//\tif (len < 0) {\n//fix_flaw_line_below:\n//\t\tstruct l2cap_disconn_req req;\n//fix_flaw_line_below:\n//\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n//fix_flaw_line_below:\n//\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n//fix_flaw_line_below:\n//\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n//fix_flaw_line_below:\n//\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n \t\tgoto unlock;\n//fix_flaw_line_below:\n//\t}\n \n \tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n//fix_flaw_line_below:\n//\tl2cap_pi(sk)->num_conf_rsp++;\n \n \t/* Reset config buffer. */\n \tl2cap_pi(sk)->conf_len = 0;\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))\n\t\tgoto unlock;\n\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {\n \t\tu8 buf[64];\n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n \t\t\t\t\tl2cap_build_conf_req(sk, buf), buf);\n//fix_flaw_line_below:\n//\t\tl2cap_pi(sk)->num_conf_req++;\n \t}\n \n unlock:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}\n",
        "linevul": 5.425402196124196e-05,
        "sysevr": 0.14242245256900787,
        "devign": 0.9999997615814209
    },
    {
        "code": "long user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd",
        "vul_func_with_fix": "long user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n",
        "linevul": 5.8941015595337376e-05,
        "sysevr": 0.22096902132034302,
        "devign": 0.6112878918647766
    },
    {
        "code": "static int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca",
        "vul_func_with_fix": "static int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n",
        "linevul": 5.6157699873438105e-05,
        "sysevr": 0.12521357834339142,
        "devign": 0.00017778751498553902
    },
    {
        "code": "static int snd_timer_user_status(struct file *file,\n\t\t\t\t struct snd_timer_status __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp = tu->tstamp;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e4ec8cc8039a7063e24204299b462bd1383184a5",
        "vul_func_with_fix": "static int snd_timer_user_status(struct file *file,\n\t\t\t\t struct snd_timer_status __user *_status)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_status status;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tmemset(&status, 0, sizeof(status));\n\tstatus.tstamp = tu->tstamp;\n\tstatus.resolution = snd_timer_resolution(tu->timeri);\n\tstatus.lost = tu->timeri->lost;\n\tstatus.overrun = tu->overrun;\n\tspin_lock_irq(&tu->qlock);\n\tstatus.queue = tu->qused;\n\tspin_unlock_irq(&tu->qlock);\n\tif (copy_to_user(_status, &status, sizeof(status)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "linevul": 4.960595106240362e-05,
        "sysevr": 0.13962744176387787,
        "devign": 0.66461181640625
    },
    {
        "code": "static int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\ttu->timeri->lost = 0;\n\treturn (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/e4ec8cc8039a7063e24204299b462bd1383184a5",
        "vul_func_with_fix": "static int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\ttu->timeri->lost = 0;\n\treturn (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;\n}\n",
        "linevul": 6.968518573557958e-05,
        "sysevr": 0.12811948359012604,
        "devign": 0.00041799197788350284
    },
    {
        "code": " static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    int nmi, struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tdata->period = event->hw.last_period;\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n \t\treturn;\n \n \tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, nmi, throttle,\n \t\t\t\t\t    data, regs)) {\n \t\t\t/*\n \t\t\t * We inhibit the overflow from happening when\n\t\t\t * hwc->interrupts == MAX_INTERRUPTS.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233",
        "vul_func_with_fix": " static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n//flaw_line_below:\n\t\t\t\t    int nmi, struct perf_sample_data *data,\n//fix_flaw_line_below:\n//\t\t\t\t    struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tdata->period = event->hw.last_period;\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n \t\treturn;\n \n \tfor (; overflow; overflow--) {\n//flaw_line_below:\n\t\tif (__perf_event_overflow(event, nmi, throttle,\n//fix_flaw_line_below:\n//\t\tif (__perf_event_overflow(event, throttle,\n \t\t\t\t\t    data, regs)) {\n \t\t\t/*\n \t\t\t * We inhibit the overflow from happening when\n\t\t\t * hwc->interrupts == MAX_INTERRUPTS.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n }\n",
        "linevul": 0.9995657801628113,
        "sysevr": 0.16034969687461853,
        "devign": 7.69400255312691e-12
    },
    {
        "code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\n\t/* The assumption is that we are safe to process the chunks\n\t * at this time.\n\t */\n\n\tif ((chunk = queue->in_progress)) {\n\t\t/* There is a packet that we have been working on.\n\t\t * Any post processing work to do before we move on?\n\t\t */\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n \t\t} else {\n \t\t\t/* Nothing to do. Next chunk in the packet, please. */\n \t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n \t\t\t/* Force chunk->skb->data to chunk->chunk_end.  */\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\t/* Verify that we have at least chunk headers\n\t\t\t * worth of buffer left.\n\t\t\t */\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n \t\t}\n \t}\n \n\t/* Do we need to take the next packet out of the queue to process? */\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\n\t\t/* Is the queue empty?  */\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\n\t\t/* This is the first chunk in the packet.  */\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t/* In the unlikely case of an IP reassembly, the skb could be\n\t * non-linear. If so, update chunk_end so that it doesn't go past\n\t * the skb->tail.\n\t */\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n \tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n \tchunk->subh.v = NULL; /* Subheader is no longer valid.  */\n \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n \t\t/* This is not a singleton */\n \t\tchunk->singleton = 0;\n \t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\t/* RFC 2960, Section 6.10  Bundling\n\t\t *\n\t\t * Partial chunks MUST NOT be placed in an SCTP packet.\n\t\t * If the receiver detects a partial chunk, it MUST drop\n\t\t * the chunk.\n\t\t *\n\t\t * Since the end of the chunk is past the end of our buffer\n\t\t * (which contains the whole packet, we can freely discard\n\t\t * the whole packet.\n\t\t */\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n \t} else {\n \t\t/* We are at the end of the packet, so mark the chunk\n \t\t * in case we need to send a SACK.\n\t\t */\n\t\tchunk->end_of_packet = 1;\n\t}\n\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\n\treturn chunk;\n}\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/26b87c7881006311828bb0ab271a551a62dcceb4",
        "vul_func_with_fix": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\n\t/* The assumption is that we are safe to process the chunks\n\t * at this time.\n\t */\n\n\tif ((chunk = queue->in_progress)) {\n\t\t/* There is a packet that we have been working on.\n\t\t * Any post processing work to do before we move on?\n\t\t */\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n \t\t} else {\n \t\t\t/* Nothing to do. Next chunk in the packet, please. */\n \t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n//flaw_line_below:\n\n \t\t\t/* Force chunk->skb->data to chunk->chunk_end.  */\n//flaw_line_below:\n\t\t\tskb_pull(chunk->skb,\n//flaw_line_below:\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n//flaw_line_below:\n\n//flaw_line_below:\n\t\t\t/* Verify that we have at least chunk headers\n//flaw_line_below:\n\t\t\t * worth of buffer left.\n//flaw_line_below:\n\t\t\t */\n//flaw_line_below:\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n//flaw_line_below:\n\t\t\t\tsctp_chunk_free(chunk);\n//flaw_line_below:\n\t\t\t\tchunk = queue->in_progress = NULL;\n//flaw_line_below:\n\t\t\t}\n//fix_flaw_line_below:\n//\t\t\tskb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);\n//fix_flaw_line_below:\n//\t\t\t/* We are guaranteed to pull a SCTP header. */\n \t\t}\n \t}\n \n\t/* Do we need to take the next packet out of the queue to process? */\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\n\t\t/* Is the queue empty?  */\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\n\t\t/* This is the first chunk in the packet.  */\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t/* In the unlikely case of an IP reassembly, the skb could be\n\t * non-linear. If so, update chunk_end so that it doesn't go past\n\t * the skb->tail.\n\t */\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n \tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n \tchunk->subh.v = NULL; /* Subheader is no longer valid.  */\n \n//flaw_line_below:\n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n//fix_flaw_line_below:\n//\tif (chunk->chunk_end + sizeof(sctp_chunkhdr_t) <\n//fix_flaw_line_below:\n//\t    skb_tail_pointer(chunk->skb)) {\n \t\t/* This is not a singleton */\n \t\tchunk->singleton = 0;\n \t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n//flaw_line_below:\n\t\t/* RFC 2960, Section 6.10  Bundling\n//flaw_line_below:\n\t\t *\n//flaw_line_below:\n\t\t * Partial chunks MUST NOT be placed in an SCTP packet.\n//flaw_line_below:\n\t\t * If the receiver detects a partial chunk, it MUST drop\n//flaw_line_below:\n\t\t * the chunk.\n//flaw_line_below:\n\t\t *\n//flaw_line_below:\n\t\t * Since the end of the chunk is past the end of our buffer\n//flaw_line_below:\n\t\t * (which contains the whole packet, we can freely discard\n//flaw_line_below:\n\t\t * the whole packet.\n//flaw_line_below:\n\t\t */\n//flaw_line_below:\n\t\tsctp_chunk_free(chunk);\n//flaw_line_below:\n\t\tchunk = queue->in_progress = NULL;\n//flaw_line_below:\n\n//flaw_line_below:\n\t\treturn NULL;\n//fix_flaw_line_below:\n//\t\t/* Discard inside state machine. */\n//fix_flaw_line_below:\n//\t\tchunk->pdiscard = 1;\n//fix_flaw_line_below:\n//\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n \t} else {\n \t\t/* We are at the end of the packet, so mark the chunk\n \t\t * in case we need to send a SACK.\n\t\t */\n\t\tchunk->end_of_packet = 1;\n\t}\n\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\n\treturn chunk;\n}\n",
        "linevul": 0.9964274764060974,
        "sysevr": 0.3003671169281006,
        "devign": 0.9990686774253845
    },
    {
        "code": "static void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.i.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.i.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/d0de4dc584ec6aa3b26fffea320a8457827768fc",
        "vul_func_with_fix": "static void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.i.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.i.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.i.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}\n",
        "linevul": 0.00010427634697407484,
        "sysevr": 0.16841916739940643,
        "devign": 0.0003071319661103189
    },
    {
        "code": "void kvm_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * no need for rcu_read_lock as VCPU_RUN is the only place that\n\t * will change the vcpu->pid pointer and on uninit all file\n\t * descriptors are already gone.\n\t */\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tkvm_arch_vcpu_uninit(vcpu);\n\tfree_page((unsigned long)vcpu->run);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9",
        "vul_func_with_fix": "void kvm_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * no need for rcu_read_lock as VCPU_RUN is the only place that\n\t * will change the vcpu->pid pointer and on uninit all file\n\t * descriptors are already gone.\n\t */\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tkvm_arch_vcpu_uninit(vcpu);\n\tfree_page((unsigned long)vcpu->run);\n}\n",
        "linevul": 5.834577314089984e-05,
        "sysevr": 0.17679859697818756,
        "devign": 4.0002198775646036e-10
    },
    {
        "code": "static int deflate_compress(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t    unsigned int slen, u8 *dst, unsigned int *dlen)\n{\n\tint ret = 0;\n\tstruct deflate_ctx *dctx = crypto_tfm_ctx(tfm);\n\tstruct z_stream_s *stream = &dctx->comp_stream;\n\n\tret = zlib_deflateReset(stream);\n\tif (ret != Z_OK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstream->next_in = (u8 *)src;\n\tstream->avail_in = slen;\n\tstream->next_out = (u8 *)dst;\n\tstream->avail_out = *dlen;\n\n\tret = zlib_deflate(stream, Z_FINISH);\n\tif (ret != Z_STREAM_END) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n\t*dlen = stream->total_out;\nout:\n\treturn ret;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b",
        "vul_func_with_fix": "static int deflate_compress(struct crypto_tfm *tfm, const u8 *src,\n\t\t\t    unsigned int slen, u8 *dst, unsigned int *dlen)\n{\n\tint ret = 0;\n\tstruct deflate_ctx *dctx = crypto_tfm_ctx(tfm);\n\tstruct z_stream_s *stream = &dctx->comp_stream;\n\n\tret = zlib_deflateReset(stream);\n\tif (ret != Z_OK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstream->next_in = (u8 *)src;\n\tstream->avail_in = slen;\n\tstream->next_out = (u8 *)dst;\n\tstream->avail_out = *dlen;\n\n\tret = zlib_deflate(stream, Z_FINISH);\n\tif (ret != Z_STREAM_END) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n\t*dlen = stream->total_out;\nout:\n\treturn ret;\n}\n",
        "linevul": 5.7375014876015484e-05,
        "sysevr": 0.16749179363250732,
        "devign": 3.2340048505830055e-07
    },
    {
        "code": "static void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tnfs4_label_free(data->label);\n\tkfree(data);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
        "vul_func_with_fix": "static void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tnfs4_label_free(data->label);\n\tkfree(data);\n}\n",
        "linevul": 6.692298484267667e-05,
        "sysevr": 0.12857721745967865,
        "devign": 2.7345565811742745e-09
    },
    {
        "code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }\n",
        "label": "1",
        "addr": "https://github.com/torvalds/linux/commit/33ab91103b3415e12457e3104f0e4517ce12d0f3",
        "vul_func_with_fix": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//\t/*\n//fix_flaw_line_below:\n//\t * None of MOV, POP and LSS can load a NULL selector in CPL=3, but\n//fix_flaw_line_below:\n//\t * they can load it at CPL<3 (Intel's manual says only LSS can,\n//fix_flaw_line_below:\n//\t * but it's wrong).\n//fix_flaw_line_below:\n//\t *\n//fix_flaw_line_below:\n//\t * However, the Intel manual says that putting IST=1/DPL=3 in\n//fix_flaw_line_below:\n//\t * an interrupt gate will result in SS=3 (the AMD manual instead\n//fix_flaw_line_below:\n//\t * says it doesn't), so allow SS=3 in __load_segment_descriptor\n//fix_flaw_line_below:\n//\t * and only forbid it here.\n//fix_flaw_line_below:\n//\t */\n//fix_flaw_line_below:\n//\tif (seg == VCPU_SREG_SS && selector == 3 &&\n//fix_flaw_line_below:\n//\t    ctxt->mode == X86EMUL_MODE_PROT64)\n//fix_flaw_line_below:\n//\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n//fix_flaw_line_below:\n//\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }\n",
        "linevul": 0.9992320537567139,
        "sysevr": 0.13012880086898804,
        "devign": 0.9963787198066711
    },
    {
        "code": "static inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca",
        "vul_func_with_fix": "static inline int search_dirblock(struct buffer_head *bh,\n\t\t\t\t  struct inode *dir,\n\t\t\t\t  const struct qstr *d_name,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  struct ext4_dir_entry_2 **res_dir)\n{\n\treturn search_dir(bh, bh->b_data, dir->i_sb->s_blocksize, dir,\n\t\t\t  d_name, offset, res_dir);\n}\n",
        "linevul": 0.00011033769987989217,
        "sysevr": 0.13256779313087463,
        "devign": 0.000504236901178956
    },
    {
        "code": "static int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)\n{\n\tstruct inet_sock *inet1 = inet_sk(sk1), *inet2 = inet_sk(sk2);\n\n\treturn \t(!ipv6_only_sock(sk2)  &&\n\t\t (!inet1->inet_rcv_saddr || !inet2->inet_rcv_saddr ||\n\t\t   inet1->inet_rcv_saddr == inet2->inet_rcv_saddr));\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259",
        "vul_func_with_fix": "static int ipv4_rcv_saddr_equal(const struct sock *sk1, const struct sock *sk2)\n{\n\tstruct inet_sock *inet1 = inet_sk(sk1), *inet2 = inet_sk(sk2);\n\n\treturn \t(!ipv6_only_sock(sk2)  &&\n\t\t (!inet1->inet_rcv_saddr || !inet2->inet_rcv_saddr ||\n\t\t   inet1->inet_rcv_saddr == inet2->inet_rcv_saddr));\n}\n",
        "linevul": 5.914111534366384e-05,
        "sysevr": 0.12166088819503784,
        "devign": 0.00013989154831506312
    },
    {
        "code": "void __init sched_init_smp(void)\n{\n\tcpumask_var_t non_isolated_cpus;\n\n\talloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL);\n\talloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tsched_init_numa();\n\n\t/*\n\t * There's no userspace yet to cause hotplug operations; hence all the\n\t * cpu masks are stable and all blatant races in the below code cannot\n\t * happen.\n\t */\n\tmutex_lock(&sched_domains_mutex);\n\tinit_sched_domains(cpu_active_mask);\n\tcpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);\n\tif (cpumask_empty(non_isolated_cpus))\n\t\tcpumask_set_cpu(smp_processor_id(), non_isolated_cpus);\n\tmutex_unlock(&sched_domains_mutex);\n\n\t/* Move init over to a non-isolated CPU */\n\tif (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0)\n\t\tBUG();\n\tsched_init_granularity();\n\tfree_cpumask_var(non_isolated_cpus);\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n\tsched_smp_initialized = true;\n}\n",
        "label": "0",
        "addr": "https://github.com/torvalds/linux/commit/f5364c150aa645b3d7daa21b5c0b9feaa1c9cd6d",
        "vul_func_with_fix": "void __init sched_init_smp(void)\n{\n\tcpumask_var_t non_isolated_cpus;\n\n\talloc_cpumask_var(&non_isolated_cpus, GFP_KERNEL);\n\talloc_cpumask_var(&fallback_doms, GFP_KERNEL);\n\n\tsched_init_numa();\n\n\t/*\n\t * There's no userspace yet to cause hotplug operations; hence all the\n\t * cpu masks are stable and all blatant races in the below code cannot\n\t * happen.\n\t */\n\tmutex_lock(&sched_domains_mutex);\n\tinit_sched_domains(cpu_active_mask);\n\tcpumask_andnot(non_isolated_cpus, cpu_possible_mask, cpu_isolated_map);\n\tif (cpumask_empty(non_isolated_cpus))\n\t\tcpumask_set_cpu(smp_processor_id(), non_isolated_cpus);\n\tmutex_unlock(&sched_domains_mutex);\n\n\t/* Move init over to a non-isolated CPU */\n\tif (set_cpus_allowed_ptr(current, non_isolated_cpus) < 0)\n\t\tBUG();\n\tsched_init_granularity();\n\tfree_cpumask_var(non_isolated_cpus);\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n\tsched_smp_initialized = true;\n}\n",
        "linevul": 5.372854138840921e-05,
        "sysevr": 0.17123618721961975,
        "devign": 0.6276456117630005
    }
]