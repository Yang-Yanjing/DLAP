[
    {
        "code": "static inline int virtio_scsi_get_lun(uint8_t *lun)\n{\n    return ((lun[2] << 8) | lun[3]) & 0x3FFF;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3c3ce981423e0d6c18af82ee62f1850c2cda5976",
        "vul_func_with_fix": "static inline int virtio_scsi_get_lun(uint8_t *lun)\n{\n    return ((lun[2] << 8) | lun[3]) & 0x3FFF;\n}\n",
        "linevul": 5.232506737229414e-05
    },
    {
        "code": "static void ahci_check_irq(AHCIState *s)\n{\n    int i;\n\n    DPRINTF(-1, \"check irq %#x\\n\", s->control_regs.irqstatus);\n\n    s->control_regs.irqstatus = 0;\n    for (i = 0; i < s->ports; i++) {\n        AHCIPortRegs *pr = &s->dev[i].port_regs;\n        if (pr->irq_stat & pr->irq_mask) {\n            s->control_regs.irqstatus |= (1 << i);\n        }\n    }\n\n    if (s->control_regs.irqstatus &&\n        (s->control_regs.ghc & HOST_CTL_IRQ_EN)) {\n            ahci_irq_raise(s, NULL);\n    } else {\n        ahci_irq_lower(s, NULL);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_check_irq(AHCIState *s)\n{\n    int i;\n\n    DPRINTF(-1, \"check irq %#x\\n\", s->control_regs.irqstatus);\n\n    s->control_regs.irqstatus = 0;\n    for (i = 0; i < s->ports; i++) {\n        AHCIPortRegs *pr = &s->dev[i].port_regs;\n        if (pr->irq_stat & pr->irq_mask) {\n            s->control_regs.irqstatus |= (1 << i);\n        }\n    }\n\n    if (s->control_regs.irqstatus &&\n        (s->control_regs.ghc & HOST_CTL_IRQ_EN)) {\n            ahci_irq_raise(s, NULL);\n    } else {\n        ahci_irq_lower(s, NULL);\n    }\n}\n",
        "linevul": 4.872629142482765e-05
    },
    {
        "code": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n\n    trace_mptsas_reset(s);\n\n    /* Temporarily disable interrupts */\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n\n    qbus_reset_all(&s->bus.qbus);\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n\n    s->state = MPI_IOC_STATE_READY;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n\n    trace_mptsas_reset(s);\n\n    /* Temporarily disable interrupts */\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n\n    qbus_reset_all(&s->bus.qbus);\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n\n    s->state = MPI_IOC_STATE_READY;\n}\n",
        "linevul": 4.634485230781138e-05
    },
    {
        "code": "static TRBCCode xhci_reset_ep(XHCIState *xhci, unsigned int slotid,\n                              unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n\n    trace_usb_xhci_ep_reset(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    if (epid < 1 || epid > 31) {\n        DPRINTF(\"xhci: bad ep %d\\n\", epid);\n        return CC_TRB_ERROR;\n    }\n\n    slot = &xhci->slots[slotid-1];\n\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d not enabled\\n\", slotid, epid);\n        return CC_EP_NOT_ENABLED_ERROR;\n    }\n\n    epctx = slot->eps[epid-1];\n\n    if (epctx->state != EP_HALTED) {\n        DPRINTF(\"xhci: reset EP while EP %d not halted (%d)\\n\",\n                epid, epctx->state);\n        return CC_CONTEXT_STATE_ERROR;\n    }\n\n    if (xhci_ep_nuke_xfers(xhci, slotid, epid, 0) > 0) {\n        DPRINTF(\"xhci: FIXME: endpoint reset w/ xfers running, \"\n                \"data might be lost\\n\");\n    }\n\n    if (!xhci->slots[slotid-1].uport ||\n        !xhci->slots[slotid-1].uport->dev ||\n        !xhci->slots[slotid-1].uport->dev->attached) {\n        return CC_USB_TRANSACTION_ERROR;\n    }\n\n    xhci_set_ep_state(xhci, epctx, NULL, EP_STOPPED);\n\n    if (epctx->nr_pstreams) {\n        xhci_reset_streams(epctx);\n    }\n\n    return CC_SUCCESS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static TRBCCode xhci_reset_ep(XHCIState *xhci, unsigned int slotid,\n                              unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n\n    trace_usb_xhci_ep_reset(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    if (epid < 1 || epid > 31) {\n        DPRINTF(\"xhci: bad ep %d\\n\", epid);\n        return CC_TRB_ERROR;\n    }\n\n    slot = &xhci->slots[slotid-1];\n\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d not enabled\\n\", slotid, epid);\n        return CC_EP_NOT_ENABLED_ERROR;\n    }\n\n    epctx = slot->eps[epid-1];\n\n    if (epctx->state != EP_HALTED) {\n        DPRINTF(\"xhci: reset EP while EP %d not halted (%d)\\n\",\n                epid, epctx->state);\n        return CC_CONTEXT_STATE_ERROR;\n    }\n\n    if (xhci_ep_nuke_xfers(xhci, slotid, epid, 0) > 0) {\n        DPRINTF(\"xhci: FIXME: endpoint reset w/ xfers running, \"\n                \"data might be lost\\n\");\n    }\n\n    if (!xhci->slots[slotid-1].uport ||\n        !xhci->slots[slotid-1].uport->dev ||\n        !xhci->slots[slotid-1].uport->dev->attached) {\n        return CC_USB_TRANSACTION_ERROR;\n    }\n\n    xhci_set_ep_state(xhci, epctx, NULL, EP_STOPPED);\n\n    if (epctx->nr_pstreams) {\n        xhci_reset_streams(epctx);\n    }\n\n    return CC_SUCCESS;\n}\n",
        "linevul": 4.560528032016009e-05
    },
    {
        "code": "static void ahci_restart_dma(IDEDMA *dma)\n{\n    /* Nothing to do, ahci_start_dma already resets s->io_buffer_offset.  */\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_restart_dma(IDEDMA *dma)\n{\n    /* Nothing to do, ahci_start_dma already resets s->io_buffer_offset.  */\n}\n",
        "linevul": 6.644434324698523e-05
    },
    {
        "code": "BlockDriverState *bdrv_new(const char *device_name)\n{\n    BlockDriverState *bs;\n\n    bs = g_malloc0(sizeof(BlockDriverState));\n    QLIST_INIT(&bs->dirty_bitmaps);\n    pstrcpy(bs->device_name, sizeof(bs->device_name), device_name);\n    if (device_name[0] != '\\0') {\n        QTAILQ_INSERT_TAIL(&bdrv_states, bs, device_list);\n    }\n    bdrv_iostatus_disable(bs);\n    notifier_list_init(&bs->close_notifiers);\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n    qemu_co_queue_init(&bs->throttled_reqs[0]);\n    qemu_co_queue_init(&bs->throttled_reqs[1]);\n    bs->refcnt = 1;\n\n    return bs;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "BlockDriverState *bdrv_new(const char *device_name)\n{\n    BlockDriverState *bs;\n\n    bs = g_malloc0(sizeof(BlockDriverState));\n    QLIST_INIT(&bs->dirty_bitmaps);\n    pstrcpy(bs->device_name, sizeof(bs->device_name), device_name);\n    if (device_name[0] != '\\0') {\n        QTAILQ_INSERT_TAIL(&bdrv_states, bs, device_list);\n    }\n    bdrv_iostatus_disable(bs);\n    notifier_list_init(&bs->close_notifiers);\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n    qemu_co_queue_init(&bs->throttled_reqs[0]);\n    qemu_co_queue_init(&bs->throttled_reqs[1]);\n    bs->refcnt = 1;\n\n    return bs;\n}\n",
        "linevul": 9.483971371082589e-05
    },
    {
        "code": "static uint64_t cirrus_linear_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    addr &= s->cirrus_addr_mask;\n\n    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&\n        ((addr & s->linear_mmio_mask) == s->linear_mmio_mask)) {\n\t/* memory-mapped I/O */\n\tret = cirrus_mmio_blt_read(s, addr & 0xff);\n    } else if (0) {\n\t/* XXX handle bitblt */\n\tret = 0xff;\n    } else {\n\t/* video memory */\n\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t    addr <<= 4;\n\t} else if (s->vga.gr[0x0B] & 0x02) {\n\t    addr <<= 3;\n\t}\n\taddr &= s->cirrus_addr_mask;\n\tret = *(s->vga.vram_ptr + addr);\n    }\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static uint64_t cirrus_linear_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    addr &= s->cirrus_addr_mask;\n\n    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&\n        ((addr & s->linear_mmio_mask) == s->linear_mmio_mask)) {\n\t/* memory-mapped I/O */\n\tret = cirrus_mmio_blt_read(s, addr & 0xff);\n    } else if (0) {\n\t/* XXX handle bitblt */\n\tret = 0xff;\n    } else {\n\t/* video memory */\n\tif ((s->vga.gr[0x0B] & 0x14) == 0x14) {\n\t    addr <<= 4;\n\t} else if (s->vga.gr[0x0B] & 0x02) {\n\t    addr <<= 3;\n\t}\n\taddr &= s->cirrus_addr_mask;\n\tret = *(s->vga.vram_ptr + addr);\n    }\n\n    return ret;\n}\n",
        "linevul": 5.075243461760692e-05
    },
    {
        "code": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* Make the file fid point to xattr */\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ff55e94d23ae94c8628b0115320157c763eb3e06",
        "vul_func_with_fix": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* Make the file fid point to xattr */\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n//fix_flaw_line_below:\n//    g_free(xattr_fidp->fs.xattr.value);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "linevul": 0.0016609113663434982
    },
    {
        "code": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n {\n     VMXNET3State *s = opaque;\n \n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n         int tx_queue_idx =\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6c352ca9b4ee3e1e286ea9e8434bd8e69ac7d0d8",
        "vul_func_with_fix": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n {\n     VMXNET3State *s = opaque;\n \n//fix_flaw_line_below:\n//    if (!s->device_active) {\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n         int tx_queue_idx =\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}\n",
        "linevul": 0.9992202520370483
    },
    {
        "code": "int vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int i;\n    uint8_t *row;\n    VncDisplay *vd = vs->vd;\n\n    row = vnc_server_fb_ptr(vd, x, y);\n    for (i = 0; i < h; i++) {\n        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n        row += vnc_server_fb_stride(vd);\n    }\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "int vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    int i;\n    uint8_t *row;\n    VncDisplay *vd = vs->vd;\n\n    row = vnc_server_fb_ptr(vd, x, y);\n    for (i = 0; i < h; i++) {\n        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n        row += vnc_server_fb_stride(vd);\n    }\n    return 1;\n}\n",
        "linevul": 4.5359873183770105e-05
    },
    {
        "code": "static bool cmd_identify_packet(IDEState *s, uint8_t cmd)\n{\n    ide_atapi_identify(s);\n    s->status = READY_STAT | SEEK_STAT;\n    ide_transfer_start(s, s->io_buffer, 512, ide_transfer_stop);\n    ide_set_irq(s->bus);\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_identify_packet(IDEState *s, uint8_t cmd)\n{\n    ide_atapi_identify(s);\n    s->status = READY_STAT | SEEK_STAT;\n    ide_transfer_start(s, s->io_buffer, 512, ide_transfer_stop);\n    ide_set_irq(s->bus);\n    return false;\n}\n",
        "linevul": 4.788387377629988e-05
    },
    {
        "code": "static TRBCCode xhci_configure_slot(XHCIState *xhci, unsigned int slotid,\n                                  uint64_t pictx, bool dc)\n{\n    dma_addr_t ictx, octx;\n    uint32_t ictl_ctx[2];\n    uint32_t slot_ctx[4];\n    uint32_t islot_ctx[4];\n    uint32_t ep_ctx[5];\n    int i;\n    TRBCCode res;\n\n    trace_usb_xhci_slot_configure(slotid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    ictx = xhci_mask64(pictx);\n    octx = xhci->slots[slotid-1].ctx;\n\n    DPRINTF(\"xhci: input context at \"DMA_ADDR_FMT\"\\n\", ictx);\n    DPRINTF(\"xhci: output context at \"DMA_ADDR_FMT\"\\n\", octx);\n\n    if (dc) {\n        for (i = 2; i <= 31; i++) {\n            if (xhci->slots[slotid-1].eps[i-1]) {\n                xhci_disable_ep(xhci, slotid, i);\n            }\n        }\n\n        xhci_dma_read_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n        slot_ctx[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);\n        slot_ctx[3] |= SLOT_ADDRESSED << SLOT_STATE_SHIFT;\n        DPRINTF(\"xhci: output slot context: %08x %08x %08x %08x\\n\",\n                slot_ctx[0], slot_ctx[1], slot_ctx[2], slot_ctx[3]);\n        xhci_dma_write_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n\n        return CC_SUCCESS;\n    }\n\n    xhci_dma_read_u32s(xhci, ictx, ictl_ctx, sizeof(ictl_ctx));\n\n    if ((ictl_ctx[0] & 0x3) != 0x0 || (ictl_ctx[1] & 0x3) != 0x1) {\n        DPRINTF(\"xhci: invalid input context control %08x %08x\\n\",\n                ictl_ctx[0], ictl_ctx[1]);\n        return CC_TRB_ERROR;\n    }\n\n    xhci_dma_read_u32s(xhci, ictx+32, islot_ctx, sizeof(islot_ctx));\n    xhci_dma_read_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n\n    if (SLOT_STATE(slot_ctx[3]) < SLOT_ADDRESSED) {\n        DPRINTF(\"xhci: invalid slot state %08x\\n\", slot_ctx[3]);\n        return CC_CONTEXT_STATE_ERROR;\n    }\n\n    xhci_free_device_streams(xhci, slotid, ictl_ctx[0] | ictl_ctx[1]);\n\n    for (i = 2; i <= 31; i++) {\n        if (ictl_ctx[0] & (1<<i)) {\n            xhci_disable_ep(xhci, slotid, i);\n        }\n        if (ictl_ctx[1] & (1<<i)) {\n            xhci_dma_read_u32s(xhci, ictx+32+(32*i), ep_ctx, sizeof(ep_ctx));\n            DPRINTF(\"xhci: input ep%d.%d context: %08x %08x %08x %08x %08x\\n\",\n                    i/2, i%2, ep_ctx[0], ep_ctx[1], ep_ctx[2],\n                    ep_ctx[3], ep_ctx[4]);\n            xhci_disable_ep(xhci, slotid, i);\n            res = xhci_enable_ep(xhci, slotid, i, octx+(32*i), ep_ctx);\n            if (res != CC_SUCCESS) {\n                return res;\n            }\n            DPRINTF(\"xhci: output ep%d.%d context: %08x %08x %08x %08x %08x\\n\",\n                    i/2, i%2, ep_ctx[0], ep_ctx[1], ep_ctx[2],\n                    ep_ctx[3], ep_ctx[4]);\n            xhci_dma_write_u32s(xhci, octx+(32*i), ep_ctx, sizeof(ep_ctx));\n        }\n    }\n\n    res = xhci_alloc_device_streams(xhci, slotid, ictl_ctx[1]);\n    if (res != CC_SUCCESS) {\n        for (i = 2; i <= 31; i++) {\n            if (ictl_ctx[1] & (1u << i)) {\n                xhci_disable_ep(xhci, slotid, i);\n            }\n        }\n        return res;\n    }\n\n    slot_ctx[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);\n    slot_ctx[3] |= SLOT_CONFIGURED << SLOT_STATE_SHIFT;\n    slot_ctx[0] &= ~(SLOT_CONTEXT_ENTRIES_MASK << SLOT_CONTEXT_ENTRIES_SHIFT);\n    slot_ctx[0] |= islot_ctx[0] & (SLOT_CONTEXT_ENTRIES_MASK <<\n                                   SLOT_CONTEXT_ENTRIES_SHIFT);\n    DPRINTF(\"xhci: output slot context: %08x %08x %08x %08x\\n\",\n            slot_ctx[0], slot_ctx[1], slot_ctx[2], slot_ctx[3]);\n\n    xhci_dma_write_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n\n    return CC_SUCCESS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static TRBCCode xhci_configure_slot(XHCIState *xhci, unsigned int slotid,\n                                  uint64_t pictx, bool dc)\n{\n    dma_addr_t ictx, octx;\n    uint32_t ictl_ctx[2];\n    uint32_t slot_ctx[4];\n    uint32_t islot_ctx[4];\n    uint32_t ep_ctx[5];\n    int i;\n    TRBCCode res;\n\n    trace_usb_xhci_slot_configure(slotid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    ictx = xhci_mask64(pictx);\n    octx = xhci->slots[slotid-1].ctx;\n\n    DPRINTF(\"xhci: input context at \"DMA_ADDR_FMT\"\\n\", ictx);\n    DPRINTF(\"xhci: output context at \"DMA_ADDR_FMT\"\\n\", octx);\n\n    if (dc) {\n        for (i = 2; i <= 31; i++) {\n            if (xhci->slots[slotid-1].eps[i-1]) {\n                xhci_disable_ep(xhci, slotid, i);\n            }\n        }\n\n        xhci_dma_read_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n        slot_ctx[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);\n        slot_ctx[3] |= SLOT_ADDRESSED << SLOT_STATE_SHIFT;\n        DPRINTF(\"xhci: output slot context: %08x %08x %08x %08x\\n\",\n                slot_ctx[0], slot_ctx[1], slot_ctx[2], slot_ctx[3]);\n        xhci_dma_write_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n\n        return CC_SUCCESS;\n    }\n\n    xhci_dma_read_u32s(xhci, ictx, ictl_ctx, sizeof(ictl_ctx));\n\n    if ((ictl_ctx[0] & 0x3) != 0x0 || (ictl_ctx[1] & 0x3) != 0x1) {\n        DPRINTF(\"xhci: invalid input context control %08x %08x\\n\",\n                ictl_ctx[0], ictl_ctx[1]);\n        return CC_TRB_ERROR;\n    }\n\n    xhci_dma_read_u32s(xhci, ictx+32, islot_ctx, sizeof(islot_ctx));\n    xhci_dma_read_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n\n    if (SLOT_STATE(slot_ctx[3]) < SLOT_ADDRESSED) {\n        DPRINTF(\"xhci: invalid slot state %08x\\n\", slot_ctx[3]);\n        return CC_CONTEXT_STATE_ERROR;\n    }\n\n    xhci_free_device_streams(xhci, slotid, ictl_ctx[0] | ictl_ctx[1]);\n\n    for (i = 2; i <= 31; i++) {\n        if (ictl_ctx[0] & (1<<i)) {\n            xhci_disable_ep(xhci, slotid, i);\n        }\n        if (ictl_ctx[1] & (1<<i)) {\n            xhci_dma_read_u32s(xhci, ictx+32+(32*i), ep_ctx, sizeof(ep_ctx));\n            DPRINTF(\"xhci: input ep%d.%d context: %08x %08x %08x %08x %08x\\n\",\n                    i/2, i%2, ep_ctx[0], ep_ctx[1], ep_ctx[2],\n                    ep_ctx[3], ep_ctx[4]);\n            xhci_disable_ep(xhci, slotid, i);\n            res = xhci_enable_ep(xhci, slotid, i, octx+(32*i), ep_ctx);\n            if (res != CC_SUCCESS) {\n                return res;\n            }\n            DPRINTF(\"xhci: output ep%d.%d context: %08x %08x %08x %08x %08x\\n\",\n                    i/2, i%2, ep_ctx[0], ep_ctx[1], ep_ctx[2],\n                    ep_ctx[3], ep_ctx[4]);\n            xhci_dma_write_u32s(xhci, octx+(32*i), ep_ctx, sizeof(ep_ctx));\n        }\n    }\n\n    res = xhci_alloc_device_streams(xhci, slotid, ictl_ctx[1]);\n    if (res != CC_SUCCESS) {\n        for (i = 2; i <= 31; i++) {\n            if (ictl_ctx[1] & (1u << i)) {\n                xhci_disable_ep(xhci, slotid, i);\n            }\n        }\n        return res;\n    }\n\n    slot_ctx[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);\n    slot_ctx[3] |= SLOT_CONFIGURED << SLOT_STATE_SHIFT;\n    slot_ctx[0] &= ~(SLOT_CONTEXT_ENTRIES_MASK << SLOT_CONTEXT_ENTRIES_SHIFT);\n    slot_ctx[0] |= islot_ctx[0] & (SLOT_CONTEXT_ENTRIES_MASK <<\n                                   SLOT_CONTEXT_ENTRIES_SHIFT);\n    DPRINTF(\"xhci: output slot context: %08x %08x %08x %08x\\n\",\n            slot_ctx[0], slot_ctx[1], slot_ctx[2], slot_ctx[3]);\n\n    xhci_dma_write_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n\n    return CC_SUCCESS;\n}\n",
        "linevul": 4.726411498268135e-05
    },
    {
        "code": "static int tight_fill_palette(VncState *vs, int x, int y,\n                              size_t count, uint32_t *bg, uint32_t *fg,\n                              VncPalette **palette)\n{\n    int max;\n\n    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;\n    if (max < 2 &&\n        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {\n        max = 2;\n    }\n    if (max >= 256) {\n         max = 256;\n     }\n \n    switch(vs->clientds.pf.bytes_per_pixel) {\n     case 4:\n         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);\n     case 2:\n        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);\n    default:\n        max = 2;\n        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);\n    }\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static int tight_fill_palette(VncState *vs, int x, int y,\n                              size_t count, uint32_t *bg, uint32_t *fg,\n                              VncPalette **palette)\n{\n    int max;\n\n    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;\n    if (max < 2 &&\n        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {\n        max = 2;\n    }\n    if (max >= 256) {\n         max = 256;\n     }\n \n//flaw_line_below:\n    switch(vs->clientds.pf.bytes_per_pixel) {\n//fix_flaw_line_below:\n//    switch (vs->client_pf.bytes_per_pixel) {\n     case 4:\n         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);\n     case 2:\n        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);\n    default:\n        max = 2;\n        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);\n    }\n    return 0;\n}\n",
        "linevul": 0.993160605430603
    },
    {
        "code": "static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,\n                uint32_t c, int x, int y, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    int bypl = surface_stride(surface);\n    int width = surface_bytes_per_pixel(surface) * w;\n    int line = h;\n    int column;\n    uint8_t *fst;\n    uint8_t *dst;\n    uint8_t *src;\n    uint8_t col[4];\n\n    if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {\n        return -1;\n    }\n\n    col[0] = c;\n    col[1] = c >> 8;\n    col[2] = c >> 16;\n    col[3] = c >> 24;\n\n    fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;\n\n    if (line--) {\n        dst = fst;\n        src = col;\n        for (column = width; column > 0; column--) {\n            *(dst++) = *(src++);\n            if (src - col == surface_bytes_per_pixel(surface)) {\n                src = col;\n            }\n        }\n        dst = fst;\n        for (; line > 0; line--) {\n            dst += bypl;\n            memcpy(dst, fst, width);\n        }\n    }\n\n    vmsvga_update_rect_delayed(s, x, y, w, h);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static inline int vmsvga_fill_rect(struct vmsvga_state_s *s,\n                uint32_t c, int x, int y, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    int bypl = surface_stride(surface);\n    int width = surface_bytes_per_pixel(surface) * w;\n    int line = h;\n    int column;\n    uint8_t *fst;\n    uint8_t *dst;\n    uint8_t *src;\n    uint8_t col[4];\n\n    if (!vmsvga_verify_rect(surface, __func__, x, y, w, h)) {\n        return -1;\n    }\n\n    col[0] = c;\n    col[1] = c >> 8;\n    col[2] = c >> 16;\n    col[3] = c >> 24;\n\n    fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;\n\n    if (line--) {\n        dst = fst;\n        src = col;\n        for (column = width; column > 0; column--) {\n            *(dst++) = *(src++);\n            if (src - col == surface_bytes_per_pixel(surface)) {\n                src = col;\n            }\n        }\n        dst = fst;\n        for (; line > 0; line--) {\n            dst += bypl;\n            memcpy(dst, fst, width);\n        }\n    }\n\n    vmsvga_update_rect_delayed(s, x, y, w, h);\n    return 0;\n}\n",
        "linevul": 5.332346700015478e-05
    },
    {
        "code": "static int32_t virtio_net_flush_tx(VirtIONetQueue *q)\n{\n    VirtIONet *n = q->n;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    VirtQueueElement elem;\n    int32_t num_packets = 0;\n    int queue_index = vq2q(virtio_get_queue_index(q->tx_vq));\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        return num_packets;\n    }\n\n    assert(vdev->vm_running);\n\n    if (q->async_tx.elem.out_num) {\n        virtio_queue_set_notification(q->tx_vq, 0);\n        return num_packets;\n    }\n\n    while (virtqueue_pop(q->tx_vq, &elem)) {\n        ssize_t ret, len;\n        unsigned int out_num = elem.out_num;\n        struct iovec *out_sg = &elem.out_sg[0];\n        struct iovec sg[VIRTQUEUE_MAX_SIZE];\n\n        if (out_num < 1) {\n            error_report(\"virtio-net header not in first element\");\n            exit(1);\n        }\n\n        /*\n         * If host wants to see the guest header as is, we can\n         * pass it on unchanged. Otherwise, copy just the parts\n         * that host is interested in.\n         */\n        assert(n->host_hdr_len <= n->guest_hdr_len);\n        if (n->host_hdr_len != n->guest_hdr_len) {\n            unsigned sg_num = iov_copy(sg, ARRAY_SIZE(sg),\n                                       out_sg, out_num,\n                                       0, n->host_hdr_len);\n            sg_num += iov_copy(sg + sg_num, ARRAY_SIZE(sg) - sg_num,\n                             out_sg, out_num,\n                             n->guest_hdr_len, -1);\n            out_num = sg_num;\n            out_sg = sg;\n        }\n\n        len = n->guest_hdr_len;\n\n        ret = qemu_sendv_packet_async(qemu_get_subqueue(n->nic, queue_index),\n                                      out_sg, out_num, virtio_net_tx_complete);\n        if (ret == 0) {\n            virtio_queue_set_notification(q->tx_vq, 0);\n            q->async_tx.elem = elem;\n            q->async_tx.len  = len;\n            return -EBUSY;\n        }\n\n        len += ret;\n\n        virtqueue_push(q->tx_vq, &elem, 0);\n        virtio_notify(vdev, q->tx_vq);\n\n        if (++num_packets >= n->tx_burst) {\n            break;\n        }\n    }\n    return num_packets;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static int32_t virtio_net_flush_tx(VirtIONetQueue *q)\n{\n    VirtIONet *n = q->n;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    VirtQueueElement elem;\n    int32_t num_packets = 0;\n    int queue_index = vq2q(virtio_get_queue_index(q->tx_vq));\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        return num_packets;\n    }\n\n    assert(vdev->vm_running);\n\n    if (q->async_tx.elem.out_num) {\n        virtio_queue_set_notification(q->tx_vq, 0);\n        return num_packets;\n    }\n\n    while (virtqueue_pop(q->tx_vq, &elem)) {\n        ssize_t ret, len;\n        unsigned int out_num = elem.out_num;\n        struct iovec *out_sg = &elem.out_sg[0];\n        struct iovec sg[VIRTQUEUE_MAX_SIZE];\n\n        if (out_num < 1) {\n            error_report(\"virtio-net header not in first element\");\n            exit(1);\n        }\n\n        /*\n         * If host wants to see the guest header as is, we can\n         * pass it on unchanged. Otherwise, copy just the parts\n         * that host is interested in.\n         */\n        assert(n->host_hdr_len <= n->guest_hdr_len);\n        if (n->host_hdr_len != n->guest_hdr_len) {\n            unsigned sg_num = iov_copy(sg, ARRAY_SIZE(sg),\n                                       out_sg, out_num,\n                                       0, n->host_hdr_len);\n            sg_num += iov_copy(sg + sg_num, ARRAY_SIZE(sg) - sg_num,\n                             out_sg, out_num,\n                             n->guest_hdr_len, -1);\n            out_num = sg_num;\n            out_sg = sg;\n        }\n\n        len = n->guest_hdr_len;\n\n        ret = qemu_sendv_packet_async(qemu_get_subqueue(n->nic, queue_index),\n                                      out_sg, out_num, virtio_net_tx_complete);\n        if (ret == 0) {\n            virtio_queue_set_notification(q->tx_vq, 0);\n            q->async_tx.elem = elem;\n            q->async_tx.len  = len;\n            return -EBUSY;\n        }\n\n        len += ret;\n\n        virtqueue_push(q->tx_vq, &elem, 0);\n        virtio_notify(vdev, q->tx_vq);\n\n        if (++num_packets >= n->tx_burst) {\n            break;\n        }\n    }\n    return num_packets;\n}\n",
        "linevul": 5.156460247235373e-05
    },
    {
        "code": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n     rc = 0;\n out:\n     if (rc) {\n        g_free(s->ctx.fs_root);\n         g_free(s->tag);\n         v9fs_path_free(&path);\n     }\n     return rc;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n     rc = 0;\n out:\n     if (rc) {\n//flaw_line_below:\n        g_free(s->ctx.fs_root);\n         g_free(s->tag);\n//fix_flaw_line_below:\n//        g_free(s->ctx.fs_root);\n         v9fs_path_free(&path);\n     }\n     return rc;\n}\n",
        "linevul": 0.00033286851248703897
    },
    {
        "code": "static V9fsFidState *coroutine_fn get_fid(V9fsPDU *pdu, int32_t fid)\n{\n    int err;\n    V9fsFidState *f;\n    V9fsState *s = pdu->s;\n\n    for (f = s->fid_list; f; f = f->next) {\n        BUG_ON(f->clunked);\n        if (f->fid == fid) {\n            /*\n             * Update the fid ref upfront so that\n             * we don't get reclaimed when we yield\n             * in open later.\n             */\n            f->ref++;\n            /*\n             * check whether we need to reopen the\n             * file. We might have closed the fd\n             * while trying to free up some file\n             * descriptors.\n             */\n            err = v9fs_reopen_fid(pdu, f);\n            if (err < 0) {\n                f->ref--;\n                return NULL;\n            }\n            /*\n             * Mark the fid as referenced so that the LRU\n             * reclaim won't close the file descriptor\n             */\n            f->flags |= FID_REFERENCED;\n            return f;\n        }\n    }\n    return NULL;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static V9fsFidState *coroutine_fn get_fid(V9fsPDU *pdu, int32_t fid)\n{\n    int err;\n    V9fsFidState *f;\n    V9fsState *s = pdu->s;\n\n    for (f = s->fid_list; f; f = f->next) {\n        BUG_ON(f->clunked);\n        if (f->fid == fid) {\n            /*\n             * Update the fid ref upfront so that\n             * we don't get reclaimed when we yield\n             * in open later.\n             */\n            f->ref++;\n            /*\n             * check whether we need to reopen the\n             * file. We might have closed the fd\n             * while trying to free up some file\n             * descriptors.\n             */\n            err = v9fs_reopen_fid(pdu, f);\n            if (err < 0) {\n                f->ref--;\n                return NULL;\n            }\n            /*\n             * Mark the fid as referenced so that the LRU\n             * reclaim won't close the file descriptor\n             */\n            f->flags |= FID_REFERENCED;\n            return f;\n        }\n    }\n    return NULL;\n}\n",
        "linevul": 8.573380182497203e-05
    },
    {
        "code": "void vbe_ioport_write_data(void *opaque, uint32_t addr, uint32_t val)\n{\n    VGACommonState *s = opaque;\n\n    if (s->vbe_index <= VBE_DISPI_INDEX_NB) {\n        trace_vga_vbe_write(s->vbe_index, val);\n        switch(s->vbe_index) {\n        case VBE_DISPI_INDEX_ID:\n            if (val == VBE_DISPI_ID0 ||\n                val == VBE_DISPI_ID1 ||\n                val == VBE_DISPI_ID2 ||\n                val == VBE_DISPI_ID3 ||\n                val == VBE_DISPI_ID4) {\n                s->vbe_regs[s->vbe_index] = val;\n            }\n            break;\n        case VBE_DISPI_INDEX_XRES:\n        case VBE_DISPI_INDEX_YRES:\n        case VBE_DISPI_INDEX_BPP:\n        case VBE_DISPI_INDEX_VIRT_WIDTH:\n        case VBE_DISPI_INDEX_X_OFFSET:\n        case VBE_DISPI_INDEX_Y_OFFSET:\n            s->vbe_regs[s->vbe_index] = val;\n            vbe_fixup_regs(s);\n            vbe_update_vgaregs(s);\n            break;\n        case VBE_DISPI_INDEX_BANK:\n            val &= s->vbe_bank_mask;\n            s->vbe_regs[s->vbe_index] = val;\n            s->bank_offset = (val << 16);\n            vga_update_memory_access(s);\n            break;\n        case VBE_DISPI_INDEX_ENABLE:\n            if ((val & VBE_DISPI_ENABLED) &&\n                !(s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED)) {\n\n                s->vbe_regs[VBE_DISPI_INDEX_VIRT_WIDTH] = 0;\n                s->vbe_regs[VBE_DISPI_INDEX_X_OFFSET] = 0;\n                s->vbe_regs[VBE_DISPI_INDEX_Y_OFFSET] = 0;\n                s->vbe_regs[VBE_DISPI_INDEX_ENABLE] |= VBE_DISPI_ENABLED;\n                vbe_fixup_regs(s);\n                vbe_update_vgaregs(s);\n\n                /* clear the screen */\n                if (!(val & VBE_DISPI_NOCLEARMEM)) {\n                    memset(s->vram_ptr, 0,\n                           s->vbe_regs[VBE_DISPI_INDEX_YRES] * s->vbe_line_offset);\n                }\n            } else {\n                s->bank_offset = 0;\n            }\n            s->dac_8bit = (val & VBE_DISPI_8BIT_DAC) > 0;\n            s->vbe_regs[s->vbe_index] = val;\n            vga_update_memory_access(s);\n            break;\n        default:\n            break;\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "void vbe_ioport_write_data(void *opaque, uint32_t addr, uint32_t val)\n{\n    VGACommonState *s = opaque;\n\n    if (s->vbe_index <= VBE_DISPI_INDEX_NB) {\n        trace_vga_vbe_write(s->vbe_index, val);\n        switch(s->vbe_index) {\n        case VBE_DISPI_INDEX_ID:\n            if (val == VBE_DISPI_ID0 ||\n                val == VBE_DISPI_ID1 ||\n                val == VBE_DISPI_ID2 ||\n                val == VBE_DISPI_ID3 ||\n                val == VBE_DISPI_ID4) {\n                s->vbe_regs[s->vbe_index] = val;\n            }\n            break;\n        case VBE_DISPI_INDEX_XRES:\n        case VBE_DISPI_INDEX_YRES:\n        case VBE_DISPI_INDEX_BPP:\n        case VBE_DISPI_INDEX_VIRT_WIDTH:\n        case VBE_DISPI_INDEX_X_OFFSET:\n        case VBE_DISPI_INDEX_Y_OFFSET:\n            s->vbe_regs[s->vbe_index] = val;\n            vbe_fixup_regs(s);\n            vbe_update_vgaregs(s);\n            break;\n        case VBE_DISPI_INDEX_BANK:\n            val &= s->vbe_bank_mask;\n            s->vbe_regs[s->vbe_index] = val;\n            s->bank_offset = (val << 16);\n            vga_update_memory_access(s);\n            break;\n        case VBE_DISPI_INDEX_ENABLE:\n            if ((val & VBE_DISPI_ENABLED) &&\n                !(s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED)) {\n\n                s->vbe_regs[VBE_DISPI_INDEX_VIRT_WIDTH] = 0;\n                s->vbe_regs[VBE_DISPI_INDEX_X_OFFSET] = 0;\n                s->vbe_regs[VBE_DISPI_INDEX_Y_OFFSET] = 0;\n                s->vbe_regs[VBE_DISPI_INDEX_ENABLE] |= VBE_DISPI_ENABLED;\n                vbe_fixup_regs(s);\n                vbe_update_vgaregs(s);\n\n                /* clear the screen */\n                if (!(val & VBE_DISPI_NOCLEARMEM)) {\n                    memset(s->vram_ptr, 0,\n                           s->vbe_regs[VBE_DISPI_INDEX_YRES] * s->vbe_line_offset);\n                }\n            } else {\n                s->bank_offset = 0;\n            }\n            s->dac_8bit = (val & VBE_DISPI_8BIT_DAC) > 0;\n            s->vbe_regs[s->vbe_index] = val;\n            vga_update_memory_access(s);\n            break;\n        default:\n            break;\n        }\n    }\n}\n",
        "linevul": 6.260097870836034e-05
    },
    {
        "code": "static void ehci_trace_usbsts(uint32_t mask, int state)\n{\n    /* interrupts */\n    if (mask & USBSTS_INT) {\n        trace_usb_ehci_usbsts(\"INT\", state);\n    }\n    if (mask & USBSTS_ERRINT) {\n        trace_usb_ehci_usbsts(\"ERRINT\", state);\n    }\n    if (mask & USBSTS_PCD) {\n        trace_usb_ehci_usbsts(\"PCD\", state);\n    }\n    if (mask & USBSTS_FLR) {\n        trace_usb_ehci_usbsts(\"FLR\", state);\n    }\n    if (mask & USBSTS_HSE) {\n        trace_usb_ehci_usbsts(\"HSE\", state);\n    }\n    if (mask & USBSTS_IAA) {\n        trace_usb_ehci_usbsts(\"IAA\", state);\n    }\n\n    /* status */\n    if (mask & USBSTS_HALT) {\n        trace_usb_ehci_usbsts(\"HALT\", state);\n    }\n    if (mask & USBSTS_REC) {\n        trace_usb_ehci_usbsts(\"REC\", state);\n    }\n    if (mask & USBSTS_PSS) {\n        trace_usb_ehci_usbsts(\"PSS\", state);\n    }\n    if (mask & USBSTS_ASS) {\n        trace_usb_ehci_usbsts(\"ASS\", state);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_trace_usbsts(uint32_t mask, int state)\n{\n    /* interrupts */\n    if (mask & USBSTS_INT) {\n        trace_usb_ehci_usbsts(\"INT\", state);\n    }\n    if (mask & USBSTS_ERRINT) {\n        trace_usb_ehci_usbsts(\"ERRINT\", state);\n    }\n    if (mask & USBSTS_PCD) {\n        trace_usb_ehci_usbsts(\"PCD\", state);\n    }\n    if (mask & USBSTS_FLR) {\n        trace_usb_ehci_usbsts(\"FLR\", state);\n    }\n    if (mask & USBSTS_HSE) {\n        trace_usb_ehci_usbsts(\"HSE\", state);\n    }\n    if (mask & USBSTS_IAA) {\n        trace_usb_ehci_usbsts(\"IAA\", state);\n    }\n\n    /* status */\n    if (mask & USBSTS_HALT) {\n        trace_usb_ehci_usbsts(\"HALT\", state);\n    }\n    if (mask & USBSTS_REC) {\n        trace_usb_ehci_usbsts(\"REC\", state);\n    }\n    if (mask & USBSTS_PSS) {\n        trace_usb_ehci_usbsts(\"PSS\", state);\n    }\n    if (mask & USBSTS_ASS) {\n        trace_usb_ehci_usbsts(\"ASS\", state);\n    }\n}\n",
        "linevul": 5.491780393640511e-05
    },
    {
        "code": "static int validate_table_offset(BlockDriverState *bs, uint64_t offset,\n                                 uint64_t entries, size_t entry_len)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t size;\n\n    /* Use signed INT64_MAX as the maximum even for uint64_t header fields,\n     * because values will be passed to qemu functions taking int64_t. */\n    if (entries > INT64_MAX / entry_len) {\n        return -EINVAL;\n    }\n\n    size = entries * entry_len;\n\n    if (INT64_MAX - size < offset) {\n        return -EINVAL;\n    }\n\n    /* Tables must be cluster aligned */\n    if (offset & (s->cluster_size - 1)) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static int validate_table_offset(BlockDriverState *bs, uint64_t offset,\n                                 uint64_t entries, size_t entry_len)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t size;\n\n    /* Use signed INT64_MAX as the maximum even for uint64_t header fields,\n     * because values will be passed to qemu functions taking int64_t. */\n    if (entries > INT64_MAX / entry_len) {\n        return -EINVAL;\n    }\n\n    size = entries * entry_len;\n\n    if (INT64_MAX - size < offset) {\n        return -EINVAL;\n    }\n\n    /* Tables must be cluster aligned */\n    if (offset & (s->cluster_size - 1)) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n",
        "linevul": 8.323806832777336e-05
    },
    {
        "code": "static void virtio_net_handle_tx_timer(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q = &n->vqs[vq2q(virtio_get_queue_index(vq))];\n\n    /* This happens when device was stopped but VCPU wasn't. */\n    if (!vdev->vm_running) {\n        q->tx_waiting = 1;\n        return;\n    }\n\n    if (q->tx_waiting) {\n        virtio_queue_set_notification(vq, 1);\n        timer_del(q->tx_timer);\n        q->tx_waiting = 0;\n        virtio_net_flush_tx(q);\n    } else {\n        timer_mod(q->tx_timer,\n                       qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n        q->tx_waiting = 1;\n        virtio_queue_set_notification(vq, 0);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_handle_tx_timer(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q = &n->vqs[vq2q(virtio_get_queue_index(vq))];\n\n    /* This happens when device was stopped but VCPU wasn't. */\n    if (!vdev->vm_running) {\n        q->tx_waiting = 1;\n        return;\n    }\n\n    if (q->tx_waiting) {\n        virtio_queue_set_notification(vq, 1);\n        timer_del(q->tx_timer);\n        q->tx_waiting = 0;\n        virtio_net_flush_tx(q);\n    } else {\n        timer_mod(q->tx_timer,\n                       qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n        q->tx_waiting = 1;\n        virtio_queue_set_notification(vq, 0);\n    }\n}\n",
        "linevul": 6.0004033002769575e-05
    },
    {
        "code": "static void vmsvga_invalidate_display(void *opaque)\n{\n    struct vmsvga_state_s *s = opaque;\n    if (!s->enable) {\n        s->vga.hw_ops->invalidate(&s->vga);\n        return;\n    }\n\n    s->invalidated = 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static void vmsvga_invalidate_display(void *opaque)\n{\n    struct vmsvga_state_s *s = opaque;\n    if (!s->enable) {\n        s->vga.hw_ops->invalidate(&s->vga);\n        return;\n    }\n\n    s->invalidated = 1;\n}\n",
        "linevul": 4.660879130824469e-05
    },
    {
        "code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n \n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n \n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n \n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n \n//fix_flaw_line_below:\n//    memset(&txcq_descr, 0, sizeof(txcq_descr));\n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}\n",
        "linevul": 0.9984591007232666
    },
    {
        "code": "static void local_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    rewinddir(fs->dir.stream);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static void local_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n{\n    rewinddir(fs->dir.stream);\n}\n",
        "linevul": 5.27827360201627e-05
    },
    {
        "code": "static uint8_t lsi_get_msgbyte(LSIState *s)\n{\n    uint8_t data;\n    pci_dma_read(PCI_DEVICE(s), s->dnad, &data, 1);\n    s->dnad++;\n    s->dbc--;\n    return data;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08",
        "vul_func_with_fix": "static uint8_t lsi_get_msgbyte(LSIState *s)\n{\n    uint8_t data;\n    pci_dma_read(PCI_DEVICE(s), s->dnad, &data, 1);\n    s->dnad++;\n    s->dbc--;\n    return data;\n}\n",
        "linevul": 5.450137177831493e-05
    },
    {
        "code": "static void virtio_gpu_handle_cursor_cb(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n    qemu_bh_schedule(g->cursor_bh);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static void virtio_gpu_handle_cursor_cb(VirtIODevice *vdev, VirtQueue *vq)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n    qemu_bh_schedule(g->cursor_bh);\n}\n",
        "linevul": 4.640363476937637e-05
    },
    {
        "code": "vmxnet3_write_config(PCIDevice *pci_dev, uint32_t addr, uint32_t val, int len)\n{\n    pci_default_write_config(pci_dev, addr, val, len);\n    msix_write_config(pci_dev, addr, val, len);\n    msi_write_config(pci_dev, addr, val, len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484",
        "vul_func_with_fix": "vmxnet3_write_config(PCIDevice *pci_dev, uint32_t addr, uint32_t val, int len)\n{\n    pci_default_write_config(pci_dev, addr, val, len);\n    msix_write_config(pci_dev, addr, val, len);\n    msi_write_config(pci_dev, addr, val, len);\n}\n",
        "linevul": 4.950321454089135e-05
    },
    {
        "code": "e1000e_start_xmit(E1000ECore *core, const E1000E_TxRing *txr)\n{\n    dma_addr_t base;\n    struct e1000_tx_desc desc;\n    bool ide = false;\n    const E1000E_RingInfo *txi = txr->i;\n    uint32_t cause = E1000_ICS_TXQE;\n\n    if (!(core->mac[TCTL] & E1000_TCTL_EN)) {\n        trace_e1000e_tx_disabled();\n        return;\n    }\n\n    while (!e1000e_ring_empty(core, txi)) {\n        base = e1000e_ring_head_descr(core, txi);\n\n        pci_dma_read(core->owner, base, &desc, sizeof(desc));\n\n        trace_e1000e_tx_descr((void *)(intptr_t)desc.buffer_addr,\n                              desc.lower.data, desc.upper.data);\n\n        e1000e_process_tx_desc(core, txr->tx, &desc, txi->idx);\n        cause |= e1000e_txdesc_writeback(core, base, &desc, &ide, txi->idx);\n\n        e1000e_ring_advance(core, txi, 1);\n    }\n\n    if (!ide || !e1000e_intrmgr_delay_tx_causes(core, &cause)) {\n        e1000e_set_interrupt_cause(core, cause);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_start_xmit(E1000ECore *core, const E1000E_TxRing *txr)\n{\n    dma_addr_t base;\n    struct e1000_tx_desc desc;\n    bool ide = false;\n    const E1000E_RingInfo *txi = txr->i;\n    uint32_t cause = E1000_ICS_TXQE;\n\n    if (!(core->mac[TCTL] & E1000_TCTL_EN)) {\n        trace_e1000e_tx_disabled();\n        return;\n    }\n\n    while (!e1000e_ring_empty(core, txi)) {\n        base = e1000e_ring_head_descr(core, txi);\n\n        pci_dma_read(core->owner, base, &desc, sizeof(desc));\n\n        trace_e1000e_tx_descr((void *)(intptr_t)desc.buffer_addr,\n                              desc.lower.data, desc.upper.data);\n\n        e1000e_process_tx_desc(core, txr->tx, &desc, txi->idx);\n        cause |= e1000e_txdesc_writeback(core, base, &desc, &ide, txi->idx);\n\n        e1000e_ring_advance(core, txi, 1);\n    }\n\n    if (!ide || !e1000e_intrmgr_delay_tx_causes(core, &cause)) {\n        e1000e_set_interrupt_cause(core, cause);\n    }\n}\n",
        "linevul": 5.138984852237627e-05
    },
    {
        "code": "static void ohci_port_set_status(OHCIState *ohci, int portnum, uint32_t val)\n{\n    uint32_t old_state;\n    OHCIPort *port;\n\n    port = &ohci->rhport[portnum];\n    old_state = port->ctrl;\n\n    /* Write to clear CSC, PESC, PSSC, OCIC, PRSC */\n    if (val & OHCI_PORT_WTC)\n        port->ctrl &= ~(val & OHCI_PORT_WTC);\n\n    if (val & OHCI_PORT_CCS)\n        port->ctrl &= ~OHCI_PORT_PES;\n\n    ohci_port_set_if_connected(ohci, portnum, val & OHCI_PORT_PES);\n\n    if (ohci_port_set_if_connected(ohci, portnum, val & OHCI_PORT_PSS)) {\n        trace_usb_ohci_port_suspend(portnum);\n    }\n\n    if (ohci_port_set_if_connected(ohci, portnum, val & OHCI_PORT_PRS)) {\n        trace_usb_ohci_port_reset(portnum);\n        usb_device_reset(port->port.dev);\n        port->ctrl &= ~OHCI_PORT_PRS;\n        /* ??? Should this also set OHCI_PORT_PESC.  */\n        port->ctrl |= OHCI_PORT_PES | OHCI_PORT_PRSC;\n    }\n\n    /* Invert order here to ensure in ambiguous case, device is\n     * powered up...\n     */\n    if (val & OHCI_PORT_LSDA)\n        ohci_port_power(ohci, portnum, 0);\n    if (val & OHCI_PORT_PPS)\n        ohci_port_power(ohci, portnum, 1);\n\n    if (old_state != port->ctrl)\n        ohci_set_interrupt(ohci, OHCI_INTR_RHSC);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void ohci_port_set_status(OHCIState *ohci, int portnum, uint32_t val)\n{\n    uint32_t old_state;\n    OHCIPort *port;\n\n    port = &ohci->rhport[portnum];\n    old_state = port->ctrl;\n\n    /* Write to clear CSC, PESC, PSSC, OCIC, PRSC */\n    if (val & OHCI_PORT_WTC)\n        port->ctrl &= ~(val & OHCI_PORT_WTC);\n\n    if (val & OHCI_PORT_CCS)\n        port->ctrl &= ~OHCI_PORT_PES;\n\n    ohci_port_set_if_connected(ohci, portnum, val & OHCI_PORT_PES);\n\n    if (ohci_port_set_if_connected(ohci, portnum, val & OHCI_PORT_PSS)) {\n        trace_usb_ohci_port_suspend(portnum);\n    }\n\n    if (ohci_port_set_if_connected(ohci, portnum, val & OHCI_PORT_PRS)) {\n        trace_usb_ohci_port_reset(portnum);\n        usb_device_reset(port->port.dev);\n        port->ctrl &= ~OHCI_PORT_PRS;\n        /* ??? Should this also set OHCI_PORT_PESC.  */\n        port->ctrl |= OHCI_PORT_PES | OHCI_PORT_PRSC;\n    }\n\n    /* Invert order here to ensure in ambiguous case, device is\n     * powered up...\n     */\n    if (val & OHCI_PORT_LSDA)\n        ohci_port_power(ohci, portnum, 0);\n    if (val & OHCI_PORT_PPS)\n        ohci_port_power(ohci, portnum, 1);\n\n    if (old_state != port->ctrl)\n        ohci_set_interrupt(ohci, OHCI_INTR_RHSC);\n}\n",
        "linevul": 4.518067362369038e-05
    },
    {
        "code": "e1000e_write_ext_rx_descr(E1000ECore *core, uint8_t *desc,\n                          struct NetRxPkt *pkt,\n                          const E1000E_RSSInfo *rss_info,\n                          uint16_t length)\n{\n    union e1000_rx_desc_extended *d = (union e1000_rx_desc_extended *) desc;\n\n    memset(&d->wb, 0, sizeof(d->wb));\n\n    d->wb.upper.length = cpu_to_le16(length);\n\n    e1000e_build_rx_metadata(core, pkt, pkt != NULL,\n                             rss_info,\n                             &d->wb.lower.hi_dword.rss,\n                             &d->wb.lower.mrq,\n                             &d->wb.upper.status_error,\n                             &d->wb.lower.hi_dword.csum_ip.ip_id,\n                             &d->wb.upper.vlan);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_write_ext_rx_descr(E1000ECore *core, uint8_t *desc,\n                          struct NetRxPkt *pkt,\n                          const E1000E_RSSInfo *rss_info,\n                          uint16_t length)\n{\n    union e1000_rx_desc_extended *d = (union e1000_rx_desc_extended *) desc;\n\n    memset(&d->wb, 0, sizeof(d->wb));\n\n    d->wb.upper.length = cpu_to_le16(length);\n\n    e1000e_build_rx_metadata(core, pkt, pkt != NULL,\n                             rss_info,\n                             &d->wb.lower.hi_dword.rss,\n                             &d->wb.lower.mrq,\n                             &d->wb.upper.status_error,\n                             &d->wb.lower.hi_dword.csum_ip.ip_id,\n                             &d->wb.upper.vlan);\n}\n",
        "linevul": 5.204399712965824e-05
    },
    {
        "code": "static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG];\n \n     bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                             ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < ETH_MAX_L2_HDR_LEN) {\n         l2_hdr->iov_len = 0;\n         return false;\n    } else {\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n     }\n \n     l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        /* copy optional IPv4 header data */\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                l2_hdr->iov_len + sizeof(struct ip_header),\n                                l3_hdr->iov_base + sizeof(struct ip_header),\n                                l3_hdr->iov_len - sizeof(struct ip_header));\n        if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n        break;\n\n    case ETH_P_IPV6:\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                               &pkt->l4proto, &full_ip6hdr_len)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_base = g_malloc(full_ip6hdr_len);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a7278b36fcab9af469563bd7b",
        "vul_func_with_fix": "static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG];\n \n     bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                             ETH_MAX_L2_HDR_LEN);\n//flaw_line_below:\n    if (bytes_read < ETH_MAX_L2_HDR_LEN) {\n//fix_flaw_line_below:\n//    if (bytes_read < sizeof(struct eth_header)) {\n//fix_flaw_line_below:\n//        l2_hdr->iov_len = 0;\n//fix_flaw_line_below:\n//        return false;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    l2_hdr->iov_len = sizeof(struct eth_header);\n//fix_flaw_line_below:\n//    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n//fix_flaw_line_below:\n//    case ETH_P_VLAN:\n//fix_flaw_line_below:\n//        l2_hdr->iov_len += sizeof(struct vlan_header);\n//fix_flaw_line_below:\n//        break;\n//fix_flaw_line_below:\n//    case ETH_P_DVLAN:\n//fix_flaw_line_below:\n//        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n//fix_flaw_line_below:\n//        break;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    if (bytes_read < l2_hdr->iov_len) {\n         l2_hdr->iov_len = 0;\n         return false;\n//flaw_line_below:\n    } else {\n//flaw_line_below:\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n     }\n \n     l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        /* copy optional IPv4 header data */\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                l2_hdr->iov_len + sizeof(struct ip_header),\n                                l3_hdr->iov_base + sizeof(struct ip_header),\n                                l3_hdr->iov_len - sizeof(struct ip_header));\n        if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n        break;\n\n    case ETH_P_IPV6:\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                               &pkt->l4proto, &full_ip6hdr_len)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_base = g_malloc(full_ip6hdr_len);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n",
        "linevul": 0.9988105297088623
    },
    {
        "code": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n         return;\n     }\n \n     xhci_kick_epctx(epctx, streamid);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n         return;\n     }\n \n//fix_flaw_line_below:\n//    if (epctx->kick_active) {\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n     xhci_kick_epctx(epctx, streamid);\n }\n",
        "linevul": 0.00013380360906012356
    },
    {
        "code": "static ssize_t proxy_preadv(FsContext *ctx, V9fsFidOpenState *fs,\n                            const struct iovec *iov,\n                            int iovcnt, off_t offset)\n{\n    ssize_t ret;\n#ifdef CONFIG_PREADV\n    ret = preadv(fs->fd, iov, iovcnt, offset);\n#else\n    ret = lseek(fs->fd, offset, SEEK_SET);\n    if (ret >= 0) {\n        ret = readv(fs->fd, iov, iovcnt);\n    }\n#endif\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static ssize_t proxy_preadv(FsContext *ctx, V9fsFidOpenState *fs,\n                            const struct iovec *iov,\n                            int iovcnt, off_t offset)\n{\n    ssize_t ret;\n#ifdef CONFIG_PREADV\n    ret = preadv(fs->fd, iov, iovcnt, offset);\n#else\n    ret = lseek(fs->fd, offset, SEEK_SET);\n    if (ret >= 0) {\n        ret = readv(fs->fd, iov, iovcnt);\n    }\n#endif\n    return ret;\n}\n",
        "linevul": 5.953029540251009e-05
    },
    {
        "code": "static uint64_t mptsas_mmio_read(void *opaque, hwaddr addr,\n                                  unsigned size)\n{\n    MPTSASState *s = opaque;\n    uint32_t ret = 0;\n\n    switch (addr & ~3) {\n    case MPI_DOORBELL_OFFSET:\n        ret = mptsas_doorbell_read(s);\n        break;\n\n    case MPI_DIAGNOSTIC_OFFSET:\n        ret = s->diagnostic;\n        break;\n\n    case MPI_HOST_INTERRUPT_STATUS_OFFSET:\n        ret = s->intr_status;\n        break;\n\n    case MPI_HOST_INTERRUPT_MASK_OFFSET:\n        ret = s->intr_mask;\n        break;\n\n    case MPI_REPLY_POST_FIFO_OFFSET:\n        ret = mptsas_reply_post_read(s);\n        break;\n\n    default:\n        trace_mptsas_mmio_unhandled_read(s, addr);\n        break;\n    }\n    trace_mptsas_mmio_read(s, addr, ret);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static uint64_t mptsas_mmio_read(void *opaque, hwaddr addr,\n                                  unsigned size)\n{\n    MPTSASState *s = opaque;\n    uint32_t ret = 0;\n\n    switch (addr & ~3) {\n    case MPI_DOORBELL_OFFSET:\n        ret = mptsas_doorbell_read(s);\n        break;\n\n    case MPI_DIAGNOSTIC_OFFSET:\n        ret = s->diagnostic;\n        break;\n\n    case MPI_HOST_INTERRUPT_STATUS_OFFSET:\n        ret = s->intr_status;\n        break;\n\n    case MPI_HOST_INTERRUPT_MASK_OFFSET:\n        ret = s->intr_mask;\n        break;\n\n    case MPI_REPLY_POST_FIFO_OFFSET:\n        ret = mptsas_reply_post_read(s);\n        break;\n\n    default:\n        trace_mptsas_mmio_unhandled_read(s, addr);\n        break;\n    }\n    trace_mptsas_mmio_read(s, addr, ret);\n    return ret;\n}\n",
        "linevul": 4.901276406599209e-05
    },
    {
        "code": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1);\n         vnc_framebuffer_update(vs, absolute, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                                VNC_ENCODING_POINTER_TYPE_CHANGE);\n         vnc_unlock_output(vs);\n         vnc_flush(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=bea60dd7679364493a0d7f5b54316c767cf894ef",
        "vul_func_with_fix": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1);\n         vnc_framebuffer_update(vs, absolute, 0,\n//flaw_line_below:\n                               surface_width(vs->vd->ds),\n//flaw_line_below:\n                               surface_height(vs->vd->ds),\n//fix_flaw_line_below:\n//                               pixman_image_get_width(vs->vd->server),\n//fix_flaw_line_below:\n//                               pixman_image_get_height(vs->vd->server),\n                                VNC_ENCODING_POINTER_TYPE_CHANGE);\n         vnc_unlock_output(vs);\n         vnc_flush(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n",
        "linevul": 5.314132067724131e-05
    },
    {
        "code": "static bool cmd_identify(IDEState *s, uint8_t cmd)\n{\n    if (s->blk && s->drive_kind != IDE_CD) {\n        if (s->drive_kind != IDE_CFATA) {\n            ide_identify(s);\n        } else {\n            ide_cfata_identify(s);\n        }\n        s->status = READY_STAT | SEEK_STAT;\n        ide_transfer_start(s, s->io_buffer, 512, ide_transfer_stop);\n        ide_set_irq(s->bus);\n        return false;\n    } else {\n        if (s->drive_kind == IDE_CD) {\n            ide_set_signature(s);\n        }\n        ide_abort_command(s);\n    }\n\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_identify(IDEState *s, uint8_t cmd)\n{\n    if (s->blk && s->drive_kind != IDE_CD) {\n        if (s->drive_kind != IDE_CFATA) {\n            ide_identify(s);\n        } else {\n            ide_cfata_identify(s);\n        }\n        s->status = READY_STAT | SEEK_STAT;\n        ide_transfer_start(s, s->io_buffer, 512, ide_transfer_stop);\n        ide_set_irq(s->bus);\n        return false;\n    } else {\n        if (s->drive_kind == IDE_CD) {\n            ide_set_signature(s);\n        }\n        ide_abort_command(s);\n    }\n\n    return true;\n}\n",
        "linevul": 5.24847891938407e-05
    },
    {
        "code": " int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n {\n     int i, ret;\n     uint32_t num;\n     uint32_t features;\n     uint32_t supported_features;\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {\n        return -1;\n    }\n    qemu_get_be32s(f, &features);\n\n    if (virtio_set_features(vdev, features) < 0) {\n        supported_features = k->get_features(qbus->parent);\n        error_report(\"Features 0x%x unsupported. Allowed features: 0x%x\",\n                     features, supported_features);\n                      features, supported_features);\n         return -1;\n     }\n    vdev->config_len = qemu_get_be32(f);\n     qemu_get_buffer(f, vdev->config, vdev->config_len);\n \n     num = qemu_get_be32(f);\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": " int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n {\n     int i, ret;\n//fix_flaw_line_below:\n//    int32_t config_len;\n     uint32_t num;\n     uint32_t features;\n     uint32_t supported_features;\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {\n        return -1;\n    }\n    qemu_get_be32s(f, &features);\n\n    if (virtio_set_features(vdev, features) < 0) {\n        supported_features = k->get_features(qbus->parent);\n        error_report(\"Features 0x%x unsupported. Allowed features: 0x%x\",\n                     features, supported_features);\n                      features, supported_features);\n         return -1;\n     }\n//flaw_line_below:\n    vdev->config_len = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    config_len = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (config_len != vdev->config_len) {\n//fix_flaw_line_below:\n//        error_report(\"Unexpected config length 0x%x. Expected 0x%zx\",\n//fix_flaw_line_below:\n//                     config_len, vdev->config_len);\n//fix_flaw_line_below:\n//        return -1;\n//fix_flaw_line_below:\n//    }\n     qemu_get_buffer(f, vdev->config, vdev->config_len);\n \n     num = qemu_get_be32(f);\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}\n",
        "linevul": 6.0166010371176526e-05
    },
    {
        "code": "static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret;\n    uint8_t *buffer = g_malloc(MIN(65536, size));\n    while (size > 0) {\n        size_t count = MIN(65536, size);\n        ret = nbd_negotiate_read(ioc, buffer, count);\n        if (ret < 0) {\n            g_free(buffer);\n            return ret;\n        }\n        size -= count;\n    }\n    g_free(buffer);\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=2b0bbc4f8809c972bad134bc1a2570dbb01dea0b",
        "vul_func_with_fix": "static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)\n//flaw_line_below:\n{\n//flaw_line_below:\n    ssize_t ret;\n//flaw_line_below:\n    uint8_t *buffer = g_malloc(MIN(65536, size));\n//flaw_line_below:\n\n//flaw_line_below:\n    while (size > 0) {\n//flaw_line_below:\n        size_t count = MIN(65536, size);\n//flaw_line_below:\n        ret = nbd_negotiate_read(ioc, buffer, count);\n//flaw_line_below:\n        if (ret < 0) {\n//flaw_line_below:\n            g_free(buffer);\n//flaw_line_below:\n            return ret;\n//flaw_line_below:\n        }\n//flaw_line_below:\n\n//flaw_line_below:\n        size -= count;\n//flaw_line_below:\n    }\n//flaw_line_below:\n\n//flaw_line_below:\n    g_free(buffer);\n//flaw_line_below:\n    return 0;\n//flaw_line_below:\n}\n",
        "linevul": 5.1281265768921e-05
    },
    {
        "code": "static void iscsi_readcapacity_sync(IscsiLun *iscsilun, Error **errp)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_readcapacity10 *rc10 = NULL;\n    struct scsi_readcapacity16 *rc16 = NULL;\n    int retries = ISCSI_CMD_RETRIES; \n\n    do {\n        if (task != NULL) {\n            scsi_free_scsi_task(task);\n            task = NULL;\n        }\n\n        switch (iscsilun->type) {\n        case TYPE_DISK:\n            task = iscsi_readcapacity16_sync(iscsilun->iscsi, iscsilun->lun);\n            if (task != NULL && task->status == SCSI_STATUS_GOOD) {\n                rc16 = scsi_datain_unmarshall(task);\n                if (rc16 == NULL) {\n                    error_setg(errp, \"iSCSI: Failed to unmarshall readcapacity16 data.\");\n                } else {\n                    iscsilun->block_size = rc16->block_length;\n                    iscsilun->num_blocks = rc16->returned_lba + 1;\n                    iscsilun->lbpme = !!rc16->lbpme;\n                    iscsilun->lbprz = !!rc16->lbprz;\n                    iscsilun->use_16_for_rw = (rc16->returned_lba > 0xffffffff);\n                }\n                break;\n            }\n            if (task != NULL && task->status == SCSI_STATUS_CHECK_CONDITION\n                && task->sense.key == SCSI_SENSE_UNIT_ATTENTION) {\n                break;\n            }\n            /* Fall through and try READ CAPACITY(10) instead.  */\n        case TYPE_ROM:\n            task = iscsi_readcapacity10_sync(iscsilun->iscsi, iscsilun->lun, 0, 0);\n            if (task != NULL && task->status == SCSI_STATUS_GOOD) {\n                rc10 = scsi_datain_unmarshall(task);\n                if (rc10 == NULL) {\n                    error_setg(errp, \"iSCSI: Failed to unmarshall readcapacity10 data.\");\n                } else {\n                    iscsilun->block_size = rc10->block_size;\n                    if (rc10->lba == 0) {\n                        /* blank disk loaded */\n                        iscsilun->num_blocks = 0;\n                    } else {\n                        iscsilun->num_blocks = rc10->lba + 1;\n                    }\n                }\n            }\n            break;\n        default:\n            return;\n        }\n    } while (task != NULL && task->status == SCSI_STATUS_CHECK_CONDITION\n             && task->sense.key == SCSI_SENSE_UNIT_ATTENTION\n             && retries-- > 0);\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n        error_setg(errp, \"iSCSI: failed to send readcapacity10/16 command\");\n    } else if (!iscsilun->block_size ||\n               iscsilun->block_size % BDRV_SECTOR_SIZE) {\n        error_setg(errp, \"iSCSI: the target returned an invalid \"\n                   \"block size of %d.\", iscsilun->block_size);\n    }\n    if (task) {\n        scsi_free_scsi_task(task);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_readcapacity_sync(IscsiLun *iscsilun, Error **errp)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_readcapacity10 *rc10 = NULL;\n    struct scsi_readcapacity16 *rc16 = NULL;\n    int retries = ISCSI_CMD_RETRIES; \n\n    do {\n        if (task != NULL) {\n            scsi_free_scsi_task(task);\n            task = NULL;\n        }\n\n        switch (iscsilun->type) {\n        case TYPE_DISK:\n            task = iscsi_readcapacity16_sync(iscsilun->iscsi, iscsilun->lun);\n            if (task != NULL && task->status == SCSI_STATUS_GOOD) {\n                rc16 = scsi_datain_unmarshall(task);\n                if (rc16 == NULL) {\n                    error_setg(errp, \"iSCSI: Failed to unmarshall readcapacity16 data.\");\n                } else {\n                    iscsilun->block_size = rc16->block_length;\n                    iscsilun->num_blocks = rc16->returned_lba + 1;\n                    iscsilun->lbpme = !!rc16->lbpme;\n                    iscsilun->lbprz = !!rc16->lbprz;\n                    iscsilun->use_16_for_rw = (rc16->returned_lba > 0xffffffff);\n                }\n                break;\n            }\n            if (task != NULL && task->status == SCSI_STATUS_CHECK_CONDITION\n                && task->sense.key == SCSI_SENSE_UNIT_ATTENTION) {\n                break;\n            }\n            /* Fall through and try READ CAPACITY(10) instead.  */\n        case TYPE_ROM:\n            task = iscsi_readcapacity10_sync(iscsilun->iscsi, iscsilun->lun, 0, 0);\n            if (task != NULL && task->status == SCSI_STATUS_GOOD) {\n                rc10 = scsi_datain_unmarshall(task);\n                if (rc10 == NULL) {\n                    error_setg(errp, \"iSCSI: Failed to unmarshall readcapacity10 data.\");\n                } else {\n                    iscsilun->block_size = rc10->block_size;\n                    if (rc10->lba == 0) {\n                        /* blank disk loaded */\n                        iscsilun->num_blocks = 0;\n                    } else {\n                        iscsilun->num_blocks = rc10->lba + 1;\n                    }\n                }\n            }\n            break;\n        default:\n            return;\n        }\n    } while (task != NULL && task->status == SCSI_STATUS_CHECK_CONDITION\n             && task->sense.key == SCSI_SENSE_UNIT_ATTENTION\n             && retries-- > 0);\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n        error_setg(errp, \"iSCSI: failed to send readcapacity10/16 command\");\n    } else if (!iscsilun->block_size ||\n               iscsilun->block_size % BDRV_SECTOR_SIZE) {\n        error_setg(errp, \"iSCSI: the target returned an invalid \"\n                   \"block size of %d.\", iscsilun->block_size);\n    }\n    if (task) {\n        scsi_free_scsi_task(task);\n    }\n}\n",
        "linevul": 4.8995891120284796e-05
    },
    {
        "code": "static void coroutine_fn v9fs_lock(void *opaque)\n{\n    int8_t status;\n    V9fsFlock flock;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n\n    status = P9_LOCK_ERROR;\n    v9fs_string_init(&flock.client_id);\n    err = pdu_unmarshal(pdu, offset, \"dbdqqds\", &fid, &flock.type,\n                        &flock.flags, &flock.start, &flock.length,\n                        &flock.proc_id, &flock.client_id);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_lock(pdu->tag, pdu->id, fid,\n                    flock.type, flock.start, flock.length);\n\n\n    /* We support only block flag now (that too ignored currently) */\n    if (flock.flags & ~P9_LOCK_FLAGS_BLOCK) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    status = P9_LOCK_SUCCESS;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    err = pdu_marshal(pdu, offset, \"b\", status);\n    if (err > 0) {\n        err += offset;\n    }\n    trace_v9fs_lock_return(pdu->tag, pdu->id, status);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&flock.client_id);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": "static void coroutine_fn v9fs_lock(void *opaque)\n{\n    int8_t status;\n    V9fsFlock flock;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    int32_t fid, err = 0;\n    V9fsPDU *pdu = opaque;\n\n    status = P9_LOCK_ERROR;\n    v9fs_string_init(&flock.client_id);\n    err = pdu_unmarshal(pdu, offset, \"dbdqqds\", &fid, &flock.type,\n                        &flock.flags, &flock.start, &flock.length,\n                        &flock.proc_id, &flock.client_id);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_lock(pdu->tag, pdu->id, fid,\n                    flock.type, flock.start, flock.length);\n\n\n    /* We support only block flag now (that too ignored currently) */\n    if (flock.flags & ~P9_LOCK_FLAGS_BLOCK) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_fstat(pdu, fidp, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    status = P9_LOCK_SUCCESS;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    err = pdu_marshal(pdu, offset, \"b\", status);\n    if (err > 0) {\n        err += offset;\n    }\n    trace_v9fs_lock_return(pdu->tag, pdu->id, status);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&flock.client_id);\n}\n",
        "linevul": 0.00011932973575312644
    },
    {
        "code": "uint16_t virtio_get_queue_index(VirtQueue *vq)\n{\n    return vq->queue_index;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "uint16_t virtio_get_queue_index(VirtQueue *vq)\n{\n    return vq->queue_index;\n}\n",
        "linevul": 4.810530299437232e-05
    },
    {
        "code": "static void rng_backend_free_request(RngRequest *req)\n{\n    g_free(req->data);\n    g_free(req);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=60253ed1e6ec6d8e5ef2efe7bf755f475dce9956",
        "vul_func_with_fix": "static void rng_backend_free_request(RngRequest *req)\n{\n    g_free(req->data);\n    g_free(req);\n}\n",
        "linevul": 0.0001405237999279052
    },
    {
        "code": "static uint8_t cirrus_mmio_blt_read(CirrusVGAState * s, unsigned address)\n{\n    int value = 0xff;\n\n    switch (address) {\n    case (CIRRUS_MMIO_BLTBGCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x00);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x10);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x12);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 3):\n\tvalue = cirrus_vga_read_gr(s, 0x14);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x01);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x11);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x13);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 3):\n\tvalue = cirrus_vga_read_gr(s, 0x15);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x20);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x21);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x22);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x23);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x24);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x25);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x26);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x27);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x28);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x29);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x2a);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x2c);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x2d);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x2e);\n\tbreak;\n    case CIRRUS_MMIO_BLTWRITEMASK:\n\tvalue = cirrus_vga_read_gr(s, 0x2f);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODE:\n\tvalue = cirrus_vga_read_gr(s, 0x30);\n\tbreak;\n    case CIRRUS_MMIO_BLTROP:\n\tvalue = cirrus_vga_read_gr(s, 0x32);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODEEXT:\n\tvalue = cirrus_vga_read_gr(s, 0x33);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x34);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x35);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x38);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x39);\n\tbreak;\n    case CIRRUS_MMIO_BLTSTATUS:\n\tvalue = cirrus_vga_read_gr(s, 0x31);\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: mmio read - address 0x%04x\\n\", address);\n#endif\n\tbreak;\n    }\n\n    return (uint8_t) value;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static uint8_t cirrus_mmio_blt_read(CirrusVGAState * s, unsigned address)\n{\n    int value = 0xff;\n\n    switch (address) {\n    case (CIRRUS_MMIO_BLTBGCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x00);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x10);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x12);\n\tbreak;\n    case (CIRRUS_MMIO_BLTBGCOLOR + 3):\n\tvalue = cirrus_vga_read_gr(s, 0x14);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x01);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x11);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x13);\n\tbreak;\n    case (CIRRUS_MMIO_BLTFGCOLOR + 3):\n\tvalue = cirrus_vga_read_gr(s, 0x15);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x20);\n\tbreak;\n    case (CIRRUS_MMIO_BLTWIDTH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x21);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x22);\n\tbreak;\n    case (CIRRUS_MMIO_BLTHEIGHT + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x23);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x24);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTPITCH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x25);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x26);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCPITCH + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x27);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x28);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x29);\n\tbreak;\n    case (CIRRUS_MMIO_BLTDESTADDR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x2a);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x2c);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x2d);\n\tbreak;\n    case (CIRRUS_MMIO_BLTSRCADDR + 2):\n\tvalue = cirrus_vga_read_gr(s, 0x2e);\n\tbreak;\n    case CIRRUS_MMIO_BLTWRITEMASK:\n\tvalue = cirrus_vga_read_gr(s, 0x2f);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODE:\n\tvalue = cirrus_vga_read_gr(s, 0x30);\n\tbreak;\n    case CIRRUS_MMIO_BLTROP:\n\tvalue = cirrus_vga_read_gr(s, 0x32);\n\tbreak;\n    case CIRRUS_MMIO_BLTMODEEXT:\n\tvalue = cirrus_vga_read_gr(s, 0x33);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x34);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLOR + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x35);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 0):\n\tvalue = cirrus_vga_read_gr(s, 0x38);\n\tbreak;\n    case (CIRRUS_MMIO_BLTTRANSPARENTCOLORMASK + 1):\n\tvalue = cirrus_vga_read_gr(s, 0x39);\n\tbreak;\n    case CIRRUS_MMIO_BLTSTATUS:\n\tvalue = cirrus_vga_read_gr(s, 0x31);\n\tbreak;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: mmio read - address 0x%04x\\n\", address);\n#endif\n\tbreak;\n    }\n\n    return (uint8_t) value;\n}\n",
        "linevul": 5.003238402423449e-05
    },
    {
        "code": "static void vmsvga_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = pci_vmsvga_realize;\n    k->romfile = \"vgabios-vmware.bin\";\n    k->vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->device_id = SVGA_PCI_DEVICE_ID;\n    k->class_id = PCI_CLASS_DISPLAY_VGA;\n    k->subsystem_vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->subsystem_id = SVGA_PCI_DEVICE_ID;\n    dc->reset = vmsvga_reset;\n    dc->vmsd = &vmstate_vmware_vga;\n    dc->props = vga_vmware_properties;\n    dc->hotpluggable = false;\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static void vmsvga_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = pci_vmsvga_realize;\n    k->romfile = \"vgabios-vmware.bin\";\n    k->vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->device_id = SVGA_PCI_DEVICE_ID;\n    k->class_id = PCI_CLASS_DISPLAY_VGA;\n    k->subsystem_vendor_id = PCI_VENDOR_ID_VMWARE;\n    k->subsystem_id = SVGA_PCI_DEVICE_ID;\n    dc->reset = vmsvga_reset;\n    dc->vmsd = &vmstate_vmware_vga;\n    dc->props = vga_vmware_properties;\n    dc->hotpluggable = false;\n    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);\n}\n",
        "linevul": 5.070899351267144e-05
    },
    {
        "code": "void qemu_spice_cursor_refresh_unlocked(SimpleSpiceDisplay *ssd)\n{\n    if (ssd->cursor) {\n        assert(ssd->dcl.con);\n        dpy_cursor_define(ssd->dcl.con, ssd->cursor);\n        cursor_put(ssd->cursor);\n        ssd->cursor = NULL;\n    }\n    if (ssd->mouse_x != -1 && ssd->mouse_y != -1) {\n        assert(ssd->dcl.con);\n        dpy_mouse_set(ssd->dcl.con, ssd->mouse_x, ssd->mouse_y, 1);\n        ssd->mouse_x = -1;\n        ssd->mouse_y = -1;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "void qemu_spice_cursor_refresh_unlocked(SimpleSpiceDisplay *ssd)\n{\n    if (ssd->cursor) {\n        assert(ssd->dcl.con);\n        dpy_cursor_define(ssd->dcl.con, ssd->cursor);\n        cursor_put(ssd->cursor);\n        ssd->cursor = NULL;\n    }\n    if (ssd->mouse_x != -1 && ssd->mouse_y != -1) {\n        assert(ssd->dcl.con);\n        dpy_mouse_set(ssd->dcl.con, ssd->mouse_x, ssd->mouse_y, 1);\n        ssd->mouse_x = -1;\n        ssd->mouse_y = -1;\n    }\n}\n",
        "linevul": 4.8164794861804694e-05
    },
    {
        "code": "static inline uint16_t vring_avail_flags(VirtQueue *vq)\n{\n    hwaddr pa;\n    pa = vq->vring.avail + offsetof(VRingAvail, flags);\n    return virtio_lduw_phys(vq->vdev, pa);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static inline uint16_t vring_avail_flags(VirtQueue *vq)\n{\n    hwaddr pa;\n    pa = vq->vring.avail + offsetof(VRingAvail, flags);\n    return virtio_lduw_phys(vq->vdev, pa);\n}\n",
        "linevul": 5.059104296378791e-05
    },
    {
        "code": "static int vmstate_n_elems(void *opaque, VMStateField *field)\n{\n    int n_elems = 1;\n\n    if (field->flags & VMS_ARRAY) {\n        n_elems = field->num;\n    } else if (field->flags & VMS_VARRAY_INT32) {\n        n_elems = *(int32_t *)(opaque+field->num_offset);\n    } else if (field->flags & VMS_VARRAY_UINT32) {\n        n_elems = *(uint32_t *)(opaque+field->num_offset);\n    } else if (field->flags & VMS_VARRAY_UINT16) {\n        n_elems = *(uint16_t *)(opaque+field->num_offset);\n    } else if (field->flags & VMS_VARRAY_UINT8) {\n        n_elems = *(uint8_t *)(opaque+field->num_offset);\n    }\n\n    return n_elems;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "static int vmstate_n_elems(void *opaque, VMStateField *field)\n{\n    int n_elems = 1;\n\n    if (field->flags & VMS_ARRAY) {\n        n_elems = field->num;\n    } else if (field->flags & VMS_VARRAY_INT32) {\n        n_elems = *(int32_t *)(opaque+field->num_offset);\n    } else if (field->flags & VMS_VARRAY_UINT32) {\n        n_elems = *(uint32_t *)(opaque+field->num_offset);\n    } else if (field->flags & VMS_VARRAY_UINT16) {\n        n_elems = *(uint16_t *)(opaque+field->num_offset);\n    } else if (field->flags & VMS_VARRAY_UINT8) {\n        n_elems = *(uint8_t *)(opaque+field->num_offset);\n    }\n\n    return n_elems;\n}\n",
        "linevul": 5.1482944400049746e-05
    },
    {
        "code": "static int cirrus_read_hidden_dac(CirrusVGAState * s)\n{\n    if (++s->cirrus_hidden_dac_lockindex == 5) {\n        s->cirrus_hidden_dac_lockindex = 0;\n        return s->cirrus_hidden_dac_data;\n    }\n    return 0xff;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static int cirrus_read_hidden_dac(CirrusVGAState * s)\n{\n    if (++s->cirrus_hidden_dac_lockindex == 5) {\n        s->cirrus_hidden_dac_lockindex = 0;\n        return s->cirrus_hidden_dac_data;\n    }\n    return 0xff;\n}\n",
        "linevul": 5.0988877774216235e-05
    },
    {
        "code": "static void inc_refcounts(BlockDriverState *bs,\n                          BdrvCheckResult *res,\n                          uint16_t *refcount_table,\n                          int refcount_table_size,\n                          int64_t offset, int64_t size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int64_t start, last, cluster_offset;\n    int k;\n\n    if (size <= 0)\n        return;\n\n    start = start_of_cluster(s, offset);\n    last = start_of_cluster(s, offset + size - 1);\n    for(cluster_offset = start; cluster_offset <= last;\n        cluster_offset += s->cluster_size) {\n        k = cluster_offset >> s->cluster_bits;\n        if (k < 0) {\n            fprintf(stderr, \"ERROR: invalid cluster offset=0x%\" PRIx64 \"\\n\",\n                cluster_offset);\n            res->corruptions++;\n        } else if (k >= refcount_table_size) {\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n                \"the end of the image file, can't properly check refcounts.\\n\",\n                cluster_offset);\n            res->check_errors++;\n        } else {\n            if (++refcount_table[k] == 0) {\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n                    \"\\n\", cluster_offset);\n                res->corruptions++;\n            }\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": "static void inc_refcounts(BlockDriverState *bs,\n                          BdrvCheckResult *res,\n                          uint16_t *refcount_table,\n                          int refcount_table_size,\n                          int64_t offset, int64_t size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int64_t start, last, cluster_offset;\n    int k;\n\n    if (size <= 0)\n        return;\n\n    start = start_of_cluster(s, offset);\n    last = start_of_cluster(s, offset + size - 1);\n    for(cluster_offset = start; cluster_offset <= last;\n        cluster_offset += s->cluster_size) {\n        k = cluster_offset >> s->cluster_bits;\n        if (k < 0) {\n            fprintf(stderr, \"ERROR: invalid cluster offset=0x%\" PRIx64 \"\\n\",\n                cluster_offset);\n            res->corruptions++;\n        } else if (k >= refcount_table_size) {\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n                \"the end of the image file, can't properly check refcounts.\\n\",\n                cluster_offset);\n            res->check_errors++;\n        } else {\n            if (++refcount_table[k] == 0) {\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n                    \"\\n\", cluster_offset);\n                res->corruptions++;\n            }\n        }\n    }\n}\n",
        "linevul": 0.00040345825254917145
    },
    {
        "code": "static target_ulong disas_insn(CPUX86State *env, DisasContext *s,\n                               target_ulong pc_start)\n{\n    int b, prefixes;\n    int shift;\n    TCGMemOp ot, aflag, dflag;\n    int modrm, reg, rm, mod, op, opreg, val;\n    target_ulong next_eip, tval;\n    int rex_w, rex_r;\n\n    s->pc_start = s->pc = pc_start;\n    prefixes = 0;\n    s->override = -1;\n    rex_w = -1;\n    rex_r = 0;\n#ifdef TARGET_X86_64\n    s->rex_x = 0;\n    s->rex_b = 0;\n    x86_64_hregs = 0;\n#endif\n    s->rip_offset = 0; /* for relative ip address */\n     s->vex_l = 0;\n     s->vex_v = 0;\n  next_byte:\n     b = cpu_ldub_code(env, s->pc);\n     s->pc++;\n     /* Collect prefixes.  */\n    switch (b) {\n    case 0xf3:\n        prefixes |= PREFIX_REPZ;\n        goto next_byte;\n    case 0xf2:\n        prefixes |= PREFIX_REPNZ;\n        goto next_byte;\n    case 0xf0:\n        prefixes |= PREFIX_LOCK;\n        goto next_byte;\n    case 0x2e:\n        s->override = R_CS;\n        goto next_byte;\n    case 0x36:\n        s->override = R_SS;\n        goto next_byte;\n    case 0x3e:\n        s->override = R_DS;\n        goto next_byte;\n    case 0x26:\n        s->override = R_ES;\n        goto next_byte;\n    case 0x64:\n        s->override = R_FS;\n        goto next_byte;\n    case 0x65:\n        s->override = R_GS;\n        goto next_byte;\n    case 0x66:\n        prefixes |= PREFIX_DATA;\n        goto next_byte;\n    case 0x67:\n        prefixes |= PREFIX_ADR;\n        goto next_byte;\n#ifdef TARGET_X86_64\n    case 0x40 ... 0x4f:\n        if (CODE64(s)) {\n            /* REX prefix */\n            rex_w = (b >> 3) & 1;\n            rex_r = (b & 0x4) << 1;\n            s->rex_x = (b & 0x2) << 2;\n            REX_B(s) = (b & 0x1) << 3;\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n            goto next_byte;\n        }\n        break;\n#endif\n    case 0xc5: /* 2-byte VEX */\n    case 0xc4: /* 3-byte VEX */\n        /* VEX prefixes cannot be used except in 32-bit mode.\n           Otherwise the instruction is LES or LDS.  */\n        if (s->code32 && !s->vm86) {\n            static const int pp_prefix[4] = {\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n            };\n            int vex3, vex2 = cpu_ldub_code(env, s->pc);\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n                   otherwise the instruction is LES or LDS.  */\n                break;\n            }\n            s->pc++;\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n                goto illegal_op;\n            }\n#ifdef TARGET_X86_64\n            if (x86_64_hregs) {\n                goto illegal_op;\n            }\n#endif\n            rex_r = (~vex2 >> 4) & 8;\n            if (b == 0xc5) {\n                vex3 = vex2;\n                b = cpu_ldub_code(env, s->pc++);\n            } else {\n#ifdef TARGET_X86_64\n                s->rex_x = (~vex2 >> 3) & 8;\n                s->rex_b = (~vex2 >> 2) & 8;\n#endif\n                vex3 = cpu_ldub_code(env, s->pc++);\n                rex_w = (vex3 >> 7) & 1;\n                switch (vex2 & 0x1f) {\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n                    b = cpu_ldub_code(env, s->pc++) | 0x100;\n                    break;\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n                    b = 0x138;\n                    break;\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n                    b = 0x13a;\n                    break;\n                default:   /* Reserved for future use.  */\n                    goto unknown_op;\n                }\n            }\n            s->vex_v = (~vex3 >> 3) & 0xf;\n            s->vex_l = (vex3 >> 2) & 1;\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n        }\n        break;\n    }\n\n    /* Post-process prefixes.  */\n    if (CODE64(s)) {\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n           over 0x66 if both are present.  */\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n    } else {\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n            dflag = MO_32;\n        } else {\n            dflag = MO_16;\n        }\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n            aflag = MO_32;\n        }  else {\n            aflag = MO_16;\n        }\n    }\n\n    s->prefix = prefixes;\n    s->aflag = aflag;\n    s->dflag = dflag;\n\n    /* now check op code */\n reswitch:\n    switch(b) {\n    case 0x0f:\n        /**************************/\n        /* extended op code */\n        b = cpu_ldub_code(env, s->pc++) | 0x100;\n        goto reswitch;\n\n        /**************************/\n        /* arith & logic */\n    case 0x00 ... 0x05:\n    case 0x08 ... 0x0d:\n    case 0x10 ... 0x15:\n    case 0x18 ... 0x1d:\n    case 0x20 ... 0x25:\n    case 0x28 ... 0x2d:\n    case 0x30 ... 0x35:\n    case 0x38 ... 0x3d:\n        {\n            int op, f, val;\n            op = (b >> 3) & 7;\n            f = (b >> 1) & 3;\n\n            ot = mo_b_d(b, dflag);\n\n            switch(f) {\n            case 0: /* OP Ev, Gv */\n                modrm = cpu_ldub_code(env, s->pc++);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                mod = (modrm >> 6) & 3;\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3) {\n                    gen_lea_modrm(env, s, modrm);\n                    opreg = OR_TMP0;\n                } else if (op == OP_XORL && rm == reg) {\n                xor_zero:\n                    /* xor reg, reg optimisation */\n                    set_cc_op(s, CC_OP_CLR);\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                    break;\n                } else {\n                    opreg = rm;\n                }\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n                gen_op(s, op, ot, opreg);\n                break;\n            case 1: /* OP Gv, Ev */\n                modrm = cpu_ldub_code(env, s->pc++);\n                mod = (modrm >> 6) & 3;\n                reg = ((modrm >> 3) & 7) | rex_r;\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3) {\n                    gen_lea_modrm(env, s, modrm);\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n                } else if (op == OP_XORL && rm == reg) {\n                    goto xor_zero;\n                } else {\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n                }\n                gen_op(s, op, ot, reg);\n                break;\n            case 2: /* OP A, Iv */\n                val = insn_get(env, s, ot);\n                tcg_gen_movi_tl(cpu_T1, val);\n                gen_op(s, op, ot, OR_EAX);\n                break;\n            }\n        }\n        break;\n\n    case 0x82:\n        if (CODE64(s))\n            goto illegal_op;\n    case 0x80: /* GRP1 */\n    case 0x81:\n    case 0x83:\n        {\n            int val;\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = cpu_ldub_code(env, s->pc++);\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n            op = (modrm >> 3) & 7;\n\n            if (mod != 3) {\n                if (b == 0x83)\n                    s->rip_offset = 1;\n                else\n                    s->rip_offset = insn_const_size(ot);\n                gen_lea_modrm(env, s, modrm);\n                opreg = OR_TMP0;\n            } else {\n                opreg = rm;\n            }\n\n            switch(b) {\n            default:\n            case 0x80:\n            case 0x81:\n            case 0x82:\n                val = insn_get(env, s, ot);\n                break;\n            case 0x83:\n                val = (int8_t)insn_get(env, s, MO_8);\n                break;\n            }\n            tcg_gen_movi_tl(cpu_T1, val);\n            gen_op(s, op, ot, opreg);\n        }\n        break;\n\n        /**************************/\n        /* inc, dec, and other misc arith */\n    case 0x40 ... 0x47: /* inc Gv */\n        ot = dflag;\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n        break;\n    case 0x48 ... 0x4f: /* dec Gv */\n        ot = dflag;\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n        break;\n    case 0xf6: /* GRP3 */\n    case 0xf7:\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        op = (modrm >> 3) & 7;\n        if (mod != 3) {\n            if (op == 0) {\n                s->rip_offset = insn_const_size(ot);\n            }\n            gen_lea_modrm(env, s, modrm);\n            /* For those below that handle locked memory, don't load here.  */\n            if (!(s->prefix & PREFIX_LOCK)\n                || op != 2) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n\n        switch(op) {\n        case 0: /* test */\n            val = insn_get(env, s, ot);\n            tcg_gen_movi_tl(cpu_T1, val);\n            gen_op_testl_T0_T1_cc();\n            set_cc_op(s, CC_OP_LOGICB + ot);\n            break;\n        case 2: /* not */\n            if (s->prefix & PREFIX_LOCK) {\n                if (mod == 3) {\n                    goto illegal_op;\n                }\n                tcg_gen_movi_tl(cpu_T0, ~0);\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n                                            s->mem_index, ot | MO_LE);\n            } else {\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n                if (mod != 3) {\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n            }\n            break;\n        case 3: /* neg */\n            if (s->prefix & PREFIX_LOCK) {\n                TCGLabel *label1;\n                TCGv a0, t0, t1, t2;\n\n                if (mod == 3) {\n                    goto illegal_op;\n                }\n                a0 = tcg_temp_local_new();\n                t0 = tcg_temp_local_new();\n                label1 = gen_new_label();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n                gen_set_label(label1);\n                t1 = tcg_temp_new();\n                t2 = tcg_temp_new();\n                tcg_gen_mov_tl(t2, t0);\n                tcg_gen_neg_tl(t1, t0);\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n                                          s->mem_index, ot | MO_LE);\n                tcg_temp_free(t1);\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n                tcg_temp_free(t2);\n                tcg_temp_free(a0);\n                tcg_gen_mov_tl(cpu_T0, t0);\n                tcg_temp_free(t0);\n            } else {\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n                if (mod != 3) {\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n            }\n            gen_op_update_neg_cc();\n            set_cc_op(s, CC_OP_SUBB + ot);\n            break;\n        case 4: /* mul */\n            switch(ot) {\n            case MO_8:\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n                set_cc_op(s, CC_OP_MULB);\n                break;\n            case MO_16:\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                set_cc_op(s, CC_OP_MULW);\n                break;\n            default:\n            case MO_32:\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(s, CC_OP_MULL);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n                                  cpu_T0, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(s, CC_OP_MULQ);\n                break;\n#endif\n            }\n            break;\n        case 5: /* imul */\n            switch(ot) {\n            case MO_8:\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n                set_cc_op(s, CC_OP_MULB);\n                break;\n            case MO_16:\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n                set_cc_op(s, CC_OP_MULW);\n                break;\n            default:\n            case MO_32:\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n                set_cc_op(s, CC_OP_MULL);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n                                  cpu_T0, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(s, CC_OP_MULQ);\n                break;\n#endif\n            }\n            break;\n        case 6: /* div */\n            switch(ot) {\n            case MO_8:\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n                break;\n            case MO_16:\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n                break;\n            default:\n            case MO_32:\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n                break;\n#endif\n            }\n            break;\n        case 7: /* idiv */\n            switch(ot) {\n            case MO_8:\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n                break;\n            case MO_16:\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n                break;\n            default:\n            case MO_32:\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n                break;\n#endif\n            }\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0xfe: /* GRP4 */\n    case 0xff: /* GRP5 */\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        op = (modrm >> 3) & 7;\n        if (op >= 2 && b == 0xfe) {\n            goto unknown_op;\n        }\n        if (CODE64(s)) {\n            if (op == 2 || op == 4) {\n                /* operand size for jumps is 64 bit */\n                ot = MO_64;\n            } else if (op == 3 || op == 5) {\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n            } else if (op == 6) {\n                /* default push size is 64 bit */\n                ot = mo_pushpop(s, dflag);\n            }\n        }\n        if (mod != 3) {\n            gen_lea_modrm(env, s, modrm);\n            if (op >= 2 && op != 3 && op != 5)\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n\n        switch(op) {\n        case 0: /* inc Ev */\n            if (mod != 3)\n                opreg = OR_TMP0;\n            else\n                opreg = rm;\n            gen_inc(s, ot, opreg, 1);\n            break;\n        case 1: /* dec Ev */\n            if (mod != 3)\n                opreg = OR_TMP0;\n            else\n                opreg = rm;\n            gen_inc(s, ot, opreg, -1);\n            break;\n        case 2: /* call Ev */\n            /* XXX: optimize if memory (no 'and' is necessary) */\n            if (dflag == MO_16) {\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n            }\n            next_eip = s->pc - s->cs_base;\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n            gen_push_v(s, cpu_T1);\n            gen_op_jmp_v(cpu_T0);\n            gen_bnd_jmp(s);\n            gen_eob(s);\n            break;\n        case 3: /* lcall Ev */\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 1 << ot);\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n        do_lcall:\n            if (s->pe && !s->vm86) {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                           tcg_const_i32(dflag - 1),\n                                           tcg_const_tl(s->pc - s->cs_base));\n            } else {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                      tcg_const_i32(dflag - 1),\n                                      tcg_const_i32(s->pc - s->cs_base));\n            }\n            gen_eob(s);\n            break;\n        case 4: /* jmp Ev */\n            if (dflag == MO_16) {\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n            }\n            gen_op_jmp_v(cpu_T0);\n            gen_bnd_jmp(s);\n            gen_eob(s);\n            break;\n        case 5: /* ljmp Ev */\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 1 << ot);\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n        do_ljmp:\n            if (s->pe && !s->vm86) {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                          tcg_const_tl(s->pc - s->cs_base));\n            } else {\n                gen_op_movl_seg_T0_vm(R_CS);\n                gen_op_jmp_v(cpu_T1);\n            }\n            gen_eob(s);\n            break;\n        case 6: /* push Ev */\n            gen_push_v(s, cpu_T0);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x84: /* test Ev, Gv */\n    case 0x85:\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n        gen_op_testl_T0_T1_cc();\n        set_cc_op(s, CC_OP_LOGICB + ot);\n        break;\n\n    case 0xa8: /* test eAX, Iv */\n    case 0xa9:\n        ot = mo_b_d(b, dflag);\n        val = insn_get(env, s, ot);\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n        tcg_gen_movi_tl(cpu_T1, val);\n        gen_op_testl_T0_T1_cc();\n        set_cc_op(s, CC_OP_LOGICB + ot);\n        break;\n\n    case 0x98: /* CWDE/CBW */\n        switch (dflag) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n            break;\n#endif\n        case MO_32:\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n            break;\n        case MO_16:\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n            break;\n        default:\n            tcg_abort();\n        }\n        break;\n    case 0x99: /* CDQ/CWD */\n        switch (dflag) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n            break;\n#endif\n        case MO_32:\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n            break;\n        case MO_16:\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n            break;\n        default:\n            tcg_abort();\n        }\n        break;\n    case 0x1af: /* imul Gv, Ev */\n    case 0x69: /* imul Gv, Ev, I */\n    case 0x6b:\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        if (b == 0x69)\n            s->rip_offset = insn_const_size(ot);\n        else if (b == 0x6b)\n            s->rip_offset = 1;\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        if (b == 0x69) {\n            val = insn_get(env, s, ot);\n            tcg_gen_movi_tl(cpu_T1, val);\n        } else if (b == 0x6b) {\n            val = (int8_t)insn_get(env, s, MO_8);\n            tcg_gen_movi_tl(cpu_T1, val);\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n        }\n        switch (ot) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n            break;\n#endif\n        case MO_32:\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n            break;\n        default:\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n            /* XXX: use 32 bit mul which could be faster */\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        }\n        set_cc_op(s, CC_OP_MULB + ot);\n        break;\n    case 0x1c0:\n    case 0x1c1: /* xadd Ev, Gv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n        if (mod == 3) {\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n        } else {\n            gen_lea_modrm(env, s, modrm);\n            if (s->prefix & PREFIX_LOCK) {\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n                                            s->mem_index, ot | MO_LE);\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n            } else {\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n            }\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n        }\n        gen_op_update2_cc();\n        set_cc_op(s, CC_OP_ADDB + ot);\n        break;\n    case 0x1b0:\n    case 0x1b1: /* cmpxchg Ev, Gv */\n        {\n            TCGv oldv, newv, cmpv;\n\n            ot = mo_b_d(b, dflag);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            oldv = tcg_temp_new();\n            newv = tcg_temp_new();\n            cmpv = tcg_temp_new();\n            gen_op_mov_v_reg(ot, newv, reg);\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n            if (s->prefix & PREFIX_LOCK) {\n                if (mod == 3) {\n                    goto illegal_op;\n                }\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n                                          s->mem_index, ot | MO_LE);\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n            } else {\n                if (mod == 3) {\n                    rm = (modrm & 7) | REX_B(s);\n                    gen_op_mov_v_reg(ot, oldv, rm);\n                } else {\n                    gen_lea_modrm(env, s, modrm);\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n                    rm = 0; /* avoid warning */\n                }\n                gen_extu(ot, oldv);\n                gen_extu(ot, cmpv);\n                /* store value = (old == cmp ? new : old);  */\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n                if (mod == 3) {\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n                    gen_op_mov_reg_v(ot, rm, newv);\n                } else {\n                    /* Perform an unconditional store cycle like physical cpu;\n                       must be before changing accumulator to ensure\n                       idempotency if the store faults and the instruction\n                       is restarted */\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n                }\n            }\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n            set_cc_op(s, CC_OP_SUBB + ot);\n            tcg_temp_free(oldv);\n            tcg_temp_free(newv);\n            tcg_temp_free(cmpv);\n        }\n        break;\n    case 0x1c7: /* cmpxchg8b */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n            goto illegal_op;\n#ifdef TARGET_X86_64\n        if (dflag == MO_64) {\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n            } else {\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n            }\n        } else\n#endif        \n        {\n            if (!(s->cpuid_features & CPUID_CX8))\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n            } else {\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n            }\n        }\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n\n        /**************************/\n        /* push/pop */\n    case 0x50 ... 0x57: /* push */\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x58 ... 0x5f: /* pop */\n        ot = gen_pop_T0(s);\n        /* NOTE: order is important for pop %sp */\n        gen_pop_update(s, ot);\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n        break;\n    case 0x60: /* pusha */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_pusha(s);\n        break;\n    case 0x61: /* popa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_popa(s);\n        break;\n    case 0x68: /* push Iv */\n    case 0x6a:\n        ot = mo_pushpop(s, dflag);\n        if (b == 0x68)\n            val = insn_get(env, s, ot);\n        else\n            val = (int8_t)insn_get(env, s, MO_8);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x8f: /* pop Ev */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        ot = gen_pop_T0(s);\n        if (mod == 3) {\n            /* NOTE: order is important for pop %sp */\n            gen_pop_update(s, ot);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n        } else {\n            /* NOTE: order is important too for MMU exceptions */\n            s->popl_esp_hack = 1 << ot;\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            s->popl_esp_hack = 0;\n            gen_pop_update(s, ot);\n        }\n        break;\n    case 0xc8: /* enter */\n        {\n            int level;\n            val = cpu_lduw_code(env, s->pc);\n            s->pc += 2;\n            level = cpu_ldub_code(env, s->pc++);\n            gen_enter(s, val, level);\n        }\n        break;\n    case 0xc9: /* leave */\n        gen_leave(s);\n        break;\n    case 0x06: /* push es */\n    case 0x0e: /* push cs */\n    case 0x16: /* push ss */\n    case 0x1e: /* push ds */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_op_movl_T0_seg(b >> 3);\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x1a0: /* push fs */\n    case 0x1a8: /* push gs */\n        gen_op_movl_T0_seg((b >> 3) & 7);\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x07: /* pop es */\n    case 0x17: /* pop ss */\n    case 0x1f: /* pop ds */\n        if (CODE64(s))\n            goto illegal_op;\n        reg = b >> 3;\n        ot = gen_pop_T0(s);\n        gen_movl_seg_T0(s, reg);\n        gen_pop_update(s, ot);\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            if (reg == R_SS) {\n                s->tf = 0;\n                gen_eob_inhibit_irq(s, true);\n            } else {\n                gen_eob(s);\n            }\n        }\n        break;\n    case 0x1a1: /* pop fs */\n    case 0x1a9: /* pop gs */\n        ot = gen_pop_T0(s);\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n        gen_pop_update(s, ot);\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n\n        /**************************/\n        /* mov */\n    case 0x88:\n    case 0x89: /* mov Gv, Ev */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n        break;\n    case 0xc6:\n    case 0xc7: /* mov Ev, Iv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod != 3) {\n            s->rip_offset = insn_const_size(ot);\n            gen_lea_modrm(env, s, modrm);\n        }\n        val = insn_get(env, s, ot);\n        tcg_gen_movi_tl(cpu_T0, val);\n        if (mod != 3) {\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n        } else {\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n        }\n        break;\n    case 0x8a:\n    case 0x8b: /* mov Ev, Gv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n        break;\n    case 0x8e: /* mov seg, Gv */\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = (modrm >> 3) & 7;\n        if (reg >= 6 || reg == R_CS)\n            goto illegal_op;\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n        gen_movl_seg_T0(s, reg);\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            if (reg == R_SS) {\n                s->tf = 0;\n                gen_eob_inhibit_irq(s, true);\n            } else {\n                gen_eob(s);\n            }\n        }\n        break;\n    case 0x8c: /* mov Gv, seg */\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        if (reg >= 6)\n            goto illegal_op;\n        gen_op_movl_T0_seg(reg);\n        ot = mod == 3 ? dflag : MO_16;\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n        break;\n\n    case 0x1b6: /* movzbS Gv, Eb */\n    case 0x1b7: /* movzwS Gv, Eb */\n    case 0x1be: /* movsbS Gv, Eb */\n    case 0x1bf: /* movswS Gv, Eb */\n        {\n            TCGMemOp d_ot;\n            TCGMemOp s_ot;\n\n            /* d_ot is the size of destination */\n            d_ot = dflag;\n            /* ot is the size of source */\n            ot = (b & 1) + MO_8;\n            /* s_ot is the sign+size of source */\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n\n            if (mod == 3) {\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n                } else {\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n                    switch (s_ot) {\n                    case MO_UB:\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n                        break;\n                    case MO_SB:\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n                        break;\n                    case MO_UW:\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n                        break;\n                    default:\n                    case MO_SW:\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n                        break;\n                    }\n                }\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            } else {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            }\n        }\n        break;\n\n    case 0x8d: /* lea */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        reg = ((modrm >> 3) & 7) | rex_r;\n        {\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n            TCGv ea = gen_lea_modrm_1(a);\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n        }\n        break;\n\n    case 0xa0: /* mov EAX, Ov */\n    case 0xa1:\n    case 0xa2: /* mov Ov, EAX */\n    case 0xa3:\n        {\n            target_ulong offset_addr;\n\n            ot = mo_b_d(b, dflag);\n            switch (s->aflag) {\n#ifdef TARGET_X86_64\n            case MO_64:\n                offset_addr = cpu_ldq_code(env, s->pc);\n                s->pc += 8;\n                break;\n#endif\n            default:\n                offset_addr = insn_get(env, s, s->aflag);\n                break;\n            }\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n            gen_add_A0_ds_seg(s);\n            if ((b & 2) == 0) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n            } else {\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n            }\n        }\n        break;\n    case 0xd7: /* xlat */\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n        gen_extu(s->aflag, cpu_A0);\n        gen_add_A0_ds_seg(s);\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n        break;\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n        val = insn_get(env, s, MO_8);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n        break;\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n#ifdef TARGET_X86_64\n        if (dflag == MO_64) {\n            uint64_t tmp;\n            /* 64 bit case */\n            tmp = cpu_ldq_code(env, s->pc);\n            s->pc += 8;\n            reg = (b & 7) | REX_B(s);\n            tcg_gen_movi_tl(cpu_T0, tmp);\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n        } else\n#endif\n        {\n            ot = dflag;\n            val = insn_get(env, s, ot);\n            reg = (b & 7) | REX_B(s);\n            tcg_gen_movi_tl(cpu_T0, val);\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n        }\n        break;\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n    do_xchg_reg_eax:\n        ot = dflag;\n        reg = (b & 7) | REX_B(s);\n        rm = R_EAX;\n        goto do_xchg_reg;\n    case 0x86:\n    case 0x87: /* xchg Ev, Gv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3) {\n            rm = (modrm & 7) | REX_B(s);\n        do_xchg_reg:\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n        } else {\n            gen_lea_modrm(env, s, modrm);\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n            /* for xchg, lock is implicit */\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n                                   s->mem_index, ot | MO_LE);\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n        }\n        break;\n    case 0xc4: /* les Gv */\n        /* In CODE64 this is VEX3; see above.  */\n        op = R_ES;\n        goto do_lxx;\n    case 0xc5: /* lds Gv */\n        /* In CODE64 this is VEX2; see above.  */\n        op = R_DS;\n        goto do_lxx;\n    case 0x1b2: /* lss Gv */\n        op = R_SS;\n        goto do_lxx;\n    case 0x1b4: /* lfs Gv */\n        op = R_FS;\n        goto do_lxx;\n    case 0x1b5: /* lgs Gv */\n        op = R_GS;\n    do_lxx:\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_lea_modrm(env, s, modrm);\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n        gen_add_A0_im(s, 1 << ot);\n        /* load the segment first to handle exceptions properly */\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n        gen_movl_seg_T0(s, op);\n        /* then put the data */\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n\n        /************************/\n        /* shifts */\n    case 0xc0:\n    case 0xc1:\n        /* shift Ev,Ib */\n        shift = 2;\n    grp2:\n        {\n            ot = mo_b_d(b, dflag);\n            modrm = cpu_ldub_code(env, s->pc++);\n            mod = (modrm >> 6) & 3;\n            op = (modrm >> 3) & 7;\n\n            if (mod != 3) {\n                if (shift == 2) {\n                    s->rip_offset = 1;\n                }\n                gen_lea_modrm(env, s, modrm);\n                opreg = OR_TMP0;\n            } else {\n                opreg = (modrm & 7) | REX_B(s);\n            }\n\n            /* simpler op */\n            if (shift == 0) {\n                gen_shift(s, op, ot, opreg, OR_ECX);\n            } else {\n                if (shift == 2) {\n                    shift = cpu_ldub_code(env, s->pc++);\n                }\n                gen_shifti(s, op, ot, opreg, shift);\n            }\n        }\n        break;\n    case 0xd0:\n    case 0xd1:\n        /* shift Ev,1 */\n        shift = 1;\n        goto grp2;\n    case 0xd2:\n    case 0xd3:\n        /* shift Ev,cl */\n        shift = 0;\n        goto grp2;\n\n    case 0x1a4: /* shld imm */\n        op = 0;\n        shift = 1;\n        goto do_shiftd;\n    case 0x1a5: /* shld cl */\n        op = 0;\n        shift = 0;\n        goto do_shiftd;\n    case 0x1ac: /* shrd imm */\n        op = 1;\n        shift = 1;\n        goto do_shiftd;\n    case 0x1ad: /* shrd cl */\n        op = 1;\n        shift = 0;\n    do_shiftd:\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        if (mod != 3) {\n            gen_lea_modrm(env, s, modrm);\n            opreg = OR_TMP0;\n        } else {\n            opreg = rm;\n        }\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        if (shift) {\n            TCGv imm = tcg_const_tl(cpu_ldub_code(env, s->pc++));\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n            tcg_temp_free(imm);\n        } else {\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n        }\n        break;\n\n        /************************/\n        /* floats */\n    case 0xd8 ... 0xdf:\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n            /* XXX: what to do if illegal op ? */\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n            break;\n        }\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = modrm & 7;\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n        if (mod != 3) {\n            /* memory op */\n            gen_lea_modrm(env, s, modrm);\n            switch(op) {\n            case 0x00 ... 0x07: /* fxxxs */\n            case 0x10 ... 0x17: /* fixxxl */\n            case 0x20 ... 0x27: /* fxxxl */\n            case 0x30 ... 0x37: /* fixxx */\n                {\n                    int op1;\n                    op1 = op & 7;\n\n                    switch(op >> 4) {\n                    case 0:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LESW);\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    }\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n                    if (op1 == 3) {\n                        /* fcomp needs pop */\n                        gen_helper_fpop(cpu_env);\n                    }\n                }\n                break;\n            case 0x08: /* flds */\n            case 0x0a: /* fsts */\n            case 0x0b: /* fstps */\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n                switch(op & 7) {\n                case 0:\n                    switch(op >> 4) {\n                    case 0:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LESW);\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    }\n                    break;\n                case 1:\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n                    switch(op >> 4) {\n                    case 1:\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        break;\n                    case 2:\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUW);\n                        break;\n                    }\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    switch(op >> 4) {\n                    case 0:\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        break;\n                    case 1:\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        break;\n                    case 2:\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUW);\n                        break;\n                    }\n                    if ((op & 7) == 3)\n                        gen_helper_fpop(cpu_env);\n                    break;\n                }\n                break;\n            case 0x0c: /* fldenv mem */\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x0d: /* fldcw mem */\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                    s->mem_index, MO_LEUW);\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n                break;\n            case 0x0e: /* fnstenv mem */\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x0f: /* fnstcw mem */\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                    s->mem_index, MO_LEUW);\n                break;\n            case 0x1d: /* fldt mem */\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n                break;\n            case 0x1f: /* fstpt mem */\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x2c: /* frstor mem */\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x2e: /* fnsave mem */\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x2f: /* fnstsw mem */\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                    s->mem_index, MO_LEUW);\n                break;\n            case 0x3c: /* fbld */\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n                break;\n            case 0x3e: /* fbstp */\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x3d: /* fildll */\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n                break;\n            case 0x3f: /* fistpll */\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n                gen_helper_fpop(cpu_env);\n                break;\n            default:\n                goto unknown_op;\n            }\n        } else {\n            /* register float ops */\n            opreg = rm;\n\n            switch(op) {\n            case 0x08: /* fld sti */\n                gen_helper_fpush(cpu_env);\n                gen_helper_fmov_ST0_STN(cpu_env,\n                                        tcg_const_i32((opreg + 1) & 7));\n                break;\n            case 0x09: /* fxchg sti */\n            case 0x29: /* fxchg4 sti, undocumented op */\n            case 0x39: /* fxchg7 sti, undocumented op */\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n                break;\n            case 0x0a: /* grp d9/2 */\n                switch(rm) {\n                case 0: /* fnop */\n                    /* check exceptions (FreeBSD FPU probe) */\n                    gen_helper_fwait(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x0c: /* grp d9/4 */\n                switch(rm) {\n                case 0: /* fchs */\n                    gen_helper_fchs_ST0(cpu_env);\n                    break;\n                case 1: /* fabs */\n                    gen_helper_fabs_ST0(cpu_env);\n                    break;\n                case 4: /* ftst */\n                    gen_helper_fldz_FT0(cpu_env);\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n                    break;\n                case 5: /* fxam */\n                    gen_helper_fxam_ST0(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x0d: /* grp d9/5 */\n                {\n                    switch(rm) {\n                    case 0:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fld1_ST0(cpu_env);\n                        break;\n                    case 1:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldl2t_ST0(cpu_env);\n                        break;\n                    case 2:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldl2e_ST0(cpu_env);\n                        break;\n                    case 3:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldpi_ST0(cpu_env);\n                        break;\n                    case 4:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldlg2_ST0(cpu_env);\n                        break;\n                    case 5:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldln2_ST0(cpu_env);\n                        break;\n                    case 6:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldz_ST0(cpu_env);\n                        break;\n                    default:\n                        goto unknown_op;\n                    }\n                }\n                break;\n            case 0x0e: /* grp d9/6 */\n                switch(rm) {\n                case 0: /* f2xm1 */\n                    gen_helper_f2xm1(cpu_env);\n                    break;\n                case 1: /* fyl2x */\n                    gen_helper_fyl2x(cpu_env);\n                    break;\n                case 2: /* fptan */\n                    gen_helper_fptan(cpu_env);\n                    break;\n                case 3: /* fpatan */\n                    gen_helper_fpatan(cpu_env);\n                    break;\n                case 4: /* fxtract */\n                    gen_helper_fxtract(cpu_env);\n                    break;\n                case 5: /* fprem1 */\n                    gen_helper_fprem1(cpu_env);\n                    break;\n                case 6: /* fdecstp */\n                    gen_helper_fdecstp(cpu_env);\n                    break;\n                default:\n                case 7: /* fincstp */\n                    gen_helper_fincstp(cpu_env);\n                    break;\n                }\n                break;\n            case 0x0f: /* grp d9/7 */\n                switch(rm) {\n                case 0: /* fprem */\n                    gen_helper_fprem(cpu_env);\n                    break;\n                case 1: /* fyl2xp1 */\n                    gen_helper_fyl2xp1(cpu_env);\n                    break;\n                case 2: /* fsqrt */\n                    gen_helper_fsqrt(cpu_env);\n                    break;\n                case 3: /* fsincos */\n                    gen_helper_fsincos(cpu_env);\n                    break;\n                case 5: /* fscale */\n                    gen_helper_fscale(cpu_env);\n                    break;\n                case 4: /* frndint */\n                    gen_helper_frndint(cpu_env);\n                    break;\n                case 6: /* fsin */\n                    gen_helper_fsin(cpu_env);\n                    break;\n                default:\n                case 7: /* fcos */\n                    gen_helper_fcos(cpu_env);\n                    break;\n                }\n                break;\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n                {\n                    int op1;\n\n                    op1 = op & 7;\n                    if (op >= 0x20) {\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n                        if (op >= 0x30)\n                            gen_helper_fpop(cpu_env);\n                    } else {\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                        gen_helper_fp_arith_ST0_FT0(op1);\n                    }\n                }\n                break;\n            case 0x02: /* fcom */\n            case 0x22: /* fcom2, undocumented op */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcom_ST0_FT0(cpu_env);\n                break;\n            case 0x03: /* fcomp */\n            case 0x23: /* fcomp3, undocumented op */\n            case 0x32: /* fcomp5, undocumented op */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcom_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x15: /* da/5 */\n                switch(rm) {\n                case 1: /* fucompp */\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x1c:\n                switch(rm) {\n                case 0: /* feni (287 only, just do nop here) */\n                    break;\n                case 1: /* fdisi (287 only, just do nop here) */\n                    break;\n                case 2: /* fclex */\n                    gen_helper_fclex(cpu_env);\n                    break;\n                case 3: /* fninit */\n                    gen_helper_fninit(cpu_env);\n                    break;\n                case 4: /* fsetpm (287 only, just do nop here) */\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x1d: /* fucomi */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x1e: /* fcomi */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x28: /* ffree sti */\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n                break;\n            case 0x2a: /* fst sti */\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n                break;\n            case 0x2b: /* fstp sti */\n            case 0x0b: /* fstp1 sti, undocumented op */\n            case 0x3a: /* fstp8 sti, undocumented op */\n            case 0x3b: /* fstp9 sti, undocumented op */\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x2c: /* fucom st(i) */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucom_ST0_FT0(cpu_env);\n                break;\n            case 0x2d: /* fucomp st(i) */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucom_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x33: /* de/3 */\n                switch(rm) {\n                case 1: /* fcompp */\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x38: /* ffreep sti, undocumented op */\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x3c: /* df/4 */\n                switch(rm) {\n                case 0:\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x3d: /* fucomip */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x3e: /* fcomip */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x10 ... 0x13: /* fcmovxx */\n            case 0x18 ... 0x1b:\n                {\n                    int op1;\n                    TCGLabel *l1;\n                    static const uint8_t fcmov_cc[8] = {\n                        (JCC_B << 1),\n                        (JCC_Z << 1),\n                        (JCC_BE << 1),\n                        (JCC_P << 1),\n                    };\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n                        goto illegal_op;\n                    }\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n                    l1 = gen_new_label();\n                    gen_jcc1_noeob(s, op1, l1);\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n                    gen_set_label(l1);\n                }\n                break;\n            default:\n                goto unknown_op;\n            }\n        }\n        break;\n        /************************/\n        /* string ops */\n\n    case 0xa4: /* movsS */\n    case 0xa5:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_movs(s, ot);\n        }\n        break;\n\n    case 0xaa: /* stosS */\n    case 0xab:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_stos(s, ot);\n        }\n        break;\n    case 0xac: /* lodsS */\n    case 0xad:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_lods(s, ot);\n        }\n        break;\n    case 0xae: /* scasS */\n    case 0xaf:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & PREFIX_REPNZ) {\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n        } else if (prefixes & PREFIX_REPZ) {\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n        } else {\n            gen_scas(s, ot);\n        }\n        break;\n\n    case 0xa6: /* cmpsS */\n    case 0xa7:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & PREFIX_REPNZ) {\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n        } else if (prefixes & PREFIX_REPZ) {\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n        } else {\n            gen_cmps(s, ot);\n        }\n        break;\n    case 0x6c: /* insS */\n    case 0x6d:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base, \n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_ins(s, ot);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n        }\n        break;\n    case 0x6e: /* outsS */\n    case 0x6f:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes) | 4);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_outs(s, ot);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n        }\n        break;\n\n        /************************/\n        /* port I/O */\n\n    case 0xe4:\n    case 0xe5:\n        ot = mo_b_d32(b, dflag);\n        val = cpu_ldub_code(env, s->pc++);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xe6:\n    case 0xe7:\n        ot = mo_b_d32(b, dflag);\n        val = cpu_ldub_code(env, s->pc++);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes));\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xec:\n    case 0xed:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xee:\n    case 0xef:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes));\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n\n        /************************/\n        /* control */\n    case 0xc2: /* ret im */\n        val = cpu_ldsw_code(env, s->pc);\n        s->pc += 2;\n        ot = gen_pop_T0(s);\n        gen_stack_update(s, val + (1 << ot));\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n        gen_op_jmp_v(cpu_T0);\n        gen_bnd_jmp(s);\n        gen_eob(s);\n        break;\n    case 0xc3: /* ret */\n        ot = gen_pop_T0(s);\n        gen_pop_update(s, ot);\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n        gen_op_jmp_v(cpu_T0);\n        gen_bnd_jmp(s);\n        gen_eob(s);\n        break;\n    case 0xca: /* lret im */\n        val = cpu_ldsw_code(env, s->pc);\n        s->pc += 2;\n    do_lret:\n        if (s->pe && !s->vm86) {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n                                      tcg_const_i32(val));\n        } else {\n            gen_stack_A0(s);\n            /* pop offset */\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n            /* NOTE: keeping EIP updated is not a problem in case of\n               exception */\n            gen_op_jmp_v(cpu_T0);\n            /* pop selector */\n            gen_add_A0_im(s, 1 << dflag);\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n            gen_op_movl_seg_T0_vm(R_CS);\n            /* add stack offset */\n            gen_stack_update(s, val + (2 << dflag));\n        }\n        gen_eob(s);\n        break;\n    case 0xcb: /* lret */\n        val = 0;\n        goto do_lret;\n    case 0xcf: /* iret */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n        if (!s->pe) {\n            /* real mode */\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n            set_cc_op(s, CC_OP_EFLAGS);\n        } else if (s->vm86) {\n            if (s->iopl != 3) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n        } else {\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n                                      tcg_const_i32(s->pc - s->cs_base));\n            set_cc_op(s, CC_OP_EFLAGS);\n        }\n        gen_eob(s);\n        break;\n    case 0xe8: /* call im */\n        {\n            if (dflag != MO_16) {\n                tval = (int32_t)insn_get(env, s, MO_32);\n            } else {\n                tval = (int16_t)insn_get(env, s, MO_16);\n            }\n            next_eip = s->pc - s->cs_base;\n            tval += next_eip;\n            if (dflag == MO_16) {\n                tval &= 0xffff;\n            } else if (!CODE64(s)) {\n                tval &= 0xffffffff;\n            }\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n            gen_push_v(s, cpu_T0);\n            gen_bnd_jmp(s);\n            gen_jmp(s, tval);\n        }\n        break;\n    case 0x9a: /* lcall im */\n        {\n            unsigned int selector, offset;\n\n            if (CODE64(s))\n                goto illegal_op;\n            ot = dflag;\n            offset = insn_get(env, s, ot);\n            selector = insn_get(env, s, MO_16);\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n            tcg_gen_movi_tl(cpu_T1, offset);\n        }\n        goto do_lcall;\n    case 0xe9: /* jmp im */\n        if (dflag != MO_16) {\n            tval = (int32_t)insn_get(env, s, MO_32);\n        } else {\n            tval = (int16_t)insn_get(env, s, MO_16);\n        }\n        tval += s->pc - s->cs_base;\n        if (dflag == MO_16) {\n            tval &= 0xffff;\n        } else if (!CODE64(s)) {\n            tval &= 0xffffffff;\n        }\n        gen_bnd_jmp(s);\n        gen_jmp(s, tval);\n        break;\n    case 0xea: /* ljmp im */\n        {\n            unsigned int selector, offset;\n\n            if (CODE64(s))\n                goto illegal_op;\n            ot = dflag;\n            offset = insn_get(env, s, ot);\n            selector = insn_get(env, s, MO_16);\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n            tcg_gen_movi_tl(cpu_T1, offset);\n        }\n        goto do_ljmp;\n    case 0xeb: /* jmp Jb */\n        tval = (int8_t)insn_get(env, s, MO_8);\n        tval += s->pc - s->cs_base;\n        if (dflag == MO_16) {\n            tval &= 0xffff;\n        }\n        gen_jmp(s, tval);\n        break;\n    case 0x70 ... 0x7f: /* jcc Jb */\n        tval = (int8_t)insn_get(env, s, MO_8);\n        goto do_jcc;\n    case 0x180 ... 0x18f: /* jcc Jv */\n        if (dflag != MO_16) {\n            tval = (int32_t)insn_get(env, s, MO_32);\n        } else {\n            tval = (int16_t)insn_get(env, s, MO_16);\n        }\n    do_jcc:\n        next_eip = s->pc - s->cs_base;\n        tval += next_eip;\n        if (dflag == MO_16) {\n            tval &= 0xffff;\n        }\n        gen_bnd_jmp(s);\n        gen_jcc(s, b, tval, next_eip);\n        break;\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n        modrm = cpu_ldub_code(env, s->pc++);\n        gen_setcc1(s, b, cpu_T0);\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n        break;\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n            goto illegal_op;\n        }\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n        break;\n\n        /************************/\n        /* flags */\n    case 0x9c: /* pushf */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_update_cc_op(s);\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n            gen_push_v(s, cpu_T0);\n        }\n        break;\n    case 0x9d: /* popf */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            ot = gen_pop_T0(s);\n            if (s->cpl == 0) {\n                if (dflag != MO_16) {\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n                                                           ID_MASK | NT_MASK |\n                                                           IF_MASK |\n                                                           IOPL_MASK)));\n                } else {\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n                                                           ID_MASK | NT_MASK |\n                                                           IF_MASK | IOPL_MASK)\n                                                          & 0xffff));\n                }\n            } else {\n                if (s->cpl <= s->iopl) {\n                    if (dflag != MO_16) {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                                tcg_const_i32((TF_MASK |\n                                                               AC_MASK |\n                                                               ID_MASK |\n                                                               NT_MASK |\n                                                               IF_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                                tcg_const_i32((TF_MASK |\n                                                               AC_MASK |\n                                                               ID_MASK |\n                                                               NT_MASK |\n                                                               IF_MASK)\n                                                              & 0xffff));\n                    }\n                } else {\n                    if (dflag != MO_16) {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n                                                          ID_MASK | NT_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n                                                          ID_MASK | NT_MASK)\n                                                         & 0xffff));\n                    }\n                }\n            }\n            gen_pop_update(s, ot);\n            set_cc_op(s, CC_OP_EFLAGS);\n            /* abort translation because TF/AC flag may change */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    case 0x9e: /* sahf */\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n        gen_compute_eflags(s);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n        break;\n    case 0x9f: /* lahf */\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_compute_eflags(s);\n        /* Note: gen_compute_eflags() only gives the condition codes */\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n        break;\n    case 0xf5: /* cmc */\n        gen_compute_eflags(s);\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        break;\n    case 0xf8: /* clc */\n        gen_compute_eflags(s);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n        break;\n    case 0xf9: /* stc */\n        gen_compute_eflags(s);\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        break;\n    case 0xfc: /* cld */\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n        break;\n    case 0xfd: /* std */\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n        break;\n\n        /************************/\n        /* bit operations */\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        op = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        if (mod != 3) {\n            s->rip_offset = 1;\n            gen_lea_modrm(env, s, modrm);\n            if (!(s->prefix & PREFIX_LOCK)) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n        /* load shift */\n        val = cpu_ldub_code(env, s->pc++);\n        tcg_gen_movi_tl(cpu_T1, val);\n        if (op < 4)\n            goto unknown_op;\n        op -= 4;\n        goto bt_op;\n    case 0x1a3: /* bt Gv, Ev */\n        op = 0;\n        goto do_btx;\n    case 0x1ab: /* bts */\n        op = 1;\n        goto do_btx;\n    case 0x1b3: /* btr */\n        op = 2;\n        goto do_btx;\n    case 0x1bb: /* btc */\n        op = 3;\n    do_btx:\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n        if (mod != 3) {\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n            /* specific case: we need to add a displacement */\n            gen_exts(ot, cpu_T1);\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n            if (!(s->prefix & PREFIX_LOCK)) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n    bt_op:\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n        if (s->prefix & PREFIX_LOCK) {\n            switch (op) {\n            case 0: /* bt */\n                /* Needs no atomic ops; we surpressed the normal\n                   memory load for LOCK above so do it now.  */\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n                break;\n            case 1: /* bts */\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                           s->mem_index, ot | MO_LE);\n                break;\n            case 2: /* btr */\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                            s->mem_index, ot | MO_LE);\n                break;\n            default:\n            case 3: /* btc */\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                            s->mem_index, ot | MO_LE);\n                break;\n            }\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n        } else {\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n            switch (op) {\n            case 0: /* bt */\n                /* Data already loaded; nothing to do.  */\n                break;\n            case 1: /* bts */\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            case 2: /* btr */\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            default:\n            case 3: /* btc */\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            }\n            if (op != 0) {\n                if (mod != 3) {\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n            }\n        }\n\n        /* Delay all CC updates until after the store above.  Note that\n           C is the result of the test, Z is unchanged, and the others\n           are all undefined.  */\n        switch (s->cc_op) {\n        case CC_OP_MULB ... CC_OP_MULQ:\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n        case CC_OP_INCB ... CC_OP_INCQ:\n        case CC_OP_DECB ... CC_OP_DECQ:\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n        case CC_OP_SARB ... CC_OP_SARQ:\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n            /* Z was going to be computed from the non-zero status of CC_DST.\n               We can get that same Z value (and the new C value) by leaving\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n               same width.  */\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n            break;\n        default:\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n            gen_compute_eflags(s);\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n                               ctz32(CC_C), 1);\n            break;\n        }\n        break;\n    case 0x1bc: /* bsf / tzcnt */\n    case 0x1bd: /* bsr / lzcnt */\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_extu(ot, cpu_T0);\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n        if ((prefixes & PREFIX_REPZ)\n            && (b & 1\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n            int size = 8 << ot;\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n            if (b & 1) {\n                /* For lzcnt, reduce the target_ulong result by the\n                   number of zeros that we expect to find at the top.  */\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n            } else {\n                /* For tzcnt, a zero input must return the operand size.  */\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n            }\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n            gen_op_update1_cc();\n            set_cc_op(s, CC_OP_BMILGB + ot);\n        } else {\n            /* For bsr/bsf, only the Z bit is defined and it is related\n               to the input and not the result.  */\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            /* ??? The manual says that the output is undefined when the\n               input is zero, but real hardware leaves it unchanged, and\n               real programs appear to depend on that.  Accomplish this\n               by passing the output as the value to return upon zero.  */\n            if (b & 1) {\n                /* For bsr, return the bit index of the first 1 bit,\n                   not the count of leading zeros.  */\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n            } else {\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n            }\n        }\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n        break;\n        /************************/\n        /* bcd */\n    case 0x27: /* daa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_daa(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0x2f: /* das */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_das(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0x37: /* aaa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_aaa(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0x3f: /* aas */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_aas(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0xd4: /* aam */\n        if (CODE64(s))\n            goto illegal_op;\n        val = cpu_ldub_code(env, s->pc++);\n        if (val == 0) {\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n        } else {\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n            set_cc_op(s, CC_OP_LOGICB);\n        }\n        break;\n    case 0xd5: /* aad */\n        if (CODE64(s))\n            goto illegal_op;\n        val = cpu_ldub_code(env, s->pc++);\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n        set_cc_op(s, CC_OP_LOGICB);\n        break;\n        /************************/\n        /* misc */\n    case 0x90: /* nop */\n        /* XXX: correct lock test for all insn */\n        if (prefixes & PREFIX_LOCK) {\n            goto illegal_op;\n        }\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n        if (REX_B(s)) {\n            goto do_xchg_reg_eax;\n        }\n        if (prefixes & PREFIX_REPZ) {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n            s->is_jmp = DISAS_TB_JUMP;\n        }\n        break;\n    case 0x9b: /* fwait */\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n            (HF_MP_MASK | HF_TS_MASK)) {\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        } else {\n            gen_helper_fwait(cpu_env);\n        }\n        break;\n    case 0xcc: /* int3 */\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n        break;\n    case 0xcd: /* int N */\n        val = cpu_ldub_code(env, s->pc++);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n        }\n        break;\n    case 0xce: /* into */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n        break;\n#ifdef WANT_ICEBP\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n#if 1\n        gen_debug(s, pc_start - s->cs_base);\n#else\n        /* start debug */\n        tb_flush(CPU(x86_env_get_cpu(env)));\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n#endif\n        break;\n#endif\n    case 0xfa: /* cli */\n        if (!s->vm86) {\n            if (s->cpl <= s->iopl) {\n                gen_helper_cli(cpu_env);\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        } else {\n            if (s->iopl == 3) {\n                gen_helper_cli(cpu_env);\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        }\n        break;\n    case 0xfb: /* sti */\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n            gen_helper_sti(cpu_env);\n            /* interruptions are enabled only the first insn after sti */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob_inhibit_irq(s, true);\n        } else {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        }\n        break;\n    case 0x62: /* bound */\n        if (CODE64(s))\n            goto illegal_op;\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n        gen_lea_modrm(env, s, modrm);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        if (ot == MO_16) {\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n        } else {\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n        }\n        break;\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n        reg = (b & 7) | REX_B(s);\n#ifdef TARGET_X86_64\n        if (dflag == MO_64) {\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n        } else\n#endif\n        {\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n        }\n        break;\n    case 0xd6: /* salc */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_compute_eflags_c(s, cpu_T0);\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n        break;\n    case 0xe0: /* loopnz */\n    case 0xe1: /* loopz */\n    case 0xe2: /* loop */\n    case 0xe3: /* jecxz */\n        {\n            TCGLabel *l1, *l2, *l3;\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n            next_eip = s->pc - s->cs_base;\n            tval += next_eip;\n            if (dflag == MO_16) {\n                tval &= 0xffff;\n            }\n\n            l1 = gen_new_label();\n            l2 = gen_new_label();\n            l3 = gen_new_label();\n            b &= 3;\n            switch(b) {\n            case 0: /* loopnz */\n            case 1: /* loopz */\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n                gen_op_jz_ecx(s->aflag, l3);\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n                break;\n            case 2: /* loop */\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n                gen_op_jnz_ecx(s->aflag, l1);\n                break;\n            default:\n            case 3: /* jcxz */\n                gen_op_jz_ecx(s->aflag, l1);\n                break;\n            }\n\n            gen_set_label(l3);\n            gen_jmp_im(next_eip);\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n            gen_jmp_im(tval);\n            gen_set_label(l2);\n            gen_eob(s);\n        }\n        break;\n    case 0x130: /* wrmsr */\n    case 0x132: /* rdmsr */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            if (b & 2) {\n                gen_helper_rdmsr(cpu_env);\n            } else {\n                gen_helper_wrmsr(cpu_env);\n            }\n        }\n        break;\n    case 0x131: /* rdtsc */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        gen_helper_rdtsc(cpu_env);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0x133: /* rdpmc */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_rdpmc(cpu_env);\n        break;\n    case 0x134: /* sysenter */\n        /* For Intel SYSENTER is valid on 64-bit */\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_helper_sysenter(cpu_env);\n            gen_eob(s);\n        }\n        break;\n    case 0x135: /* sysexit */\n        /* For Intel SYSEXIT is valid on 64-bit */\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n            gen_eob(s);\n        }\n        break;\n#ifdef TARGET_X86_64\n    case 0x105: /* syscall */\n        /* XXX: is it usable in real mode ? */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n           after the syscall insn completes. This allows #DB to not be\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n        gen_eob_worker(s, false, true);\n        break;\n    case 0x107: /* sysret */\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n            /* condition codes are modified only in long mode */\n            if (s->lma) {\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n            /* TF handling for the sysret insn is different. The TF bit is\n               checked after the sysret insn completes. This allows #DB to be\n               generated \"as if\" the syscall insn in userspace has just\n               completed.  */\n            gen_eob_worker(s, false, true);\n        }\n        break;\n#endif\n    case 0x1a2: /* cpuid */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_cpuid(cpu_env);\n        break;\n    case 0xf4: /* hlt */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n            s->is_jmp = DISAS_TB_JUMP;\n        }\n        break;\n    case 0x100:\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* sldt */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                             offsetof(CPUX86State, ldt.selector));\n            ot = mod == 3 ? dflag : MO_16;\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 2: /* lldt */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n            }\n            break;\n        case 1: /* str */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                             offsetof(CPUX86State, tr.selector));\n            ot = mod == 3 ? dflag : MO_16;\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 3: /* ltr */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n            }\n            break;\n        case 4: /* verr */\n        case 5: /* verw */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            gen_update_cc_op(s);\n            if (op == 4) {\n                gen_helper_verr(cpu_env, cpu_T0);\n            } else {\n                gen_helper_verw(cpu_env, cpu_T0);\n            }\n            set_cc_op(s, CC_OP_EFLAGS);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x101:\n        modrm = cpu_ldub_code(env, s->pc++);\n        switch (modrm) {\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_ld32u_tl(cpu_T0,\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n            gen_add_A0_im(s, 2);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            break;\n\n        case 0xc8: /* monitor */\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n            gen_extu(s->aflag, cpu_A0);\n            gen_add_A0_ds_seg(s);\n            gen_helper_monitor(cpu_env, cpu_A0);\n            break;\n\n        case 0xc9: /* mwait */\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n            gen_eob(s);\n            break;\n\n        case 0xca: /* clac */\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n                || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_helper_clac(cpu_env);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        case 0xcb: /* stac */\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n                || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_helper_stac(cpu_env);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n            gen_add_A0_im(s, 2);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            break;\n\n        case 0xd0: /* xgetbv */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n            break;\n\n        case 0xd1: /* xsetbv */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n            /* End TB because translation flags may change.  */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        case 0xd8: /* VMRUN */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n                             tcg_const_i32(s->pc - pc_start));\n            tcg_gen_exit_tb(0);\n            s->is_jmp = DISAS_TB_JUMP;\n            break;\n\n        case 0xd9: /* VMMCALL */\n            if (!(s->flags & HF_SVME_MASK)) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmmcall(cpu_env);\n            break;\n\n        case 0xda: /* VMLOAD */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n            break;\n\n        case 0xdb: /* VMSAVE */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n            break;\n\n        case 0xdc: /* STGI */\n            if ((!(s->flags & HF_SVME_MASK)\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n                || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_stgi(cpu_env);\n            break;\n\n        case 0xdd: /* CLGI */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_clgi(cpu_env);\n            break;\n\n        case 0xde: /* SKINIT */\n            if ((!(s->flags & HF_SVME_MASK)\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n                || !s->pe) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_skinit(cpu_env);\n            break;\n\n        case 0xdf: /* INVLPGA */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n            break;\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n            gen_lea_modrm(env, s, modrm);\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 2);\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n            break;\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n            gen_lea_modrm(env, s, modrm);\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 2);\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n            break;\n\n        CASE_MODRM_OP(4): /* smsw */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n            if (CODE64(s)) {\n                mod = (modrm >> 6) & 3;\n                ot = (mod != 3 ? MO_16 : s->dflag);\n            } else {\n                ot = MO_16;\n            }\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 0xee: /* rdpkru */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n            break;\n        case 0xef: /* wrpkru */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n            break;\n        CASE_MODRM_OP(6): /* lmsw */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            gen_helper_lmsw(cpu_env, cpu_T0);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_lea_modrm(env, s, modrm);\n            gen_helper_invlpg(cpu_env, cpu_A0);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        case 0xf8: /* swapgs */\n#ifdef TARGET_X86_64\n            if (CODE64(s)) {\n                if (s->cpl != 0) {\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                } else {\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n                                  offsetof(CPUX86State, kernelgsbase));\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n                                  offsetof(CPUX86State, kernelgsbase));\n                }\n                break;\n            }\n#endif\n            goto illegal_op;\n\n        case 0xf9: /* rdtscp */\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_io_start();\n            }\n            gen_helper_rdtscp(cpu_env);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_io_end();\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n            break;\n\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x108: /* invd */\n    case 0x109: /* wbinvd */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n            /* nothing to do */\n        }\n        break;\n    case 0x63: /* arpl or movslS (x86_64) */\n#ifdef TARGET_X86_64\n        if (CODE64(s)) {\n            int d_ot;\n            /* d_ot is the size of destination */\n            d_ot = dflag;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n\n            if (mod == 3) {\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n                /* sign extend */\n                if (d_ot == MO_64) {\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                }\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            } else {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            }\n        } else\n#endif\n        {\n            TCGLabel *label1;\n            TCGv t0, t1, t2, a0;\n\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            t0 = tcg_temp_local_new();\n            t1 = tcg_temp_local_new();\n            t2 = tcg_temp_local_new();\n            ot = MO_16;\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = (modrm >> 3) & 7;\n            mod = (modrm >> 6) & 3;\n            rm = modrm & 7;\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n                a0 = tcg_temp_local_new();\n                tcg_gen_mov_tl(a0, cpu_A0);\n            } else {\n                gen_op_mov_v_reg(ot, t0, rm);\n                TCGV_UNUSED(a0);\n            }\n            gen_op_mov_v_reg(ot, t1, reg);\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n            tcg_gen_andi_tl(t1, t1, 3);\n            tcg_gen_movi_tl(t2, 0);\n            label1 = gen_new_label();\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n            tcg_gen_andi_tl(t0, t0, ~3);\n            tcg_gen_or_tl(t0, t0, t1);\n            tcg_gen_movi_tl(t2, CC_Z);\n            gen_set_label(label1);\n            if (mod != 3) {\n                gen_op_st_v(s, ot, t0, a0);\n                tcg_temp_free(a0);\n           } else {\n                gen_op_mov_reg_v(ot, rm, t0);\n            }\n            gen_compute_eflags(s);\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n            tcg_temp_free(t0);\n            tcg_temp_free(t1);\n            tcg_temp_free(t2);\n        }\n        break;\n    case 0x102: /* lar */\n    case 0x103: /* lsl */\n        {\n            TCGLabel *label1;\n            TCGv t0;\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            t0 = tcg_temp_local_new();\n            gen_update_cc_op(s);\n            if (b == 0x102) {\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n            } else {\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n            }\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n            label1 = gen_new_label();\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n            gen_op_mov_reg_v(ot, reg, t0);\n            gen_set_label(label1);\n            set_cc_op(s, CC_OP_EFLAGS);\n            tcg_temp_free(t0);\n        }\n        break;\n    case 0x118:\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* prefetchnta */\n        case 1: /* prefetchnt0 */\n        case 2: /* prefetchnt0 */\n        case 3: /* prefetchnt0 */\n            if (mod == 3)\n                goto illegal_op;\n            gen_nop_modrm(env, s, modrm);\n            /* nothing more to do */\n            break;\n        default: /* nop (multi byte) */\n            gen_nop_modrm(env, s, modrm);\n            break;\n        }\n        break;\n    case 0x11a:\n        modrm = cpu_ldub_code(env, s->pc++);\n        if (s->flags & HF_MPX_EN_MASK) {\n            mod = (modrm >> 6) & 3;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (prefixes & PREFIX_REPZ) {\n                /* bndcl */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n            } else if (prefixes & PREFIX_REPNZ) {\n                /* bndcu */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                TCGv_i64 notu = tcg_temp_new_i64();\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n                tcg_temp_free_i64(notu);\n            } else if (prefixes & PREFIX_DATA) {\n                /* bndmov -- from reg/mem */\n                if (reg >= 4 || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                if (mod == 3) {\n                    int reg2 = (modrm & 7) | REX_B(s);\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n                        goto illegal_op;\n                    }\n                    if (s->flags & HF_MPX_IU_MASK) {\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n                    }\n                } else {\n                    gen_lea_modrm(env, s, modrm);\n                    if (CODE64(s)) {\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                    } else {\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                    /* bnd registers are now in-use */\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n                }\n            } else if (mod != 3) {\n                /* bndldx */\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16\n                    || a.base < -1) {\n                    goto illegal_op;\n                }\n                if (a.base >= 0) {\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n                } else {\n                    tcg_gen_movi_tl(cpu_A0, 0);\n                }\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n                if (a.index >= 0) {\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n                } else {\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                }\n                if (CODE64(s)) {\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n                } else {\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n                }\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n            }\n        }\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x11b:\n        modrm = cpu_ldub_code(env, s->pc++);\n        if (s->flags & HF_MPX_EN_MASK) {\n            mod = (modrm >> 6) & 3;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n                /* bndmk */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n                if (a.base >= 0) {\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n                    if (!CODE64(s)) {\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n                    }\n                } else if (a.base == -1) {\n                    /* no base register has lower bound of 0 */\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n                } else {\n                    /* rip-relative generates #ud */\n                    goto illegal_op;\n                }\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n                if (!CODE64(s)) {\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n                }\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n                /* bnd registers are now in-use */\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n                break;\n            } else if (prefixes & PREFIX_REPNZ) {\n                /* bndcn */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n            } else if (prefixes & PREFIX_DATA) {\n                /* bndmov -- to reg/mem */\n                if (reg >= 4 || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                if (mod == 3) {\n                    int reg2 = (modrm & 7) | REX_B(s);\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n                        goto illegal_op;\n                    }\n                    if (s->flags & HF_MPX_IU_MASK) {\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n                    }\n                } else {\n                    gen_lea_modrm(env, s, modrm);\n                    if (CODE64(s)) {\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                    } else {\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                }\n            } else if (mod != 3) {\n                /* bndstx */\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16\n                    || a.base < -1) {\n                    goto illegal_op;\n                }\n                if (a.base >= 0) {\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n                } else {\n                    tcg_gen_movi_tl(cpu_A0, 0);\n                }\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n                if (a.index >= 0) {\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n                } else {\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                }\n                if (CODE64(s)) {\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n                } else {\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n                }\n            }\n        }\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n        modrm = cpu_ldub_code(env, s->pc++);\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x120: /* mov reg, crN */\n    case 0x122: /* mov crN, reg */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            modrm = cpu_ldub_code(env, s->pc++);\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n             * AMD documentation (24594.pdf) and testing of\n             * intel 386 and 486 processors all show that the mod bits\n             * are assumed to be 1's, regardless of actual values.\n             */\n            rm = (modrm & 7) | REX_B(s);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (CODE64(s))\n                ot = MO_64;\n            else\n                ot = MO_32;\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n                reg = 8;\n            }\n            switch(reg) {\n            case 0:\n            case 2:\n            case 3:\n            case 4:\n            case 8:\n                gen_update_cc_op(s);\n                gen_jmp_im(pc_start - s->cs_base);\n                if (b & 2) {\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n                                         cpu_T0);\n                    gen_jmp_im(s->pc - s->cs_base);\n                    gen_eob(s);\n                } else {\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n                break;\n            default:\n                goto unknown_op;\n            }\n        }\n        break;\n    case 0x121: /* mov reg, drN */\n    case 0x123: /* mov drN, reg */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            modrm = cpu_ldub_code(env, s->pc++);\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n             * AMD documentation (24594.pdf) and testing of\n             * intel 386 and 486 processors all show that the mod bits\n             * are assumed to be 1's, regardless of actual values.\n             */\n            rm = (modrm & 7) | REX_B(s);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (CODE64(s))\n                ot = MO_64;\n            else\n                ot = MO_32;\n            if (reg >= 8) {\n                goto illegal_op;\n            }\n            if (b & 2) {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n                gen_jmp_im(s->pc - s->cs_base);\n                gen_eob(s);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n            }\n        }\n        break;\n    case 0x106: /* clts */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_helper_clts(cpu_env);\n            /* abort block because static cpu state changed */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n    case 0x1c3: /* MOVNTI reg, mem */\n        if (!(s->cpuid_features & CPUID_SSE2))\n            goto illegal_op;\n        ot = mo_64_32(dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        reg = ((modrm >> 3) & 7) | rex_r;\n        /* generate a generic store */\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n        break;\n    case 0x1ae:\n        modrm = cpu_ldub_code(env, s->pc++);\n        switch (modrm) {\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n            if (!(s->cpuid_features & CPUID_FXSR)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_helper_fxsave(cpu_env, cpu_A0);\n            break;\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n            if (!(s->cpuid_features & CPUID_FXSR)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n            break;\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n                goto illegal_op;\n            }\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n            break;\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n                goto illegal_op;\n            }\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            break;\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n            break;\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n            /* XRSTOR is how MPX is enabled, which changes how\n               we translate.  Thus we need to end the TB.  */\n            gen_update_cc_op(s);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            if (prefixes & PREFIX_DATA) {\n                /* clwb */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n                    goto illegal_op;\n                }\n                gen_nop_modrm(env, s, modrm);\n            } else {\n                /* xsaveopt */\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n                    goto illegal_op;\n                }\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                      cpu_regs[R_EDX]);\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n            }\n            break;\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            if (prefixes & PREFIX_DATA) {\n                /* clflushopt */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n                    goto illegal_op;\n                }\n            } else {\n                /* clflush */\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n                    goto illegal_op;\n                }\n            }\n            gen_nop_modrm(env, s, modrm);\n            break;\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n        case 0xc8 ... 0xc8: /* rdgsbase (f3 0f ae /1) */\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n        case 0xd8 ... 0xd8: /* wrgsbase (f3 0f ae /3) */\n            if (CODE64(s)\n                && (prefixes & PREFIX_REPZ)\n                && !(prefixes & PREFIX_LOCK)\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n                TCGv base, treg, src, dst;\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n                if (modrm & 0x10) {\n                    /* wr*base */\n                    dst = base, src = treg;\n                } else {\n                    /* rd*base */\n                    dst = treg, src = base;\n                }\n\n                if (s->dflag == MO_32) {\n                    tcg_gen_ext32u_tl(dst, src);\n                } else {\n                    tcg_gen_mov_tl(dst, src);\n                }\n                break;\n            }\n            goto unknown_op;\n\n        case 0xf8: /* sfence / pcommit */\n            if (prefixes & PREFIX_DATA) {\n                /* pcommit */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n                    || (prefixes & PREFIX_LOCK)) {\n                    goto illegal_op;\n                }\n                break;\n            }\n            /* fallthru */\n        case 0xf9 ... 0xff: /* sfence */\n            if (!(s->cpuid_features & CPUID_SSE)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n            break;\n        case 0xe8 ... 0xef: /* lfence */\n            if (!(s->cpuid_features & CPUID_SSE)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n            break;\n        case 0xf0 ... 0xf7: /* mfence */\n            if (!(s->cpuid_features & CPUID_SSE2)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n            break;\n\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x1aa: /* rsm */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n        if (!(s->flags & HF_SMM_MASK))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_jmp_im(s->pc - s->cs_base);\n        gen_helper_rsm(cpu_env);\n        gen_eob(s);\n        break;\n    case 0x1b8: /* SSE4.2 popcnt */\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n             PREFIX_REPZ)\n            goto illegal_op;\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n            goto illegal_op;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (s->prefix & PREFIX_DATA) {\n            ot = MO_16;\n        } else {\n            ot = mo_64_32(dflag);\n        }\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_extu(ot, cpu_T0);\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        set_cc_op(s, CC_OP_POPCNT);\n        break;\n    case 0x10e ... 0x10f:\n        /* 3DNow! instructions, ignore prefixes */\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n    case 0x110 ... 0x117:\n    case 0x128 ... 0x12f:\n    case 0x138 ... 0x13a:\n    case 0x150 ... 0x179:\n    case 0x17c ... 0x17f:\n    case 0x1c2:\n    case 0x1c4 ... 0x1c6:\n    case 0x1d0 ... 0x1fe:\n        gen_sse(env, s, b, pc_start, rex_r);\n        break;\n    default:\n        goto unknown_op;\n    }\n    return s->pc;\n illegal_op:\n    gen_illegal_opcode(s);\n    return s->pc;\n unknown_op:\n    gen_unknown_opcode(env, s);\n    return s->pc;\n}\n",
        "label": "1",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static target_ulong disas_insn(CPUX86State *env, DisasContext *s,\n                               target_ulong pc_start)\n{\n    int b, prefixes;\n    int shift;\n    TCGMemOp ot, aflag, dflag;\n    int modrm, reg, rm, mod, op, opreg, val;\n    target_ulong next_eip, tval;\n    int rex_w, rex_r;\n\n    s->pc_start = s->pc = pc_start;\n    prefixes = 0;\n    s->override = -1;\n    rex_w = -1;\n    rex_r = 0;\n#ifdef TARGET_X86_64\n    s->rex_x = 0;\n    s->rex_b = 0;\n    x86_64_hregs = 0;\n#endif\n    s->rip_offset = 0; /* for relative ip address */\n     s->vex_l = 0;\n     s->vex_v = 0;\n  next_byte:\n//fix_flaw_line_below:\n//    /* x86 has an upper limit of 15 bytes for an instruction. Since we\n//fix_flaw_line_below:\n//     * do not want to decode and generate IR for an illegal\n//fix_flaw_line_below:\n//     * instruction, the following check limits the instruction size to\n//fix_flaw_line_below:\n//     * 25 bytes: 14 prefix + 1 opc + 6 (modrm+sib+ofs) + 4 imm */\n//fix_flaw_line_below:\n//    if (s->pc - pc_start > 14) {\n//fix_flaw_line_below:\n//        goto illegal_op;\n//fix_flaw_line_below:\n//    }\n     b = cpu_ldub_code(env, s->pc);\n     s->pc++;\n     /* Collect prefixes.  */\n    switch (b) {\n    case 0xf3:\n        prefixes |= PREFIX_REPZ;\n        goto next_byte;\n    case 0xf2:\n        prefixes |= PREFIX_REPNZ;\n        goto next_byte;\n    case 0xf0:\n        prefixes |= PREFIX_LOCK;\n        goto next_byte;\n    case 0x2e:\n        s->override = R_CS;\n        goto next_byte;\n    case 0x36:\n        s->override = R_SS;\n        goto next_byte;\n    case 0x3e:\n        s->override = R_DS;\n        goto next_byte;\n    case 0x26:\n        s->override = R_ES;\n        goto next_byte;\n    case 0x64:\n        s->override = R_FS;\n        goto next_byte;\n    case 0x65:\n        s->override = R_GS;\n        goto next_byte;\n    case 0x66:\n        prefixes |= PREFIX_DATA;\n        goto next_byte;\n    case 0x67:\n        prefixes |= PREFIX_ADR;\n        goto next_byte;\n#ifdef TARGET_X86_64\n    case 0x40 ... 0x4f:\n        if (CODE64(s)) {\n            /* REX prefix */\n            rex_w = (b >> 3) & 1;\n            rex_r = (b & 0x4) << 1;\n            s->rex_x = (b & 0x2) << 2;\n            REX_B(s) = (b & 0x1) << 3;\n            x86_64_hregs = 1; /* select uniform byte register addressing */\n            goto next_byte;\n        }\n        break;\n#endif\n    case 0xc5: /* 2-byte VEX */\n    case 0xc4: /* 3-byte VEX */\n        /* VEX prefixes cannot be used except in 32-bit mode.\n           Otherwise the instruction is LES or LDS.  */\n        if (s->code32 && !s->vm86) {\n            static const int pp_prefix[4] = {\n                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ\n            };\n            int vex3, vex2 = cpu_ldub_code(env, s->pc);\n\n            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {\n                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,\n                   otherwise the instruction is LES or LDS.  */\n                break;\n            }\n            s->pc++;\n\n            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */\n            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ\n                            | PREFIX_LOCK | PREFIX_DATA)) {\n                goto illegal_op;\n            }\n#ifdef TARGET_X86_64\n            if (x86_64_hregs) {\n                goto illegal_op;\n            }\n#endif\n            rex_r = (~vex2 >> 4) & 8;\n            if (b == 0xc5) {\n                vex3 = vex2;\n                b = cpu_ldub_code(env, s->pc++);\n            } else {\n#ifdef TARGET_X86_64\n                s->rex_x = (~vex2 >> 3) & 8;\n                s->rex_b = (~vex2 >> 2) & 8;\n#endif\n                vex3 = cpu_ldub_code(env, s->pc++);\n                rex_w = (vex3 >> 7) & 1;\n                switch (vex2 & 0x1f) {\n                case 0x01: /* Implied 0f leading opcode bytes.  */\n                    b = cpu_ldub_code(env, s->pc++) | 0x100;\n                    break;\n                case 0x02: /* Implied 0f 38 leading opcode bytes.  */\n                    b = 0x138;\n                    break;\n                case 0x03: /* Implied 0f 3a leading opcode bytes.  */\n                    b = 0x13a;\n                    break;\n                default:   /* Reserved for future use.  */\n                    goto unknown_op;\n                }\n            }\n            s->vex_v = (~vex3 >> 3) & 0xf;\n            s->vex_l = (vex3 >> 2) & 1;\n            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;\n        }\n        break;\n    }\n\n    /* Post-process prefixes.  */\n    if (CODE64(s)) {\n        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit\n           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence\n           over 0x66 if both are present.  */\n        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);\n        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */\n        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);\n    } else {\n        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */\n        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {\n            dflag = MO_32;\n        } else {\n            dflag = MO_16;\n        }\n        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */\n        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {\n            aflag = MO_32;\n        }  else {\n            aflag = MO_16;\n        }\n    }\n\n    s->prefix = prefixes;\n    s->aflag = aflag;\n    s->dflag = dflag;\n\n    /* now check op code */\n reswitch:\n    switch(b) {\n    case 0x0f:\n        /**************************/\n        /* extended op code */\n        b = cpu_ldub_code(env, s->pc++) | 0x100;\n        goto reswitch;\n\n        /**************************/\n        /* arith & logic */\n    case 0x00 ... 0x05:\n    case 0x08 ... 0x0d:\n    case 0x10 ... 0x15:\n    case 0x18 ... 0x1d:\n    case 0x20 ... 0x25:\n    case 0x28 ... 0x2d:\n    case 0x30 ... 0x35:\n    case 0x38 ... 0x3d:\n        {\n            int op, f, val;\n            op = (b >> 3) & 7;\n            f = (b >> 1) & 3;\n\n            ot = mo_b_d(b, dflag);\n\n            switch(f) {\n            case 0: /* OP Ev, Gv */\n                modrm = cpu_ldub_code(env, s->pc++);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                mod = (modrm >> 6) & 3;\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3) {\n                    gen_lea_modrm(env, s, modrm);\n                    opreg = OR_TMP0;\n                } else if (op == OP_XORL && rm == reg) {\n                xor_zero:\n                    /* xor reg, reg optimisation */\n                    set_cc_op(s, CC_OP_CLR);\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                    break;\n                } else {\n                    opreg = rm;\n                }\n                gen_op_mov_v_reg(ot, cpu_T1, reg);\n                gen_op(s, op, ot, opreg);\n                break;\n            case 1: /* OP Gv, Ev */\n                modrm = cpu_ldub_code(env, s->pc++);\n                mod = (modrm >> 6) & 3;\n                reg = ((modrm >> 3) & 7) | rex_r;\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3) {\n                    gen_lea_modrm(env, s, modrm);\n                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n                } else if (op == OP_XORL && rm == reg) {\n                    goto xor_zero;\n                } else {\n                    gen_op_mov_v_reg(ot, cpu_T1, rm);\n                }\n                gen_op(s, op, ot, reg);\n                break;\n            case 2: /* OP A, Iv */\n                val = insn_get(env, s, ot);\n                tcg_gen_movi_tl(cpu_T1, val);\n                gen_op(s, op, ot, OR_EAX);\n                break;\n            }\n        }\n        break;\n\n    case 0x82:\n        if (CODE64(s))\n            goto illegal_op;\n    case 0x80: /* GRP1 */\n    case 0x81:\n    case 0x83:\n        {\n            int val;\n\n            ot = mo_b_d(b, dflag);\n\n            modrm = cpu_ldub_code(env, s->pc++);\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n            op = (modrm >> 3) & 7;\n\n            if (mod != 3) {\n                if (b == 0x83)\n                    s->rip_offset = 1;\n                else\n                    s->rip_offset = insn_const_size(ot);\n                gen_lea_modrm(env, s, modrm);\n                opreg = OR_TMP0;\n            } else {\n                opreg = rm;\n            }\n\n            switch(b) {\n            default:\n            case 0x80:\n            case 0x81:\n            case 0x82:\n                val = insn_get(env, s, ot);\n                break;\n            case 0x83:\n                val = (int8_t)insn_get(env, s, MO_8);\n                break;\n            }\n            tcg_gen_movi_tl(cpu_T1, val);\n            gen_op(s, op, ot, opreg);\n        }\n        break;\n\n        /**************************/\n        /* inc, dec, and other misc arith */\n    case 0x40 ... 0x47: /* inc Gv */\n        ot = dflag;\n        gen_inc(s, ot, OR_EAX + (b & 7), 1);\n        break;\n    case 0x48 ... 0x4f: /* dec Gv */\n        ot = dflag;\n        gen_inc(s, ot, OR_EAX + (b & 7), -1);\n        break;\n    case 0xf6: /* GRP3 */\n    case 0xf7:\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        op = (modrm >> 3) & 7;\n        if (mod != 3) {\n            if (op == 0) {\n                s->rip_offset = insn_const_size(ot);\n            }\n            gen_lea_modrm(env, s, modrm);\n            /* For those below that handle locked memory, don't load here.  */\n            if (!(s->prefix & PREFIX_LOCK)\n                || op != 2) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n\n        switch(op) {\n        case 0: /* test */\n            val = insn_get(env, s, ot);\n            tcg_gen_movi_tl(cpu_T1, val);\n            gen_op_testl_T0_T1_cc();\n            set_cc_op(s, CC_OP_LOGICB + ot);\n            break;\n        case 2: /* not */\n            if (s->prefix & PREFIX_LOCK) {\n                if (mod == 3) {\n                    goto illegal_op;\n                }\n                tcg_gen_movi_tl(cpu_T0, ~0);\n                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,\n                                            s->mem_index, ot | MO_LE);\n            } else {\n                tcg_gen_not_tl(cpu_T0, cpu_T0);\n                if (mod != 3) {\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n            }\n            break;\n        case 3: /* neg */\n            if (s->prefix & PREFIX_LOCK) {\n                TCGLabel *label1;\n                TCGv a0, t0, t1, t2;\n\n                if (mod == 3) {\n                    goto illegal_op;\n                }\n                a0 = tcg_temp_local_new();\n                t0 = tcg_temp_local_new();\n                label1 = gen_new_label();\n\n                tcg_gen_mov_tl(a0, cpu_A0);\n                tcg_gen_mov_tl(t0, cpu_T0);\n\n                gen_set_label(label1);\n                t1 = tcg_temp_new();\n                t2 = tcg_temp_new();\n                tcg_gen_mov_tl(t2, t0);\n                tcg_gen_neg_tl(t1, t0);\n                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,\n                                          s->mem_index, ot | MO_LE);\n                tcg_temp_free(t1);\n                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);\n\n                tcg_temp_free(t2);\n                tcg_temp_free(a0);\n                tcg_gen_mov_tl(cpu_T0, t0);\n                tcg_temp_free(t0);\n            } else {\n                tcg_gen_neg_tl(cpu_T0, cpu_T0);\n                if (mod != 3) {\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n            }\n            gen_op_update_neg_cc();\n            set_cc_op(s, CC_OP_SUBB + ot);\n            break;\n        case 4: /* mul */\n            switch(ot) {\n            case MO_8:\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);\n                set_cc_op(s, CC_OP_MULB);\n                break;\n            case MO_16:\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                set_cc_op(s, CC_OP_MULW);\n                break;\n            default:\n            case MO_32:\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(s, CC_OP_MULL);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n                                  cpu_T0, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(s, CC_OP_MULQ);\n                break;\n#endif\n            }\n            break;\n        case 5: /* imul */\n            switch(ot) {\n            case MO_8:\n                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);\n                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n                set_cc_op(s, CC_OP_MULB);\n                break;\n            case MO_16:\n                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);\n                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n                /* XXX: use 32 bit mul which could be faster */\n                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);\n                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n                set_cc_op(s, CC_OP_MULW);\n                break;\n            default:\n            case MO_32:\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);\n                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                  cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);\n                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);\n                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n                set_cc_op(s, CC_OP_MULL);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],\n                                  cpu_T0, cpu_regs[R_EAX]);\n                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);\n                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);\n                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);\n                set_cc_op(s, CC_OP_MULQ);\n                break;\n#endif\n            }\n            break;\n        case 6: /* div */\n            switch(ot) {\n            case MO_8:\n                gen_helper_divb_AL(cpu_env, cpu_T0);\n                break;\n            case MO_16:\n                gen_helper_divw_AX(cpu_env, cpu_T0);\n                break;\n            default:\n            case MO_32:\n                gen_helper_divl_EAX(cpu_env, cpu_T0);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                gen_helper_divq_EAX(cpu_env, cpu_T0);\n                break;\n#endif\n            }\n            break;\n        case 7: /* idiv */\n            switch(ot) {\n            case MO_8:\n                gen_helper_idivb_AL(cpu_env, cpu_T0);\n                break;\n            case MO_16:\n                gen_helper_idivw_AX(cpu_env, cpu_T0);\n                break;\n            default:\n            case MO_32:\n                gen_helper_idivl_EAX(cpu_env, cpu_T0);\n                break;\n#ifdef TARGET_X86_64\n            case MO_64:\n                gen_helper_idivq_EAX(cpu_env, cpu_T0);\n                break;\n#endif\n            }\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0xfe: /* GRP4 */\n    case 0xff: /* GRP5 */\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        op = (modrm >> 3) & 7;\n        if (op >= 2 && b == 0xfe) {\n            goto unknown_op;\n        }\n        if (CODE64(s)) {\n            if (op == 2 || op == 4) {\n                /* operand size for jumps is 64 bit */\n                ot = MO_64;\n            } else if (op == 3 || op == 5) {\n                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;\n            } else if (op == 6) {\n                /* default push size is 64 bit */\n                ot = mo_pushpop(s, dflag);\n            }\n        }\n        if (mod != 3) {\n            gen_lea_modrm(env, s, modrm);\n            if (op >= 2 && op != 3 && op != 5)\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n\n        switch(op) {\n        case 0: /* inc Ev */\n            if (mod != 3)\n                opreg = OR_TMP0;\n            else\n                opreg = rm;\n            gen_inc(s, ot, opreg, 1);\n            break;\n        case 1: /* dec Ev */\n            if (mod != 3)\n                opreg = OR_TMP0;\n            else\n                opreg = rm;\n            gen_inc(s, ot, opreg, -1);\n            break;\n        case 2: /* call Ev */\n            /* XXX: optimize if memory (no 'and' is necessary) */\n            if (dflag == MO_16) {\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n            }\n            next_eip = s->pc - s->cs_base;\n            tcg_gen_movi_tl(cpu_T1, next_eip);\n            gen_push_v(s, cpu_T1);\n            gen_op_jmp_v(cpu_T0);\n            gen_bnd_jmp(s);\n            gen_eob(s);\n            break;\n        case 3: /* lcall Ev */\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 1 << ot);\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n        do_lcall:\n            if (s->pe && !s->vm86) {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                           tcg_const_i32(dflag - 1),\n                                           tcg_const_tl(s->pc - s->cs_base));\n            } else {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                      tcg_const_i32(dflag - 1),\n                                      tcg_const_i32(s->pc - s->cs_base));\n            }\n            gen_eob(s);\n            break;\n        case 4: /* jmp Ev */\n            if (dflag == MO_16) {\n                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n            }\n            gen_op_jmp_v(cpu_T0);\n            gen_bnd_jmp(s);\n            gen_eob(s);\n            break;\n        case 5: /* ljmp Ev */\n            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 1 << ot);\n            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n        do_ljmp:\n            if (s->pe && !s->vm86) {\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,\n                                          tcg_const_tl(s->pc - s->cs_base));\n            } else {\n                gen_op_movl_seg_T0_vm(R_CS);\n                gen_op_jmp_v(cpu_T1);\n            }\n            gen_eob(s);\n            break;\n        case 6: /* push Ev */\n            gen_push_v(s, cpu_T0);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x84: /* test Ev, Gv */\n    case 0x85:\n        ot = mo_b_d(b, dflag);\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n        gen_op_testl_T0_T1_cc();\n        set_cc_op(s, CC_OP_LOGICB + ot);\n        break;\n\n    case 0xa8: /* test eAX, Iv */\n    case 0xa9:\n        ot = mo_b_d(b, dflag);\n        val = insn_get(env, s, ot);\n\n        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);\n        tcg_gen_movi_tl(cpu_T1, val);\n        gen_op_testl_T0_T1_cc();\n        set_cc_op(s, CC_OP_LOGICB + ot);\n        break;\n\n    case 0x98: /* CWDE/CBW */\n        switch (dflag) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);\n            break;\n#endif\n        case MO_32:\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);\n            break;\n        case MO_16:\n            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);\n            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n            break;\n        default:\n            tcg_abort();\n        }\n        break;\n    case 0x99: /* CDQ/CWD */\n        switch (dflag) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);\n            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);\n            break;\n#endif\n        case MO_32:\n            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);\n            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);\n            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);\n            break;\n        case MO_16:\n            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);\n            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);\n            break;\n        default:\n            tcg_abort();\n        }\n        break;\n    case 0x1af: /* imul Gv, Ev */\n    case 0x69: /* imul Gv, Ev, I */\n    case 0x6b:\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        if (b == 0x69)\n            s->rip_offset = insn_const_size(ot);\n        else if (b == 0x6b)\n            s->rip_offset = 1;\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        if (b == 0x69) {\n            val = insn_get(env, s, ot);\n            tcg_gen_movi_tl(cpu_T1, val);\n        } else if (b == 0x6b) {\n            val = (int8_t)insn_get(env, s, MO_8);\n            tcg_gen_movi_tl(cpu_T1, val);\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T1, reg);\n        }\n        switch (ot) {\n#ifdef TARGET_X86_64\n        case MO_64:\n            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);\n            break;\n#endif\n        case MO_32:\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                              cpu_tmp2_i32, cpu_tmp3_i32);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);\n            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);\n            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);\n            break;\n        default:\n            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);\n            /* XXX: use 32 bit mul which could be faster */\n            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);\n            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        }\n        set_cc_op(s, CC_OP_MULB + ot);\n        break;\n    case 0x1c0:\n    case 0x1c1: /* xadd Ev, Gv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n        if (mod == 3) {\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n        } else {\n            gen_lea_modrm(env, s, modrm);\n            if (s->prefix & PREFIX_LOCK) {\n                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,\n                                            s->mem_index, ot | MO_LE);\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n            } else {\n                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n            }\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n        }\n        gen_op_update2_cc();\n        set_cc_op(s, CC_OP_ADDB + ot);\n        break;\n    case 0x1b0:\n    case 0x1b1: /* cmpxchg Ev, Gv */\n        {\n            TCGv oldv, newv, cmpv;\n\n            ot = mo_b_d(b, dflag);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            oldv = tcg_temp_new();\n            newv = tcg_temp_new();\n            cmpv = tcg_temp_new();\n            gen_op_mov_v_reg(ot, newv, reg);\n            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);\n\n            if (s->prefix & PREFIX_LOCK) {\n                if (mod == 3) {\n                    goto illegal_op;\n                }\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,\n                                          s->mem_index, ot | MO_LE);\n                gen_op_mov_reg_v(ot, R_EAX, oldv);\n            } else {\n                if (mod == 3) {\n                    rm = (modrm & 7) | REX_B(s);\n                    gen_op_mov_v_reg(ot, oldv, rm);\n                } else {\n                    gen_lea_modrm(env, s, modrm);\n                    gen_op_ld_v(s, ot, oldv, cpu_A0);\n                    rm = 0; /* avoid warning */\n                }\n                gen_extu(ot, oldv);\n                gen_extu(ot, cmpv);\n                /* store value = (old == cmp ? new : old);  */\n                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);\n                if (mod == 3) {\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n                    gen_op_mov_reg_v(ot, rm, newv);\n                } else {\n                    /* Perform an unconditional store cycle like physical cpu;\n                       must be before changing accumulator to ensure\n                       idempotency if the store faults and the instruction\n                       is restarted */\n                    gen_op_st_v(s, ot, newv, cpu_A0);\n                    gen_op_mov_reg_v(ot, R_EAX, oldv);\n                }\n            }\n            tcg_gen_mov_tl(cpu_cc_src, oldv);\n            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);\n            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);\n            set_cc_op(s, CC_OP_SUBB + ot);\n            tcg_temp_free(oldv);\n            tcg_temp_free(newv);\n            tcg_temp_free(cmpv);\n        }\n        break;\n    case 0x1c7: /* cmpxchg8b */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if ((mod == 3) || ((modrm & 0x38) != 0x8))\n            goto illegal_op;\n#ifdef TARGET_X86_64\n        if (dflag == MO_64) {\n            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n                gen_helper_cmpxchg16b(cpu_env, cpu_A0);\n            } else {\n                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);\n            }\n        } else\n#endif        \n        {\n            if (!(s->cpuid_features & CPUID_CX8))\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {\n                gen_helper_cmpxchg8b(cpu_env, cpu_A0);\n            } else {\n                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);\n            }\n        }\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n\n        /**************************/\n        /* push/pop */\n    case 0x50 ... 0x57: /* push */\n        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x58 ... 0x5f: /* pop */\n        ot = gen_pop_T0(s);\n        /* NOTE: order is important for pop %sp */\n        gen_pop_update(s, ot);\n        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);\n        break;\n    case 0x60: /* pusha */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_pusha(s);\n        break;\n    case 0x61: /* popa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_popa(s);\n        break;\n    case 0x68: /* push Iv */\n    case 0x6a:\n        ot = mo_pushpop(s, dflag);\n        if (b == 0x68)\n            val = insn_get(env, s, ot);\n        else\n            val = (int8_t)insn_get(env, s, MO_8);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x8f: /* pop Ev */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        ot = gen_pop_T0(s);\n        if (mod == 3) {\n            /* NOTE: order is important for pop %sp */\n            gen_pop_update(s, ot);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n        } else {\n            /* NOTE: order is important too for MMU exceptions */\n            s->popl_esp_hack = 1 << ot;\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            s->popl_esp_hack = 0;\n            gen_pop_update(s, ot);\n        }\n        break;\n    case 0xc8: /* enter */\n        {\n            int level;\n            val = cpu_lduw_code(env, s->pc);\n            s->pc += 2;\n            level = cpu_ldub_code(env, s->pc++);\n            gen_enter(s, val, level);\n        }\n        break;\n    case 0xc9: /* leave */\n        gen_leave(s);\n        break;\n    case 0x06: /* push es */\n    case 0x0e: /* push cs */\n    case 0x16: /* push ss */\n    case 0x1e: /* push ds */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_op_movl_T0_seg(b >> 3);\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x1a0: /* push fs */\n    case 0x1a8: /* push gs */\n        gen_op_movl_T0_seg((b >> 3) & 7);\n        gen_push_v(s, cpu_T0);\n        break;\n    case 0x07: /* pop es */\n    case 0x17: /* pop ss */\n    case 0x1f: /* pop ds */\n        if (CODE64(s))\n            goto illegal_op;\n        reg = b >> 3;\n        ot = gen_pop_T0(s);\n        gen_movl_seg_T0(s, reg);\n        gen_pop_update(s, ot);\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            if (reg == R_SS) {\n                s->tf = 0;\n                gen_eob_inhibit_irq(s, true);\n            } else {\n                gen_eob(s);\n            }\n        }\n        break;\n    case 0x1a1: /* pop fs */\n    case 0x1a9: /* pop gs */\n        ot = gen_pop_T0(s);\n        gen_movl_seg_T0(s, (b >> 3) & 7);\n        gen_pop_update(s, ot);\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n\n        /**************************/\n        /* mov */\n    case 0x88:\n    case 0x89: /* mov Gv, Ev */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        /* generate a generic store */\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n        break;\n    case 0xc6:\n    case 0xc7: /* mov Ev, Iv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod != 3) {\n            s->rip_offset = insn_const_size(ot);\n            gen_lea_modrm(env, s, modrm);\n        }\n        val = insn_get(env, s, ot);\n        tcg_gen_movi_tl(cpu_T0, val);\n        if (mod != 3) {\n            gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n        } else {\n            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);\n        }\n        break;\n    case 0x8a:\n    case 0x8b: /* mov Ev, Gv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n        break;\n    case 0x8e: /* mov seg, Gv */\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = (modrm >> 3) & 7;\n        if (reg >= 6 || reg == R_CS)\n            goto illegal_op;\n        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n        gen_movl_seg_T0(s, reg);\n        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            if (reg == R_SS) {\n                s->tf = 0;\n                gen_eob_inhibit_irq(s, true);\n            } else {\n                gen_eob(s);\n            }\n        }\n        break;\n    case 0x8c: /* mov Gv, seg */\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        if (reg >= 6)\n            goto illegal_op;\n        gen_op_movl_T0_seg(reg);\n        ot = mod == 3 ? dflag : MO_16;\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n        break;\n\n    case 0x1b6: /* movzbS Gv, Eb */\n    case 0x1b7: /* movzwS Gv, Eb */\n    case 0x1be: /* movsbS Gv, Eb */\n    case 0x1bf: /* movswS Gv, Eb */\n        {\n            TCGMemOp d_ot;\n            TCGMemOp s_ot;\n\n            /* d_ot is the size of destination */\n            d_ot = dflag;\n            /* ot is the size of source */\n            ot = (b & 1) + MO_8;\n            /* s_ot is the sign+size of source */\n            s_ot = b & 8 ? MO_SIGN | ot : ot;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n\n            if (mod == 3) {\n                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {\n                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);\n                } else {\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n                    switch (s_ot) {\n                    case MO_UB:\n                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);\n                        break;\n                    case MO_SB:\n                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);\n                        break;\n                    case MO_UW:\n                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n                        break;\n                    default:\n                    case MO_SW:\n                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);\n                        break;\n                    }\n                }\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            } else {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            }\n        }\n        break;\n\n    case 0x8d: /* lea */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        reg = ((modrm >> 3) & 7) | rex_r;\n        {\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n            TCGv ea = gen_lea_modrm_1(a);\n            gen_lea_v_seg(s, s->aflag, ea, -1, -1);\n            gen_op_mov_reg_v(dflag, reg, cpu_A0);\n        }\n        break;\n\n    case 0xa0: /* mov EAX, Ov */\n    case 0xa1:\n    case 0xa2: /* mov Ov, EAX */\n    case 0xa3:\n        {\n            target_ulong offset_addr;\n\n            ot = mo_b_d(b, dflag);\n            switch (s->aflag) {\n#ifdef TARGET_X86_64\n            case MO_64:\n                offset_addr = cpu_ldq_code(env, s->pc);\n                s->pc += 8;\n                break;\n#endif\n            default:\n                offset_addr = insn_get(env, s, s->aflag);\n                break;\n            }\n            tcg_gen_movi_tl(cpu_A0, offset_addr);\n            gen_add_A0_ds_seg(s);\n            if ((b & 2) == 0) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);\n            } else {\n                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);\n                gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n            }\n        }\n        break;\n    case 0xd7: /* xlat */\n        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);\n        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);\n        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);\n        gen_extu(s->aflag, cpu_A0);\n        gen_add_A0_ds_seg(s);\n        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n        break;\n    case 0xb0 ... 0xb7: /* mov R, Ib */\n        val = insn_get(env, s, MO_8);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);\n        break;\n    case 0xb8 ... 0xbf: /* mov R, Iv */\n#ifdef TARGET_X86_64\n        if (dflag == MO_64) {\n            uint64_t tmp;\n            /* 64 bit case */\n            tmp = cpu_ldq_code(env, s->pc);\n            s->pc += 8;\n            reg = (b & 7) | REX_B(s);\n            tcg_gen_movi_tl(cpu_T0, tmp);\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n        } else\n#endif\n        {\n            ot = dflag;\n            val = insn_get(env, s, ot);\n            reg = (b & 7) | REX_B(s);\n            tcg_gen_movi_tl(cpu_T0, val);\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n        }\n        break;\n\n    case 0x91 ... 0x97: /* xchg R, EAX */\n    do_xchg_reg_eax:\n        ot = dflag;\n        reg = (b & 7) | REX_B(s);\n        rm = R_EAX;\n        goto do_xchg_reg;\n    case 0x86:\n    case 0x87: /* xchg Ev, Gv */\n        ot = mo_b_d(b, dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3) {\n            rm = (modrm & 7) | REX_B(s);\n        do_xchg_reg:\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n            gen_op_mov_v_reg(ot, cpu_T1, rm);\n            gen_op_mov_reg_v(ot, rm, cpu_T0);\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n        } else {\n            gen_lea_modrm(env, s, modrm);\n            gen_op_mov_v_reg(ot, cpu_T0, reg);\n            /* for xchg, lock is implicit */\n            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,\n                                   s->mem_index, ot | MO_LE);\n            gen_op_mov_reg_v(ot, reg, cpu_T1);\n        }\n        break;\n    case 0xc4: /* les Gv */\n        /* In CODE64 this is VEX3; see above.  */\n        op = R_ES;\n        goto do_lxx;\n    case 0xc5: /* lds Gv */\n        /* In CODE64 this is VEX2; see above.  */\n        op = R_DS;\n        goto do_lxx;\n    case 0x1b2: /* lss Gv */\n        op = R_SS;\n        goto do_lxx;\n    case 0x1b4: /* lfs Gv */\n        op = R_FS;\n        goto do_lxx;\n    case 0x1b5: /* lgs Gv */\n        op = R_GS;\n    do_lxx:\n        ot = dflag != MO_16 ? MO_32 : MO_16;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_lea_modrm(env, s, modrm);\n        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);\n        gen_add_A0_im(s, 1 << ot);\n        /* load the segment first to handle exceptions properly */\n        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);\n        gen_movl_seg_T0(s, op);\n        /* then put the data */\n        gen_op_mov_reg_v(ot, reg, cpu_T1);\n        if (s->is_jmp) {\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n\n        /************************/\n        /* shifts */\n    case 0xc0:\n    case 0xc1:\n        /* shift Ev,Ib */\n        shift = 2;\n    grp2:\n        {\n            ot = mo_b_d(b, dflag);\n            modrm = cpu_ldub_code(env, s->pc++);\n            mod = (modrm >> 6) & 3;\n            op = (modrm >> 3) & 7;\n\n            if (mod != 3) {\n                if (shift == 2) {\n                    s->rip_offset = 1;\n                }\n                gen_lea_modrm(env, s, modrm);\n                opreg = OR_TMP0;\n            } else {\n                opreg = (modrm & 7) | REX_B(s);\n            }\n\n            /* simpler op */\n            if (shift == 0) {\n                gen_shift(s, op, ot, opreg, OR_ECX);\n            } else {\n                if (shift == 2) {\n                    shift = cpu_ldub_code(env, s->pc++);\n                }\n                gen_shifti(s, op, ot, opreg, shift);\n            }\n        }\n        break;\n    case 0xd0:\n    case 0xd1:\n        /* shift Ev,1 */\n        shift = 1;\n        goto grp2;\n    case 0xd2:\n    case 0xd3:\n        /* shift Ev,cl */\n        shift = 0;\n        goto grp2;\n\n    case 0x1a4: /* shld imm */\n        op = 0;\n        shift = 1;\n        goto do_shiftd;\n    case 0x1a5: /* shld cl */\n        op = 0;\n        shift = 0;\n        goto do_shiftd;\n    case 0x1ac: /* shrd imm */\n        op = 1;\n        shift = 1;\n        goto do_shiftd;\n    case 0x1ad: /* shrd cl */\n        op = 1;\n        shift = 0;\n    do_shiftd:\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        if (mod != 3) {\n            gen_lea_modrm(env, s, modrm);\n            opreg = OR_TMP0;\n        } else {\n            opreg = rm;\n        }\n        gen_op_mov_v_reg(ot, cpu_T1, reg);\n\n        if (shift) {\n            TCGv imm = tcg_const_tl(cpu_ldub_code(env, s->pc++));\n            gen_shiftd_rm_T1(s, ot, opreg, op, imm);\n            tcg_temp_free(imm);\n        } else {\n            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);\n        }\n        break;\n\n        /************************/\n        /* floats */\n    case 0xd8 ... 0xdf:\n        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {\n            /* if CR0.EM or CR0.TS are set, generate an FPU exception */\n            /* XXX: what to do if illegal op ? */\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n            break;\n        }\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        rm = modrm & 7;\n        op = ((b & 7) << 3) | ((modrm >> 3) & 7);\n        if (mod != 3) {\n            /* memory op */\n            gen_lea_modrm(env, s, modrm);\n            switch(op) {\n            case 0x00 ... 0x07: /* fxxxs */\n            case 0x10 ... 0x17: /* fixxxl */\n            case 0x20 ... 0x27: /* fxxxl */\n            case 0x30 ... 0x37: /* fixxx */\n                {\n                    int op1;\n                    op1 = op & 7;\n\n                    switch(op >> 4) {\n                    case 0:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LESW);\n                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    }\n\n                    gen_helper_fp_arith_ST0_FT0(op1);\n                    if (op1 == 3) {\n                        /* fcomp needs pop */\n                        gen_helper_fpop(cpu_env);\n                    }\n                }\n                break;\n            case 0x08: /* flds */\n            case 0x0a: /* fsts */\n            case 0x0b: /* fstps */\n            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */\n            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */\n            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */\n                switch(op & 7) {\n                case 0:\n                    switch(op >> 4) {\n                    case 0:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 1:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    case 2:\n                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);\n                        break;\n                    case 3:\n                    default:\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LESW);\n                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);\n                        break;\n                    }\n                    break;\n                case 1:\n                    /* XXX: the corresponding CPUID bit must be tested ! */\n                    switch(op >> 4) {\n                    case 1:\n                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        break;\n                    case 2:\n                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUW);\n                        break;\n                    }\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    switch(op >> 4) {\n                    case 0:\n                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        break;\n                    case 1:\n                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        break;\n                    case 2:\n                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);\n                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        break;\n                    case 3:\n                    default:\n                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);\n                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUW);\n                        break;\n                    }\n                    if ((op & 7) == 3)\n                        gen_helper_fpop(cpu_env);\n                    break;\n                }\n                break;\n            case 0x0c: /* fldenv mem */\n                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x0d: /* fldcw mem */\n                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                    s->mem_index, MO_LEUW);\n                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);\n                break;\n            case 0x0e: /* fnstenv mem */\n                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x0f: /* fnstcw mem */\n                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                    s->mem_index, MO_LEUW);\n                break;\n            case 0x1d: /* fldt mem */\n                gen_helper_fldt_ST0(cpu_env, cpu_A0);\n                break;\n            case 0x1f: /* fstpt mem */\n                gen_helper_fstt_ST0(cpu_env, cpu_A0);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x2c: /* frstor mem */\n                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x2e: /* fnsave mem */\n                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));\n                break;\n            case 0x2f: /* fnstsw mem */\n                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                    s->mem_index, MO_LEUW);\n                break;\n            case 0x3c: /* fbld */\n                gen_helper_fbld_ST0(cpu_env, cpu_A0);\n                break;\n            case 0x3e: /* fbstp */\n                gen_helper_fbst_ST0(cpu_env, cpu_A0);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x3d: /* fildll */\n                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);\n                break;\n            case 0x3f: /* fistpll */\n                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);\n                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);\n                gen_helper_fpop(cpu_env);\n                break;\n            default:\n                goto unknown_op;\n            }\n        } else {\n            /* register float ops */\n            opreg = rm;\n\n            switch(op) {\n            case 0x08: /* fld sti */\n                gen_helper_fpush(cpu_env);\n                gen_helper_fmov_ST0_STN(cpu_env,\n                                        tcg_const_i32((opreg + 1) & 7));\n                break;\n            case 0x09: /* fxchg sti */\n            case 0x29: /* fxchg4 sti, undocumented op */\n            case 0x39: /* fxchg7 sti, undocumented op */\n                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));\n                break;\n            case 0x0a: /* grp d9/2 */\n                switch(rm) {\n                case 0: /* fnop */\n                    /* check exceptions (FreeBSD FPU probe) */\n                    gen_helper_fwait(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x0c: /* grp d9/4 */\n                switch(rm) {\n                case 0: /* fchs */\n                    gen_helper_fchs_ST0(cpu_env);\n                    break;\n                case 1: /* fabs */\n                    gen_helper_fabs_ST0(cpu_env);\n                    break;\n                case 4: /* ftst */\n                    gen_helper_fldz_FT0(cpu_env);\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n                    break;\n                case 5: /* fxam */\n                    gen_helper_fxam_ST0(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x0d: /* grp d9/5 */\n                {\n                    switch(rm) {\n                    case 0:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fld1_ST0(cpu_env);\n                        break;\n                    case 1:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldl2t_ST0(cpu_env);\n                        break;\n                    case 2:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldl2e_ST0(cpu_env);\n                        break;\n                    case 3:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldpi_ST0(cpu_env);\n                        break;\n                    case 4:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldlg2_ST0(cpu_env);\n                        break;\n                    case 5:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldln2_ST0(cpu_env);\n                        break;\n                    case 6:\n                        gen_helper_fpush(cpu_env);\n                        gen_helper_fldz_ST0(cpu_env);\n                        break;\n                    default:\n                        goto unknown_op;\n                    }\n                }\n                break;\n            case 0x0e: /* grp d9/6 */\n                switch(rm) {\n                case 0: /* f2xm1 */\n                    gen_helper_f2xm1(cpu_env);\n                    break;\n                case 1: /* fyl2x */\n                    gen_helper_fyl2x(cpu_env);\n                    break;\n                case 2: /* fptan */\n                    gen_helper_fptan(cpu_env);\n                    break;\n                case 3: /* fpatan */\n                    gen_helper_fpatan(cpu_env);\n                    break;\n                case 4: /* fxtract */\n                    gen_helper_fxtract(cpu_env);\n                    break;\n                case 5: /* fprem1 */\n                    gen_helper_fprem1(cpu_env);\n                    break;\n                case 6: /* fdecstp */\n                    gen_helper_fdecstp(cpu_env);\n                    break;\n                default:\n                case 7: /* fincstp */\n                    gen_helper_fincstp(cpu_env);\n                    break;\n                }\n                break;\n            case 0x0f: /* grp d9/7 */\n                switch(rm) {\n                case 0: /* fprem */\n                    gen_helper_fprem(cpu_env);\n                    break;\n                case 1: /* fyl2xp1 */\n                    gen_helper_fyl2xp1(cpu_env);\n                    break;\n                case 2: /* fsqrt */\n                    gen_helper_fsqrt(cpu_env);\n                    break;\n                case 3: /* fsincos */\n                    gen_helper_fsincos(cpu_env);\n                    break;\n                case 5: /* fscale */\n                    gen_helper_fscale(cpu_env);\n                    break;\n                case 4: /* frndint */\n                    gen_helper_frndint(cpu_env);\n                    break;\n                case 6: /* fsin */\n                    gen_helper_fsin(cpu_env);\n                    break;\n                default:\n                case 7: /* fcos */\n                    gen_helper_fcos(cpu_env);\n                    break;\n                }\n                break;\n            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */\n            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */\n            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */\n                {\n                    int op1;\n\n                    op1 = op & 7;\n                    if (op >= 0x20) {\n                        gen_helper_fp_arith_STN_ST0(op1, opreg);\n                        if (op >= 0x30)\n                            gen_helper_fpop(cpu_env);\n                    } else {\n                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                        gen_helper_fp_arith_ST0_FT0(op1);\n                    }\n                }\n                break;\n            case 0x02: /* fcom */\n            case 0x22: /* fcom2, undocumented op */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcom_ST0_FT0(cpu_env);\n                break;\n            case 0x03: /* fcomp */\n            case 0x23: /* fcomp3, undocumented op */\n            case 0x32: /* fcomp5, undocumented op */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcom_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x15: /* da/5 */\n                switch(rm) {\n                case 1: /* fucompp */\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n                    gen_helper_fucom_ST0_FT0(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x1c:\n                switch(rm) {\n                case 0: /* feni (287 only, just do nop here) */\n                    break;\n                case 1: /* fdisi (287 only, just do nop here) */\n                    break;\n                case 2: /* fclex */\n                    gen_helper_fclex(cpu_env);\n                    break;\n                case 3: /* fninit */\n                    gen_helper_fninit(cpu_env);\n                    break;\n                case 4: /* fsetpm (287 only, just do nop here) */\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x1d: /* fucomi */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x1e: /* fcomi */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x28: /* ffree sti */\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n                break;\n            case 0x2a: /* fst sti */\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n                break;\n            case 0x2b: /* fstp sti */\n            case 0x0b: /* fstp1 sti, undocumented op */\n            case 0x3a: /* fstp8 sti, undocumented op */\n            case 0x3b: /* fstp9 sti, undocumented op */\n                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x2c: /* fucom st(i) */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucom_ST0_FT0(cpu_env);\n                break;\n            case 0x2d: /* fucomp st(i) */\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucom_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x33: /* de/3 */\n                switch(rm) {\n                case 1: /* fcompp */\n                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));\n                    gen_helper_fcom_ST0_FT0(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    gen_helper_fpop(cpu_env);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x38: /* ffreep sti, undocumented op */\n                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fpop(cpu_env);\n                break;\n            case 0x3c: /* df/4 */\n                switch(rm) {\n                case 0:\n                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);\n                    break;\n                default:\n                    goto unknown_op;\n                }\n                break;\n            case 0x3d: /* fucomip */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fucomi_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x3e: /* fcomip */\n                if (!(s->cpuid_features & CPUID_CMOV)) {\n                    goto illegal_op;\n                }\n                gen_update_cc_op(s);\n                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));\n                gen_helper_fcomi_ST0_FT0(cpu_env);\n                gen_helper_fpop(cpu_env);\n                set_cc_op(s, CC_OP_EFLAGS);\n                break;\n            case 0x10 ... 0x13: /* fcmovxx */\n            case 0x18 ... 0x1b:\n                {\n                    int op1;\n                    TCGLabel *l1;\n                    static const uint8_t fcmov_cc[8] = {\n                        (JCC_B << 1),\n                        (JCC_Z << 1),\n                        (JCC_BE << 1),\n                        (JCC_P << 1),\n                    };\n\n                    if (!(s->cpuid_features & CPUID_CMOV)) {\n                        goto illegal_op;\n                    }\n                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);\n                    l1 = gen_new_label();\n                    gen_jcc1_noeob(s, op1, l1);\n                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));\n                    gen_set_label(l1);\n                }\n                break;\n            default:\n                goto unknown_op;\n            }\n        }\n        break;\n        /************************/\n        /* string ops */\n\n    case 0xa4: /* movsS */\n    case 0xa5:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_movs(s, ot);\n        }\n        break;\n\n    case 0xaa: /* stosS */\n    case 0xab:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_stos(s, ot);\n        }\n        break;\n    case 0xac: /* lodsS */\n    case 0xad:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_lods(s, ot);\n        }\n        break;\n    case 0xae: /* scasS */\n    case 0xaf:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & PREFIX_REPNZ) {\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n        } else if (prefixes & PREFIX_REPZ) {\n            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n        } else {\n            gen_scas(s, ot);\n        }\n        break;\n\n    case 0xa6: /* cmpsS */\n    case 0xa7:\n        ot = mo_b_d(b, dflag);\n        if (prefixes & PREFIX_REPNZ) {\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);\n        } else if (prefixes & PREFIX_REPZ) {\n            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);\n        } else {\n            gen_cmps(s, ot);\n        }\n        break;\n    case 0x6c: /* insS */\n    case 0x6d:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base, \n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_ins(s, ot);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n        }\n        break;\n    case 0x6e: /* outsS */\n    case 0x6f:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes) | 4);\n        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {\n            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);\n        } else {\n            gen_outs(s, ot);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n        }\n        break;\n\n        /************************/\n        /* port I/O */\n\n    case 0xe4:\n    case 0xe5:\n        ot = mo_b_d32(b, dflag);\n        val = cpu_ldub_code(env, s->pc++);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xe6:\n    case 0xe7:\n        ot = mo_b_d32(b, dflag);\n        val = cpu_ldub_code(env, s->pc++);\n        tcg_gen_movi_tl(cpu_T0, val);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes));\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_movi_i32(cpu_tmp2_i32, val);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xec:\n    case 0xed:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);\n        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0xee:\n    case 0xef:\n        ot = mo_b_d32(b, dflag);\n        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);\n        gen_check_io(s, ot, pc_start - s->cs_base,\n                     svm_is_rep(prefixes));\n        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);\n\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);\n        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n        gen_bpt_io(s, cpu_tmp2_i32, ot);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n\n        /************************/\n        /* control */\n    case 0xc2: /* ret im */\n        val = cpu_ldsw_code(env, s->pc);\n        s->pc += 2;\n        ot = gen_pop_T0(s);\n        gen_stack_update(s, val + (1 << ot));\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n        gen_op_jmp_v(cpu_T0);\n        gen_bnd_jmp(s);\n        gen_eob(s);\n        break;\n    case 0xc3: /* ret */\n        ot = gen_pop_T0(s);\n        gen_pop_update(s, ot);\n        /* Note that gen_pop_T0 uses a zero-extending load.  */\n        gen_op_jmp_v(cpu_T0);\n        gen_bnd_jmp(s);\n        gen_eob(s);\n        break;\n    case 0xca: /* lret im */\n        val = cpu_ldsw_code(env, s->pc);\n        s->pc += 2;\n    do_lret:\n        if (s->pe && !s->vm86) {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),\n                                      tcg_const_i32(val));\n        } else {\n            gen_stack_A0(s);\n            /* pop offset */\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n            /* NOTE: keeping EIP updated is not a problem in case of\n               exception */\n            gen_op_jmp_v(cpu_T0);\n            /* pop selector */\n            gen_add_A0_im(s, 1 << dflag);\n            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);\n            gen_op_movl_seg_T0_vm(R_CS);\n            /* add stack offset */\n            gen_stack_update(s, val + (2 << dflag));\n        }\n        gen_eob(s);\n        break;\n    case 0xcb: /* lret */\n        val = 0;\n        goto do_lret;\n    case 0xcf: /* iret */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);\n        if (!s->pe) {\n            /* real mode */\n            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n            set_cc_op(s, CC_OP_EFLAGS);\n        } else if (s->vm86) {\n            if (s->iopl != 3) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n        } else {\n            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),\n                                      tcg_const_i32(s->pc - s->cs_base));\n            set_cc_op(s, CC_OP_EFLAGS);\n        }\n        gen_eob(s);\n        break;\n    case 0xe8: /* call im */\n        {\n            if (dflag != MO_16) {\n                tval = (int32_t)insn_get(env, s, MO_32);\n            } else {\n                tval = (int16_t)insn_get(env, s, MO_16);\n            }\n            next_eip = s->pc - s->cs_base;\n            tval += next_eip;\n            if (dflag == MO_16) {\n                tval &= 0xffff;\n            } else if (!CODE64(s)) {\n                tval &= 0xffffffff;\n            }\n            tcg_gen_movi_tl(cpu_T0, next_eip);\n            gen_push_v(s, cpu_T0);\n            gen_bnd_jmp(s);\n            gen_jmp(s, tval);\n        }\n        break;\n    case 0x9a: /* lcall im */\n        {\n            unsigned int selector, offset;\n\n            if (CODE64(s))\n                goto illegal_op;\n            ot = dflag;\n            offset = insn_get(env, s, ot);\n            selector = insn_get(env, s, MO_16);\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n            tcg_gen_movi_tl(cpu_T1, offset);\n        }\n        goto do_lcall;\n    case 0xe9: /* jmp im */\n        if (dflag != MO_16) {\n            tval = (int32_t)insn_get(env, s, MO_32);\n        } else {\n            tval = (int16_t)insn_get(env, s, MO_16);\n        }\n        tval += s->pc - s->cs_base;\n        if (dflag == MO_16) {\n            tval &= 0xffff;\n        } else if (!CODE64(s)) {\n            tval &= 0xffffffff;\n        }\n        gen_bnd_jmp(s);\n        gen_jmp(s, tval);\n        break;\n    case 0xea: /* ljmp im */\n        {\n            unsigned int selector, offset;\n\n            if (CODE64(s))\n                goto illegal_op;\n            ot = dflag;\n            offset = insn_get(env, s, ot);\n            selector = insn_get(env, s, MO_16);\n\n            tcg_gen_movi_tl(cpu_T0, selector);\n            tcg_gen_movi_tl(cpu_T1, offset);\n        }\n        goto do_ljmp;\n    case 0xeb: /* jmp Jb */\n        tval = (int8_t)insn_get(env, s, MO_8);\n        tval += s->pc - s->cs_base;\n        if (dflag == MO_16) {\n            tval &= 0xffff;\n        }\n        gen_jmp(s, tval);\n        break;\n    case 0x70 ... 0x7f: /* jcc Jb */\n        tval = (int8_t)insn_get(env, s, MO_8);\n        goto do_jcc;\n    case 0x180 ... 0x18f: /* jcc Jv */\n        if (dflag != MO_16) {\n            tval = (int32_t)insn_get(env, s, MO_32);\n        } else {\n            tval = (int16_t)insn_get(env, s, MO_16);\n        }\n    do_jcc:\n        next_eip = s->pc - s->cs_base;\n        tval += next_eip;\n        if (dflag == MO_16) {\n            tval &= 0xffff;\n        }\n        gen_bnd_jmp(s);\n        gen_jcc(s, b, tval, next_eip);\n        break;\n\n    case 0x190 ... 0x19f: /* setcc Gv */\n        modrm = cpu_ldub_code(env, s->pc++);\n        gen_setcc1(s, b, cpu_T0);\n        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);\n        break;\n    case 0x140 ... 0x14f: /* cmov Gv, Ev */\n        if (!(s->cpuid_features & CPUID_CMOV)) {\n            goto illegal_op;\n        }\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        gen_cmovcc1(env, s, ot, b, modrm, reg);\n        break;\n\n        /************************/\n        /* flags */\n    case 0x9c: /* pushf */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_update_cc_op(s);\n            gen_helper_read_eflags(cpu_T0, cpu_env);\n            gen_push_v(s, cpu_T0);\n        }\n        break;\n    case 0x9d: /* popf */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            ot = gen_pop_T0(s);\n            if (s->cpl == 0) {\n                if (dflag != MO_16) {\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n                                                           ID_MASK | NT_MASK |\n                                                           IF_MASK |\n                                                           IOPL_MASK)));\n                } else {\n                    gen_helper_write_eflags(cpu_env, cpu_T0,\n                                            tcg_const_i32((TF_MASK | AC_MASK |\n                                                           ID_MASK | NT_MASK |\n                                                           IF_MASK | IOPL_MASK)\n                                                          & 0xffff));\n                }\n            } else {\n                if (s->cpl <= s->iopl) {\n                    if (dflag != MO_16) {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                                tcg_const_i32((TF_MASK |\n                                                               AC_MASK |\n                                                               ID_MASK |\n                                                               NT_MASK |\n                                                               IF_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                                tcg_const_i32((TF_MASK |\n                                                               AC_MASK |\n                                                               ID_MASK |\n                                                               NT_MASK |\n                                                               IF_MASK)\n                                                              & 0xffff));\n                    }\n                } else {\n                    if (dflag != MO_16) {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n                                                          ID_MASK | NT_MASK)));\n                    } else {\n                        gen_helper_write_eflags(cpu_env, cpu_T0,\n                                           tcg_const_i32((TF_MASK | AC_MASK |\n                                                          ID_MASK | NT_MASK)\n                                                         & 0xffff));\n                    }\n                }\n            }\n            gen_pop_update(s, ot);\n            set_cc_op(s, CC_OP_EFLAGS);\n            /* abort translation because TF/AC flag may change */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    case 0x9e: /* sahf */\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);\n        gen_compute_eflags(s);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);\n        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);\n        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);\n        break;\n    case 0x9f: /* lahf */\n        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))\n            goto illegal_op;\n        gen_compute_eflags(s);\n        /* Note: gen_compute_eflags() only gives the condition codes */\n        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);\n        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);\n        break;\n    case 0xf5: /* cmc */\n        gen_compute_eflags(s);\n        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        break;\n    case 0xf8: /* clc */\n        gen_compute_eflags(s);\n        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);\n        break;\n    case 0xf9: /* stc */\n        gen_compute_eflags(s);\n        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);\n        break;\n    case 0xfc: /* cld */\n        tcg_gen_movi_i32(cpu_tmp2_i32, 1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n        break;\n    case 0xfd: /* std */\n        tcg_gen_movi_i32(cpu_tmp2_i32, -1);\n        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));\n        break;\n\n        /************************/\n        /* bit operations */\n    case 0x1ba: /* bt/bts/btr/btc Gv, im */\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        op = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        if (mod != 3) {\n            s->rip_offset = 1;\n            gen_lea_modrm(env, s, modrm);\n            if (!(s->prefix & PREFIX_LOCK)) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n        /* load shift */\n        val = cpu_ldub_code(env, s->pc++);\n        tcg_gen_movi_tl(cpu_T1, val);\n        if (op < 4)\n            goto unknown_op;\n        op -= 4;\n        goto bt_op;\n    case 0x1a3: /* bt Gv, Ev */\n        op = 0;\n        goto do_btx;\n    case 0x1ab: /* bts */\n        op = 1;\n        goto do_btx;\n    case 0x1b3: /* btr */\n        op = 2;\n        goto do_btx;\n    case 0x1bb: /* btc */\n        op = 3;\n    do_btx:\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        mod = (modrm >> 6) & 3;\n        rm = (modrm & 7) | REX_B(s);\n        gen_op_mov_v_reg(MO_32, cpu_T1, reg);\n        if (mod != 3) {\n            AddressParts a = gen_lea_modrm_0(env, s, modrm);\n            /* specific case: we need to add a displacement */\n            gen_exts(ot, cpu_T1);\n            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);\n            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);\n            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);\n            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n            if (!(s->prefix & PREFIX_LOCK)) {\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n            }\n        } else {\n            gen_op_mov_v_reg(ot, cpu_T0, rm);\n        }\n    bt_op:\n        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);\n        tcg_gen_movi_tl(cpu_tmp0, 1);\n        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);\n        if (s->prefix & PREFIX_LOCK) {\n            switch (op) {\n            case 0: /* bt */\n                /* Needs no atomic ops; we surpressed the normal\n                   memory load for LOCK above so do it now.  */\n                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n                break;\n            case 1: /* bts */\n                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                           s->mem_index, ot | MO_LE);\n                break;\n            case 2: /* btr */\n                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);\n                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                            s->mem_index, ot | MO_LE);\n                break;\n            default:\n            case 3: /* btc */\n                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,\n                                            s->mem_index, ot | MO_LE);\n                break;\n            }\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n        } else {\n            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);\n            switch (op) {\n            case 0: /* bt */\n                /* Data already loaded; nothing to do.  */\n                break;\n            case 1: /* bts */\n                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            case 2: /* btr */\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            default:\n            case 3: /* btc */\n                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);\n                break;\n            }\n            if (op != 0) {\n                if (mod != 3) {\n                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n                } else {\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n            }\n        }\n\n        /* Delay all CC updates until after the store above.  Note that\n           C is the result of the test, Z is unchanged, and the others\n           are all undefined.  */\n        switch (s->cc_op) {\n        case CC_OP_MULB ... CC_OP_MULQ:\n        case CC_OP_ADDB ... CC_OP_ADDQ:\n        case CC_OP_ADCB ... CC_OP_ADCQ:\n        case CC_OP_SUBB ... CC_OP_SUBQ:\n        case CC_OP_SBBB ... CC_OP_SBBQ:\n        case CC_OP_LOGICB ... CC_OP_LOGICQ:\n        case CC_OP_INCB ... CC_OP_INCQ:\n        case CC_OP_DECB ... CC_OP_DECQ:\n        case CC_OP_SHLB ... CC_OP_SHLQ:\n        case CC_OP_SARB ... CC_OP_SARQ:\n        case CC_OP_BMILGB ... CC_OP_BMILGQ:\n            /* Z was going to be computed from the non-zero status of CC_DST.\n               We can get that same Z value (and the new C value) by leaving\n               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the\n               same width.  */\n            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);\n            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);\n            break;\n        default:\n            /* Otherwise, generate EFLAGS and replace the C bit.  */\n            gen_compute_eflags(s);\n            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,\n                               ctz32(CC_C), 1);\n            break;\n        }\n        break;\n    case 0x1bc: /* bsf / tzcnt */\n    case 0x1bd: /* bsr / lzcnt */\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_extu(ot, cpu_T0);\n\n        /* Note that lzcnt and tzcnt are in different extensions.  */\n        if ((prefixes & PREFIX_REPZ)\n            && (b & 1\n                ? s->cpuid_ext3_features & CPUID_EXT3_ABM\n                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {\n            int size = 8 << ot;\n            /* For lzcnt/tzcnt, C bit is defined related to the input. */\n            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n            if (b & 1) {\n                /* For lzcnt, reduce the target_ulong result by the\n                   number of zeros that we expect to find at the top.  */\n                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);\n                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);\n            } else {\n                /* For tzcnt, a zero input must return the operand size.  */\n                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);\n            }\n            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */\n            gen_op_update1_cc();\n            set_cc_op(s, CC_OP_BMILGB + ot);\n        } else {\n            /* For bsr/bsf, only the Z bit is defined and it is related\n               to the input and not the result.  */\n            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n            set_cc_op(s, CC_OP_LOGICB + ot);\n\n            /* ??? The manual says that the output is undefined when the\n               input is zero, but real hardware leaves it unchanged, and\n               real programs appear to depend on that.  Accomplish this\n               by passing the output as the value to return upon zero.  */\n            if (b & 1) {\n                /* For bsr, return the bit index of the first 1 bit,\n                   not the count of leading zeros.  */\n                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);\n                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);\n                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);\n            } else {\n                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);\n            }\n        }\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n        break;\n        /************************/\n        /* bcd */\n    case 0x27: /* daa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_daa(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0x2f: /* das */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_das(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0x37: /* aaa */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_aaa(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0x3f: /* aas */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_helper_aas(cpu_env);\n        set_cc_op(s, CC_OP_EFLAGS);\n        break;\n    case 0xd4: /* aam */\n        if (CODE64(s))\n            goto illegal_op;\n        val = cpu_ldub_code(env, s->pc++);\n        if (val == 0) {\n            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);\n        } else {\n            gen_helper_aam(cpu_env, tcg_const_i32(val));\n            set_cc_op(s, CC_OP_LOGICB);\n        }\n        break;\n    case 0xd5: /* aad */\n        if (CODE64(s))\n            goto illegal_op;\n        val = cpu_ldub_code(env, s->pc++);\n        gen_helper_aad(cpu_env, tcg_const_i32(val));\n        set_cc_op(s, CC_OP_LOGICB);\n        break;\n        /************************/\n        /* misc */\n    case 0x90: /* nop */\n        /* XXX: correct lock test for all insn */\n        if (prefixes & PREFIX_LOCK) {\n            goto illegal_op;\n        }\n        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */\n        if (REX_B(s)) {\n            goto do_xchg_reg_eax;\n        }\n        if (prefixes & PREFIX_REPZ) {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));\n            s->is_jmp = DISAS_TB_JUMP;\n        }\n        break;\n    case 0x9b: /* fwait */\n        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==\n            (HF_MP_MASK | HF_TS_MASK)) {\n            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        } else {\n            gen_helper_fwait(cpu_env);\n        }\n        break;\n    case 0xcc: /* int3 */\n        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);\n        break;\n    case 0xcd: /* int N */\n        val = cpu_ldub_code(env, s->pc++);\n        if (s->vm86 && s->iopl != 3) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);\n        }\n        break;\n    case 0xce: /* into */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));\n        break;\n#ifdef WANT_ICEBP\n    case 0xf1: /* icebp (undocumented, exits to external debugger) */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);\n#if 1\n        gen_debug(s, pc_start - s->cs_base);\n#else\n        /* start debug */\n        tb_flush(CPU(x86_env_get_cpu(env)));\n        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);\n#endif\n        break;\n#endif\n    case 0xfa: /* cli */\n        if (!s->vm86) {\n            if (s->cpl <= s->iopl) {\n                gen_helper_cli(cpu_env);\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        } else {\n            if (s->iopl == 3) {\n                gen_helper_cli(cpu_env);\n            } else {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            }\n        }\n        break;\n    case 0xfb: /* sti */\n        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {\n            gen_helper_sti(cpu_env);\n            /* interruptions are enabled only the first insn after sti */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob_inhibit_irq(s, true);\n        } else {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        }\n        break;\n    case 0x62: /* bound */\n        if (CODE64(s))\n            goto illegal_op;\n        ot = dflag;\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = (modrm >> 3) & 7;\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_op_mov_v_reg(ot, cpu_T0, reg);\n        gen_lea_modrm(env, s, modrm);\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n        if (ot == MO_16) {\n            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);\n        } else {\n            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);\n        }\n        break;\n    case 0x1c8 ... 0x1cf: /* bswap reg */\n        reg = (b & 7) | REX_B(s);\n#ifdef TARGET_X86_64\n        if (dflag == MO_64) {\n            gen_op_mov_v_reg(MO_64, cpu_T0, reg);\n            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_64, reg, cpu_T0);\n        } else\n#endif\n        {\n            gen_op_mov_v_reg(MO_32, cpu_T0, reg);\n            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);\n            gen_op_mov_reg_v(MO_32, reg, cpu_T0);\n        }\n        break;\n    case 0xd6: /* salc */\n        if (CODE64(s))\n            goto illegal_op;\n        gen_compute_eflags_c(s, cpu_T0);\n        tcg_gen_neg_tl(cpu_T0, cpu_T0);\n        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);\n        break;\n    case 0xe0: /* loopnz */\n    case 0xe1: /* loopz */\n    case 0xe2: /* loop */\n    case 0xe3: /* jecxz */\n        {\n            TCGLabel *l1, *l2, *l3;\n\n            tval = (int8_t)insn_get(env, s, MO_8);\n            next_eip = s->pc - s->cs_base;\n            tval += next_eip;\n            if (dflag == MO_16) {\n                tval &= 0xffff;\n            }\n\n            l1 = gen_new_label();\n            l2 = gen_new_label();\n            l3 = gen_new_label();\n            b &= 3;\n            switch(b) {\n            case 0: /* loopnz */\n            case 1: /* loopz */\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n                gen_op_jz_ecx(s->aflag, l3);\n                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);\n                break;\n            case 2: /* loop */\n                gen_op_add_reg_im(s->aflag, R_ECX, -1);\n                gen_op_jnz_ecx(s->aflag, l1);\n                break;\n            default:\n            case 3: /* jcxz */\n                gen_op_jz_ecx(s->aflag, l1);\n                break;\n            }\n\n            gen_set_label(l3);\n            gen_jmp_im(next_eip);\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n            gen_jmp_im(tval);\n            gen_set_label(l2);\n            gen_eob(s);\n        }\n        break;\n    case 0x130: /* wrmsr */\n    case 0x132: /* rdmsr */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            if (b & 2) {\n                gen_helper_rdmsr(cpu_env);\n            } else {\n                gen_helper_wrmsr(cpu_env);\n            }\n        }\n        break;\n    case 0x131: /* rdtsc */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_start();\n\t}\n        gen_helper_rdtsc(cpu_env);\n        if (s->tb->cflags & CF_USE_ICOUNT) {\n            gen_io_end();\n            gen_jmp(s, s->pc - s->cs_base);\n        }\n        break;\n    case 0x133: /* rdpmc */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_rdpmc(cpu_env);\n        break;\n    case 0x134: /* sysenter */\n        /* For Intel SYSENTER is valid on 64-bit */\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_helper_sysenter(cpu_env);\n            gen_eob(s);\n        }\n        break;\n    case 0x135: /* sysexit */\n        /* For Intel SYSEXIT is valid on 64-bit */\n        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)\n            goto illegal_op;\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));\n            gen_eob(s);\n        }\n        break;\n#ifdef TARGET_X86_64\n    case 0x105: /* syscall */\n        /* XXX: is it usable in real mode ? */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));\n        /* TF handling for the syscall insn is different. The TF bit is  checked\n           after the syscall insn completes. This allows #DB to not be\n           generated after one has entered CPL0 if TF is set in FMASK.  */\n        gen_eob_worker(s, false, true);\n        break;\n    case 0x107: /* sysret */\n        if (!s->pe) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));\n            /* condition codes are modified only in long mode */\n            if (s->lma) {\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n            /* TF handling for the sysret insn is different. The TF bit is\n               checked after the sysret insn completes. This allows #DB to be\n               generated \"as if\" the syscall insn in userspace has just\n               completed.  */\n            gen_eob_worker(s, false, true);\n        }\n        break;\n#endif\n    case 0x1a2: /* cpuid */\n        gen_update_cc_op(s);\n        gen_jmp_im(pc_start - s->cs_base);\n        gen_helper_cpuid(cpu_env);\n        break;\n    case 0xf4: /* hlt */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));\n            s->is_jmp = DISAS_TB_JUMP;\n        }\n        break;\n    case 0x100:\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* sldt */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                             offsetof(CPUX86State, ldt.selector));\n            ot = mod == 3 ? dflag : MO_16;\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 2: /* lldt */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_lldt(cpu_env, cpu_tmp2_i32);\n            }\n            break;\n        case 1: /* str */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                             offsetof(CPUX86State, tr.selector));\n            ot = mod == 3 ? dflag : MO_16;\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 3: /* ltr */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);\n                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_ltr(cpu_env, cpu_tmp2_i32);\n            }\n            break;\n        case 4: /* verr */\n        case 5: /* verw */\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            gen_update_cc_op(s);\n            if (op == 4) {\n                gen_helper_verr(cpu_env, cpu_T0);\n            } else {\n                gen_helper_verw(cpu_env, cpu_T0);\n            }\n            set_cc_op(s, CC_OP_EFLAGS);\n            break;\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x101:\n        modrm = cpu_ldub_code(env, s->pc++);\n        switch (modrm) {\n        CASE_MODRM_MEM_OP(0): /* sgdt */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_ld32u_tl(cpu_T0,\n                             cpu_env, offsetof(CPUX86State, gdt.limit));\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n            gen_add_A0_im(s, 2);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            break;\n\n        case 0xc8: /* monitor */\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);\n            gen_extu(s->aflag, cpu_A0);\n            gen_add_A0_ds_seg(s);\n            gen_helper_monitor(cpu_env, cpu_A0);\n            break;\n\n        case 0xc9: /* mwait */\n            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));\n            gen_eob(s);\n            break;\n\n        case 0xca: /* clac */\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n                || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_helper_clac(cpu_env);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        case 0xcb: /* stac */\n            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)\n                || s->cpl != 0) {\n                goto illegal_op;\n            }\n            gen_helper_stac(cpu_env);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        CASE_MODRM_MEM_OP(1): /* sidt */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));\n            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);\n            gen_add_A0_im(s, 2);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            break;\n\n        case 0xd0: /* xgetbv */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n            break;\n\n        case 0xd1: /* xsetbv */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA\n                                 | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n            /* End TB because translation flags may change.  */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        case 0xd8: /* VMRUN */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),\n                             tcg_const_i32(s->pc - pc_start));\n            tcg_gen_exit_tb(0);\n            s->is_jmp = DISAS_TB_JUMP;\n            break;\n\n        case 0xd9: /* VMMCALL */\n            if (!(s->flags & HF_SVME_MASK)) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmmcall(cpu_env);\n            break;\n\n        case 0xda: /* VMLOAD */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));\n            break;\n\n        case 0xdb: /* VMSAVE */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));\n            break;\n\n        case 0xdc: /* STGI */\n            if ((!(s->flags & HF_SVME_MASK)\n                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n                || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_stgi(cpu_env);\n            break;\n\n        case 0xdd: /* CLGI */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_clgi(cpu_env);\n            break;\n\n        case 0xde: /* SKINIT */\n            if ((!(s->flags & HF_SVME_MASK)\n                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))\n                || !s->pe) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_skinit(cpu_env);\n            break;\n\n        case 0xdf: /* INVLPGA */\n            if (!(s->flags & HF_SVME_MASK) || !s->pe) {\n                goto illegal_op;\n            }\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));\n            break;\n\n        CASE_MODRM_MEM_OP(2): /* lgdt */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);\n            gen_lea_modrm(env, s, modrm);\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 2);\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));\n            break;\n\n        CASE_MODRM_MEM_OP(3): /* lidt */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);\n            gen_lea_modrm(env, s, modrm);\n            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);\n            gen_add_A0_im(s, 2);\n            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);\n            if (dflag == MO_16) {\n                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);\n            }\n            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));\n            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));\n            break;\n\n        CASE_MODRM_OP(4): /* smsw */\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);\n            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));\n            if (CODE64(s)) {\n                mod = (modrm >> 6) & 3;\n                ot = (mod != 3 ? MO_16 : s->dflag);\n            } else {\n                ot = MO_16;\n            }\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);\n            break;\n        case 0xee: /* rdpkru */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);\n            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);\n            break;\n        case 0xef: /* wrpkru */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);\n            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);\n            break;\n        CASE_MODRM_OP(6): /* lmsw */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            gen_helper_lmsw(cpu_env, cpu_T0);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        CASE_MODRM_MEM_OP(7): /* invlpg */\n            if (s->cpl != 0) {\n                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                break;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            gen_lea_modrm(env, s, modrm);\n            gen_helper_invlpg(cpu_env, cpu_A0);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        case 0xf8: /* swapgs */\n#ifdef TARGET_X86_64\n            if (CODE64(s)) {\n                if (s->cpl != 0) {\n                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n                } else {\n                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);\n                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,\n                                  offsetof(CPUX86State, kernelgsbase));\n                    tcg_gen_st_tl(cpu_T0, cpu_env,\n                                  offsetof(CPUX86State, kernelgsbase));\n                }\n                break;\n            }\n#endif\n            goto illegal_op;\n\n        case 0xf9: /* rdtscp */\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {\n                goto illegal_op;\n            }\n            gen_update_cc_op(s);\n            gen_jmp_im(pc_start - s->cs_base);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_io_start();\n            }\n            gen_helper_rdtscp(cpu_env);\n            if (s->tb->cflags & CF_USE_ICOUNT) {\n                gen_io_end();\n                gen_jmp(s, s->pc - s->cs_base);\n            }\n            break;\n\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x108: /* invd */\n    case 0x109: /* wbinvd */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);\n            /* nothing to do */\n        }\n        break;\n    case 0x63: /* arpl or movslS (x86_64) */\n#ifdef TARGET_X86_64\n        if (CODE64(s)) {\n            int d_ot;\n            /* d_ot is the size of destination */\n            d_ot = dflag;\n\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            rm = (modrm & 7) | REX_B(s);\n\n            if (mod == 3) {\n                gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n                /* sign extend */\n                if (d_ot == MO_64) {\n                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                }\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            } else {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(d_ot, reg, cpu_T0);\n            }\n        } else\n#endif\n        {\n            TCGLabel *label1;\n            TCGv t0, t1, t2, a0;\n\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            t0 = tcg_temp_local_new();\n            t1 = tcg_temp_local_new();\n            t2 = tcg_temp_local_new();\n            ot = MO_16;\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = (modrm >> 3) & 7;\n            mod = (modrm >> 6) & 3;\n            rm = modrm & 7;\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, ot, t0, cpu_A0);\n                a0 = tcg_temp_local_new();\n                tcg_gen_mov_tl(a0, cpu_A0);\n            } else {\n                gen_op_mov_v_reg(ot, t0, rm);\n                TCGV_UNUSED(a0);\n            }\n            gen_op_mov_v_reg(ot, t1, reg);\n            tcg_gen_andi_tl(cpu_tmp0, t0, 3);\n            tcg_gen_andi_tl(t1, t1, 3);\n            tcg_gen_movi_tl(t2, 0);\n            label1 = gen_new_label();\n            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);\n            tcg_gen_andi_tl(t0, t0, ~3);\n            tcg_gen_or_tl(t0, t0, t1);\n            tcg_gen_movi_tl(t2, CC_Z);\n            gen_set_label(label1);\n            if (mod != 3) {\n                gen_op_st_v(s, ot, t0, a0);\n                tcg_temp_free(a0);\n           } else {\n                gen_op_mov_reg_v(ot, rm, t0);\n            }\n            gen_compute_eflags(s);\n            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);\n            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);\n            tcg_temp_free(t0);\n            tcg_temp_free(t1);\n            tcg_temp_free(t2);\n        }\n        break;\n    case 0x102: /* lar */\n    case 0x103: /* lsl */\n        {\n            TCGLabel *label1;\n            TCGv t0;\n            if (!s->pe || s->vm86)\n                goto illegal_op;\n            ot = dflag != MO_16 ? MO_32 : MO_16;\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            t0 = tcg_temp_local_new();\n            gen_update_cc_op(s);\n            if (b == 0x102) {\n                gen_helper_lar(t0, cpu_env, cpu_T0);\n            } else {\n                gen_helper_lsl(t0, cpu_env, cpu_T0);\n            }\n            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);\n            label1 = gen_new_label();\n            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);\n            gen_op_mov_reg_v(ot, reg, t0);\n            gen_set_label(label1);\n            set_cc_op(s, CC_OP_EFLAGS);\n            tcg_temp_free(t0);\n        }\n        break;\n    case 0x118:\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        op = (modrm >> 3) & 7;\n        switch(op) {\n        case 0: /* prefetchnta */\n        case 1: /* prefetchnt0 */\n        case 2: /* prefetchnt0 */\n        case 3: /* prefetchnt0 */\n            if (mod == 3)\n                goto illegal_op;\n            gen_nop_modrm(env, s, modrm);\n            /* nothing more to do */\n            break;\n        default: /* nop (multi byte) */\n            gen_nop_modrm(env, s, modrm);\n            break;\n        }\n        break;\n    case 0x11a:\n        modrm = cpu_ldub_code(env, s->pc++);\n        if (s->flags & HF_MPX_EN_MASK) {\n            mod = (modrm >> 6) & 3;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (prefixes & PREFIX_REPZ) {\n                /* bndcl */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);\n            } else if (prefixes & PREFIX_REPNZ) {\n                /* bndcu */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                TCGv_i64 notu = tcg_temp_new_i64();\n                tcg_gen_not_i64(notu, cpu_bndu[reg]);\n                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);\n                tcg_temp_free_i64(notu);\n            } else if (prefixes & PREFIX_DATA) {\n                /* bndmov -- from reg/mem */\n                if (reg >= 4 || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                if (mod == 3) {\n                    int reg2 = (modrm & 7) | REX_B(s);\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n                        goto illegal_op;\n                    }\n                    if (s->flags & HF_MPX_IU_MASK) {\n                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);\n                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);\n                    }\n                } else {\n                    gen_lea_modrm(env, s, modrm);\n                    if (CODE64(s)) {\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                    } else {\n                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                    /* bnd registers are now in-use */\n                    gen_set_hflag(s, HF_MPX_IU_MASK);\n                }\n            } else if (mod != 3) {\n                /* bndldx */\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16\n                    || a.base < -1) {\n                    goto illegal_op;\n                }\n                if (a.base >= 0) {\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n                } else {\n                    tcg_gen_movi_tl(cpu_A0, 0);\n                }\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n                if (a.index >= 0) {\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n                } else {\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                }\n                if (CODE64(s)) {\n                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);\n                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,\n                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));\n                } else {\n                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);\n                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);\n                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);\n                }\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n            }\n        }\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x11b:\n        modrm = cpu_ldub_code(env, s->pc++);\n        if (s->flags & HF_MPX_EN_MASK) {\n            mod = (modrm >> 6) & 3;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (mod != 3 && (prefixes & PREFIX_REPZ)) {\n                /* bndmk */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n                if (a.base >= 0) {\n                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);\n                    if (!CODE64(s)) {\n                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);\n                    }\n                } else if (a.base == -1) {\n                    /* no base register has lower bound of 0 */\n                    tcg_gen_movi_i64(cpu_bndl[reg], 0);\n                } else {\n                    /* rip-relative generates #ud */\n                    goto illegal_op;\n                }\n                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));\n                if (!CODE64(s)) {\n                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);\n                }\n                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);\n                /* bnd registers are now in-use */\n                gen_set_hflag(s, HF_MPX_IU_MASK);\n                break;\n            } else if (prefixes & PREFIX_REPNZ) {\n                /* bndcn */\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);\n            } else if (prefixes & PREFIX_DATA) {\n                /* bndmov -- to reg/mem */\n                if (reg >= 4 || s->aflag == MO_16) {\n                    goto illegal_op;\n                }\n                if (mod == 3) {\n                    int reg2 = (modrm & 7) | REX_B(s);\n                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {\n                        goto illegal_op;\n                    }\n                    if (s->flags & HF_MPX_IU_MASK) {\n                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);\n                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);\n                    }\n                } else {\n                    gen_lea_modrm(env, s, modrm);\n                    if (CODE64(s)) {\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEQ);\n                    } else {\n                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);\n                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                }\n            } else if (mod != 3) {\n                /* bndstx */\n                AddressParts a = gen_lea_modrm_0(env, s, modrm);\n                if (reg >= 4\n                    || (prefixes & PREFIX_LOCK)\n                    || s->aflag == MO_16\n                    || a.base < -1) {\n                    goto illegal_op;\n                }\n                if (a.base >= 0) {\n                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);\n                } else {\n                    tcg_gen_movi_tl(cpu_A0, 0);\n                }\n                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);\n                if (a.index >= 0) {\n                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);\n                } else {\n                    tcg_gen_movi_tl(cpu_T0, 0);\n                }\n                if (CODE64(s)) {\n                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n                } else {\n                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,\n                                        cpu_bndl[reg], cpu_bndu[reg]);\n                }\n            }\n        }\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */\n        modrm = cpu_ldub_code(env, s->pc++);\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x120: /* mov reg, crN */\n    case 0x122: /* mov crN, reg */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            modrm = cpu_ldub_code(env, s->pc++);\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n             * AMD documentation (24594.pdf) and testing of\n             * intel 386 and 486 processors all show that the mod bits\n             * are assumed to be 1's, regardless of actual values.\n             */\n            rm = (modrm & 7) | REX_B(s);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (CODE64(s))\n                ot = MO_64;\n            else\n                ot = MO_32;\n            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&\n                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {\n                reg = 8;\n            }\n            switch(reg) {\n            case 0:\n            case 2:\n            case 3:\n            case 4:\n            case 8:\n                gen_update_cc_op(s);\n                gen_jmp_im(pc_start - s->cs_base);\n                if (b & 2) {\n                    gen_op_mov_v_reg(ot, cpu_T0, rm);\n                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),\n                                         cpu_T0);\n                    gen_jmp_im(s->pc - s->cs_base);\n                    gen_eob(s);\n                } else {\n                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));\n                    gen_op_mov_reg_v(ot, rm, cpu_T0);\n                }\n                break;\n            default:\n                goto unknown_op;\n            }\n        }\n        break;\n    case 0x121: /* mov reg, drN */\n    case 0x123: /* mov drN, reg */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            modrm = cpu_ldub_code(env, s->pc++);\n            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).\n             * AMD documentation (24594.pdf) and testing of\n             * intel 386 and 486 processors all show that the mod bits\n             * are assumed to be 1's, regardless of actual values.\n             */\n            rm = (modrm & 7) | REX_B(s);\n            reg = ((modrm >> 3) & 7) | rex_r;\n            if (CODE64(s))\n                ot = MO_64;\n            else\n                ot = MO_32;\n            if (reg >= 8) {\n                goto illegal_op;\n            }\n            if (b & 2) {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);\n                gen_op_mov_v_reg(ot, cpu_T0, rm);\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);\n                gen_jmp_im(s->pc - s->cs_base);\n                gen_eob(s);\n            } else {\n                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);\n                tcg_gen_movi_i32(cpu_tmp2_i32, reg);\n                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);\n                gen_op_mov_reg_v(ot, rm, cpu_T0);\n            }\n        }\n        break;\n    case 0x106: /* clts */\n        if (s->cpl != 0) {\n            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);\n        } else {\n            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);\n            gen_helper_clts(cpu_env);\n            /* abort block because static cpu state changed */\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n        }\n        break;\n    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */\n    case 0x1c3: /* MOVNTI reg, mem */\n        if (!(s->cpuid_features & CPUID_SSE2))\n            goto illegal_op;\n        ot = mo_64_32(dflag);\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        reg = ((modrm >> 3) & 7) | rex_r;\n        /* generate a generic store */\n        gen_ldst_modrm(env, s, modrm, ot, reg, 1);\n        break;\n    case 0x1ae:\n        modrm = cpu_ldub_code(env, s->pc++);\n        switch (modrm) {\n        CASE_MODRM_MEM_OP(0): /* fxsave */\n            if (!(s->cpuid_features & CPUID_FXSR)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_helper_fxsave(cpu_env, cpu_A0);\n            break;\n\n        CASE_MODRM_MEM_OP(1): /* fxrstor */\n            if (!(s->cpuid_features & CPUID_FXSR)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_helper_fxrstor(cpu_env, cpu_A0);\n            break;\n\n        CASE_MODRM_MEM_OP(2): /* ldmxcsr */\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n                goto illegal_op;\n            }\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);\n            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);\n            break;\n\n        CASE_MODRM_MEM_OP(3): /* stmxcsr */\n            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {\n                goto illegal_op;\n            }\n            if (s->flags & HF_TS_MASK) {\n                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n                break;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));\n            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            break;\n\n        CASE_MODRM_MEM_OP(4): /* xsave */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);\n            break;\n\n        CASE_MODRM_MEM_OP(5): /* xrstor */\n            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                || (prefixes & (PREFIX_LOCK | PREFIX_DATA\n                                | PREFIX_REPZ | PREFIX_REPNZ))) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                  cpu_regs[R_EDX]);\n            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);\n            /* XRSTOR is how MPX is enabled, which changes how\n               we translate.  Thus we need to end the TB.  */\n            gen_update_cc_op(s);\n            gen_jmp_im(s->pc - s->cs_base);\n            gen_eob(s);\n            break;\n\n        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            if (prefixes & PREFIX_DATA) {\n                /* clwb */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {\n                    goto illegal_op;\n                }\n                gen_nop_modrm(env, s, modrm);\n            } else {\n                /* xsaveopt */\n                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0\n                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0\n                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {\n                    goto illegal_op;\n                }\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],\n                                      cpu_regs[R_EDX]);\n                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);\n            }\n            break;\n\n        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */\n            if (prefixes & PREFIX_LOCK) {\n                goto illegal_op;\n            }\n            if (prefixes & PREFIX_DATA) {\n                /* clflushopt */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {\n                    goto illegal_op;\n                }\n            } else {\n                /* clflush */\n                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))\n                    || !(s->cpuid_features & CPUID_CLFLUSH)) {\n                    goto illegal_op;\n                }\n            }\n            gen_nop_modrm(env, s, modrm);\n            break;\n\n        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */\n        case 0xc8 ... 0xc8: /* rdgsbase (f3 0f ae /1) */\n        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */\n        case 0xd8 ... 0xd8: /* wrgsbase (f3 0f ae /3) */\n            if (CODE64(s)\n                && (prefixes & PREFIX_REPZ)\n                && !(prefixes & PREFIX_LOCK)\n                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {\n                TCGv base, treg, src, dst;\n\n                /* Preserve hflags bits by testing CR4 at runtime.  */\n                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);\n                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);\n\n                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];\n                treg = cpu_regs[(modrm & 7) | REX_B(s)];\n\n                if (modrm & 0x10) {\n                    /* wr*base */\n                    dst = base, src = treg;\n                } else {\n                    /* rd*base */\n                    dst = treg, src = base;\n                }\n\n                if (s->dflag == MO_32) {\n                    tcg_gen_ext32u_tl(dst, src);\n                } else {\n                    tcg_gen_mov_tl(dst, src);\n                }\n                break;\n            }\n            goto unknown_op;\n\n        case 0xf8: /* sfence / pcommit */\n            if (prefixes & PREFIX_DATA) {\n                /* pcommit */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)\n                    || (prefixes & PREFIX_LOCK)) {\n                    goto illegal_op;\n                }\n                break;\n            }\n            /* fallthru */\n        case 0xf9 ... 0xff: /* sfence */\n            if (!(s->cpuid_features & CPUID_SSE)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);\n            break;\n        case 0xe8 ... 0xef: /* lfence */\n            if (!(s->cpuid_features & CPUID_SSE)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);\n            break;\n        case 0xf0 ... 0xf7: /* mfence */\n            if (!(s->cpuid_features & CPUID_SSE2)\n                || (prefixes & PREFIX_LOCK)) {\n                goto illegal_op;\n            }\n            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);\n            break;\n\n        default:\n            goto unknown_op;\n        }\n        break;\n\n    case 0x10d: /* 3DNow! prefetch(w) */\n        modrm = cpu_ldub_code(env, s->pc++);\n        mod = (modrm >> 6) & 3;\n        if (mod == 3)\n            goto illegal_op;\n        gen_nop_modrm(env, s, modrm);\n        break;\n    case 0x1aa: /* rsm */\n        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);\n        if (!(s->flags & HF_SMM_MASK))\n            goto illegal_op;\n        gen_update_cc_op(s);\n        gen_jmp_im(s->pc - s->cs_base);\n        gen_helper_rsm(cpu_env);\n        gen_eob(s);\n        break;\n    case 0x1b8: /* SSE4.2 popcnt */\n        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=\n             PREFIX_REPZ)\n            goto illegal_op;\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n            goto illegal_op;\n\n        modrm = cpu_ldub_code(env, s->pc++);\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n        if (s->prefix & PREFIX_DATA) {\n            ot = MO_16;\n        } else {\n            ot = mo_64_32(dflag);\n        }\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n        gen_extu(ot, cpu_T0);\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n        set_cc_op(s, CC_OP_POPCNT);\n        break;\n    case 0x10e ... 0x10f:\n        /* 3DNow! instructions, ignore prefixes */\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n    case 0x110 ... 0x117:\n    case 0x128 ... 0x12f:\n    case 0x138 ... 0x13a:\n    case 0x150 ... 0x179:\n    case 0x17c ... 0x17f:\n    case 0x1c2:\n    case 0x1c4 ... 0x1c6:\n    case 0x1d0 ... 0x1fe:\n        gen_sse(env, s, b, pc_start, rex_r);\n        break;\n    default:\n        goto unknown_op;\n    }\n    return s->pc;\n illegal_op:\n    gen_illegal_opcode(s);\n    return s->pc;\n unknown_op:\n    gen_unknown_opcode(env, s);\n    return s->pc;\n}\n",
        "linevul": 0.5228651165962219
    },
    {
        "code": "static void __attribute__((__constructor__)) v9fs_set_fd_limit(void)\n{\n    struct rlimit rlim;\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        error_report(\"Failed to get the resource limit\");\n        exit(1);\n    }\n    open_fd_hw = rlim.rlim_cur - MIN(400, rlim.rlim_cur/3);\n    open_fd_rc = rlim.rlim_cur/2;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": "static void __attribute__((__constructor__)) v9fs_set_fd_limit(void)\n{\n    struct rlimit rlim;\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        error_report(\"Failed to get the resource limit\");\n        exit(1);\n    }\n    open_fd_hw = rlim.rlim_cur - MIN(400, rlim.rlim_cur/3);\n    open_fd_rc = rlim.rlim_cur/2;\n}\n",
        "linevul": 8.000541129149497e-05
    },
    {
        "code": "static int dotl_to_open_flags(int flags)\n{\n    int i;\n    /*\n     * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n     * and P9_DOTL_NOACCESS\n     */\n    int oflags = flags & O_ACCMODE;\n\n    DotlOpenflagMap dotl_oflag_map[] = {\n        { P9_DOTL_CREATE, O_CREAT },\n        { P9_DOTL_EXCL, O_EXCL },\n        { P9_DOTL_NOCTTY , O_NOCTTY },\n        { P9_DOTL_TRUNC, O_TRUNC },\n        { P9_DOTL_APPEND, O_APPEND },\n        { P9_DOTL_NONBLOCK, O_NONBLOCK } ,\n        { P9_DOTL_DSYNC, O_DSYNC },\n        { P9_DOTL_FASYNC, FASYNC },\n        { P9_DOTL_DIRECT, O_DIRECT },\n        { P9_DOTL_LARGEFILE, O_LARGEFILE },\n        { P9_DOTL_DIRECTORY, O_DIRECTORY },\n        { P9_DOTL_NOFOLLOW, O_NOFOLLOW },\n        { P9_DOTL_NOATIME, O_NOATIME },\n        { P9_DOTL_SYNC, O_SYNC },\n    };\n\n    for (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n        if (flags & dotl_oflag_map[i].dotl_flag) {\n            oflags |= dotl_oflag_map[i].open_flag;\n        }\n    }\n\n    return oflags;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int dotl_to_open_flags(int flags)\n{\n    int i;\n    /*\n     * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n     * and P9_DOTL_NOACCESS\n     */\n    int oflags = flags & O_ACCMODE;\n\n    DotlOpenflagMap dotl_oflag_map[] = {\n        { P9_DOTL_CREATE, O_CREAT },\n        { P9_DOTL_EXCL, O_EXCL },\n        { P9_DOTL_NOCTTY , O_NOCTTY },\n        { P9_DOTL_TRUNC, O_TRUNC },\n        { P9_DOTL_APPEND, O_APPEND },\n        { P9_DOTL_NONBLOCK, O_NONBLOCK } ,\n        { P9_DOTL_DSYNC, O_DSYNC },\n        { P9_DOTL_FASYNC, FASYNC },\n        { P9_DOTL_DIRECT, O_DIRECT },\n        { P9_DOTL_LARGEFILE, O_LARGEFILE },\n        { P9_DOTL_DIRECTORY, O_DIRECTORY },\n        { P9_DOTL_NOFOLLOW, O_NOFOLLOW },\n        { P9_DOTL_NOATIME, O_NOATIME },\n        { P9_DOTL_SYNC, O_SYNC },\n    };\n\n    for (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n        if (flags & dotl_oflag_map[i].dotl_flag) {\n            oflags |= dotl_oflag_map[i].open_flag;\n        }\n    }\n\n    return oflags;\n}\n",
        "linevul": 4.902496584691107e-05
    },
    {
        "code": "ssize_t nbd_wr_syncv(QIOChannel *ioc,\n                     struct iovec *iov,\n                     size_t niov,\n                     size_t length,\n                     bool do_read)\n{\n    ssize_t done = 0;\n    Error *local_err = NULL;\n    struct iovec *local_iov = g_new(struct iovec, niov);\n    struct iovec *local_iov_head = local_iov;\n    unsigned int nlocal_iov = niov;\n\n    nlocal_iov = iov_copy(local_iov, nlocal_iov, iov, niov, 0, length);\n\n    while (nlocal_iov > 0) {\n        ssize_t len;\n        if (do_read) {\n            len = qio_channel_readv(ioc, local_iov, nlocal_iov, &local_err);\n        } else {\n            len = qio_channel_writev(ioc, local_iov, nlocal_iov, &local_err);\n         }\n         if (len == QIO_CHANNEL_ERR_BLOCK) {\n             if (qemu_in_coroutine()) {\n                /* XXX figure out if we can create a variant on\n                 * qio_channel_yield() that works with AIO contexts\n                 * and consider using that in this branch */\n                qemu_coroutine_yield();\n            } else if (done) {\n                /* XXX this is needed by nbd_reply_ready.  */\n                qio_channel_wait(ioc,\n                                 do_read ? G_IO_IN : G_IO_OUT);\n             } else {\n                 return -EAGAIN;\n             }\n            } else if (done) {\n                /* XXX this is needed by nbd_reply_ready.  */\n                qio_channel_wait(ioc,\n                                 do_read ? G_IO_IN : G_IO_OUT);\n            } else {\n                return -EAGAIN;\n            }\n            continue;\n        }\n        if (len < 0) {\n            TRACE(\"I/O error: %s\", error_get_pretty(local_err));\n            error_free(local_err);\n            /* XXX handle Error objects */\n            done = -EIO;\n            goto cleanup;\n        }\n\n        if (do_read && len == 0) {\n            break;\n        }\n\n        iov_discard_front(&local_iov, &nlocal_iov, len);\n        done += len;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "ssize_t nbd_wr_syncv(QIOChannel *ioc,\n                     struct iovec *iov,\n                     size_t niov,\n                     size_t length,\n                     bool do_read)\n{\n    ssize_t done = 0;\n    Error *local_err = NULL;\n    struct iovec *local_iov = g_new(struct iovec, niov);\n    struct iovec *local_iov_head = local_iov;\n    unsigned int nlocal_iov = niov;\n\n    nlocal_iov = iov_copy(local_iov, nlocal_iov, iov, niov, 0, length);\n\n    while (nlocal_iov > 0) {\n        ssize_t len;\n        if (do_read) {\n            len = qio_channel_readv(ioc, local_iov, nlocal_iov, &local_err);\n        } else {\n            len = qio_channel_writev(ioc, local_iov, nlocal_iov, &local_err);\n         }\n         if (len == QIO_CHANNEL_ERR_BLOCK) {\n             if (qemu_in_coroutine()) {\n//flaw_line_below:\n                /* XXX figure out if we can create a variant on\n//flaw_line_below:\n                 * qio_channel_yield() that works with AIO contexts\n//flaw_line_below:\n                 * and consider using that in this branch */\n//flaw_line_below:\n                qemu_coroutine_yield();\n//flaw_line_below:\n            } else if (done) {\n//flaw_line_below:\n                /* XXX this is needed by nbd_reply_ready.  */\n//flaw_line_below:\n                qio_channel_wait(ioc,\n//flaw_line_below:\n                                 do_read ? G_IO_IN : G_IO_OUT);\n//fix_flaw_line_below:\n//                qio_channel_yield(ioc, do_read ? G_IO_IN : G_IO_OUT);\n             } else {\n                 return -EAGAIN;\n             }\n            } else if (done) {\n                /* XXX this is needed by nbd_reply_ready.  */\n                qio_channel_wait(ioc,\n                                 do_read ? G_IO_IN : G_IO_OUT);\n            } else {\n                return -EAGAIN;\n            }\n            continue;\n        }\n        if (len < 0) {\n            TRACE(\"I/O error: %s\", error_get_pretty(local_err));\n            error_free(local_err);\n            /* XXX handle Error objects */\n            done = -EIO;\n            goto cleanup;\n        }\n\n        if (do_read && len == 0) {\n            break;\n        }\n\n        iov_discard_front(&local_iov, &nlocal_iov, len);\n        done += len;\n    }\n",
        "linevul": 7.096416084095836e-05
    },
    {
        "code": "static void vga_precise_update_retrace_info(VGACommonState *s)\n{\n    int htotal_chars;\n    int hretr_start_char;\n    int hretr_skew_chars;\n    int hretr_end_char;\n\n    int vtotal_lines;\n    int vretr_start_line;\n    int vretr_end_line;\n\n    int dots;\n#if 0\n    int div2, sldiv2;\n#endif\n    int clocking_mode;\n    int clock_sel;\n    const int clk_hz[] = {25175000, 28322000, 25175000, 25175000};\n    int64_t chars_per_sec;\n    struct vga_precise_retrace *r = &s->retrace_info.precise;\n\n    htotal_chars = s->cr[VGA_CRTC_H_TOTAL] + 5;\n    hretr_start_char = s->cr[VGA_CRTC_H_SYNC_START];\n    hretr_skew_chars = (s->cr[VGA_CRTC_H_SYNC_END] >> 5) & 3;\n    hretr_end_char = s->cr[VGA_CRTC_H_SYNC_END] & 0x1f;\n\n    vtotal_lines = (s->cr[VGA_CRTC_V_TOTAL] |\n                    (((s->cr[VGA_CRTC_OVERFLOW] & 1) |\n                      ((s->cr[VGA_CRTC_OVERFLOW] >> 4) & 2)) << 8)) + 2;\n    vretr_start_line = s->cr[VGA_CRTC_V_SYNC_START] |\n        ((((s->cr[VGA_CRTC_OVERFLOW] >> 2) & 1) |\n          ((s->cr[VGA_CRTC_OVERFLOW] >> 6) & 2)) << 8);\n    vretr_end_line = s->cr[VGA_CRTC_V_SYNC_END] & 0xf;\n\n    clocking_mode = (sr(s, VGA_SEQ_CLOCK_MODE) >> 3) & 1;\n    clock_sel = (s->msr >> 2) & 3;\n    dots = (s->msr & 1) ? 8 : 9;\n\n    chars_per_sec = clk_hz[clock_sel] / dots;\n\n    htotal_chars <<= clocking_mode;\n\n    r->total_chars = vtotal_lines * htotal_chars;\n    if (r->freq) {\n        r->ticks_per_char = NANOSECONDS_PER_SECOND / (r->total_chars * r->freq);\n    } else {\n        r->ticks_per_char = NANOSECONDS_PER_SECOND / chars_per_sec;\n    }\n\n    r->vstart = vretr_start_line;\n    r->vend = r->vstart + vretr_end_line + 1;\n\n    r->hstart = hretr_start_char + hretr_skew_chars;\n    r->hend = r->hstart + hretr_end_char + 1;\n    r->htotal = htotal_chars;\n\n#if 0\n    div2 = (s->cr[VGA_CRTC_MODE] >> 2) & 1;\n    sldiv2 = (s->cr[VGA_CRTC_MODE] >> 3) & 1;\n    printf (\n        \"hz=%f\\n\"\n        \"htotal = %d\\n\"\n        \"hretr_start = %d\\n\"\n        \"hretr_skew = %d\\n\"\n        \"hretr_end = %d\\n\"\n        \"vtotal = %d\\n\"\n        \"vretr_start = %d\\n\"\n        \"vretr_end = %d\\n\"\n        \"div2 = %d sldiv2 = %d\\n\"\n        \"clocking_mode = %d\\n\"\n        \"clock_sel = %d %d\\n\"\n        \"dots = %d\\n\"\n        \"ticks/char = %\" PRId64 \"\\n\"\n        \"\\n\",\n        (double) NANOSECONDS_PER_SECOND / (r->ticks_per_char * r->total_chars),\n        htotal_chars,\n        hretr_start_char,\n        hretr_skew_chars,\n        hretr_end_char,\n        vtotal_lines,\n        vretr_start_line,\n        vretr_end_line,\n        div2, sldiv2,\n        clocking_mode,\n        clock_sel,\n        clk_hz[clock_sel],\n        dots,\n        r->ticks_per_char\n        );\n#endif\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "static void vga_precise_update_retrace_info(VGACommonState *s)\n{\n    int htotal_chars;\n    int hretr_start_char;\n    int hretr_skew_chars;\n    int hretr_end_char;\n\n    int vtotal_lines;\n    int vretr_start_line;\n    int vretr_end_line;\n\n    int dots;\n#if 0\n    int div2, sldiv2;\n#endif\n    int clocking_mode;\n    int clock_sel;\n    const int clk_hz[] = {25175000, 28322000, 25175000, 25175000};\n    int64_t chars_per_sec;\n    struct vga_precise_retrace *r = &s->retrace_info.precise;\n\n    htotal_chars = s->cr[VGA_CRTC_H_TOTAL] + 5;\n    hretr_start_char = s->cr[VGA_CRTC_H_SYNC_START];\n    hretr_skew_chars = (s->cr[VGA_CRTC_H_SYNC_END] >> 5) & 3;\n    hretr_end_char = s->cr[VGA_CRTC_H_SYNC_END] & 0x1f;\n\n    vtotal_lines = (s->cr[VGA_CRTC_V_TOTAL] |\n                    (((s->cr[VGA_CRTC_OVERFLOW] & 1) |\n                      ((s->cr[VGA_CRTC_OVERFLOW] >> 4) & 2)) << 8)) + 2;\n    vretr_start_line = s->cr[VGA_CRTC_V_SYNC_START] |\n        ((((s->cr[VGA_CRTC_OVERFLOW] >> 2) & 1) |\n          ((s->cr[VGA_CRTC_OVERFLOW] >> 6) & 2)) << 8);\n    vretr_end_line = s->cr[VGA_CRTC_V_SYNC_END] & 0xf;\n\n    clocking_mode = (sr(s, VGA_SEQ_CLOCK_MODE) >> 3) & 1;\n    clock_sel = (s->msr >> 2) & 3;\n    dots = (s->msr & 1) ? 8 : 9;\n\n    chars_per_sec = clk_hz[clock_sel] / dots;\n\n    htotal_chars <<= clocking_mode;\n\n    r->total_chars = vtotal_lines * htotal_chars;\n    if (r->freq) {\n        r->ticks_per_char = NANOSECONDS_PER_SECOND / (r->total_chars * r->freq);\n    } else {\n        r->ticks_per_char = NANOSECONDS_PER_SECOND / chars_per_sec;\n    }\n\n    r->vstart = vretr_start_line;\n    r->vend = r->vstart + vretr_end_line + 1;\n\n    r->hstart = hretr_start_char + hretr_skew_chars;\n    r->hend = r->hstart + hretr_end_char + 1;\n    r->htotal = htotal_chars;\n\n#if 0\n    div2 = (s->cr[VGA_CRTC_MODE] >> 2) & 1;\n    sldiv2 = (s->cr[VGA_CRTC_MODE] >> 3) & 1;\n    printf (\n        \"hz=%f\\n\"\n        \"htotal = %d\\n\"\n        \"hretr_start = %d\\n\"\n        \"hretr_skew = %d\\n\"\n        \"hretr_end = %d\\n\"\n        \"vtotal = %d\\n\"\n        \"vretr_start = %d\\n\"\n        \"vretr_end = %d\\n\"\n        \"div2 = %d sldiv2 = %d\\n\"\n        \"clocking_mode = %d\\n\"\n        \"clock_sel = %d %d\\n\"\n        \"dots = %d\\n\"\n        \"ticks/char = %\" PRId64 \"\\n\"\n        \"\\n\",\n        (double) NANOSECONDS_PER_SECOND / (r->ticks_per_char * r->total_chars),\n        htotal_chars,\n        hretr_start_char,\n        hretr_skew_chars,\n        hretr_end_char,\n        vtotal_lines,\n        vretr_start_line,\n        vretr_end_line,\n        div2, sldiv2,\n        clocking_mode,\n        clock_sel,\n        clk_hz[clock_sel],\n        dots,\n        r->ticks_per_char\n        );\n#endif\n}\n",
        "linevul": 5.6439454056089744e-05
    },
    {
        "code": "void usb_ehci_init(EHCIState *s, DeviceState *dev)\n{\n    /* 2.2 host controller interface version */\n    s->caps[0x00] = (uint8_t)(s->opregbase - s->capsbase);\n    s->caps[0x01] = 0x00;\n    s->caps[0x02] = 0x00;\n    s->caps[0x03] = 0x01;        /* HC version */\n    s->caps[0x04] = s->portnr;   /* Number of downstream ports */\n    s->caps[0x05] = 0x00;        /* No companion ports at present */\n    s->caps[0x06] = 0x00;\n    s->caps[0x07] = 0x00;\n    s->caps[0x08] = 0x80;        /* We can cache whole frame, no 64-bit */\n    s->caps[0x0a] = 0x00;\n    s->caps[0x0b] = 0x00;\n\n    QTAILQ_INIT(&s->aqueues);\n    QTAILQ_INIT(&s->pqueues);\n    usb_packet_init(&s->ipacket);\n\n    memory_region_init(&s->mem, OBJECT(dev), \"ehci\", MMIO_SIZE);\n    memory_region_init_io(&s->mem_caps, OBJECT(dev), &ehci_mmio_caps_ops, s,\n                          \"capabilities\", CAPA_SIZE);\n    memory_region_init_io(&s->mem_opreg, OBJECT(dev), &ehci_mmio_opreg_ops, s,\n                          \"operational\", s->portscbase);\n    memory_region_init_io(&s->mem_ports, OBJECT(dev), &ehci_mmio_port_ops, s,\n                          \"ports\", 4 * s->portnr);\n\n    memory_region_add_subregion(&s->mem, s->capsbase, &s->mem_caps);\n    memory_region_add_subregion(&s->mem, s->opregbase, &s->mem_opreg);\n    memory_region_add_subregion(&s->mem, s->opregbase + s->portscbase,\n                                &s->mem_ports);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b16c129daf0fed91febbb88de23dae8271c8898a",
        "vul_func_with_fix": "void usb_ehci_init(EHCIState *s, DeviceState *dev)\n{\n    /* 2.2 host controller interface version */\n    s->caps[0x00] = (uint8_t)(s->opregbase - s->capsbase);\n    s->caps[0x01] = 0x00;\n    s->caps[0x02] = 0x00;\n    s->caps[0x03] = 0x01;        /* HC version */\n    s->caps[0x04] = s->portnr;   /* Number of downstream ports */\n    s->caps[0x05] = 0x00;        /* No companion ports at present */\n    s->caps[0x06] = 0x00;\n    s->caps[0x07] = 0x00;\n    s->caps[0x08] = 0x80;        /* We can cache whole frame, no 64-bit */\n    s->caps[0x0a] = 0x00;\n    s->caps[0x0b] = 0x00;\n\n    QTAILQ_INIT(&s->aqueues);\n    QTAILQ_INIT(&s->pqueues);\n    usb_packet_init(&s->ipacket);\n\n    memory_region_init(&s->mem, OBJECT(dev), \"ehci\", MMIO_SIZE);\n    memory_region_init_io(&s->mem_caps, OBJECT(dev), &ehci_mmio_caps_ops, s,\n                          \"capabilities\", CAPA_SIZE);\n    memory_region_init_io(&s->mem_opreg, OBJECT(dev), &ehci_mmio_opreg_ops, s,\n                          \"operational\", s->portscbase);\n    memory_region_init_io(&s->mem_ports, OBJECT(dev), &ehci_mmio_port_ops, s,\n                          \"ports\", 4 * s->portnr);\n\n    memory_region_add_subregion(&s->mem, s->capsbase, &s->mem_caps);\n    memory_region_add_subregion(&s->mem, s->opregbase, &s->mem_opreg);\n    memory_region_add_subregion(&s->mem, s->opregbase + s->portscbase,\n                                &s->mem_ports);\n}\n",
        "linevul": 0.00011998775153188035
    },
    {
        "code": "static void coroutine_fn v9fs_unlinkat(void *opaque)\n{\n    int err = 0;\n    V9fsString name;\n    int32_t dfid, flags, rflags = 0;\n    size_t offset = 7;\n    V9fsPath path;\n    V9fsFidState *dfidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsd\", &dfid, &name, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data)) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\"..\", name.data)) {\n        err = -ENOTEMPTY;\n        goto out_nofid;\n    }\n\n    if (flags & ~P9_DOTL_AT_REMOVEDIR) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n\n    if (flags & P9_DOTL_AT_REMOVEDIR) {\n        rflags |= AT_REMOVEDIR;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    v9fs_path_init(&path);\n    err = v9fs_co_name_to_path(pdu, &dfidp->path, name.data, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_mark_fids_unreclaim(pdu, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_unlinkat(pdu, &dfidp->path, &name, rflags);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    put_fid(pdu, dfidp);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static void coroutine_fn v9fs_unlinkat(void *opaque)\n{\n    int err = 0;\n    V9fsString name;\n    int32_t dfid, flags, rflags = 0;\n    size_t offset = 7;\n    V9fsPath path;\n    V9fsFidState *dfidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsd\", &dfid, &name, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data)) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\"..\", name.data)) {\n        err = -ENOTEMPTY;\n        goto out_nofid;\n    }\n\n    if (flags & ~P9_DOTL_AT_REMOVEDIR) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n\n    if (flags & P9_DOTL_AT_REMOVEDIR) {\n        rflags |= AT_REMOVEDIR;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    v9fs_path_init(&path);\n    err = v9fs_co_name_to_path(pdu, &dfidp->path, name.data, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_mark_fids_unreclaim(pdu, &path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_unlinkat(pdu, &dfidp->path, &name, rflags);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    put_fid(pdu, dfidp);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "linevul": 0.000347864261129871
    },
    {
        "code": "static bool opcode_matches(uint8_t *opcode, const TPRInstruction *instr)\n{\n    return opcode[0] == instr->opcode &&\n        (!(instr->flags & TPR_INSTR_ABS_MODRM) || is_abs_modrm(opcode[1])) &&\n        (!(instr->flags & TPR_INSTR_MATCH_MODRM_REG) ||\n         modrm_reg(opcode[1]) == instr->modrm_reg);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static bool opcode_matches(uint8_t *opcode, const TPRInstruction *instr)\n{\n    return opcode[0] == instr->opcode &&\n        (!(instr->flags & TPR_INSTR_ABS_MODRM) || is_abs_modrm(opcode[1])) &&\n        (!(instr->flags & TPR_INSTR_MATCH_MODRM_REG) ||\n         modrm_reg(opcode[1]) == instr->modrm_reg);\n}\n",
        "linevul": 5.7344703236594796e-05
    },
    {
        "code": "static inline dma_addr_t xhci_addr64(uint32_t low, uint32_t high)\n{\n    if (sizeof(dma_addr_t) == 4) {\n        return low;\n    } else {\n        return low | (((dma_addr_t)high << 16) << 16);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static inline dma_addr_t xhci_addr64(uint32_t low, uint32_t high)\n{\n    if (sizeof(dma_addr_t) == 4) {\n        return low;\n    } else {\n        return low | (((dma_addr_t)high << 16) << 16);\n    }\n}\n",
        "linevul": 9.897627751342952e-05
    },
    {
        "code": "e1000e_has_rxbufs(E1000ECore *core, const E1000E_RingInfo *r,\n                  size_t total_size)\n{\n    uint32_t bufs = e1000e_ring_free_descr_num(core, r);\n\n    trace_e1000e_rx_has_buffers(r->idx, bufs, total_size,\n                                core->rx_desc_buf_size);\n\n    return total_size <= bufs / (core->rx_desc_len / E1000_MIN_RX_DESC_LEN) *\n                         core->rx_desc_buf_size;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_has_rxbufs(E1000ECore *core, const E1000E_RingInfo *r,\n                  size_t total_size)\n{\n    uint32_t bufs = e1000e_ring_free_descr_num(core, r);\n\n    trace_e1000e_rx_has_buffers(r->idx, bufs, total_size,\n                                core->rx_desc_buf_size);\n\n    return total_size <= bufs / (core->rx_desc_len / E1000_MIN_RX_DESC_LEN) *\n                         core->rx_desc_buf_size;\n}\n",
        "linevul": 4.6421690058195964e-05
    },
    {
        "code": "static void pcnet_poll(PCNetState *s)\n{\n    if (CSR_RXON(s)) {\n        pcnet_rdte_poll(s);\n    }\n\n    if (CSR_TDMD(s) ||\n        (CSR_TXON(s) && !CSR_DPOLL(s) && pcnet_tdte_poll(s)))\n    {\n        /* prevent recursion */\n        if (s->tx_busy)\n            return;\n\n        pcnet_transmit(s);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "static void pcnet_poll(PCNetState *s)\n{\n    if (CSR_RXON(s)) {\n        pcnet_rdte_poll(s);\n    }\n\n    if (CSR_TDMD(s) ||\n        (CSR_TXON(s) && !CSR_DPOLL(s) && pcnet_tdte_poll(s)))\n    {\n        /* prevent recursion */\n        if (s->tx_busy)\n            return;\n\n        pcnet_transmit(s);\n    }\n}\n",
        "linevul": 4.8496269300812855e-05
    },
    {
        "code": "static int scsi_hd_initfn(SCSIDevice *dev)\n{\n    return scsi_initfn(dev, TYPE_DISK);\n}\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static int scsi_hd_initfn(SCSIDevice *dev)\n{\n    return scsi_initfn(dev, TYPE_DISK);\n}\n",
        "linevul": 5.5588025134056807e-05
    },
    {
        "code": "ssize_t nbd_receive_reply(QIOChannel *ioc, NBDReply *reply)\n{\n    uint8_t buf[NBD_REPLY_SIZE];\n    uint32_t magic;\n     ssize_t ret;\n \n     ret = read_sync(ioc, buf, sizeof(buf));\n    if (ret < 0) {\n         return ret;\n     }\n    if (ret != sizeof(buf)) {\n        LOG(\"read failed\");\n        return -EINVAL;\n    }\n\n    /* Reply\n       [ 0 ..  3]    magic   (NBD_REPLY_MAGIC)\n       [ 4 ..  7]    error   (0 == no error)\n       [ 7 .. 15]    handle\n     */\n\n    magic = ldl_be_p(buf);\n    reply->error  = ldl_be_p(buf + 4);\n    reply->handle = ldq_be_p(buf + 8);\n\n    reply->error = nbd_errno_to_system_errno(reply->error);\n\n    if (reply->error == ESHUTDOWN) {\n        /* This works even on mingw which lacks a native ESHUTDOWN */\n        LOG(\"server shutting down\");\n        return -EINVAL;\n    }\n    TRACE(\"Got reply: { magic = 0x%\" PRIx32 \", .error = % \" PRId32\n          \", handle = %\" PRIu64\" }\",\n          magic, reply->error, reply->handle);\n\n    if (magic != NBD_REPLY_MAGIC) {\n        LOG(\"invalid magic (got 0x%\" PRIx32 \")\", magic);\n        return -EINVAL;\n    }\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "ssize_t nbd_receive_reply(QIOChannel *ioc, NBDReply *reply)\n{\n    uint8_t buf[NBD_REPLY_SIZE];\n    uint32_t magic;\n     ssize_t ret;\n \n     ret = read_sync(ioc, buf, sizeof(buf));\n//flaw_line_below:\n    if (ret < 0) {\n//fix_flaw_line_below:\n//    if (ret <= 0) {\n         return ret;\n     }\n    if (ret != sizeof(buf)) {\n        LOG(\"read failed\");\n        return -EINVAL;\n    }\n\n    /* Reply\n       [ 0 ..  3]    magic   (NBD_REPLY_MAGIC)\n       [ 4 ..  7]    error   (0 == no error)\n       [ 7 .. 15]    handle\n     */\n\n    magic = ldl_be_p(buf);\n    reply->error  = ldl_be_p(buf + 4);\n    reply->handle = ldq_be_p(buf + 8);\n\n    reply->error = nbd_errno_to_system_errno(reply->error);\n\n    if (reply->error == ESHUTDOWN) {\n        /* This works even on mingw which lacks a native ESHUTDOWN */\n        LOG(\"server shutting down\");\n        return -EINVAL;\n    }\n    TRACE(\"Got reply: { magic = 0x%\" PRIx32 \", .error = % \" PRId32\n          \", handle = %\" PRIu64\" }\",\n          magic, reply->error, reply->handle);\n\n    if (magic != NBD_REPLY_MAGIC) {\n        LOG(\"invalid magic (got 0x%\" PRIx32 \")\", magic);\n        return -EINVAL;\n    }\n    return 0;\n}\n",
        "linevul": 0.9954177141189575
    },
    {
        "code": "static uint32_t xhci_nec_challenge(uint32_t hi, uint32_t lo)\n{\n    uint32_t val;\n    val = rotl(lo - 0x49434878, 32 - ((hi>>8) & 0x1F));\n    val += rotl(lo + 0x49434878, hi & 0x1F);\n    val -= rotl(hi ^ 0x49434878, (lo >> 16) & 0x1F);\n    return ~val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static uint32_t xhci_nec_challenge(uint32_t hi, uint32_t lo)\n{\n    uint32_t val;\n    val = rotl(lo - 0x49434878, 32 - ((hi>>8) & 0x1F));\n    val += rotl(lo + 0x49434878, hi & 0x1F);\n    val -= rotl(hi ^ 0x49434878, (lo >> 16) & 0x1F);\n    return ~val;\n}\n",
        "linevul": 4.902795990346931e-05
    },
    {
        "code": "static void usb_net_class_initfn(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n    uc->realize        = usb_net_realize;\n    uc->product_desc   = \"QEMU USB Network Interface\";\n    uc->usb_desc       = &desc_net;\n    uc->handle_reset   = usb_net_handle_reset;\n    uc->handle_control = usb_net_handle_control;\n    uc->handle_data    = usb_net_handle_data;\n    uc->handle_destroy = usb_net_handle_destroy;\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n    dc->fw_name = \"network\";\n    dc->vmsd = &vmstate_usb_net;\n    dc->props = net_properties;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=80eecda8e5d09c442c24307f340840a5b70ea3b9",
        "vul_func_with_fix": "static void usb_net_class_initfn(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n    uc->realize        = usb_net_realize;\n    uc->product_desc   = \"QEMU USB Network Interface\";\n    uc->usb_desc       = &desc_net;\n    uc->handle_reset   = usb_net_handle_reset;\n    uc->handle_control = usb_net_handle_control;\n    uc->handle_data    = usb_net_handle_data;\n    uc->handle_destroy = usb_net_handle_destroy;\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n    dc->fw_name = \"network\";\n    dc->vmsd = &vmstate_usb_net;\n    dc->props = net_properties;\n}\n",
        "linevul": 7.945040124468505e-05
    },
    {
        "code": "void qemu_spice_add_memslot(SimpleSpiceDisplay *ssd, QXLDevMemSlot *memslot,\n                            qxl_async_io async)\n{\n    trace_qemu_spice_add_memslot(ssd->qxl.id, memslot->slot_id,\n                                memslot->virt_start, memslot->virt_end,\n                                async);\n\n    if (async != QXL_SYNC) {\n        spice_qxl_add_memslot_async(&ssd->qxl, memslot,\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n                                          QXL_IO_MEMSLOT_ADD_ASYNC));\n    } else {\n        spice_qxl_add_memslot(&ssd->qxl, memslot);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "void qemu_spice_add_memslot(SimpleSpiceDisplay *ssd, QXLDevMemSlot *memslot,\n                            qxl_async_io async)\n{\n    trace_qemu_spice_add_memslot(ssd->qxl.id, memslot->slot_id,\n                                memslot->virt_start, memslot->virt_end,\n                                async);\n\n    if (async != QXL_SYNC) {\n        spice_qxl_add_memslot_async(&ssd->qxl, memslot,\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n                                          QXL_IO_MEMSLOT_ADD_ASYNC));\n    } else {\n        spice_qxl_add_memslot(&ssd->qxl, memslot);\n    }\n}\n",
        "linevul": 4.6944776840973645e-05
    },
    {
        "code": "static TCGv gen_lea_modrm_1(AddressParts a)\n{\n    TCGv ea;\n\n    TCGV_UNUSED(ea);\n    if (a.index >= 0) {\n        if (a.scale == 0) {\n            ea = cpu_regs[a.index];\n        } else {\n            tcg_gen_shli_tl(cpu_A0, cpu_regs[a.index], a.scale);\n            ea = cpu_A0;\n        }\n        if (a.base >= 0) {\n            tcg_gen_add_tl(cpu_A0, ea, cpu_regs[a.base]);\n            ea = cpu_A0;\n        }\n    } else if (a.base >= 0) {\n        ea = cpu_regs[a.base];\n    }\n    if (TCGV_IS_UNUSED(ea)) {\n        tcg_gen_movi_tl(cpu_A0, a.disp);\n        ea = cpu_A0;\n    } else if (a.disp != 0) {\n        tcg_gen_addi_tl(cpu_A0, ea, a.disp);\n        ea = cpu_A0;\n    }\n\n    return ea;\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static TCGv gen_lea_modrm_1(AddressParts a)\n{\n    TCGv ea;\n\n    TCGV_UNUSED(ea);\n    if (a.index >= 0) {\n        if (a.scale == 0) {\n            ea = cpu_regs[a.index];\n        } else {\n            tcg_gen_shli_tl(cpu_A0, cpu_regs[a.index], a.scale);\n            ea = cpu_A0;\n        }\n        if (a.base >= 0) {\n            tcg_gen_add_tl(cpu_A0, ea, cpu_regs[a.base]);\n            ea = cpu_A0;\n        }\n    } else if (a.base >= 0) {\n        ea = cpu_regs[a.base];\n    }\n    if (TCGV_IS_UNUSED(ea)) {\n        tcg_gen_movi_tl(cpu_A0, a.disp);\n        ea = cpu_A0;\n    } else if (a.disp != 0) {\n        tcg_gen_addi_tl(cpu_A0, ea, a.disp);\n        ea = cpu_A0;\n    }\n\n    return ea;\n}\n",
        "linevul": 5.500586485140957e-05
    },
    {
        "code": "static int qcow2_set_key(BlockDriverState *bs, const char *key)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint8_t keybuf[16];\n    int len, i;\n\n    memset(keybuf, 0, 16);\n    len = strlen(key);\n    if (len > 16)\n        len = 16;\n    /* XXX: we could compress the chars to 7 bits to increase\n       entropy */\n    for(i = 0;i < len;i++) {\n        keybuf[i] = key[i];\n    }\n    s->crypt_method = s->crypt_method_header;\n\n    if (AES_set_encrypt_key(keybuf, 128, &s->aes_encrypt_key) != 0)\n        return -1;\n    if (AES_set_decrypt_key(keybuf, 128, &s->aes_decrypt_key) != 0)\n        return -1;\n#if 0\n    /* test */\n    {\n        uint8_t in[16];\n        uint8_t out[16];\n        uint8_t tmp[16];\n        for(i=0;i<16;i++)\n            in[i] = i;\n        AES_encrypt(in, tmp, &s->aes_encrypt_key);\n        AES_decrypt(tmp, out, &s->aes_decrypt_key);\n        for(i = 0; i < 16; i++)\n            printf(\" %02x\", tmp[i]);\n        printf(\"\\n\");\n        for(i = 0; i < 16; i++)\n            printf(\" %02x\", out[i]);\n        printf(\"\\n\");\n    }\n#endif\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static int qcow2_set_key(BlockDriverState *bs, const char *key)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint8_t keybuf[16];\n    int len, i;\n\n    memset(keybuf, 0, 16);\n    len = strlen(key);\n    if (len > 16)\n        len = 16;\n    /* XXX: we could compress the chars to 7 bits to increase\n       entropy */\n    for(i = 0;i < len;i++) {\n        keybuf[i] = key[i];\n    }\n    s->crypt_method = s->crypt_method_header;\n\n    if (AES_set_encrypt_key(keybuf, 128, &s->aes_encrypt_key) != 0)\n        return -1;\n    if (AES_set_decrypt_key(keybuf, 128, &s->aes_decrypt_key) != 0)\n        return -1;\n#if 0\n    /* test */\n    {\n        uint8_t in[16];\n        uint8_t out[16];\n        uint8_t tmp[16];\n        for(i=0;i<16;i++)\n            in[i] = i;\n        AES_encrypt(in, tmp, &s->aes_encrypt_key);\n        AES_decrypt(tmp, out, &s->aes_decrypt_key);\n        for(i = 0; i < 16; i++)\n            printf(\" %02x\", tmp[i]);\n        printf(\"\\n\");\n        for(i = 0; i < 16; i++)\n            printf(\" %02x\", out[i]);\n        printf(\"\\n\");\n    }\n#endif\n    return 0;\n}\n",
        "linevul": 6.960322934901342e-05
    },
    {
        "code": "    vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)\n{\n    while (sub && sub->needed) {\n        if (strcmp(idstr, sub->vmsd->name) == 0) {\n            return sub->vmsd;\n        }\n        sub++;\n    }\n    return NULL;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "    vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)\n{\n    while (sub && sub->needed) {\n        if (strcmp(idstr, sub->vmsd->name) == 0) {\n            return sub->vmsd;\n        }\n        sub++;\n    }\n    return NULL;\n}\n",
        "linevul": 6.639404455199838e-05
    },
    {
        "code": "static void virtio_gpu_set_scanout(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_scanout *scanout;\n    pixman_format_code_t format;\n    uint32_t offset;\n    int bpp;\n    struct virtio_gpu_set_scanout ss;\n\n    VIRTIO_GPU_FILL_CMD(ss);\n    trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,\n                                     ss.r.width, ss.r.height, ss.r.x, ss.r.y);\n\n    if (ss.scanout_id >= g->conf.max_outputs) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",\n                      __func__, ss.scanout_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n        return;\n    }\n\n    g->enable = 1;\n    if (ss.resource_id == 0) {\n        scanout = &g->scanout[ss.scanout_id];\n        if (scanout->resource_id) {\n            res = virtio_gpu_find_resource(g, scanout->resource_id);\n            if (res) {\n                res->scanout_bitmask &= ~(1 << ss.scanout_id);\n            }\n        }\n        if (ss.scanout_id == 0) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"%s: illegal scanout id specified %d\",\n                          __func__, ss.scanout_id);\n            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n            return;\n        }\n        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);\n        scanout->ds = NULL;\n        scanout->width = 0;\n        scanout->height = 0;\n        return;\n    }\n\n    /* create a surface for this scanout */\n    res = virtio_gpu_find_resource(g, ss.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ss.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (ss.r.x > res->width ||\n        ss.r.y > res->height ||\n        ss.r.width > res->width ||\n        ss.r.height > res->height ||\n        ss.r.x + ss.r.width > res->width ||\n        ss.r.y + ss.r.height > res->height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout %d bounds for\"\n                      \" resource %d, (%d,%d)+%d,%d vs %d %d\\n\",\n                      __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,\n                      ss.r.width, ss.r.height, res->width, res->height);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;\n        return;\n    }\n\n    scanout = &g->scanout[ss.scanout_id];\n\n    format = pixman_image_get_format(res->image);\n    bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;\n    offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);\n    if (!scanout->ds || surface_data(scanout->ds)\n        != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||\n        scanout->width != ss.r.width ||\n        scanout->height != ss.r.height) {\n        pixman_image_t *rect;\n        void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;\n        rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,\n                                        pixman_image_get_stride(res->image));\n        pixman_image_ref(res->image);\n        pixman_image_set_destroy_function(rect, virtio_unref_resource,\n                                          res->image);\n        /* realloc the surface ptr */\n        scanout->ds = qemu_create_displaysurface_pixman(rect);\n        if (!scanout->ds) {\n             cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n             return;\n         }\n         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);\n     }\n    scanout->resource_id = ss.resource_id;\n    scanout->x = ss.r.x;\n    scanout->y = ss.r.y;\n    scanout->width = ss.r.width;\n    scanout->height = ss.r.height;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static void virtio_gpu_set_scanout(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_scanout *scanout;\n    pixman_format_code_t format;\n    uint32_t offset;\n    int bpp;\n    struct virtio_gpu_set_scanout ss;\n\n    VIRTIO_GPU_FILL_CMD(ss);\n    trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,\n                                     ss.r.width, ss.r.height, ss.r.x, ss.r.y);\n\n    if (ss.scanout_id >= g->conf.max_outputs) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",\n                      __func__, ss.scanout_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n        return;\n    }\n\n    g->enable = 1;\n    if (ss.resource_id == 0) {\n        scanout = &g->scanout[ss.scanout_id];\n        if (scanout->resource_id) {\n            res = virtio_gpu_find_resource(g, scanout->resource_id);\n            if (res) {\n                res->scanout_bitmask &= ~(1 << ss.scanout_id);\n            }\n        }\n        if (ss.scanout_id == 0) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"%s: illegal scanout id specified %d\",\n                          __func__, ss.scanout_id);\n            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n            return;\n        }\n        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);\n        scanout->ds = NULL;\n        scanout->width = 0;\n        scanout->height = 0;\n        return;\n    }\n\n    /* create a surface for this scanout */\n    res = virtio_gpu_find_resource(g, ss.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ss.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (ss.r.x > res->width ||\n        ss.r.y > res->height ||\n        ss.r.width > res->width ||\n        ss.r.height > res->height ||\n        ss.r.x + ss.r.width > res->width ||\n        ss.r.y + ss.r.height > res->height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout %d bounds for\"\n                      \" resource %d, (%d,%d)+%d,%d vs %d %d\\n\",\n                      __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,\n                      ss.r.width, ss.r.height, res->width, res->height);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;\n        return;\n    }\n\n    scanout = &g->scanout[ss.scanout_id];\n\n    format = pixman_image_get_format(res->image);\n    bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;\n    offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);\n    if (!scanout->ds || surface_data(scanout->ds)\n        != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||\n        scanout->width != ss.r.width ||\n        scanout->height != ss.r.height) {\n        pixman_image_t *rect;\n        void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;\n        rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,\n                                        pixman_image_get_stride(res->image));\n        pixman_image_ref(res->image);\n        pixman_image_set_destroy_function(rect, virtio_unref_resource,\n                                          res->image);\n        /* realloc the surface ptr */\n        scanout->ds = qemu_create_displaysurface_pixman(rect);\n        if (!scanout->ds) {\n             cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n             return;\n         }\n//fix_flaw_line_below:\n//        pixman_image_unref(rect);\n         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);\n     }\n    scanout->resource_id = ss.resource_id;\n    scanout->x = ss.r.x;\n    scanout->y = ss.r.y;\n    scanout->width = ss.r.width;\n    scanout->height = ss.r.height;\n}\n",
        "linevul": 0.9306643009185791
    },
    {
        "code": "void net_tx_pkt_setup_vlan_header_ex(struct NetTxPkt *pkt,\n    uint16_t vlan, uint16_t vlan_ethtype)\n{\n    bool is_new;\n    assert(pkt);\n\n    eth_setup_vlan_headers_ex(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n        vlan, vlan_ethtype, &is_new);\n\n    /* update l2hdrlen */\n    if (is_new) {\n        pkt->hdr_len += sizeof(struct vlan_header);\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len +=\n            sizeof(struct vlan_header);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "void net_tx_pkt_setup_vlan_header_ex(struct NetTxPkt *pkt,\n    uint16_t vlan, uint16_t vlan_ethtype)\n{\n    bool is_new;\n    assert(pkt);\n\n    eth_setup_vlan_headers_ex(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n        vlan, vlan_ethtype, &is_new);\n\n    /* update l2hdrlen */\n    if (is_new) {\n        pkt->hdr_len += sizeof(struct vlan_header);\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len +=\n            sizeof(struct vlan_header);\n    }\n}\n",
        "linevul": 4.8262452764902264e-05
    },
    {
        "code": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n                            VirtIOHandleOutput handle_output)\n{\n    return virtio_add_queue_internal(vdev, queue_size, handle_output, false);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n                            VirtIOHandleOutput handle_output)\n{\n    return virtio_add_queue_internal(vdev, queue_size, handle_output, false);\n}\n",
        "linevul": 4.704390084953047e-05
    },
    {
        "code": "static int handle_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    char *buffer;\n    struct file_handle *fh;\n    int dirfd, ret, mnt_id;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    /* \".\" and \"..\" are not allowed */\n    if (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n        errno = EINVAL;\n        return -1;\n\n    }\n    if (dir_path) {\n        dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    } else {\n        /* relative to export root */\n        buffer = rpath(ctx, \".\");\n        dirfd = open(buffer, O_DIRECTORY);\n        g_free(buffer);\n    }\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    fh = g_malloc(sizeof(struct file_handle) + data->handle_bytes);\n    fh->handle_bytes = data->handle_bytes;\n    /* add a \"./\" at the beginning of the path */\n    buffer = g_strdup_printf(\"./%s\", name);\n    /* flag = 0 imply don't follow symlink */\n    ret = name_to_handle(dirfd, buffer, fh, &mnt_id, 0);\n    if (!ret) {\n        target->data = (char *)fh;\n        target->size = sizeof(struct file_handle) + data->handle_bytes;\n    } else {\n        g_free(fh);\n    }\n    close(dirfd);\n    g_free(buffer);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    char *buffer;\n    struct file_handle *fh;\n    int dirfd, ret, mnt_id;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    /* \".\" and \"..\" are not allowed */\n    if (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n        errno = EINVAL;\n        return -1;\n\n    }\n    if (dir_path) {\n        dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    } else {\n        /* relative to export root */\n        buffer = rpath(ctx, \".\");\n        dirfd = open(buffer, O_DIRECTORY);\n        g_free(buffer);\n    }\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    fh = g_malloc(sizeof(struct file_handle) + data->handle_bytes);\n    fh->handle_bytes = data->handle_bytes;\n    /* add a \"./\" at the beginning of the path */\n    buffer = g_strdup_printf(\"./%s\", name);\n    /* flag = 0 imply don't follow symlink */\n    ret = name_to_handle(dirfd, buffer, fh, &mnt_id, 0);\n    if (!ret) {\n        target->data = (char *)fh;\n        target->size = sizeof(struct file_handle) + data->handle_bytes;\n    } else {\n        g_free(fh);\n    }\n    close(dirfd);\n    g_free(buffer);\n    return ret;\n}\n",
        "linevul": 0.00011442881077528
    },
    {
        "code": "static void ohci_eof_timer(OHCIState *ohci)\n{\n    ohci->sof_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    timer_mod(ohci->eof_timer, ohci->sof_time + usb_frame_time);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void ohci_eof_timer(OHCIState *ohci)\n{\n    ohci->sof_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    timer_mod(ohci->eof_timer, ohci->sof_time + usb_frame_time);\n}\n",
        "linevul": 4.8658774176146835e-05
    },
    {
        "code": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n     int32_t len;\n     uint8_t command;\n    uint8_t *outbuf;\n     int rc;\n \n     command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n     DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n \n #ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n     case GET_CONFIGURATION:\n     case SERVICE_ACTION_IN_16:\n     case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n         if (rc < 0) {\n             return 0;\n         }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n     int32_t len;\n     uint8_t command;\n//flaw_line_below:\n    uint8_t *outbuf;\n     int rc;\n \n     command = buf[0];\n//flaw_line_below:\n    outbuf = (uint8_t *)r->iov.iov_base;\n     DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n \n #ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n     case GET_CONFIGURATION:\n     case SERVICE_ACTION_IN_16:\n     case VERIFY_10:\n//flaw_line_below:\n        rc = scsi_disk_emulate_command(r, outbuf);\n//fix_flaw_line_below:\n//        rc = scsi_disk_emulate_command(r);\n         if (rc < 0) {\n             return 0;\n         }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}\n",
        "linevul": 0.9953970313072205
    },
    {
        "code": "static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n{\n    ssize_t ret;\n    guint watch;\n    assert(qemu_in_coroutine());\n    /* Negotiation are always in main loop. */\n    watch = qio_channel_add_watch(ioc,\n                                  G_IO_IN,\n                                  nbd_negotiate_continue,\n                                  qemu_coroutine_self(),\n                                  NULL);\n    ret = nbd_read(ioc, buffer, size, NULL);\n    g_source_remove(watch);\n    return ret;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=2b0bbc4f8809c972bad134bc1a2570dbb01dea0b",
        "vul_func_with_fix": "static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n//flaw_line_below:\n{\n//flaw_line_below:\n    ssize_t ret;\n//flaw_line_below:\n    guint watch;\n//flaw_line_below:\n\n//flaw_line_below:\n    assert(qemu_in_coroutine());\n//flaw_line_below:\n    /* Negotiation are always in main loop. */\n//flaw_line_below:\n    watch = qio_channel_add_watch(ioc,\n//flaw_line_below:\n                                  G_IO_IN,\n//flaw_line_below:\n                                  nbd_negotiate_continue,\n//flaw_line_below:\n                                  qemu_coroutine_self(),\n//flaw_line_below:\n                                  NULL);\n//flaw_line_below:\n    ret = nbd_read(ioc, buffer, size, NULL);\n//flaw_line_below:\n    g_source_remove(watch);\n//flaw_line_below:\n    return ret;\n//flaw_line_below:\n\n//flaw_line_below:\n}\n",
        "linevul": 0.000115756738523487
    },
    {
        "code": "size_t mptsas_config_phy_1(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);\n        return i;\n    }\n\n    (void) mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);\n\n    return MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"*l*l*l*l*l\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_phy_1(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);\n        return i;\n    }\n\n    (void) mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 1);\n\n    return MPTSAS_CONFIG_PACK_EXT(1, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"*l*l*l*l*l\");\n}\n",
        "linevul": 4.99681118526496e-05
    },
    {
        "code": "static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}\n",
        "linevul": 6.661989027634263e-05
    },
    {
        "code": "static int qcow2_refresh_limits(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n\n    bs->bl.write_zeroes_alignment = s->cluster_sectors;\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static int qcow2_refresh_limits(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n\n    bs->bl.write_zeroes_alignment = s->cluster_sectors;\n\n    return 0;\n}\n",
        "linevul": 4.8647129005985335e-05
    },
    {
        "code": "static void ahci_start_transfer(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    IDEState *s = &ad->port.ifs[0];\n    uint32_t size = (uint32_t)(s->data_end - s->data_ptr);\n    /* write == ram -> device */\n    uint16_t opts = le16_to_cpu(ad->cur_cmd->opts);\n    int is_write = opts & AHCI_CMD_WRITE;\n    int is_atapi = opts & AHCI_CMD_ATAPI;\n    int has_sglist = 0;\n\n    if (is_atapi && !ad->done_atapi_packet) {\n        /* already prepopulated iobuffer */\n        ad->done_atapi_packet = true;\n        size = 0;\n        goto out;\n    }\n\n    if (ahci_dma_prepare_buf(dma, size)) {\n        has_sglist = 1;\n    }\n\n    DPRINTF(ad->port_no, \"%sing %d bytes on %s w/%s sglist\\n\",\n            is_write ? \"writ\" : \"read\", size, is_atapi ? \"atapi\" : \"ata\",\n            has_sglist ? \"\" : \"o\");\n\n    if (has_sglist && size) {\n        if (is_write) {\n            dma_buf_write(s->data_ptr, size, &s->sg);\n        } else {\n            dma_buf_read(s->data_ptr, size, &s->sg);\n        }\n    }\n\nout:\n    /* declare that we processed everything */\n    s->data_ptr = s->data_end;\n\n    /* Update number of transferred bytes, destroy sglist */\n    dma_buf_commit(s, size);\n\n    s->end_transfer_func(s);\n\n    if (!(s->status & DRQ_STAT)) {\n        /* done with PIO send/receive */\n        ahci_write_fis_pio(ad, le32_to_cpu(ad->cur_cmd->status));\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_start_transfer(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    IDEState *s = &ad->port.ifs[0];\n    uint32_t size = (uint32_t)(s->data_end - s->data_ptr);\n    /* write == ram -> device */\n    uint16_t opts = le16_to_cpu(ad->cur_cmd->opts);\n    int is_write = opts & AHCI_CMD_WRITE;\n    int is_atapi = opts & AHCI_CMD_ATAPI;\n    int has_sglist = 0;\n\n    if (is_atapi && !ad->done_atapi_packet) {\n        /* already prepopulated iobuffer */\n        ad->done_atapi_packet = true;\n        size = 0;\n        goto out;\n    }\n\n    if (ahci_dma_prepare_buf(dma, size)) {\n        has_sglist = 1;\n    }\n\n    DPRINTF(ad->port_no, \"%sing %d bytes on %s w/%s sglist\\n\",\n            is_write ? \"writ\" : \"read\", size, is_atapi ? \"atapi\" : \"ata\",\n            has_sglist ? \"\" : \"o\");\n\n    if (has_sglist && size) {\n        if (is_write) {\n            dma_buf_write(s->data_ptr, size, &s->sg);\n        } else {\n            dma_buf_read(s->data_ptr, size, &s->sg);\n        }\n    }\n\nout:\n    /* declare that we processed everything */\n    s->data_ptr = s->data_end;\n\n    /* Update number of transferred bytes, destroy sglist */\n    dma_buf_commit(s, size);\n\n    s->end_transfer_func(s);\n\n    if (!(s->status & DRQ_STAT)) {\n        /* done with PIO send/receive */\n        ahci_write_fis_pio(ad, le32_to_cpu(ad->cur_cmd->status));\n    }\n}\n",
        "linevul": 8.942460408434272e-05
    },
    {
        "code": "int v9fs_set_xattr(FsContext *ctx, const char *path, const char *name,\n                   void *value, size_t size, int flags)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->setxattr(ctx, path, name, value, size, flags);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "int v9fs_set_xattr(FsContext *ctx, const char *path, const char *name,\n                   void *value, size_t size, int flags)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->setxattr(ctx, path, name, value, size, flags);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n\n}\n",
        "linevul": 8.934694051276892e-05
    },
    {
        "code": "static int xhci_fire_transfer(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    trace_usb_xhci_xfer_start(xfer, xfer->slotid, xfer->epid, xfer->streamid);\n    return xhci_submit(xhci, xfer, epctx);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b53dd4495ced2432a0b652ea895e651d07336f7e",
        "vul_func_with_fix": "static int xhci_fire_transfer(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    trace_usb_xhci_xfer_start(xfer, xfer->slotid, xfer->epid, xfer->streamid);\n    return xhci_submit(xhci, xfer, epctx);\n}\n",
        "linevul": 4.696196992881596e-05
    },
    {
        "code": "static void virtio_gpu_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    vdc->realize = virtio_gpu_device_realize;\n    vdc->unrealize = virtio_gpu_device_unrealize;\n    vdc->get_config = virtio_gpu_get_config;\n    vdc->set_config = virtio_gpu_set_config;\n    vdc->get_features = virtio_gpu_get_features;\n    vdc->set_features = virtio_gpu_set_features;\n\n    vdc->reset = virtio_gpu_reset;\n\n    dc->props = virtio_gpu_properties;\n    dc->vmsd = &vmstate_virtio_gpu;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=204f01b30975923c64006f8067f0937b91eea68b",
        "vul_func_with_fix": "static void virtio_gpu_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    vdc->realize = virtio_gpu_device_realize;\n    vdc->unrealize = virtio_gpu_device_unrealize;\n    vdc->get_config = virtio_gpu_get_config;\n    vdc->set_config = virtio_gpu_set_config;\n    vdc->get_features = virtio_gpu_get_features;\n    vdc->set_features = virtio_gpu_set_features;\n\n    vdc->reset = virtio_gpu_reset;\n\n    dc->props = virtio_gpu_properties;\n    dc->vmsd = &vmstate_virtio_gpu;\n}\n",
        "linevul": 5.2635557949543e-05
    },
    {
        "code": "static long vnc_client_write_plain(VncState *vs)\n{\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif /* CONFIG_VNC_SASL */\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n\n    buffer_advance(&vs->output, ret);\n\n    if (vs->output.offset == 0) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static long vnc_client_write_plain(VncState *vs)\n{\n    long ret;\n\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif /* CONFIG_VNC_SASL */\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n\n    buffer_advance(&vs->output, ret);\n\n    if (vs->output.offset == 0) {\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n    }\n\n    return ret;\n}\n",
        "linevul": 5.5110820539994165e-05
    },
    {
        "code": "static int ssd0323_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n         return -EINVAL;\n \n     s->cmd_len = qemu_get_be32(f);\n     s->cmd = qemu_get_be32(f);\n     for (i = 0; i < 8; i++)\n         s->cmd_data[i] = qemu_get_be32(f);\n     s->row = qemu_get_be32(f);\n     s->row_start = qemu_get_be32(f);\n     s->row_end = qemu_get_be32(f);\n     s->col = qemu_get_be32(f);\n     s->col_start = qemu_get_be32(f);\n     s->col_end = qemu_get_be32(f);\n     s->redraw = qemu_get_be32(f);\n     s->remap = qemu_get_be32(f);\n     s->mode = qemu_get_be32(f);\n     qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));\n \n     ss->cs = qemu_get_be32(f);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ead7a57df37d2187813a121308213f41591bd811",
        "vul_func_with_fix": "static int ssd0323_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n         return -EINVAL;\n \n     s->cmd_len = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->cmd_len < 0 || s->cmd_len > ARRAY_SIZE(s->cmd_data)) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->cmd = qemu_get_be32(f);\n     for (i = 0; i < 8; i++)\n         s->cmd_data[i] = qemu_get_be32(f);\n     s->row = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->row < 0 || s->row >= 80) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->row_start = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->row_start < 0 || s->row_start >= 80) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->row_end = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->row_end < 0 || s->row_end >= 80) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->col = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->col < 0 || s->col >= 64) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->col_start = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->col_start < 0 || s->col_start >= 64) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->col_end = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->col_end < 0 || s->col_end >= 64) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->redraw = qemu_get_be32(f);\n     s->remap = qemu_get_be32(f);\n     s->mode = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->mode != SSD0323_CMD && s->mode != SSD0323_DATA) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));\n \n     ss->cs = qemu_get_be32(f);\n}\n",
        "linevul": 0.9983910322189331
    },
    {
        "code": "static void vmxnet3_get_rx_stats_from_file(QEMUFile *f,\n    struct UPT1_RxStats *rx_stat)\n{\n    rx_stat->LROPktsRxOK = qemu_get_be64(f);\n    rx_stat->LROBytesRxOK = qemu_get_be64(f);\n    rx_stat->ucastPktsRxOK = qemu_get_be64(f);\n    rx_stat->ucastBytesRxOK = qemu_get_be64(f);\n    rx_stat->mcastPktsRxOK = qemu_get_be64(f);\n    rx_stat->mcastBytesRxOK = qemu_get_be64(f);\n    rx_stat->bcastPktsRxOK = qemu_get_be64(f);\n    rx_stat->bcastBytesRxOK = qemu_get_be64(f);\n    rx_stat->pktsRxOutOfBuf = qemu_get_be64(f);\n    rx_stat->pktsRxError = qemu_get_be64(f);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_get_rx_stats_from_file(QEMUFile *f,\n    struct UPT1_RxStats *rx_stat)\n{\n    rx_stat->LROPktsRxOK = qemu_get_be64(f);\n    rx_stat->LROBytesRxOK = qemu_get_be64(f);\n    rx_stat->ucastPktsRxOK = qemu_get_be64(f);\n    rx_stat->ucastBytesRxOK = qemu_get_be64(f);\n    rx_stat->mcastPktsRxOK = qemu_get_be64(f);\n    rx_stat->mcastBytesRxOK = qemu_get_be64(f);\n    rx_stat->bcastPktsRxOK = qemu_get_be64(f);\n    rx_stat->bcastBytesRxOK = qemu_get_be64(f);\n    rx_stat->pktsRxOutOfBuf = qemu_get_be64(f);\n    rx_stat->pktsRxError = qemu_get_be64(f);\n}\n",
        "linevul": 5.184566180105321e-05
    },
    {
        "code": "static void do_cmd(ESPState *s, uint8_t *buf)\n{\n    uint8_t busid = buf[0];\n\n    do_busid_cmd(s, &buf[1], busid);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11",
        "vul_func_with_fix": "static void do_cmd(ESPState *s, uint8_t *buf)\n{\n    uint8_t busid = buf[0];\n\n    do_busid_cmd(s, &buf[1], busid);\n}\n",
        "linevul": 4.6882858441676944e-05
    },
    {
        "code": "static int find_real_tpr_addr(VAPICROMState *s, CPUX86State *env)\n{\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n    hwaddr paddr;\n    target_ulong addr;\n\n    if (s->state == VAPIC_ACTIVE) {\n        return 0;\n    }\n    /*\n     * If there is no prior TPR access instruction we could analyze (which is\n     * the case after resume from hibernation), we need to scan the possible\n     * virtual address space for the APIC mapping.\n     */\n    for (addr = 0xfffff000; addr >= 0x80000000; addr -= TARGET_PAGE_SIZE) {\n        paddr = cpu_get_phys_page_debug(cs, addr);\n        if (paddr != APIC_DEFAULT_ADDRESS) {\n            continue;\n        }\n        s->real_tpr_addr = addr + 0x80;\n        update_guest_rom_state(s);\n        return 0;\n    }\n    return -1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static int find_real_tpr_addr(VAPICROMState *s, CPUX86State *env)\n{\n    CPUState *cs = CPU(x86_env_get_cpu(env));\n    hwaddr paddr;\n    target_ulong addr;\n\n    if (s->state == VAPIC_ACTIVE) {\n        return 0;\n    }\n    /*\n     * If there is no prior TPR access instruction we could analyze (which is\n     * the case after resume from hibernation), we need to scan the possible\n     * virtual address space for the APIC mapping.\n     */\n    for (addr = 0xfffff000; addr >= 0x80000000; addr -= TARGET_PAGE_SIZE) {\n        paddr = cpu_get_phys_page_debug(cs, addr);\n        if (paddr != APIC_DEFAULT_ADDRESS) {\n            continue;\n        }\n        s->real_tpr_addr = addr + 0x80;\n        update_guest_rom_state(s);\n        return 0;\n    }\n    return -1;\n}\n",
        "linevul": 5.30124525539577e-05
    },
    {
        "code": "void vbe_ioport_write_index(void *opaque, uint32_t addr, uint32_t val)\n{\n    VGACommonState *s = opaque;\n    s->vbe_index = val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "void vbe_ioport_write_index(void *opaque, uint32_t addr, uint32_t val)\n{\n    VGACommonState *s = opaque;\n    s->vbe_index = val;\n}\n",
        "linevul": 6.777664384571835e-05
    },
    {
        "code": "static VirtIONetQueue *virtio_net_get_subqueue(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n\n    return &n->vqs[nc->queue_index];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static VirtIONetQueue *virtio_net_get_subqueue(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n\n    return &n->vqs[nc->queue_index];\n}\n",
        "linevul": 4.9257869250141084e-05
    },
    {
        "code": "static void cirrus_vga_write_sr(CirrusVGAState * s, uint32_t val)\n{\n    switch (s->vga.sr_index) {\n    case 0x00:\t\t\t// Standard VGA\n    case 0x01:\t\t\t// Standard VGA\n    case 0x02:\t\t\t// Standard VGA\n    case 0x03:\t\t\t// Standard VGA\n    case 0x04:\t\t\t// Standard VGA\n\ts->vga.sr[s->vga.sr_index] = val & sr_mask[s->vga.sr_index];\n\tif (s->vga.sr_index == 1)\n            s->vga.update_retrace_info(&s->vga);\n        break;\n    case 0x06:\t\t\t// Unlock Cirrus extensions\n\tval &= 0x17;\n\tif (val == 0x12) {\n\t    s->vga.sr[s->vga.sr_index] = 0x12;\n\t} else {\n\t    s->vga.sr[s->vga.sr_index] = 0x0f;\n\t}\n\tbreak;\n    case 0x10:\n    case 0x30:\n    case 0x50:\n    case 0x70:\t\t\t// Graphics Cursor X\n    case 0x90:\n    case 0xb0:\n    case 0xd0:\n    case 0xf0:\t\t\t// Graphics Cursor X\n\ts->vga.sr[0x10] = val;\n        s->vga.hw_cursor_x = (val << 3) | (s->vga.sr_index >> 5);\n\tbreak;\n    case 0x11:\n    case 0x31:\n    case 0x51:\n    case 0x71:\t\t\t// Graphics Cursor Y\n    case 0x91:\n    case 0xb1:\n    case 0xd1:\n    case 0xf1:\t\t\t// Graphics Cursor Y\n\ts->vga.sr[0x11] = val;\n        s->vga.hw_cursor_y = (val << 3) | (s->vga.sr_index >> 5);\n\tbreak;\n    case 0x07:\t\t\t// Extended Sequencer Mode\n    cirrus_update_memory_access(s);\n    case 0x08:\t\t\t// EEPROM Control\n    case 0x09:\t\t\t// Scratch Register 0\n    case 0x0a:\t\t\t// Scratch Register 1\n    case 0x0b:\t\t\t// VCLK 0\n    case 0x0c:\t\t\t// VCLK 1\n    case 0x0d:\t\t\t// VCLK 2\n    case 0x0e:\t\t\t// VCLK 3\n    case 0x0f:\t\t\t// DRAM Control\n    case 0x13:\t\t\t// Graphics Cursor Pattern Address\n    case 0x14:\t\t\t// Scratch Register 2\n    case 0x15:\t\t\t// Scratch Register 3\n    case 0x16:\t\t\t// Performance Tuning Register\n    case 0x18:\t\t\t// Signature Generator Control\n    case 0x19:\t\t\t// Signature Generator Result\n    case 0x1a:\t\t\t// Signature Generator Result\n    case 0x1b:\t\t\t// VCLK 0 Denominator & Post\n    case 0x1c:\t\t\t// VCLK 1 Denominator & Post\n    case 0x1d:\t\t\t// VCLK 2 Denominator & Post\n    case 0x1e:\t\t\t// VCLK 3 Denominator & Post\n    case 0x1f:\t\t\t// BIOS Write Enable and MCLK select\n\ts->vga.sr[s->vga.sr_index] = val;\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: handled outport sr_index %02x, sr_value %02x\\n\",\n\t       s->vga.sr_index, val);\n#endif\n\tbreak;\n    case 0x12:\t\t\t// Graphics Cursor Attribute\n\ts->vga.sr[0x12] = val;\n        s->vga.force_shadow = !!(val & CIRRUS_CURSOR_SHOW);\n#ifdef DEBUG_CIRRUS\n        printf(\"cirrus: cursor ctl SR12=%02x (force shadow: %d)\\n\",\n               val, s->vga.force_shadow);\n#endif\n        break;\n    case 0x17:\t\t\t// Configuration Readback and Extended Control\n\ts->vga.sr[s->vga.sr_index] = (s->vga.sr[s->vga.sr_index] & 0x38)\n                                   | (val & 0xc7);\n        cirrus_update_memory_access(s);\n        break;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: outport sr_index %02x, sr_value %02x\\n\",\n               s->vga.sr_index, val);\n#endif\n\tbreak;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=f153b563f8cf121aebf5a2fff5f0110faf58ccb3",
        "vul_func_with_fix": "static void cirrus_vga_write_sr(CirrusVGAState * s, uint32_t val)\n{\n    switch (s->vga.sr_index) {\n    case 0x00:\t\t\t// Standard VGA\n    case 0x01:\t\t\t// Standard VGA\n    case 0x02:\t\t\t// Standard VGA\n    case 0x03:\t\t\t// Standard VGA\n    case 0x04:\t\t\t// Standard VGA\n\ts->vga.sr[s->vga.sr_index] = val & sr_mask[s->vga.sr_index];\n\tif (s->vga.sr_index == 1)\n            s->vga.update_retrace_info(&s->vga);\n        break;\n    case 0x06:\t\t\t// Unlock Cirrus extensions\n\tval &= 0x17;\n\tif (val == 0x12) {\n\t    s->vga.sr[s->vga.sr_index] = 0x12;\n\t} else {\n\t    s->vga.sr[s->vga.sr_index] = 0x0f;\n\t}\n\tbreak;\n    case 0x10:\n    case 0x30:\n    case 0x50:\n    case 0x70:\t\t\t// Graphics Cursor X\n    case 0x90:\n    case 0xb0:\n    case 0xd0:\n    case 0xf0:\t\t\t// Graphics Cursor X\n\ts->vga.sr[0x10] = val;\n        s->vga.hw_cursor_x = (val << 3) | (s->vga.sr_index >> 5);\n\tbreak;\n    case 0x11:\n    case 0x31:\n    case 0x51:\n    case 0x71:\t\t\t// Graphics Cursor Y\n    case 0x91:\n    case 0xb1:\n    case 0xd1:\n    case 0xf1:\t\t\t// Graphics Cursor Y\n\ts->vga.sr[0x11] = val;\n        s->vga.hw_cursor_y = (val << 3) | (s->vga.sr_index >> 5);\n\tbreak;\n    case 0x07:\t\t\t// Extended Sequencer Mode\n    cirrus_update_memory_access(s);\n    case 0x08:\t\t\t// EEPROM Control\n    case 0x09:\t\t\t// Scratch Register 0\n    case 0x0a:\t\t\t// Scratch Register 1\n    case 0x0b:\t\t\t// VCLK 0\n    case 0x0c:\t\t\t// VCLK 1\n    case 0x0d:\t\t\t// VCLK 2\n    case 0x0e:\t\t\t// VCLK 3\n    case 0x0f:\t\t\t// DRAM Control\n    case 0x13:\t\t\t// Graphics Cursor Pattern Address\n    case 0x14:\t\t\t// Scratch Register 2\n    case 0x15:\t\t\t// Scratch Register 3\n    case 0x16:\t\t\t// Performance Tuning Register\n    case 0x18:\t\t\t// Signature Generator Control\n    case 0x19:\t\t\t// Signature Generator Result\n    case 0x1a:\t\t\t// Signature Generator Result\n    case 0x1b:\t\t\t// VCLK 0 Denominator & Post\n    case 0x1c:\t\t\t// VCLK 1 Denominator & Post\n    case 0x1d:\t\t\t// VCLK 2 Denominator & Post\n    case 0x1e:\t\t\t// VCLK 3 Denominator & Post\n    case 0x1f:\t\t\t// BIOS Write Enable and MCLK select\n\ts->vga.sr[s->vga.sr_index] = val;\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: handled outport sr_index %02x, sr_value %02x\\n\",\n\t       s->vga.sr_index, val);\n#endif\n\tbreak;\n    case 0x12:\t\t\t// Graphics Cursor Attribute\n\ts->vga.sr[0x12] = val;\n        s->vga.force_shadow = !!(val & CIRRUS_CURSOR_SHOW);\n#ifdef DEBUG_CIRRUS\n        printf(\"cirrus: cursor ctl SR12=%02x (force shadow: %d)\\n\",\n               val, s->vga.force_shadow);\n#endif\n        break;\n    case 0x17:\t\t\t// Configuration Readback and Extended Control\n\ts->vga.sr[s->vga.sr_index] = (s->vga.sr[s->vga.sr_index] & 0x38)\n                                   | (val & 0xc7);\n        cirrus_update_memory_access(s);\n        break;\n    default:\n#ifdef DEBUG_CIRRUS\n\tprintf(\"cirrus: outport sr_index %02x, sr_value %02x\\n\",\n               s->vga.sr_index, val);\n#endif\n\tbreak;\n    }\n}\n",
        "linevul": 4.87697143398691e-05
    },
    {
        "code": "static inline TCGMemOp mo_64_32(TCGMemOp ot)\n{\n#ifdef TARGET_X86_64\n    return ot == MO_64 ? MO_64 : MO_32;\n#else\n    return MO_32;\n#endif\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline TCGMemOp mo_64_32(TCGMemOp ot)\n{\n#ifdef TARGET_X86_64\n    return ot == MO_64 ? MO_64 : MO_32;\n#else\n    return MO_32;\n#endif\n}\n",
        "linevul": 6.773033237550408e-05
    },
    {
        "code": "static int ohci_copy_td(OHCIState *ohci, struct ohci_td *td,\n                        uint8_t *buf, int len, DMADirection dir)\n{\n    dma_addr_t ptr, n;\n\n    ptr = td->cbp;\n    n = 0x1000 - (ptr & 0xfff);\n    if (n > len)\n        n = len;\n\n    if (dma_memory_rw(ohci->as, ptr + ohci->localmem_base, buf, n, dir)) {\n        return -1;\n    }\n    if (n == len) {\n        return 0;\n    }\n    ptr = td->be & ~0xfffu;\n    buf += n;\n    if (dma_memory_rw(ohci->as, ptr + ohci->localmem_base, buf,\n                      len - n, dir)) {\n        return -1;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static int ohci_copy_td(OHCIState *ohci, struct ohci_td *td,\n                        uint8_t *buf, int len, DMADirection dir)\n{\n    dma_addr_t ptr, n;\n\n    ptr = td->cbp;\n    n = 0x1000 - (ptr & 0xfff);\n    if (n > len)\n        n = len;\n\n    if (dma_memory_rw(ohci->as, ptr + ohci->localmem_base, buf, n, dir)) {\n        return -1;\n    }\n    if (n == len) {\n        return 0;\n    }\n    ptr = td->be & ~0xfffu;\n    buf += n;\n    if (dma_memory_rw(ohci->as, ptr + ohci->localmem_base, buf,\n                      len - n, dir)) {\n        return -1;\n    }\n    return 0;\n}\n",
        "linevul": 7.618402014486492e-05
    },
    {
        "code": "void virtio_queue_set_num(VirtIODevice *vdev, int n, int num)\n{\n    /* Don't allow guest to flip queue between existent and\n     * nonexistent states, or to set it to an invalid size.\n     */\n    if (!!num != !!vdev->vq[n].vring.num ||\n        num > VIRTQUEUE_MAX_SIZE ||\n        num < 0) {\n        return;\n    }\n    vdev->vq[n].vring.num = num;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "void virtio_queue_set_num(VirtIODevice *vdev, int n, int num)\n{\n    /* Don't allow guest to flip queue between existent and\n     * nonexistent states, or to set it to an invalid size.\n     */\n    if (!!num != !!vdev->vq[n].vring.num ||\n        num > VIRTQUEUE_MAX_SIZE ||\n        num < 0) {\n        return;\n    }\n    vdev->vq[n].vring.num = num;\n}\n",
        "linevul": 4.804451600648463e-05
    },
    {
        "code": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    /* oid_supported_list is the largest data reply */\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n \n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(resplen);\n\n    if (infobuflen < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "vul_func_with_fix": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    /* oid_supported_list is the largest data reply */\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n//flaw_line_below:\n    if (bufoffs + buflen > length)\n//fix_flaw_line_below:\n//    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n//fix_flaw_line_below:\n//    }\n \n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n    resp->MessageLength = cpu_to_le32(resplen);\n\n    if (infobuflen < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n\n    return 0;\n}\n",
        "linevul": 0.9990010857582092
    },
    {
        "code": "static int iscsi_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    bdi->unallocated_blocks_are_zero = iscsilun->lbprz;\n    bdi->can_write_zeroes_with_unmap = iscsilun->lbprz && iscsilun->lbp.lbpws;\n    bdi->cluster_size = iscsilun->cluster_sectors * BDRV_SECTOR_SIZE;\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static int iscsi_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    bdi->unallocated_blocks_are_zero = iscsilun->lbprz;\n    bdi->can_write_zeroes_with_unmap = iscsilun->lbprz && iscsilun->lbp.lbpws;\n    bdi->cluster_size = iscsilun->cluster_sectors * BDRV_SECTOR_SIZE;\n    return 0;\n}\n",
        "linevul": 6.411469803424552e-05
    },
    {
        "code": "static void virtio_register_types(void)\n{\n    type_register_static(&virtio_gpu_info);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static void virtio_register_types(void)\n{\n    type_register_static(&virtio_gpu_info);\n}\n",
        "linevul": 8.222729957196862e-05
    },
    {
        "code": "int64_t qcow2_alloc_bytes(BlockDriverState *bs, int size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int64_t offset, cluster_offset;\n    int free_in_cluster;\n\n    BLKDBG_EVENT(bs->file, BLKDBG_CLUSTER_ALLOC_BYTES);\n    assert(size > 0 && size <= s->cluster_size);\n    if (s->free_byte_offset == 0) {\n        offset = qcow2_alloc_clusters(bs, s->cluster_size);\n        if (offset < 0) {\n            return offset;\n        }\n        s->free_byte_offset = offset;\n    }\n redo:\n    free_in_cluster = s->cluster_size -\n        offset_into_cluster(s, s->free_byte_offset);\n    if (size <= free_in_cluster) {\n        /* enough space in current cluster */\n        offset = s->free_byte_offset;\n        s->free_byte_offset += size;\n        free_in_cluster -= size;\n        if (free_in_cluster == 0)\n            s->free_byte_offset = 0;\n        if (offset_into_cluster(s, offset) != 0)\n            qcow2_update_cluster_refcount(bs, offset >> s->cluster_bits, 1,\n                                          QCOW2_DISCARD_NEVER);\n    } else {\n        offset = qcow2_alloc_clusters(bs, s->cluster_size);\n        if (offset < 0) {\n            return offset;\n        }\n        cluster_offset = start_of_cluster(s, s->free_byte_offset);\n        if ((cluster_offset + s->cluster_size) == offset) {\n            /* we are lucky: contiguous data */\n            offset = s->free_byte_offset;\n            qcow2_update_cluster_refcount(bs, offset >> s->cluster_bits, 1,\n                                          QCOW2_DISCARD_NEVER);\n            s->free_byte_offset += size;\n        } else {\n            s->free_byte_offset = offset;\n            goto redo;\n        }\n    }\n\n    /* The cluster refcount was incremented, either by qcow2_alloc_clusters()\n     * or explicitly by qcow2_update_cluster_refcount().  Refcount blocks must\n     * be flushed before the caller's L2 table updates.\n     */\n    qcow2_cache_set_dependency(bs, s->l2_table_cache, s->refcount_block_cache);\n    return offset;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": "int64_t qcow2_alloc_bytes(BlockDriverState *bs, int size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int64_t offset, cluster_offset;\n    int free_in_cluster;\n\n    BLKDBG_EVENT(bs->file, BLKDBG_CLUSTER_ALLOC_BYTES);\n    assert(size > 0 && size <= s->cluster_size);\n    if (s->free_byte_offset == 0) {\n        offset = qcow2_alloc_clusters(bs, s->cluster_size);\n        if (offset < 0) {\n            return offset;\n        }\n        s->free_byte_offset = offset;\n    }\n redo:\n    free_in_cluster = s->cluster_size -\n        offset_into_cluster(s, s->free_byte_offset);\n    if (size <= free_in_cluster) {\n        /* enough space in current cluster */\n        offset = s->free_byte_offset;\n        s->free_byte_offset += size;\n        free_in_cluster -= size;\n        if (free_in_cluster == 0)\n            s->free_byte_offset = 0;\n        if (offset_into_cluster(s, offset) != 0)\n            qcow2_update_cluster_refcount(bs, offset >> s->cluster_bits, 1,\n                                          QCOW2_DISCARD_NEVER);\n    } else {\n        offset = qcow2_alloc_clusters(bs, s->cluster_size);\n        if (offset < 0) {\n            return offset;\n        }\n        cluster_offset = start_of_cluster(s, s->free_byte_offset);\n        if ((cluster_offset + s->cluster_size) == offset) {\n            /* we are lucky: contiguous data */\n            offset = s->free_byte_offset;\n            qcow2_update_cluster_refcount(bs, offset >> s->cluster_bits, 1,\n                                          QCOW2_DISCARD_NEVER);\n            s->free_byte_offset += size;\n        } else {\n            s->free_byte_offset = offset;\n            goto redo;\n        }\n    }\n\n    /* The cluster refcount was incremented, either by qcow2_alloc_clusters()\n     * or explicitly by qcow2_update_cluster_refcount().  Refcount blocks must\n     * be flushed before the caller's L2 table updates.\n     */\n    qcow2_cache_set_dependency(bs, s->l2_table_cache, s->refcount_block_cache);\n    return offset;\n}\n",
        "linevul": 8.097404497675598e-05
    },
    {
        "code": "vmxnet3_rx_filter_may_indicate(VMXNET3State *s, const void *data,\n    size_t size)\n{\n    struct eth_header *ehdr = PKT_GET_ETH_HDR(data);\n\n    if (VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_PROMISC)) {\n        return true;\n    }\n\n    if (!vmxnet3_is_registered_vlan(s, data)) {\n        return false;\n    }\n\n    switch (vmxnet_rx_pkt_get_packet_type(s->rx_pkt)) {\n    case ETH_PKT_UCAST:\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_UCAST)) {\n            return false;\n        }\n        if (memcmp(s->conf.macaddr.a, ehdr->h_dest, ETH_ALEN)) {\n            return false;\n        }\n        break;\n\n    case ETH_PKT_BCAST:\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_BCAST)) {\n            return false;\n        }\n        break;\n\n    case ETH_PKT_MCAST:\n        if (VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_ALL_MULTI)) {\n            return true;\n        }\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_MCAST)) {\n            return false;\n        }\n        if (!vmxnet3_is_allowed_mcast_group(s, ehdr->h_dest)) {\n            return false;\n        }\n        break;\n\n    default:\n        g_assert_not_reached();\n    }\n\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484",
        "vul_func_with_fix": "vmxnet3_rx_filter_may_indicate(VMXNET3State *s, const void *data,\n    size_t size)\n{\n    struct eth_header *ehdr = PKT_GET_ETH_HDR(data);\n\n    if (VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_PROMISC)) {\n        return true;\n    }\n\n    if (!vmxnet3_is_registered_vlan(s, data)) {\n        return false;\n    }\n\n    switch (vmxnet_rx_pkt_get_packet_type(s->rx_pkt)) {\n    case ETH_PKT_UCAST:\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_UCAST)) {\n            return false;\n        }\n        if (memcmp(s->conf.macaddr.a, ehdr->h_dest, ETH_ALEN)) {\n            return false;\n        }\n        break;\n\n    case ETH_PKT_BCAST:\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_BCAST)) {\n            return false;\n        }\n        break;\n\n    case ETH_PKT_MCAST:\n        if (VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_ALL_MULTI)) {\n            return true;\n        }\n        if (!VMXNET_FLAG_IS_SET(s->rx_mode, VMXNET3_RXM_MCAST)) {\n            return false;\n        }\n        if (!vmxnet3_is_allowed_mcast_group(s, ehdr->h_dest)) {\n            return false;\n        }\n        break;\n\n    default:\n        g_assert_not_reached();\n    }\n\n    return true;\n}\n",
        "linevul": 5.2443163440329954e-05
    },
    {
        "code": "static int mptsas_process_scsi_io_request(MPTSASState *s,\n                                          MPIMsgSCSIIORequest *scsi_io,\n                                          hwaddr addr)\n{\n    MPTSASRequest *req;\n    MPIMsgSCSIIOReply reply;\n    SCSIDevice *sdev;\n    int status;\n\n    mptsas_fix_scsi_io_endianness(scsi_io);\n\n    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,\n                                         scsi_io->LUN[1], scsi_io->DataLength);\n\n    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,\n                                     scsi_io->LUN, &sdev);\n    if (status) {\n         goto bad;\n     }\n \n    req = g_new(MPTSASRequest, 1);\n     QTAILQ_INSERT_TAIL(&s->pending, req, next);\n     req->scsi_io = *scsi_io;\n     req->dev = s;\n\n    status = mptsas_build_sgl(s, req, addr);\n    if (status) {\n        goto free_bad;\n    }\n\n    if (req->qsg.size < scsi_io->DataLength) {\n        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,\n                                  req->qsg.size);\n        status = MPI_IOCSTATUS_INVALID_SGL;\n        goto free_bad;\n    }\n\n    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,\n                            scsi_io->LUN[1], scsi_io->CDB, req);\n\n    if (req->sreq->cmd.xfer > scsi_io->DataLength) {\n        goto overrun;\n    }\n    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {\n    case MPI_SCSIIO_CONTROL_NODATATRANSFER:\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_WRITE:\n        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_READ:\n        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {\n            goto overrun;\n        }\n        break;\n    }\n\n    if (scsi_req_enqueue(req->sreq)) {\n        scsi_req_continue(req->sreq);\n    }\n    return 0;\n\noverrun:\n    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,\n                               scsi_io->DataLength);\n    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;\nfree_bad:\n    mptsas_free_request(req);\nbad:\n    memset(&reply, 0, sizeof(reply));\n    reply.TargetID          = scsi_io->TargetID;\n    reply.Bus               = scsi_io->Bus;\n    reply.MsgLength         = sizeof(reply) / 4;\n    reply.Function          = scsi_io->Function;\n    reply.CDBLength         = scsi_io->CDBLength;\n    reply.SenseBufferLength = scsi_io->SenseBufferLength;\n    reply.MsgContext        = scsi_io->MsgContext;\n    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;\n    reply.IOCStatus         = status;\n\n    mptsas_fix_scsi_io_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static int mptsas_process_scsi_io_request(MPTSASState *s,\n                                          MPIMsgSCSIIORequest *scsi_io,\n                                          hwaddr addr)\n{\n    MPTSASRequest *req;\n    MPIMsgSCSIIOReply reply;\n    SCSIDevice *sdev;\n    int status;\n\n    mptsas_fix_scsi_io_endianness(scsi_io);\n\n    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,\n                                         scsi_io->LUN[1], scsi_io->DataLength);\n\n    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,\n                                     scsi_io->LUN, &sdev);\n    if (status) {\n         goto bad;\n     }\n \n//flaw_line_below:\n    req = g_new(MPTSASRequest, 1);\n//fix_flaw_line_below:\n//    req = g_new0(MPTSASRequest, 1);\n     QTAILQ_INSERT_TAIL(&s->pending, req, next);\n     req->scsi_io = *scsi_io;\n     req->dev = s;\n\n    status = mptsas_build_sgl(s, req, addr);\n    if (status) {\n        goto free_bad;\n    }\n\n    if (req->qsg.size < scsi_io->DataLength) {\n        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,\n                                  req->qsg.size);\n        status = MPI_IOCSTATUS_INVALID_SGL;\n        goto free_bad;\n    }\n\n    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,\n                            scsi_io->LUN[1], scsi_io->CDB, req);\n\n    if (req->sreq->cmd.xfer > scsi_io->DataLength) {\n        goto overrun;\n    }\n    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {\n    case MPI_SCSIIO_CONTROL_NODATATRANSFER:\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_WRITE:\n        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_READ:\n        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {\n            goto overrun;\n        }\n        break;\n    }\n\n    if (scsi_req_enqueue(req->sreq)) {\n        scsi_req_continue(req->sreq);\n    }\n    return 0;\n\noverrun:\n    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,\n                               scsi_io->DataLength);\n    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;\nfree_bad:\n    mptsas_free_request(req);\nbad:\n    memset(&reply, 0, sizeof(reply));\n    reply.TargetID          = scsi_io->TargetID;\n    reply.Bus               = scsi_io->Bus;\n    reply.MsgLength         = sizeof(reply) / 4;\n    reply.Function          = scsi_io->Function;\n    reply.CDBLength         = scsi_io->CDBLength;\n    reply.SenseBufferLength = scsi_io->SenseBufferLength;\n    reply.MsgContext        = scsi_io->MsgContext;\n    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;\n    reply.IOCStatus         = status;\n\n    mptsas_fix_scsi_io_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n\n    return 0;\n}\n",
        "linevul": 5.439213055069558e-05
    },
    {
        "code": " static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n     int again;\n \n     do {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n\n \n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n             break;\n \n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n             break;\n \n         case EST_ADVANCEQUEUE:\n\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n\n             break;\n         }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1ae3f2f178087711f9591350abad133525ba93f2",
        "vul_func_with_fix": " static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n//fix_flaw_line_below:\n//    int itd_count = 0;\n     int again;\n \n     do {\n        case EST_WAITLISTHEAD:\n            again = ehci_state_waitlisthead(ehci, async);\n            break;\n\n        case EST_FETCHENTRY:\n            again = ehci_state_fetchentry(ehci, async);\n            break;\n\n        case EST_FETCHQH:\n            q = ehci_state_fetchqh(ehci, async);\n            if (q != NULL) {\n                assert(q->async == async);\n                again = 1;\n            } else {\n                again = 0;\n            }\n            break;\n\n \n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n//fix_flaw_line_below:\n//            itd_count++;\n             break;\n \n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n//fix_flaw_line_below:\n//            itd_count++;\n             break;\n \n         case EST_ADVANCEQUEUE:\n\n        case EST_FETCHQTD:\n            assert(q != NULL);\n            again = ehci_state_fetchqtd(q);\n            break;\n\n        case EST_HORIZONTALQH:\n            assert(q != NULL);\n            again = ehci_state_horizqh(q);\n            break;\n\n        case EST_EXECUTE:\n            assert(q != NULL);\n            again = ehci_state_execute(q);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            break;\n\n        case EST_EXECUTING:\n            assert(q != NULL);\n            if (async) {\n                ehci->async_stepdown = 0;\n            }\n            again = ehci_state_executing(q);\n            break;\n\n        case EST_WRITEBACK:\n            assert(q != NULL);\n            again = ehci_state_writeback(q);\n            if (!async) {\n                ehci->periodic_sched_active = PERIODIC_ACTIVE;\n            }\n            break;\n\n        default:\n            fprintf(stderr, \"Bad state!\\n\");\n            again = -1;\n            g_assert_not_reached();\n            break;\n        }\n\n             break;\n         }\n",
        "linevul": 0.9975898265838623
    },
    {
        "code": "static int ehci_state_fetchentry(EHCIState *ehci, int async)\n{\n    int again = 0;\n    uint32_t entry = ehci_get_fetch_addr(ehci, async);\n\n    if (NLPTR_TBIT(entry)) {\n        ehci_set_state(ehci, async, EST_ACTIVE);\n        goto out;\n    }\n\n    /* section 4.8, only QH in async schedule */\n    if (async && (NLPTR_TYPE_GET(entry) != NLPTR_TYPE_QH)) {\n        fprintf(stderr, \"non queue head request in async schedule\\n\");\n        return -1;\n    }\n\n    switch (NLPTR_TYPE_GET(entry)) {\n    case NLPTR_TYPE_QH:\n        ehci_set_state(ehci, async, EST_FETCHQH);\n        again = 1;\n        break;\n\n    case NLPTR_TYPE_ITD:\n        ehci_set_state(ehci, async, EST_FETCHITD);\n        again = 1;\n        break;\n\n    case NLPTR_TYPE_STITD:\n        ehci_set_state(ehci, async, EST_FETCHSITD);\n        again = 1;\n        break;\n\n    default:\n        /* TODO: handle FSTN type */\n        fprintf(stderr, \"FETCHENTRY: entry at %X is of type %d \"\n                \"which is not supported yet\\n\", entry, NLPTR_TYPE_GET(entry));\n        return -1;\n    }\n\nout:\n    return again;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_state_fetchentry(EHCIState *ehci, int async)\n{\n    int again = 0;\n    uint32_t entry = ehci_get_fetch_addr(ehci, async);\n\n    if (NLPTR_TBIT(entry)) {\n        ehci_set_state(ehci, async, EST_ACTIVE);\n        goto out;\n    }\n\n    /* section 4.8, only QH in async schedule */\n    if (async && (NLPTR_TYPE_GET(entry) != NLPTR_TYPE_QH)) {\n        fprintf(stderr, \"non queue head request in async schedule\\n\");\n        return -1;\n    }\n\n    switch (NLPTR_TYPE_GET(entry)) {\n    case NLPTR_TYPE_QH:\n        ehci_set_state(ehci, async, EST_FETCHQH);\n        again = 1;\n        break;\n\n    case NLPTR_TYPE_ITD:\n        ehci_set_state(ehci, async, EST_FETCHITD);\n        again = 1;\n        break;\n\n    case NLPTR_TYPE_STITD:\n        ehci_set_state(ehci, async, EST_FETCHSITD);\n        again = 1;\n        break;\n\n    default:\n        /* TODO: handle FSTN type */\n        fprintf(stderr, \"FETCHENTRY: entry at %X is of type %d \"\n                \"which is not supported yet\\n\", entry, NLPTR_TYPE_GET(entry));\n        return -1;\n    }\n\nout:\n    return again;\n}\n",
        "linevul": 5.175279511604458e-05
    },
    {
        "code": "static uint32_t fdctrl_read (void *opaque, uint32_t reg)\n{\n    FDCtrl *fdctrl = opaque;\n    uint32_t retval;\n\n    reg &= 7;\n    switch (reg) {\n    case FD_REG_SRA:\n        retval = fdctrl_read_statusA(fdctrl);\n        break;\n    case FD_REG_SRB:\n        retval = fdctrl_read_statusB(fdctrl);\n        break;\n    case FD_REG_DOR:\n        retval = fdctrl_read_dor(fdctrl);\n        break;\n    case FD_REG_TDR:\n        retval = fdctrl_read_tape(fdctrl);\n        break;\n    case FD_REG_MSR:\n        retval = fdctrl_read_main_status(fdctrl);\n        break;\n    case FD_REG_FIFO:\n        retval = fdctrl_read_data(fdctrl);\n        break;\n    case FD_REG_DIR:\n        retval = fdctrl_read_dir(fdctrl);\n        break;\n    default:\n        retval = (uint32_t)(-1);\n        break;\n    }\n    FLOPPY_DPRINTF(\"read reg%d: 0x%02x\\n\", reg & 7, retval);\n\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static uint32_t fdctrl_read (void *opaque, uint32_t reg)\n{\n    FDCtrl *fdctrl = opaque;\n    uint32_t retval;\n\n    reg &= 7;\n    switch (reg) {\n    case FD_REG_SRA:\n        retval = fdctrl_read_statusA(fdctrl);\n        break;\n    case FD_REG_SRB:\n        retval = fdctrl_read_statusB(fdctrl);\n        break;\n    case FD_REG_DOR:\n        retval = fdctrl_read_dor(fdctrl);\n        break;\n    case FD_REG_TDR:\n        retval = fdctrl_read_tape(fdctrl);\n        break;\n    case FD_REG_MSR:\n        retval = fdctrl_read_main_status(fdctrl);\n        break;\n    case FD_REG_FIFO:\n        retval = fdctrl_read_data(fdctrl);\n        break;\n    case FD_REG_DIR:\n        retval = fdctrl_read_dir(fdctrl);\n        break;\n    default:\n        retval = (uint32_t)(-1);\n        break;\n    }\n    FLOPPY_DPRINTF(\"read reg%d: 0x%02x\\n\", reg & 7, retval);\n\n    return retval;\n}\n",
        "linevul": 5.702705311705358e-05
    },
    {
        "code": "static void bdrv_dev_change_media_cb(BlockDriverState *bs, bool load)\n{\n    if (bs->dev_ops && bs->dev_ops->change_media_cb) {\n        bool tray_was_closed = !bdrv_dev_is_tray_open(bs);\n        bs->dev_ops->change_media_cb(bs->dev_opaque, load);\n        if (tray_was_closed) {\n            /* tray open */\n            bdrv_emit_qmp_eject_event(bs, true);\n        }\n        if (load) {\n            /* tray close */\n            bdrv_emit_qmp_eject_event(bs, false);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static void bdrv_dev_change_media_cb(BlockDriverState *bs, bool load)\n{\n    if (bs->dev_ops && bs->dev_ops->change_media_cb) {\n        bool tray_was_closed = !bdrv_dev_is_tray_open(bs);\n        bs->dev_ops->change_media_cb(bs->dev_opaque, load);\n        if (tray_was_closed) {\n            /* tray open */\n            bdrv_emit_qmp_eject_event(bs, true);\n        }\n        if (load) {\n            /* tray close */\n            bdrv_emit_qmp_eject_event(bs, false);\n        }\n    }\n}\n",
        "linevul": 5.443550617201254e-05
    },
    {
        "code": "uint32_t pcnet_bcr_readw(PCNetState *s, uint32_t rap)\n{\n    uint32_t val;\n    rap &= 127;\n    switch (rap) {\n    case BCR_LNKST:\n    case BCR_LED1:\n    case BCR_LED2:\n    case BCR_LED3:\n        val = s->bcr[rap] & ~0x8000;\n        val |= (val & 0x017f & s->lnkst) ? 0x8000 : 0;\n        break;\n    default:\n        val = rap < 32 ? s->bcr[rap] : 0;\n        break;\n    }\n#ifdef PCNET_DEBUG_BCR\n    printf(\"pcnet_bcr_readw rap=%d val=0x%04x\\n\", rap, val);\n#endif\n    return val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "uint32_t pcnet_bcr_readw(PCNetState *s, uint32_t rap)\n{\n    uint32_t val;\n    rap &= 127;\n    switch (rap) {\n    case BCR_LNKST:\n    case BCR_LED1:\n    case BCR_LED2:\n    case BCR_LED3:\n        val = s->bcr[rap] & ~0x8000;\n        val |= (val & 0x017f & s->lnkst) ? 0x8000 : 0;\n        break;\n    default:\n        val = rap < 32 ? s->bcr[rap] : 0;\n        break;\n    }\n#ifdef PCNET_DEBUG_BCR\n    printf(\"pcnet_bcr_readw rap=%d val=0x%04x\\n\", rap, val);\n#endif\n    return val;\n}\n",
        "linevul": 5.032744593336247e-05
    },
    {
        "code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n     s->n_blocks = be32_to_cpu(s->n_blocks);\n \n     /* read offsets */\n     offsets_size = s->n_blocks * sizeof(uint64_t);\n     s->offsets = g_malloc(offsets_size);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=509a41bab5306181044b5fff02eadf96d9c8676a",
        "vul_func_with_fix": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n\n    bs->read_only = 1;\n\n    /* read header */\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    if (s->block_size % 512) {\n        error_setg(errp, \"block_size %u must be a multiple of 512\",\n                   s->block_size);\n        return -EINVAL;\n    }\n    if (s->block_size == 0) {\n        error_setg(errp, \"block_size cannot be zero\");\n        return -EINVAL;\n    }\n\n    /* cloop's create_compressed_fs.c warns about block sizes beyond 256 KB but\n     * we can accept more.  Prevent ridiculous values like 4 GB - 1 since we\n     * need a buffer this big.\n     */\n    if (s->block_size > MAX_BLOCK_SIZE) {\n        error_setg(errp, \"block_size %u must be %u MB or less\",\n                   s->block_size,\n                   MAX_BLOCK_SIZE / (1024 * 1024));\n        return -EINVAL;\n    }\n\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n     s->n_blocks = be32_to_cpu(s->n_blocks);\n \n     /* read offsets */\n//fix_flaw_line_below:\n//    if (s->n_blocks > UINT32_MAX / sizeof(uint64_t)) {\n//fix_flaw_line_below:\n//        /* Prevent integer overflow */\n//fix_flaw_line_below:\n//        error_setg(errp, \"n_blocks %u must be %zu or less\",\n//fix_flaw_line_below:\n//                   s->n_blocks,\n//fix_flaw_line_below:\n//                   UINT32_MAX / sizeof(uint64_t));\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     offsets_size = s->n_blocks * sizeof(uint64_t);\n     s->offsets = g_malloc(offsets_size);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n",
        "linevul": 0.5065891146659851
    },
    {
        "code": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n         return;\n     }\n \n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                       res_iovs, att_rb.nr_entries);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=33243031dad02d161225ba99d782616da133f689",
        "vul_func_with_fix": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n         return;\n     }\n \n//flaw_line_below:\n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n//flaw_line_below:\n                                       res_iovs, att_rb.nr_entries);\n//fix_flaw_line_below:\n//    ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,\n//fix_flaw_line_below:\n//                                             res_iovs, att_rb.nr_entries);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    if (ret != 0)\n//fix_flaw_line_below:\n//        virtio_gpu_cleanup_mapping_iov(res_iovs, att_rb.nr_entries);\n }\n",
        "linevul": 0.9835267663002014
    },
    {
        "code": "e1000e_clear_ims_bits(E1000ECore *core, uint32_t bits)\n{\n    trace_e1000e_irq_clear_ims(bits, core->mac[IMS], core->mac[IMS] & ~bits);\n    core->mac[IMS] &= ~bits;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_clear_ims_bits(E1000ECore *core, uint32_t bits)\n{\n    trace_e1000e_irq_clear_ims(bits, core->mac[IMS], core->mac[IMS] & ~bits);\n    core->mac[IMS] &= ~bits;\n}\n",
        "linevul": 6.076788486097939e-05
    },
    {
        "code": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n \n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n \n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a0d1cbdacff5df4ded16b753b38fdd9da6092968",
        "vul_func_with_fix": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n \n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n//fix_flaw_line_below:\n//    if (size > (R_MAX - R_RX_BUF0 - rxbase) * 4) {\n//fix_flaw_line_below:\n//        D(qemu_log(\"ethlite packet is too big, size=%x\\n\", size));\n//fix_flaw_line_below:\n//        return -1;\n//fix_flaw_line_below:\n//    }\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n \n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}\n",
        "linevul": 0.997157096862793
    },
    {
        "code": "static ImageInfoSpecific *qcow2_get_specific_info(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    ImageInfoSpecific *spec_info = g_new(ImageInfoSpecific, 1);\n\n    *spec_info = (ImageInfoSpecific){\n        .kind  = IMAGE_INFO_SPECIFIC_KIND_QCOW2,\n        {\n            .qcow2 = g_new(ImageInfoSpecificQCow2, 1),\n        },\n    };\n    if (s->qcow_version == 2) {\n        *spec_info->qcow2 = (ImageInfoSpecificQCow2){\n            .compat = g_strdup(\"0.10\"),\n        };\n    } else if (s->qcow_version == 3) {\n        *spec_info->qcow2 = (ImageInfoSpecificQCow2){\n            .compat             = g_strdup(\"1.1\"),\n            .lazy_refcounts     = s->compatible_features &\n                                  QCOW2_COMPAT_LAZY_REFCOUNTS,\n            .has_lazy_refcounts = true,\n        };\n    }\n\n    return spec_info;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9",
        "vul_func_with_fix": "static ImageInfoSpecific *qcow2_get_specific_info(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    ImageInfoSpecific *spec_info = g_new(ImageInfoSpecific, 1);\n\n    *spec_info = (ImageInfoSpecific){\n        .kind  = IMAGE_INFO_SPECIFIC_KIND_QCOW2,\n        {\n            .qcow2 = g_new(ImageInfoSpecificQCow2, 1),\n        },\n    };\n    if (s->qcow_version == 2) {\n        *spec_info->qcow2 = (ImageInfoSpecificQCow2){\n            .compat = g_strdup(\"0.10\"),\n        };\n    } else if (s->qcow_version == 3) {\n        *spec_info->qcow2 = (ImageInfoSpecificQCow2){\n            .compat             = g_strdup(\"1.1\"),\n            .lazy_refcounts     = s->compatible_features &\n                                  QCOW2_COMPAT_LAZY_REFCOUNTS,\n            .has_lazy_refcounts = true,\n        };\n    }\n\n    return spec_info;\n}\n",
        "linevul": 5.7989705965155736e-05
    },
    {
        "code": "static int nbd_receive_list(QIOChannel *ioc, const char *want, bool *match,\n                            Error **errp)\n{\n    nbd_opt_reply reply;\n    uint32_t len;\n    uint32_t namelen;\n    char name[NBD_MAX_NAME_SIZE + 1];\n    int error;\n\n    if (nbd_receive_option_reply(ioc, NBD_OPT_LIST, &reply, errp) < 0) {\n        return -1;\n    }\n    error = nbd_handle_reply_err(ioc, &reply, errp);\n    if (error <= 0) {\n        /* The server did not support NBD_OPT_LIST, so set *match on\n         * the assumption that any name will be accepted.  */\n        *match = true;\n        return error;\n    }\n    len = reply.length;\n\n    if (reply.type == NBD_REP_ACK) {\n        if (len != 0) {\n            error_setg(errp, \"length too long for option end\");\n            nbd_send_opt_abort(ioc);\n            return -1;\n        }\n        return 0;\n    } else if (reply.type != NBD_REP_SERVER) {\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n                   reply.type, NBD_REP_SERVER);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n\n    if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n        error_setg(errp, \"incorrect option length %\" PRIu32, len);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n        error_setg(errp, \"failed to read option name length\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    namelen = be32_to_cpu(namelen);\n    len -= sizeof(namelen);\n    if (len < namelen) {\n        error_setg(errp, \"incorrect option name length\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (namelen != strlen(want)) {\n        if (drop_sync(ioc, len) != len) {\n            error_setg(errp, \"failed to skip export name with wrong length\");\n            nbd_send_opt_abort(ioc);\n            return -1;\n        }\n        return 1;\n    }\n\n    assert(namelen < sizeof(name));\n    if (read_sync(ioc, name, namelen) != namelen) {\n        error_setg(errp, \"failed to read export name\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    name[namelen] = '\\0';\n    len -= namelen;\n    if (drop_sync(ioc, len) != len) {\n        error_setg(errp, \"failed to read export description\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (!strcmp(name, want)) {\n        *match = true;\n    }\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "static int nbd_receive_list(QIOChannel *ioc, const char *want, bool *match,\n                            Error **errp)\n{\n    nbd_opt_reply reply;\n    uint32_t len;\n    uint32_t namelen;\n    char name[NBD_MAX_NAME_SIZE + 1];\n    int error;\n\n    if (nbd_receive_option_reply(ioc, NBD_OPT_LIST, &reply, errp) < 0) {\n        return -1;\n    }\n    error = nbd_handle_reply_err(ioc, &reply, errp);\n    if (error <= 0) {\n        /* The server did not support NBD_OPT_LIST, so set *match on\n         * the assumption that any name will be accepted.  */\n        *match = true;\n        return error;\n    }\n    len = reply.length;\n\n    if (reply.type == NBD_REP_ACK) {\n        if (len != 0) {\n            error_setg(errp, \"length too long for option end\");\n            nbd_send_opt_abort(ioc);\n            return -1;\n        }\n        return 0;\n    } else if (reply.type != NBD_REP_SERVER) {\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n                   reply.type, NBD_REP_SERVER);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n\n    if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n        error_setg(errp, \"incorrect option length %\" PRIu32, len);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n        error_setg(errp, \"failed to read option name length\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    namelen = be32_to_cpu(namelen);\n    len -= sizeof(namelen);\n    if (len < namelen) {\n        error_setg(errp, \"incorrect option name length\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (namelen != strlen(want)) {\n        if (drop_sync(ioc, len) != len) {\n            error_setg(errp, \"failed to skip export name with wrong length\");\n            nbd_send_opt_abort(ioc);\n            return -1;\n        }\n        return 1;\n    }\n\n    assert(namelen < sizeof(name));\n    if (read_sync(ioc, name, namelen) != namelen) {\n        error_setg(errp, \"failed to read export name\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    name[namelen] = '\\0';\n    len -= namelen;\n    if (drop_sync(ioc, len) != len) {\n        error_setg(errp, \"failed to read export description\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (!strcmp(name, want)) {\n        *match = true;\n    }\n    return 1;\n}\n",
        "linevul": 0.0001359930174658075
    },
    {
        "code": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n{\n    USBDevice *dev;\n    USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n    ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n            if (len > BUFF_SIZE || pg > 6) {\n                return -1;\n            }\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n             if (off + len > 4096) {\n                 /* transfer crosses page border */\n                 if (pg == 6) {\n                     return -1;  /* avoid page pg + 1 */\n                 }\n                 ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                ehci_raise_irq(ehci, USBSTS_INT);\n            }\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n        }\n    }\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b16c129daf0fed91febbb88de23dae8271c8898a",
        "vul_func_with_fix": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n{\n    USBDevice *dev;\n    USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n    ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n            if (len > BUFF_SIZE || pg > 6) {\n                return -1;\n            }\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n             if (off + len > 4096) {\n                 /* transfer crosses page border */\n                 if (pg == 6) {\n//fix_flaw_line_below:\n//                    qemu_sglist_destroy(&ehci->isgl);\n                     return -1;  /* avoid page pg + 1 */\n                 }\n                 ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                ehci_raise_irq(ehci, USBSTS_INT);\n            }\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n        }\n    }\n    return 0;\n}\n",
        "linevul": 0.3128713071346283
    },
    {
        "code": "set_ctrl(E1000State *s, int index, uint32_t val)\n{\n    /* RST is self clearing */\n    s->mac_reg[CTRL] = val & ~E1000_CTRL_RST;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb",
        "vul_func_with_fix": "set_ctrl(E1000State *s, int index, uint32_t val)\n{\n    /* RST is self clearing */\n    s->mac_reg[CTRL] = val & ~E1000_CTRL_RST;\n}\n",
        "linevul": 4.609832467394881e-05
    },
    {
        "code": "static bool tight_can_send_png_rect(VncState *vs, int w, int h)\n{\n    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {\n        return false;\n     }\n \n     if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n        vs->clientds.pf.bytes_per_pixel == 1) {\n         return false;\n     }\n \n    return true;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static bool tight_can_send_png_rect(VncState *vs, int w, int h)\n{\n    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {\n        return false;\n     }\n \n     if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n//flaw_line_below:\n        vs->clientds.pf.bytes_per_pixel == 1) {\n//fix_flaw_line_below:\n//        vs->client_pf.bytes_per_pixel == 1) {\n         return false;\n     }\n \n    return true;\n}\n",
        "linevul": 0.9972244501113892
    },
    {
        "code": "static int prdt_tbl_entry_size(const AHCI_SG *tbl)\n{\n     return (le32_to_cpu(tbl->flags_size) & AHCI_PRDT_SIZE_MASK) + 1;\n }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static int prdt_tbl_entry_size(const AHCI_SG *tbl)\n{\n     return (le32_to_cpu(tbl->flags_size) & AHCI_PRDT_SIZE_MASK) + 1;\n }\n",
        "linevul": 8.247230289271101e-05
    },
    {
        "code": "virtio_gpu_fill_display_info(VirtIOGPU *g,\n                             struct virtio_gpu_resp_display_info *dpy_info)\n{\n    int i;\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n        if (g->enabled_output_bitmask & (1 << i)) {\n            dpy_info->pmodes[i].enabled = 1;\n            dpy_info->pmodes[i].r.width = g->req_state[i].width;\n            dpy_info->pmodes[i].r.height = g->req_state[i].height;\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "virtio_gpu_fill_display_info(VirtIOGPU *g,\n                             struct virtio_gpu_resp_display_info *dpy_info)\n{\n    int i;\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n        if (g->enabled_output_bitmask & (1 << i)) {\n            dpy_info->pmodes[i].enabled = 1;\n            dpy_info->pmodes[i].r.width = g->req_state[i].width;\n            dpy_info->pmodes[i].r.height = g->req_state[i].height;\n        }\n    }\n}\n",
        "linevul": 4.8028847231762484e-05
    },
    {
        "code": "static int ram_save_page(QEMUFile *f, RAMBlock* block, ram_addr_t offset,\n                         bool last_stage)\n{\n    int bytes_sent;\n    int cont;\n    ram_addr_t current_addr;\n    MemoryRegion *mr = block->mr;\n    uint8_t *p;\n    int ret;\n    bool send_async = true;\n\n    cont = (block == last_sent_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n    p = memory_region_get_ram_ptr(mr) + offset;\n\n    /* In doubt sent page as normal */\n    bytes_sent = -1;\n    ret = ram_control_save_page(f, block->offset,\n                           offset, TARGET_PAGE_SIZE, &bytes_sent);\n\n    XBZRLE_cache_lock();\n\n    current_addr = block->offset + offset;\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n            if (bytes_sent > 0) {\n                acct_info.norm_pages++;\n            } else if (bytes_sent == 0) {\n                acct_info.dup_pages++;\n            }\n        }\n    } else if (is_zero_range(p, TARGET_PAGE_SIZE)) {\n        acct_info.dup_pages++;\n        bytes_sent = save_block_hdr(f, block, offset, cont,\n                                    RAM_SAVE_FLAG_COMPRESS);\n        qemu_put_byte(f, 0);\n        bytes_sent++;\n        /* Must let xbzrle know, otherwise a previous (now 0'd) cached\n         * page would be stale\n         */\n        xbzrle_cache_zero_page(current_addr);\n    } else if (!ram_bulk_stage && migrate_use_xbzrle()) {\n        bytes_sent = save_xbzrle_page(f, &p, current_addr, block,\n                                      offset, cont, last_stage);\n        if (!last_stage) {\n            /* Can't send this cached data async, since the cache page\n             * might get updated before it gets to the wire\n             */\n            send_async = false;\n        }\n    }\n\n    /* XBZRLE overflow or normal page */\n    if (bytes_sent == -1) {\n        bytes_sent = save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n        if (send_async) {\n            qemu_put_buffer_async(f, p, TARGET_PAGE_SIZE);\n        } else {\n            qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n        }\n        bytes_sent += TARGET_PAGE_SIZE;\n        acct_info.norm_pages++;\n    }\n\n    XBZRLE_cache_unlock();\n\n    return bytes_sent;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static int ram_save_page(QEMUFile *f, RAMBlock* block, ram_addr_t offset,\n                         bool last_stage)\n{\n    int bytes_sent;\n    int cont;\n    ram_addr_t current_addr;\n    MemoryRegion *mr = block->mr;\n    uint8_t *p;\n    int ret;\n    bool send_async = true;\n\n    cont = (block == last_sent_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n    p = memory_region_get_ram_ptr(mr) + offset;\n\n    /* In doubt sent page as normal */\n    bytes_sent = -1;\n    ret = ram_control_save_page(f, block->offset,\n                           offset, TARGET_PAGE_SIZE, &bytes_sent);\n\n    XBZRLE_cache_lock();\n\n    current_addr = block->offset + offset;\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n            if (bytes_sent > 0) {\n                acct_info.norm_pages++;\n            } else if (bytes_sent == 0) {\n                acct_info.dup_pages++;\n            }\n        }\n    } else if (is_zero_range(p, TARGET_PAGE_SIZE)) {\n        acct_info.dup_pages++;\n        bytes_sent = save_block_hdr(f, block, offset, cont,\n                                    RAM_SAVE_FLAG_COMPRESS);\n        qemu_put_byte(f, 0);\n        bytes_sent++;\n        /* Must let xbzrle know, otherwise a previous (now 0'd) cached\n         * page would be stale\n         */\n        xbzrle_cache_zero_page(current_addr);\n    } else if (!ram_bulk_stage && migrate_use_xbzrle()) {\n        bytes_sent = save_xbzrle_page(f, &p, current_addr, block,\n                                      offset, cont, last_stage);\n        if (!last_stage) {\n            /* Can't send this cached data async, since the cache page\n             * might get updated before it gets to the wire\n             */\n            send_async = false;\n        }\n    }\n\n    /* XBZRLE overflow or normal page */\n    if (bytes_sent == -1) {\n        bytes_sent = save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n        if (send_async) {\n            qemu_put_buffer_async(f, p, TARGET_PAGE_SIZE);\n        } else {\n            qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n        }\n        bytes_sent += TARGET_PAGE_SIZE;\n        acct_info.norm_pages++;\n    }\n\n    XBZRLE_cache_unlock();\n\n    return bytes_sent;\n}\n",
        "linevul": 6.181360367918387e-05
    },
    {
        "code": "static uint32_t mptsas_reply_post_read(MPTSASState *s)\n{\n    uint32_t ret;\n\n    if (!MPTSAS_FIFO_EMPTY(s, reply_post)) {\n        ret = MPTSAS_FIFO_GET(s, reply_post);\n    } else {\n        ret = -1;\n        s->intr_status &= ~MPI_HIS_REPLY_MESSAGE_INTERRUPT;\n        mptsas_update_interrupt(s);\n    }\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static uint32_t mptsas_reply_post_read(MPTSASState *s)\n{\n    uint32_t ret;\n\n    if (!MPTSAS_FIFO_EMPTY(s, reply_post)) {\n        ret = MPTSAS_FIFO_GET(s, reply_post);\n    } else {\n        ret = -1;\n        s->intr_status &= ~MPI_HIS_REPLY_MESSAGE_INTERRUPT;\n        mptsas_update_interrupt(s);\n    }\n\n    return ret;\n}\n",
        "linevul": 4.741358497994952e-05
    },
    {
        "code": "uint64_t xbzrle_mig_pages_transferred(void)\n{\n    return acct_info.xbzrle_pages;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "uint64_t xbzrle_mig_pages_transferred(void)\n{\n    return acct_info.xbzrle_pages;\n}\n",
        "linevul": 6.376434612320736e-05
    },
    {
        "code": "void virtio_del_queue(VirtIODevice *vdev, int n)\n{\n    if (n < 0 || n >= VIRTIO_QUEUE_MAX) {\n        abort();\n    }\n\n    vdev->vq[n].vring.num = 0;\n    vdev->vq[n].vring.num_default = 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "void virtio_del_queue(VirtIODevice *vdev, int n)\n{\n    if (n < 0 || n >= VIRTIO_QUEUE_MAX) {\n        abort();\n    }\n\n    vdev->vq[n].vring.num = 0;\n    vdev->vq[n].vring.num_default = 0;\n}\n",
        "linevul": 4.532684033620171e-05
    },
    {
        "code": "static int proxy_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    if (dir_path) {\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n        v9fs_path_sprintf(target, \"%s\", name);\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    if (dir_path) {\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n        v9fs_path_sprintf(target, \"%s\", name);\n    }\n    return 0;\n}\n",
        "linevul": 5.273232454783283e-05
    },
    {
        "code": "int64_t qcow2_alloc_clusters(BlockDriverState *bs, int64_t size)\n{\n    int64_t offset;\n    int ret;\n\n    BLKDBG_EVENT(bs->file, BLKDBG_CLUSTER_ALLOC);\n    do {\n        offset = alloc_clusters_noref(bs, size);\n        if (offset < 0) {\n            return offset;\n        }\n\n        ret = update_refcount(bs, offset, size, 1, QCOW2_DISCARD_NEVER);\n    } while (ret == -EAGAIN);\n\n    if (ret < 0) {\n        return ret;\n    }\n\n    return offset;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": "int64_t qcow2_alloc_clusters(BlockDriverState *bs, int64_t size)\n{\n    int64_t offset;\n    int ret;\n\n    BLKDBG_EVENT(bs->file, BLKDBG_CLUSTER_ALLOC);\n    do {\n        offset = alloc_clusters_noref(bs, size);\n        if (offset < 0) {\n            return offset;\n        }\n\n        ret = update_refcount(bs, offset, size, 1, QCOW2_DISCARD_NEVER);\n    } while (ret == -EAGAIN);\n\n    if (ret < 0) {\n        return ret;\n    }\n\n    return offset;\n}\n",
        "linevul": 5.160622458788566e-05
    },
    {
        "code": "static int ahci_state_post_load(void *opaque, int version_id)\n{\n    int i;\n    struct AHCIDevice *ad;\n    AHCIState *s = opaque;\n\n    for (i = 0; i < s->ports; i++) {\n        ad = &s->dev[i];\n        AHCIPortRegs *pr = &ad->port_regs;\n\n        map_page(&ad->lst,\n                 ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n        map_page(&ad->res_fis,\n                 ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n        /*\n         * All pending i/o should be flushed out on a migrate. However,\n         * we might not have cleared the busy_slot since this is done\n         * in a bh. Also, issue i/o against any slots that are pending.\n         */\n        if ((ad->busy_slot != -1) &&\n            !(ad->port.ifs[0].status & (BUSY_STAT|DRQ_STAT))) {\n            pr->cmd_issue &= ~(1 << ad->busy_slot);\n            ad->busy_slot = -1;\n        }\n        check_cmd(s, i);\n    }\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static int ahci_state_post_load(void *opaque, int version_id)\n{\n    int i;\n    struct AHCIDevice *ad;\n    AHCIState *s = opaque;\n\n    for (i = 0; i < s->ports; i++) {\n        ad = &s->dev[i];\n        AHCIPortRegs *pr = &ad->port_regs;\n\n        map_page(&ad->lst,\n                 ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n        map_page(&ad->res_fis,\n                 ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n        /*\n         * All pending i/o should be flushed out on a migrate. However,\n         * we might not have cleared the busy_slot since this is done\n         * in a bh. Also, issue i/o against any slots that are pending.\n         */\n        if ((ad->busy_slot != -1) &&\n            !(ad->port.ifs[0].status & (BUSY_STAT|DRQ_STAT))) {\n            pr->cmd_issue &= ~(1 << ad->busy_slot);\n            ad->busy_slot = -1;\n        }\n        check_cmd(s, i);\n    }\n\n    return 0;\n}\n",
        "linevul": 0.00027377204969525337
    },
    {
        "code": "pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n{\n    uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n\n    if (ready_ptr != mgr->consumed_ptr) {\n        uint32_t next_ready_ptr =\n            mgr->consumed_ptr++ & mgr->txr_len_mask;\n        uint32_t next_ready_page =\n            next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n        uint32_t inpage_idx =\n            next_ready_ptr % PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8",
        "vul_func_with_fix": "pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n{\n    uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n\n    if (ready_ptr != mgr->consumed_ptr) {\n        uint32_t next_ready_ptr =\n            mgr->consumed_ptr++ & mgr->txr_len_mask;\n        uint32_t next_ready_page =\n            next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n        uint32_t inpage_idx =\n            next_ready_ptr % PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n",
        "linevul": 5.5380078265443444e-05
    },
    {
        "code": "BlockDriver *bdrv_find_whitelisted_format(const char *format_name,\n                                          bool read_only)\n{\n    BlockDriver *drv = bdrv_find_format(format_name);\n    return drv && bdrv_is_whitelisted(drv, read_only) ? drv : NULL;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "BlockDriver *bdrv_find_whitelisted_format(const char *format_name,\n                                          bool read_only)\n{\n    BlockDriver *drv = bdrv_find_format(format_name);\n    return drv && bdrv_is_whitelisted(drv, read_only) ? drv : NULL;\n}\n",
        "linevul": 4.9567879614187405e-05
    },
    {
        "code": "hwaddr virtio_queue_get_ring_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "hwaddr virtio_queue_get_ring_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n",
        "linevul": 4.8614154366077855e-05
    },
    {
        "code": "int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *new_snapshot_list = NULL;\n    QCowSnapshot *old_snapshot_list = NULL;\n    QCowSnapshot sn1, *sn = &sn1;\n    int i, ret;\n    uint64_t *l1_table = NULL;\n    int64_t l1_table_offset;\n\n    if (s->nb_snapshots >= QCOW_MAX_SNAPSHOTS) {\n        return -EFBIG;\n    }\n\n    memset(sn, 0, sizeof(*sn));\n\n    /* Generate an ID if it wasn't passed */\n    if (sn_info->id_str[0] == '\\0') {\n        find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n    }\n\n    /* Check that the ID is unique */\n    if (find_snapshot_by_id_and_name(bs, sn_info->id_str, NULL) >= 0) {\n        return -EEXIST;\n    }\n\n    /* Populate sn with passed data */\n    sn->id_str = g_strdup(sn_info->id_str);\n    sn->name = g_strdup(sn_info->name);\n\n    sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n    sn->vm_state_size = sn_info->vm_state_size;\n    sn->date_sec = sn_info->date_sec;\n    sn->date_nsec = sn_info->date_nsec;\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* Allocate the L1 table of the snapshot and copy the current one there. */\n    l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n    if (l1_table_offset < 0) {\n        ret = l1_table_offset;\n        goto fail;\n    }\n\n    sn->l1_table_offset = l1_table_offset;\n    sn->l1_size = s->l1_size;\n\n    l1_table = g_malloc(s->l1_size * sizeof(uint64_t));\n    for(i = 0; i < s->l1_size; i++) {\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n    }\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, sn->l1_table_offset,\n                                        s->l1_size * sizeof(uint64_t));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    ret = bdrv_pwrite(bs->file, sn->l1_table_offset, l1_table,\n                      s->l1_size * sizeof(uint64_t));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    g_free(l1_table);\n    l1_table = NULL;\n\n    /*\n     * Increase the refcounts of all clusters and make sure everything is\n     * stable on disk before updating the snapshot table to contain a pointer\n     * to the new L1 table.\n     */\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* Append the new snapshot to the snapshot list */\n    new_snapshot_list = g_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n    if (s->snapshots) {\n        memcpy(new_snapshot_list, s->snapshots,\n               s->nb_snapshots * sizeof(QCowSnapshot));\n        old_snapshot_list = s->snapshots;\n    }\n    s->snapshots = new_snapshot_list;\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n    ret = qcow2_write_snapshots(bs);\n    if (ret < 0) {\n        g_free(s->snapshots);\n        s->snapshots = old_snapshot_list;\n        s->nb_snapshots--;\n        goto fail;\n    }\n\n    g_free(old_snapshot_list);\n\n    /* The VM state isn't needed any more in the active L1 table; in fact, it\n     * hurts by causing expensive COW for the next snapshot. */\n    qcow2_discard_clusters(bs, qcow2_vm_state_offset(s),\n                           align_offset(sn->vm_state_size, s->cluster_size)\n                                >> BDRV_SECTOR_BITS,\n                           QCOW2_DISCARD_NEVER);\n\n#ifdef DEBUG_ALLOC\n    {\n      BdrvCheckResult result = {0};\n      qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return 0;\n\nfail:\n    g_free(sn->id_str);\n    g_free(sn->name);\n    g_free(l1_table);\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c05e4667be91b46ab42b5a11babf8e84d476cc6b",
        "vul_func_with_fix": "int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *new_snapshot_list = NULL;\n    QCowSnapshot *old_snapshot_list = NULL;\n    QCowSnapshot sn1, *sn = &sn1;\n    int i, ret;\n    uint64_t *l1_table = NULL;\n    int64_t l1_table_offset;\n\n    if (s->nb_snapshots >= QCOW_MAX_SNAPSHOTS) {\n        return -EFBIG;\n    }\n\n    memset(sn, 0, sizeof(*sn));\n\n    /* Generate an ID if it wasn't passed */\n    if (sn_info->id_str[0] == '\\0') {\n        find_new_snapshot_id(bs, sn_info->id_str, sizeof(sn_info->id_str));\n    }\n\n    /* Check that the ID is unique */\n    if (find_snapshot_by_id_and_name(bs, sn_info->id_str, NULL) >= 0) {\n        return -EEXIST;\n    }\n\n    /* Populate sn with passed data */\n    sn->id_str = g_strdup(sn_info->id_str);\n    sn->name = g_strdup(sn_info->name);\n\n    sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n    sn->vm_state_size = sn_info->vm_state_size;\n    sn->date_sec = sn_info->date_sec;\n    sn->date_nsec = sn_info->date_nsec;\n    sn->vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* Allocate the L1 table of the snapshot and copy the current one there. */\n    l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * sizeof(uint64_t));\n    if (l1_table_offset < 0) {\n        ret = l1_table_offset;\n        goto fail;\n    }\n\n    sn->l1_table_offset = l1_table_offset;\n    sn->l1_size = s->l1_size;\n\n    l1_table = g_malloc(s->l1_size * sizeof(uint64_t));\n    for(i = 0; i < s->l1_size; i++) {\n        l1_table[i] = cpu_to_be64(s->l1_table[i]);\n    }\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, sn->l1_table_offset,\n                                        s->l1_size * sizeof(uint64_t));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    ret = bdrv_pwrite(bs->file, sn->l1_table_offset, l1_table,\n                      s->l1_size * sizeof(uint64_t));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    g_free(l1_table);\n    l1_table = NULL;\n\n    /*\n     * Increase the refcounts of all clusters and make sure everything is\n     * stable on disk before updating the snapshot table to contain a pointer\n     * to the new L1 table.\n     */\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 1);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* Append the new snapshot to the snapshot list */\n    new_snapshot_list = g_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n    if (s->snapshots) {\n        memcpy(new_snapshot_list, s->snapshots,\n               s->nb_snapshots * sizeof(QCowSnapshot));\n        old_snapshot_list = s->snapshots;\n    }\n    s->snapshots = new_snapshot_list;\n    s->snapshots[s->nb_snapshots++] = *sn;\n\n    ret = qcow2_write_snapshots(bs);\n    if (ret < 0) {\n        g_free(s->snapshots);\n        s->snapshots = old_snapshot_list;\n        s->nb_snapshots--;\n        goto fail;\n    }\n\n    g_free(old_snapshot_list);\n\n    /* The VM state isn't needed any more in the active L1 table; in fact, it\n     * hurts by causing expensive COW for the next snapshot. */\n    qcow2_discard_clusters(bs, qcow2_vm_state_offset(s),\n                           align_offset(sn->vm_state_size, s->cluster_size)\n                                >> BDRV_SECTOR_BITS,\n                           QCOW2_DISCARD_NEVER);\n\n#ifdef DEBUG_ALLOC\n    {\n      BdrvCheckResult result = {0};\n      qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return 0;\n\nfail:\n    g_free(sn->id_str);\n    g_free(sn->name);\n    g_free(l1_table);\n\n    return ret;\n}\n",
        "linevul": 7.945525430841371e-05
    },
    {
        "code": "static void mptsas_save_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    MPTSASRequest *req = sreq->hba_private;\n    int i;\n\n    qemu_put_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n    qemu_put_be32(f, req->qsg.nsg);\n    for (i = 0; i < req->qsg.nsg; i++) {\n        qemu_put_be64(f, req->qsg.sg[i].base);\n        qemu_put_be64(f, req->qsg.sg[i].len);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static void mptsas_save_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    MPTSASRequest *req = sreq->hba_private;\n    int i;\n\n    qemu_put_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n    qemu_put_be32(f, req->qsg.nsg);\n    for (i = 0; i < req->qsg.nsg; i++) {\n        qemu_put_be64(f, req->qsg.sg[i].base);\n        qemu_put_be64(f, req->qsg.sg[i].len);\n    }\n}\n",
        "linevul": 5.0331378588452935e-05
    },
    {
        "code": "static void tsc210x_save(QEMUFile *f, void *opaque)\n{\n    TSC210xState *s = (TSC210xState *) opaque;\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    int i;\n\n    qemu_put_be16(f, s->x);\n    qemu_put_be16(f, s->y);\n    qemu_put_byte(f, s->pressure);\n\n    qemu_put_byte(f, s->state);\n    qemu_put_byte(f, s->page);\n    qemu_put_byte(f, s->offset);\n    qemu_put_byte(f, s->command);\n\n    qemu_put_byte(f, s->irq);\n    qemu_put_be16s(f, &s->dav);\n\n    timer_put(f, s->timer);\n    qemu_put_byte(f, s->enabled);\n    qemu_put_byte(f, s->host_mode);\n    qemu_put_byte(f, s->function);\n    qemu_put_byte(f, s->nextfunction);\n    qemu_put_byte(f, s->precision);\n    qemu_put_byte(f, s->nextprecision);\n    qemu_put_byte(f, s->filter);\n    qemu_put_byte(f, s->pin_func);\n    qemu_put_byte(f, s->ref);\n    qemu_put_byte(f, s->timing);\n    qemu_put_be32(f, s->noise);\n\n    qemu_put_be16s(f, &s->audio_ctrl1);\n    qemu_put_be16s(f, &s->audio_ctrl2);\n    qemu_put_be16s(f, &s->audio_ctrl3);\n    qemu_put_be16s(f, &s->pll[0]);\n    qemu_put_be16s(f, &s->pll[1]);\n    qemu_put_be16s(f, &s->volume);\n    qemu_put_sbe64(f, (s->volume_change - now));\n    qemu_put_sbe64(f, (s->powerdown - now));\n    qemu_put_byte(f, s->softstep);\n    qemu_put_be16s(f, &s->dac_power);\n\n    for (i = 0; i < 0x14; i ++)\n        qemu_put_be16s(f, &s->filter_data[i]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f",
        "vul_func_with_fix": "static void tsc210x_save(QEMUFile *f, void *opaque)\n{\n    TSC210xState *s = (TSC210xState *) opaque;\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    int i;\n\n    qemu_put_be16(f, s->x);\n    qemu_put_be16(f, s->y);\n    qemu_put_byte(f, s->pressure);\n\n    qemu_put_byte(f, s->state);\n    qemu_put_byte(f, s->page);\n    qemu_put_byte(f, s->offset);\n    qemu_put_byte(f, s->command);\n\n    qemu_put_byte(f, s->irq);\n    qemu_put_be16s(f, &s->dav);\n\n    timer_put(f, s->timer);\n    qemu_put_byte(f, s->enabled);\n    qemu_put_byte(f, s->host_mode);\n    qemu_put_byte(f, s->function);\n    qemu_put_byte(f, s->nextfunction);\n    qemu_put_byte(f, s->precision);\n    qemu_put_byte(f, s->nextprecision);\n    qemu_put_byte(f, s->filter);\n    qemu_put_byte(f, s->pin_func);\n    qemu_put_byte(f, s->ref);\n    qemu_put_byte(f, s->timing);\n    qemu_put_be32(f, s->noise);\n\n    qemu_put_be16s(f, &s->audio_ctrl1);\n    qemu_put_be16s(f, &s->audio_ctrl2);\n    qemu_put_be16s(f, &s->audio_ctrl3);\n    qemu_put_be16s(f, &s->pll[0]);\n    qemu_put_be16s(f, &s->pll[1]);\n    qemu_put_be16s(f, &s->volume);\n    qemu_put_sbe64(f, (s->volume_change - now));\n    qemu_put_sbe64(f, (s->powerdown - now));\n    qemu_put_byte(f, s->softstep);\n    qemu_put_be16s(f, &s->dac_power);\n\n    for (i = 0; i < 0x14; i ++)\n        qemu_put_be16s(f, &s->filter_data[i]);\n}\n",
        "linevul": 0.0006215074099600315
    },
    {
        "code": "static void tsc210x_reset(TSC210xState *s)\n{\n    s->state = 0;\n    s->pin_func = 2;\n    s->enabled = 0;\n    s->busy = 0;\n    s->nextfunction = 0;\n    s->ref = 0;\n    s->timing = 0;\n    s->irq = 0;\n    s->dav = 0;\n\n    s->audio_ctrl1 = 0x0000;\n    s->audio_ctrl2 = 0x4410;\n    s->audio_ctrl3 = 0x0000;\n    s->pll[0] = 0x1004;\n    s->pll[1] = 0x0000;\n    s->pll[2] = 0x1fff;\n    s->volume = 0xffff;\n    s->dac_power = 0x8540;\n    s->softstep = 1;\n    s->volume_change = 0;\n    s->powerdown = 0;\n    s->filter_data[0x00] = 0x6be3;\n    s->filter_data[0x01] = 0x9666;\n    s->filter_data[0x02] = 0x675d;\n    s->filter_data[0x03] = 0x6be3;\n    s->filter_data[0x04] = 0x9666;\n    s->filter_data[0x05] = 0x675d;\n    s->filter_data[0x06] = 0x7d83;\n    s->filter_data[0x07] = 0x84ee;\n    s->filter_data[0x08] = 0x7d83;\n    s->filter_data[0x09] = 0x84ee;\n    s->filter_data[0x0a] = 0x6be3;\n    s->filter_data[0x0b] = 0x9666;\n    s->filter_data[0x0c] = 0x675d;\n    s->filter_data[0x0d] = 0x6be3;\n    s->filter_data[0x0e] = 0x9666;\n    s->filter_data[0x0f] = 0x675d;\n    s->filter_data[0x10] = 0x7d83;\n    s->filter_data[0x11] = 0x84ee;\n    s->filter_data[0x12] = 0x7d83;\n    s->filter_data[0x13] = 0x84ee;\n\n    s->i2s_tx_rate = 0;\n    s->i2s_rx_rate = 0;\n\n    s->kb.scan = 1;\n    s->kb.debounce = 0;\n    s->kb.mask = 0x0000;\n    s->kb.mode = 3;\n    s->kb.intr = 0;\n\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n    qemu_irq_raise(s->kbint);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f",
        "vul_func_with_fix": "static void tsc210x_reset(TSC210xState *s)\n{\n    s->state = 0;\n    s->pin_func = 2;\n    s->enabled = 0;\n    s->busy = 0;\n    s->nextfunction = 0;\n    s->ref = 0;\n    s->timing = 0;\n    s->irq = 0;\n    s->dav = 0;\n\n    s->audio_ctrl1 = 0x0000;\n    s->audio_ctrl2 = 0x4410;\n    s->audio_ctrl3 = 0x0000;\n    s->pll[0] = 0x1004;\n    s->pll[1] = 0x0000;\n    s->pll[2] = 0x1fff;\n    s->volume = 0xffff;\n    s->dac_power = 0x8540;\n    s->softstep = 1;\n    s->volume_change = 0;\n    s->powerdown = 0;\n    s->filter_data[0x00] = 0x6be3;\n    s->filter_data[0x01] = 0x9666;\n    s->filter_data[0x02] = 0x675d;\n    s->filter_data[0x03] = 0x6be3;\n    s->filter_data[0x04] = 0x9666;\n    s->filter_data[0x05] = 0x675d;\n    s->filter_data[0x06] = 0x7d83;\n    s->filter_data[0x07] = 0x84ee;\n    s->filter_data[0x08] = 0x7d83;\n    s->filter_data[0x09] = 0x84ee;\n    s->filter_data[0x0a] = 0x6be3;\n    s->filter_data[0x0b] = 0x9666;\n    s->filter_data[0x0c] = 0x675d;\n    s->filter_data[0x0d] = 0x6be3;\n    s->filter_data[0x0e] = 0x9666;\n    s->filter_data[0x0f] = 0x675d;\n    s->filter_data[0x10] = 0x7d83;\n    s->filter_data[0x11] = 0x84ee;\n    s->filter_data[0x12] = 0x7d83;\n    s->filter_data[0x13] = 0x84ee;\n\n    s->i2s_tx_rate = 0;\n    s->i2s_rx_rate = 0;\n\n    s->kb.scan = 1;\n    s->kb.debounce = 0;\n    s->kb.mask = 0x0000;\n    s->kb.mode = 3;\n    s->kb.intr = 0;\n\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n    qemu_irq_raise(s->kbint);\n}\n",
        "linevul": 4.869711847277358e-05
    },
    {
        "code": "static void xhci_doorbell_write(void *ptr, hwaddr reg,\n                                uint64_t val, unsigned size)\n{\n    XHCIState *xhci = ptr;\n    unsigned int epid, streamid;\n\n    trace_usb_xhci_doorbell_write(reg, val);\n\n    if (!xhci_running(xhci)) {\n        DPRINTF(\"xhci: wrote doorbell while xHC stopped or paused\\n\");\n        return;\n    }\n\n    reg >>= 2;\n\n    if (reg == 0) {\n        if (val == 0) {\n            xhci_process_commands(xhci);\n        } else {\n            DPRINTF(\"xhci: bad doorbell 0 write: 0x%x\\n\",\n                    (uint32_t)val);\n        }\n    } else {\n        epid = val & 0xff;\n        streamid = (val >> 16) & 0xffff;\n        if (reg > xhci->numslots) {\n            DPRINTF(\"xhci: bad doorbell %d\\n\", (int)reg);\n        } else if (epid > 31) {\n            DPRINTF(\"xhci: bad doorbell %d write: 0x%x\\n\",\n                    (int)reg, (uint32_t)val);\n        } else {\n            xhci_kick_ep(xhci, reg, epid, streamid);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_doorbell_write(void *ptr, hwaddr reg,\n                                uint64_t val, unsigned size)\n{\n    XHCIState *xhci = ptr;\n    unsigned int epid, streamid;\n\n    trace_usb_xhci_doorbell_write(reg, val);\n\n    if (!xhci_running(xhci)) {\n        DPRINTF(\"xhci: wrote doorbell while xHC stopped or paused\\n\");\n        return;\n    }\n\n    reg >>= 2;\n\n    if (reg == 0) {\n        if (val == 0) {\n            xhci_process_commands(xhci);\n        } else {\n            DPRINTF(\"xhci: bad doorbell 0 write: 0x%x\\n\",\n                    (uint32_t)val);\n        }\n    } else {\n        epid = val & 0xff;\n        streamid = (val >> 16) & 0xffff;\n        if (reg > xhci->numslots) {\n            DPRINTF(\"xhci: bad doorbell %d\\n\", (int)reg);\n        } else if (epid > 31) {\n            DPRINTF(\"xhci: bad doorbell %d write: 0x%x\\n\",\n                    (int)reg, (uint32_t)val);\n        } else {\n            xhci_kick_ep(xhci, reg, epid, streamid);\n        }\n    }\n}\n",
        "linevul": 8.034349593799561e-05
    },
    {
        "code": "static void coroutine_fn v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static void coroutine_fn v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 7.595841452712193e-05
    },
    {
        "code": " static bool check_solid_tile(VncState *vs, int x, int y, int w, int h,\n                              uint32_t* color, bool samecolor)\n {\n    VncDisplay *vd = vs->vd;\n    switch(vd->server->pf.bytes_per_pixel) {\n     case 4:\n         return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n     case 2:\n    switch(vd->server->pf.bytes_per_pixel) {\n    case 4:\n        return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n    case 2:\n        return check_solid_tile16(vs, x, y, w, h, color, samecolor);\n    default:\n        return check_solid_tile8(vs, x, y, w, h, color, samecolor);\n    }\n}\n\nstatic void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n{\n    int dx, dy, dw, dh;\n    int w_prev;\n    int w_best = 0, h_best = 0;\n\n    w_prev = w;\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n            break;\n        }\n\n        for (dx = x + dw; dx < x + w_prev;) {\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n                break;\n            }\n            dx += dw;\n        }\n\n        w_prev = dx - x;\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n            w_best = w_prev;\n            h_best = dy + dh - y;\n        }\n    }\n\n    *w_ptr = w_best;\n    *h_ptr = h_best;\n}\n\nstatic void extend_solid_area(VncState *vs, int x, int y, int w, int h,\n                              uint32_t color, int *x_ptr, int *y_ptr,\n                              int *w_ptr, int *h_ptr)\n{\n    int cx, cy;\n\n    /* Try to extend the area upwards. */\n    for ( cy = *y_ptr - 1;\n          cy >= y && check_solid_tile(vs, *x_ptr, cy, *w_ptr, 1, &color, true);\n          cy-- );\n    *h_ptr += *y_ptr - (cy + 1);\n    *y_ptr = cy + 1;\n\n    /* ... downwards. */\n    for ( cy = *y_ptr + *h_ptr;\n          cy < y + h &&\n              check_solid_tile(vs, *x_ptr, cy, *w_ptr, 1, &color, true);\n          cy++ );\n    *h_ptr += cy - (*y_ptr + *h_ptr);\n\n    /* ... to the left. */\n    for ( cx = *x_ptr - 1;\n          cx >= x && check_solid_tile(vs, cx, *y_ptr, 1, *h_ptr, &color, true);\n          cx-- );\n    *w_ptr += *x_ptr - (cx + 1);\n    *x_ptr = cx + 1;\n\n    /* ... to the right. */\n    for ( cx = *x_ptr + *w_ptr;\n          cx < x + w &&\n              check_solid_tile(vs, cx, *y_ptr, 1, *h_ptr, &color, true);\n          cx++ );\n    *w_ptr += cx - (*x_ptr + *w_ptr);\n}\n\nstatic int tight_init_stream(VncState *vs, int stream_id,\n                             int level, int strategy)\n{\n    z_streamp zstream = &vs->tight.stream[stream_id];\n\n    if (zstream->opaque == NULL) {\n        int err;\n\n        VNC_DEBUG(\"VNC: TIGHT: initializing zlib stream %d\\n\", stream_id);\n        VNC_DEBUG(\"VNC: TIGHT: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n        zstream->zalloc = vnc_zlib_zalloc;\n        zstream->zfree = vnc_zlib_zfree;\n\n        err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n                           MAX_MEM_LEVEL, strategy);\n\n        if (err != Z_OK) {\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n            return -1;\n        }\n\n        vs->tight.levels[stream_id] = level;\n        zstream->opaque = vs;\n    }\n\n    if (vs->tight.levels[stream_id] != level) {\n        if (deflateParams(zstream, level, strategy) != Z_OK) {\n            return -1;\n        }\n        vs->tight.levels[stream_id] = level;\n    }\n    return 0;\n}\n\nstatic void tight_send_compact_size(VncState *vs, size_t len)\n{\n    int lpc = 0;\n    int bytes = 0;\n    char buf[3] = {0, 0, 0};\n\n    buf[bytes++] = len & 0x7F;\n    if (len > 0x7F) {\n        buf[bytes-1] |= 0x80;\n        buf[bytes++] = (len >> 7) & 0x7F;\n        if (len > 0x3FFF) {\n            buf[bytes-1] |= 0x80;\n            buf[bytes++] = (len >> 14) & 0xFF;\n        }\n    }\n    for (lpc = 0; lpc < bytes; lpc++) {\n        vnc_write_u8(vs, buf[lpc]);\n    }\n}\n\nstatic int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight.stream[stream_id];\n    int previous_out;\n\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight.tight.buffer, vs->tight.tight.offset);\n        return bytes;\n    }\n\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n\n    /* reserve memory in output buffer */\n    buffer_reserve(&vs->tight.zlib, bytes + 64);\n\n    /* set pointers */\n    zstream->next_in = vs->tight.tight.buffer;\n    zstream->avail_in = vs->tight.tight.offset;\n    zstream->next_out = vs->tight.zlib.buffer + vs->tight.zlib.offset;\n    zstream->avail_out = vs->tight.zlib.capacity - vs->tight.zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n\n    /* start encoding */\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n\n    vs->tight.zlib.offset = vs->tight.zlib.capacity - zstream->avail_out;\n    /* ...how much data has actually been produced by deflate() */\n    bytes = previous_out - zstream->avail_out;\n\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight.zlib.buffer, bytes);\n\n    buffer_reset(&vs->tight.zlib);\n\n    return bytes;\n}\n\n/*\n * Subencoding implementations.\n */\nstatic void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)\n \n     buf32 = (uint32_t *)buf;\n \n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n        rshift = vs->clientds.pf.rshift;\n        gshift = vs->clientds.pf.gshift;\n        bshift = vs->clientds.pf.bshift;\n     } else {\n        rshift = 24 - vs->clientds.pf.rshift;\n        gshift = 24 - vs->clientds.pf.gshift;\n        bshift = 24 - vs->clientds.pf.bshift;\n     }\n \n     if (ret) {\n        bshift = 24 - vs->clientds.pf.bshift;\n    }\n\n    if (ret) {\n        *ret = count * 3;\n    }\n\n    while (count--) {\n        pix = *buf32++;\n        *buf++ = (char)(pix >> rshift);\n        *buf++ = (char)(pix >> gshift);\n        *buf++ = (char)(pix >> bshift);\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": " static bool check_solid_tile(VncState *vs, int x, int y, int w, int h,\n                              uint32_t* color, bool samecolor)\n {\n//flaw_line_below:\n    VncDisplay *vd = vs->vd;\n//flaw_line_below:\n\n//flaw_line_below:\n    switch(vd->server->pf.bytes_per_pixel) {\n//fix_flaw_line_below:\n//    switch (VNC_SERVER_FB_BYTES) {\n     case 4:\n         return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n     case 2:\n    switch(vd->server->pf.bytes_per_pixel) {\n    case 4:\n        return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n    case 2:\n        return check_solid_tile16(vs, x, y, w, h, color, samecolor);\n    default:\n        return check_solid_tile8(vs, x, y, w, h, color, samecolor);\n    }\n}\n\nstatic void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n{\n    int dx, dy, dw, dh;\n    int w_prev;\n    int w_best = 0, h_best = 0;\n\n    w_prev = w;\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n            break;\n        }\n\n        for (dx = x + dw; dx < x + w_prev;) {\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n                break;\n            }\n            dx += dw;\n        }\n\n        w_prev = dx - x;\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n            w_best = w_prev;\n            h_best = dy + dh - y;\n        }\n    }\n\n    *w_ptr = w_best;\n    *h_ptr = h_best;\n}\n\nstatic void extend_solid_area(VncState *vs, int x, int y, int w, int h,\n                              uint32_t color, int *x_ptr, int *y_ptr,\n                              int *w_ptr, int *h_ptr)\n{\n    int cx, cy;\n\n    /* Try to extend the area upwards. */\n    for ( cy = *y_ptr - 1;\n          cy >= y && check_solid_tile(vs, *x_ptr, cy, *w_ptr, 1, &color, true);\n          cy-- );\n    *h_ptr += *y_ptr - (cy + 1);\n    *y_ptr = cy + 1;\n\n    /* ... downwards. */\n    for ( cy = *y_ptr + *h_ptr;\n          cy < y + h &&\n              check_solid_tile(vs, *x_ptr, cy, *w_ptr, 1, &color, true);\n          cy++ );\n    *h_ptr += cy - (*y_ptr + *h_ptr);\n\n    /* ... to the left. */\n    for ( cx = *x_ptr - 1;\n          cx >= x && check_solid_tile(vs, cx, *y_ptr, 1, *h_ptr, &color, true);\n          cx-- );\n    *w_ptr += *x_ptr - (cx + 1);\n    *x_ptr = cx + 1;\n\n    /* ... to the right. */\n    for ( cx = *x_ptr + *w_ptr;\n          cx < x + w &&\n              check_solid_tile(vs, cx, *y_ptr, 1, *h_ptr, &color, true);\n          cx++ );\n    *w_ptr += cx - (*x_ptr + *w_ptr);\n}\n\nstatic int tight_init_stream(VncState *vs, int stream_id,\n                             int level, int strategy)\n{\n    z_streamp zstream = &vs->tight.stream[stream_id];\n\n    if (zstream->opaque == NULL) {\n        int err;\n\n        VNC_DEBUG(\"VNC: TIGHT: initializing zlib stream %d\\n\", stream_id);\n        VNC_DEBUG(\"VNC: TIGHT: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n        zstream->zalloc = vnc_zlib_zalloc;\n        zstream->zfree = vnc_zlib_zfree;\n\n        err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n                           MAX_MEM_LEVEL, strategy);\n\n        if (err != Z_OK) {\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n            return -1;\n        }\n\n        vs->tight.levels[stream_id] = level;\n        zstream->opaque = vs;\n    }\n\n    if (vs->tight.levels[stream_id] != level) {\n        if (deflateParams(zstream, level, strategy) != Z_OK) {\n            return -1;\n        }\n        vs->tight.levels[stream_id] = level;\n    }\n    return 0;\n}\n\nstatic void tight_send_compact_size(VncState *vs, size_t len)\n{\n    int lpc = 0;\n    int bytes = 0;\n    char buf[3] = {0, 0, 0};\n\n    buf[bytes++] = len & 0x7F;\n    if (len > 0x7F) {\n        buf[bytes-1] |= 0x80;\n        buf[bytes++] = (len >> 7) & 0x7F;\n        if (len > 0x3FFF) {\n            buf[bytes-1] |= 0x80;\n            buf[bytes++] = (len >> 14) & 0xFF;\n        }\n    }\n    for (lpc = 0; lpc < bytes; lpc++) {\n        vnc_write_u8(vs, buf[lpc]);\n    }\n}\n\nstatic int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight.stream[stream_id];\n    int previous_out;\n\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight.tight.buffer, vs->tight.tight.offset);\n        return bytes;\n    }\n\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n\n    /* reserve memory in output buffer */\n    buffer_reserve(&vs->tight.zlib, bytes + 64);\n\n    /* set pointers */\n    zstream->next_in = vs->tight.tight.buffer;\n    zstream->avail_in = vs->tight.tight.offset;\n    zstream->next_out = vs->tight.zlib.buffer + vs->tight.zlib.offset;\n    zstream->avail_out = vs->tight.zlib.capacity - vs->tight.zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n\n    /* start encoding */\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n\n    vs->tight.zlib.offset = vs->tight.zlib.capacity - zstream->avail_out;\n    /* ...how much data has actually been produced by deflate() */\n    bytes = previous_out - zstream->avail_out;\n\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight.zlib.buffer, bytes);\n\n    buffer_reset(&vs->tight.zlib);\n\n    return bytes;\n}\n\n/*\n * Subencoding implementations.\n */\nstatic void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)\n \n     buf32 = (uint32_t *)buf;\n \n//flaw_line_below:\n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n//flaw_line_below:\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n//flaw_line_below:\n        rshift = vs->clientds.pf.rshift;\n//flaw_line_below:\n        gshift = vs->clientds.pf.gshift;\n//flaw_line_below:\n        bshift = vs->clientds.pf.bshift;\n//fix_flaw_line_below:\n//    if (1 /* FIXME: (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n//fix_flaw_line_below:\n//             (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG) */) {\n//fix_flaw_line_below:\n//        rshift = vs->client_pf.rshift;\n//fix_flaw_line_below:\n//        gshift = vs->client_pf.gshift;\n//fix_flaw_line_below:\n//        bshift = vs->client_pf.bshift;\n     } else {\n//flaw_line_below:\n        rshift = 24 - vs->clientds.pf.rshift;\n//flaw_line_below:\n        gshift = 24 - vs->clientds.pf.gshift;\n//flaw_line_below:\n        bshift = 24 - vs->clientds.pf.bshift;\n//fix_flaw_line_below:\n//        rshift = 24 - vs->client_pf.rshift;\n//fix_flaw_line_below:\n//        gshift = 24 - vs->client_pf.gshift;\n//fix_flaw_line_below:\n//        bshift = 24 - vs->client_pf.bshift;\n     }\n \n     if (ret) {\n        bshift = 24 - vs->clientds.pf.bshift;\n    }\n\n    if (ret) {\n        *ret = count * 3;\n    }\n\n    while (count--) {\n        pix = *buf32++;\n        *buf++ = (char)(pix >> rshift);\n        *buf++ = (char)(pix >> gshift);\n        *buf++ = (char)(pix >> bshift);\n    }\n}\n",
        "linevul": 0.00034683835110627115
    },
    {
        "code": "pvscsi_uninit(PCIDevice *pci_dev)\n{\n    PVSCSIState *s = PVSCSI(pci_dev);\n\n    trace_pvscsi_state(\"uninit\");\n    qemu_bh_delete(s->completion_worker);\n\n    pvscsi_cleanup_msi(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": "pvscsi_uninit(PCIDevice *pci_dev)\n{\n    PVSCSIState *s = PVSCSI(pci_dev);\n\n    trace_pvscsi_state(\"uninit\");\n    qemu_bh_delete(s->completion_worker);\n\n    pvscsi_cleanup_msi(s);\n}\n",
        "linevul": 4.636311132344417e-05
    },
    {
        "code": "static int local_remove(FsContext *ctx, const char *path)\n{\n    struct stat stbuf;\n    char *dirpath = g_path_get_dirname(path);\n    char *name = g_path_get_basename(path);\n    int flags = 0;\n    int dirfd;\n    int err = -1;\n\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    if (dirfd == -1) {\n        goto out;\n    }\n\n    if (fstatat(dirfd, path, &stbuf, AT_SYMLINK_NOFOLLOW) < 0) {\n        goto err_out;\n    }\n\n    if (S_ISDIR(stbuf.st_mode)) {\n        flags |= AT_REMOVEDIR;\n    }\n\n    err = local_unlinkat_common(ctx, dirfd, name, flags);\nerr_out:\n    close_preserve_errno(dirfd);\nout:\n    g_free(name);\n    g_free(dirpath);\n    return err;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_remove(FsContext *ctx, const char *path)\n{\n    struct stat stbuf;\n    char *dirpath = g_path_get_dirname(path);\n    char *name = g_path_get_basename(path);\n    int flags = 0;\n    int dirfd;\n    int err = -1;\n\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    if (dirfd == -1) {\n        goto out;\n    }\n\n    if (fstatat(dirfd, path, &stbuf, AT_SYMLINK_NOFOLLOW) < 0) {\n        goto err_out;\n    }\n\n    if (S_ISDIR(stbuf.st_mode)) {\n        flags |= AT_REMOVEDIR;\n    }\n\n    err = local_unlinkat_common(ctx, dirfd, name, flags);\nerr_out:\n    close_preserve_errno(dirfd);\nout:\n    g_free(name);\n    g_free(dirpath);\n    return err;\n}\n",
        "linevul": 5.9432608395582065e-05
    },
    {
        "code": "static void ahci_write_fis_sdb(AHCIState *s, NCQTransferState *ncq_tfs)\n{\n    AHCIDevice *ad = ncq_tfs->drive;\n    AHCIPortRegs *pr = &ad->port_regs;\n    IDEState *ide_state;\n    SDBFIS *sdb_fis;\n\n    if (!ad->res_fis ||\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n\n    sdb_fis = (SDBFIS *)&ad->res_fis[RES_FIS_SDBFIS];\n    ide_state = &ad->port.ifs[0];\n\n    sdb_fis->type = SATA_FIS_TYPE_SDB;\n    /* Interrupt pending & Notification bit */\n    sdb_fis->flags = 0x40; /* Interrupt bit, always 1 for NCQ */\n    sdb_fis->status = ide_state->status & 0x77;\n    sdb_fis->error = ide_state->error;\n    /* update SAct field in SDB_FIS */\n    sdb_fis->payload = cpu_to_le32(ad->finished);\n\n    /* Update shadow registers (except BSY 0x80 and DRQ 0x08) */\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        (ad->port.ifs[0].status & 0x77) |\n        (pr->tfdata & 0x88);\n    pr->scr_act &= ~ad->finished;\n    ad->finished = 0;\n\n    /* Trigger IRQ if interrupt bit is set (which currently, it always is) */\n    if (sdb_fis->flags & 0x40) {\n        ahci_trigger_irq(s, ad, PORT_IRQ_SDB_FIS);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_write_fis_sdb(AHCIState *s, NCQTransferState *ncq_tfs)\n{\n    AHCIDevice *ad = ncq_tfs->drive;\n    AHCIPortRegs *pr = &ad->port_regs;\n    IDEState *ide_state;\n    SDBFIS *sdb_fis;\n\n    if (!ad->res_fis ||\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n\n    sdb_fis = (SDBFIS *)&ad->res_fis[RES_FIS_SDBFIS];\n    ide_state = &ad->port.ifs[0];\n\n    sdb_fis->type = SATA_FIS_TYPE_SDB;\n    /* Interrupt pending & Notification bit */\n    sdb_fis->flags = 0x40; /* Interrupt bit, always 1 for NCQ */\n    sdb_fis->status = ide_state->status & 0x77;\n    sdb_fis->error = ide_state->error;\n    /* update SAct field in SDB_FIS */\n    sdb_fis->payload = cpu_to_le32(ad->finished);\n\n    /* Update shadow registers (except BSY 0x80 and DRQ 0x08) */\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        (ad->port.ifs[0].status & 0x77) |\n        (pr->tfdata & 0x88);\n    pr->scr_act &= ~ad->finished;\n    ad->finished = 0;\n\n    /* Trigger IRQ if interrupt bit is set (which currently, it always is) */\n    if (sdb_fis->flags & 0x40) {\n        ahci_trigger_irq(s, ad, PORT_IRQ_SDB_FIS);\n    }\n}\n",
        "linevul": 4.9940670578507707e-05
    },
    {
        "code": "virtio_gpu_resource_detach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_detach_backing detach;\n\n    VIRTIO_GPU_FILL_CMD(detach);\n    trace_virtio_gpu_cmd_res_back_detach(detach.resource_id);\n\n    res = virtio_gpu_find_resource(g, detach.resource_id);\n    if (!res || !res->iov) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, detach.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    virtio_gpu_cleanup_mapping(res);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "virtio_gpu_resource_detach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_detach_backing detach;\n\n    VIRTIO_GPU_FILL_CMD(detach);\n    trace_virtio_gpu_cmd_res_back_detach(detach.resource_id);\n\n    res = virtio_gpu_find_resource(g, detach.resource_id);\n    if (!res || !res->iov) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, detach.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    virtio_gpu_cleanup_mapping(res);\n}\n",
        "linevul": 5.233005867921747e-05
    },
    {
        "code": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n//flaw_line_below:\n                              pcic->subsystem_vendor_id,\n//fix_flaw_line_below:\n//                              pcic->class_id, pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n",
        "linevul": 7.44745775591582e-05
    },
    {
        "code": "static int ehci_get_state(EHCIState *s, int async)\n{\n    return async ? s->astate : s->pstate;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_get_state(EHCIState *s, int async)\n{\n    return async ? s->astate : s->pstate;\n}\n",
        "linevul": 4.893155346508138e-05
    },
    {
        "code": "static void pci_ne2000_realize(PCIDevice *pci_dev, Error **errp)\n{\n    PCINE2000State *d = DO_UPCAST(PCINE2000State, dev, pci_dev);\n    NE2000State *s;\n    uint8_t *pci_conf;\n\n    pci_conf = d->dev.config;\n    pci_conf[PCI_INTERRUPT_PIN] = 1; /* interrupt pin A */\n\n    s = &d->ne2000;\n    ne2000_setup_io(s, DEVICE(pci_dev), 0x100);\n    pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->io);\n    s->irq = pci_allocate_irq(&d->dev);\n\n    qemu_macaddr_default_if_unset(&s->c.macaddr);\n    ne2000_reset(s);\n\n    s->nic = qemu_new_nic(&net_ne2000_info, &s->c,\n                          object_get_typename(OBJECT(pci_dev)), pci_dev->qdev.id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->c.macaddr.a);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static void pci_ne2000_realize(PCIDevice *pci_dev, Error **errp)\n{\n    PCINE2000State *d = DO_UPCAST(PCINE2000State, dev, pci_dev);\n    NE2000State *s;\n    uint8_t *pci_conf;\n\n    pci_conf = d->dev.config;\n    pci_conf[PCI_INTERRUPT_PIN] = 1; /* interrupt pin A */\n\n    s = &d->ne2000;\n    ne2000_setup_io(s, DEVICE(pci_dev), 0x100);\n    pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->io);\n    s->irq = pci_allocate_irq(&d->dev);\n\n    qemu_macaddr_default_if_unset(&s->c.macaddr);\n    ne2000_reset(s);\n\n    s->nic = qemu_new_nic(&net_ne2000_info, &s->c,\n                          object_get_typename(OBJECT(pci_dev)), pci_dev->qdev.id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->c.macaddr.a);\n}\n",
        "linevul": 4.8099384002853185e-05
    },
    {
        "code": "static const char *code2name(int keycode)\n{\n    return QKeyCode_lookup[qemu_input_key_number_to_qcode(keycode)];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static const char *code2name(int keycode)\n{\n    return QKeyCode_lookup[qemu_input_key_number_to_qcode(keycode)];\n}\n",
        "linevul": 6.761100667063147e-05
    },
    {
        "code": "static void bmdma_start_dma(IDEDMA *dma, IDEState *s,\n                            BlockCompletionFunc *dma_cb)\n{\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    bm->unit = s->unit;\n    bm->dma_cb = dma_cb;\n    bm->cur_prd_last = 0;\n    bm->cur_prd_addr = 0;\n    bm->cur_prd_len = 0;\n    bm->sector_num = ide_get_sector(s);\n    bm->nsector = s->nsector;\n\n    if (bm->status & BM_STATUS_DMAING) {\n        bm->dma_cb(bmdma_active_if(bm), 0);\n     }\n }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void bmdma_start_dma(IDEDMA *dma, IDEState *s,\n                            BlockCompletionFunc *dma_cb)\n{\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    bm->unit = s->unit;\n    bm->dma_cb = dma_cb;\n    bm->cur_prd_last = 0;\n    bm->cur_prd_addr = 0;\n    bm->cur_prd_len = 0;\n    bm->sector_num = ide_get_sector(s);\n    bm->nsector = s->nsector;\n\n    if (bm->status & BM_STATUS_DMAING) {\n        bm->dma_cb(bmdma_active_if(bm), 0);\n     }\n }\n",
        "linevul": 6.154957372928038e-05
    },
    {
        "code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n\n     s->tracks = le32_to_cpu(ph.tracks);\n \n     s->catalog_size = le32_to_cpu(ph.catalog_entries);\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=afbcc40bee4ef51731102d7d4b499ee12fc182e1",
        "vul_func_with_fix": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n\n     s->tracks = le32_to_cpu(ph.tracks);\n \n     s->catalog_size = le32_to_cpu(ph.catalog_entries);\n//fix_flaw_line_below:\n//    if (s->catalog_size > INT_MAX / 4) {\n//fix_flaw_line_below:\n//        error_setg(errp, \"Catalog too large\");\n//fix_flaw_line_below:\n//        ret = -EFBIG;\n//fix_flaw_line_below:\n//        goto fail;\n//fix_flaw_line_below:\n//    }\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}\n",
        "linevul": 0.0002061602717731148
    },
    {
        "code": "tight_detect_smooth_image24(VncState *vs, int w, int h)\n{\n    int off;\n    int x, y, d, dx;\n    unsigned int c;\n    unsigned int stats[256];\n    int pixels = 0;\n    int pix, left[3];\n    unsigned int errors;\n    unsigned char *buf = vs->tight.tight.buffer;\n\n    /*\n      * If client is big-endian, color samples begin from the second\n      * byte (offset 1) of a 32-bit pixel value.\n      */\n    off = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n \n     memset(stats, 0, sizeof (stats));\n \n    for (y = 0, x = 0; y < h && x < w;) {\n        for (d = 0; d < h - y && d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH;\n             d++) {\n            for (c = 0; c < 3; c++) {\n                left[c] = buf[((y+d)*w+x+d)*4+off+c] & 0xFF;\n            }\n            for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH; dx++) {\n                for (c = 0; c < 3; c++) {\n                    pix = buf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;\n                    stats[abs(pix - left[c])]++;\n                    left[c] = pix;\n                }\n                pixels++;\n            }\n        }\n        if (w > h) {\n            x += h;\n            y = 0;\n        } else {\n            x = 0;\n            y += w;\n        }\n    }\n\n    /* 95% smooth or more ... */\n    if (stats[0] * 33 / pixels >= 95) {\n        return 0;\n    }\n\n    errors = 0;\n    for (c = 1; c < 8; c++) {\n        errors += stats[c] * (c * c);\n        if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n            return 0;\n        }\n    }\n    for (; c < 256; c++) {\n        errors += stats[c] * (c * c);\n    }\n    errors /= (pixels * 3 - stats[0]);\n\n    return errors;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "tight_detect_smooth_image24(VncState *vs, int w, int h)\n{\n    int off;\n    int x, y, d, dx;\n    unsigned int c;\n    unsigned int stats[256];\n    int pixels = 0;\n    int pix, left[3];\n    unsigned int errors;\n    unsigned char *buf = vs->tight.tight.buffer;\n\n    /*\n      * If client is big-endian, color samples begin from the second\n      * byte (offset 1) of a 32-bit pixel value.\n      */\n//flaw_line_below:\n    off = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n//fix_flaw_line_below:\n//    off = vs->client_be;\n \n     memset(stats, 0, sizeof (stats));\n \n    for (y = 0, x = 0; y < h && x < w;) {\n        for (d = 0; d < h - y && d < w - x - VNC_TIGHT_DETECT_SUBROW_WIDTH;\n             d++) {\n            for (c = 0; c < 3; c++) {\n                left[c] = buf[((y+d)*w+x+d)*4+off+c] & 0xFF;\n            }\n            for (dx = 1; dx <= VNC_TIGHT_DETECT_SUBROW_WIDTH; dx++) {\n                for (c = 0; c < 3; c++) {\n                    pix = buf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;\n                    stats[abs(pix - left[c])]++;\n                    left[c] = pix;\n                }\n                pixels++;\n            }\n        }\n        if (w > h) {\n            x += h;\n            y = 0;\n        } else {\n            x = 0;\n            y += w;\n        }\n    }\n\n    /* 95% smooth or more ... */\n    if (stats[0] * 33 / pixels >= 95) {\n        return 0;\n    }\n\n    errors = 0;\n    for (c = 1; c < 8; c++) {\n        errors += stats[c] * (c * c);\n        if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n            return 0;\n        }\n    }\n    for (; c < 256; c++) {\n        errors += stats[c] * (c * c);\n    }\n    errors /= (pixels * 3 - stats[0]);\n\n    return errors;\n}\n",
        "linevul": 0.9980502128601074
    },
    {
        "code": "static bool ga_create_file(const char *path)\n{\n    int fd = open(path, O_CREAT | O_WRONLY, S_IWUSR | S_IRUSR);\n    if (fd == -1) {\n        g_warning(\"unable to open/create file %s: %s\", path, strerror(errno));\n        return false;\n    }\n    close(fd);\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67",
        "vul_func_with_fix": "static bool ga_create_file(const char *path)\n{\n    int fd = open(path, O_CREAT | O_WRONLY, S_IWUSR | S_IRUSR);\n    if (fd == -1) {\n        g_warning(\"unable to open/create file %s: %s\", path, strerror(errno));\n        return false;\n    }\n    close(fd);\n    return true;\n}\n",
        "linevul": 5.514793156180531e-05
    },
    {
        "code": "static int virtio_gpu_save(QEMUFile *f, void *opaque, size_t size,\n                           VMStateField *field, QJSON *vmdesc)\n{\n    VirtIOGPU *g = opaque;\n    struct virtio_gpu_simple_resource *res;\n    int i;\n\n    /* in 2d mode we should never find unprocessed commands here */\n    assert(QTAILQ_EMPTY(&g->cmdq));\n\n    QTAILQ_FOREACH(res, &g->reslist, next) {\n        qemu_put_be32(f, res->resource_id);\n        qemu_put_be32(f, res->width);\n        qemu_put_be32(f, res->height);\n        qemu_put_be32(f, res->format);\n        qemu_put_be32(f, res->iov_cnt);\n        for (i = 0; i < res->iov_cnt; i++) {\n            qemu_put_be64(f, res->addrs[i]);\n            qemu_put_be32(f, res->iov[i].iov_len);\n        }\n        qemu_put_buffer(f, (void *)pixman_image_get_data(res->image),\n                        pixman_image_get_stride(res->image) * res->height);\n    }\n    qemu_put_be32(f, 0); /* end of list */\n\n    vmstate_save_state(f, &vmstate_virtio_gpu_scanouts, g, NULL);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static int virtio_gpu_save(QEMUFile *f, void *opaque, size_t size,\n                           VMStateField *field, QJSON *vmdesc)\n{\n    VirtIOGPU *g = opaque;\n    struct virtio_gpu_simple_resource *res;\n    int i;\n\n    /* in 2d mode we should never find unprocessed commands here */\n    assert(QTAILQ_EMPTY(&g->cmdq));\n\n    QTAILQ_FOREACH(res, &g->reslist, next) {\n        qemu_put_be32(f, res->resource_id);\n        qemu_put_be32(f, res->width);\n        qemu_put_be32(f, res->height);\n        qemu_put_be32(f, res->format);\n        qemu_put_be32(f, res->iov_cnt);\n        for (i = 0; i < res->iov_cnt; i++) {\n            qemu_put_be64(f, res->addrs[i]);\n            qemu_put_be32(f, res->iov[i].iov_len);\n        }\n        qemu_put_buffer(f, (void *)pixman_image_get_data(res->image),\n                        pixman_image_get_stride(res->image) * res->height);\n    }\n    qemu_put_be32(f, 0); /* end of list */\n\n    vmstate_save_state(f, &vmstate_virtio_gpu_scanouts, g, NULL);\n\n    return 0;\n}\n",
        "linevul": 8.238356531364843e-05
    },
    {
        "code": "e1000e_mac_read_clr4(E1000ECore *core, int index)\n{\n    uint32_t ret = core->mac[index];\n\n    core->mac[index] = 0;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_mac_read_clr4(E1000ECore *core, int index)\n{\n    uint32_t ret = core->mac[index];\n\n    core->mac[index] = 0;\n    return ret;\n}\n",
        "linevul": 4.766446363646537e-05
    },
    {
        "code": "static inline int vring_need_event(uint16_t event, uint16_t new, uint16_t old)\n{\n\t/* Note: Xen has similar logic for notification hold-off\n\t * in include/xen/interface/io/ring.h with req_event and req_prod\n\t * corresponding to event_idx + 1 and new respectively.\n\t * Note also that req_event and req_prod in Xen start at 1,\n\t * event indexes in virtio start at 0. */\n\treturn (uint16_t)(new - event - 1) < (uint16_t)(new - old);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "static inline int vring_need_event(uint16_t event, uint16_t new, uint16_t old)\n{\n\t/* Note: Xen has similar logic for notification hold-off\n\t * in include/xen/interface/io/ring.h with req_event and req_prod\n\t * corresponding to event_idx + 1 and new respectively.\n\t * Note also that req_event and req_prod in Xen start at 1,\n\t * event indexes in virtio start at 0. */\n\treturn (uint16_t)(new - event - 1) < (uint16_t)(new - old);\n}\n",
        "linevul": 5.103645889903419e-05
    },
    {
        "code": "static size_t vpack(uint8_t **p_data, const char *fmt, va_list ap1)\n{\n    size_t size = 0;\n    uint8_t *data = NULL;\n\n    if (p_data) {\n        va_list ap2;\n\n        va_copy(ap2, ap1);\n        size = vfill(NULL, 0, fmt, ap2);\n        *p_data = data = g_malloc(size);\n        va_end(ap2);\n    }\n    return vfill(data, size, fmt, ap1);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "static size_t vpack(uint8_t **p_data, const char *fmt, va_list ap1)\n{\n    size_t size = 0;\n    uint8_t *data = NULL;\n\n    if (p_data) {\n        va_list ap2;\n\n        va_copy(ap2, ap1);\n        size = vfill(NULL, 0, fmt, ap2);\n        *p_data = data = g_malloc(size);\n        va_end(ap2);\n    }\n    return vfill(data, size, fmt, ap1);\n}\n",
        "linevul": 6.019511056365445e-05
    },
    {
        "code": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    unsigned int len, i;\n    int ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    const char *opt_overlap_check;\n    int overlap_check_template = 0;\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n\n    if (header.magic != QCOW_MAGIC) {\n        error_setg(errp, \"Image is not in qcow2 format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, errp, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n\n    s->qcow_version = header.version;\n\n    /* Initialise cluster size */\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        error_setg(errp, \"Unsupported cluster size: 2^%i\", header.cluster_bits);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n\n        if (header.header_length < 104) {\n            error_setg(errp, \"qcow2 header too short\");\n            ret = -EINVAL;\n            goto fail;\n        }\n    }\n\n    if (header.header_length > s->cluster_size) {\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (header.backing_file_offset > s->cluster_size) {\n        error_setg(errp, \"Invalid backing file offset\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    }\n\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table, NULL);\n        report_unsupported_feature(bs, errp, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n        g_free(feature_table);\n        goto fail;\n    }\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n        /* Corrupt images may not be written to unless they are being repaired\n         */\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            ret = -EACCES;\n            goto fail;\n        }\n    }\n\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, errp, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n    s->refcount_order = header.refcount_order;\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        error_setg(errp, \"Unsupported encryption method: %i\",\n                   header.crypt_method);\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    }\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n    if (header.refcount_table_clusters > qcow2_max_refcount_clusters(s)) {\n        error_setg(errp, \"Reference count table too large\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n                                s->refcount_table_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* Snapshot table offset/length */\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n        error_setg(errp, \"Too many snapshots\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n                                header.nb_snapshots,\n                                sizeof(QCowSnapshotHeader));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid snapshot table offset\");\n        goto fail;\n     }\n \n     /* read the level 1 table */\n    if (header.l1_size > 0x2000000) {\n        /* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n         error_setg(errp, \"Active L1 table too large\");\n         ret = -EFBIG;\n         goto fail;\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_size = header.l1_size;\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        error_setg(errp, \"Image is too big\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_vm_state_index = l1_vm_state_index;\n\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        error_setg(errp, \"L1 table is too small\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.l1_table_offset,\n                                header.l1_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    s->l1_table_offset = header.l1_table_offset;\n\n\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n        }\n    }\n\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n        &local_err)) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > MIN(1023, s->cluster_size - header.backing_file_offset)) {\n            error_setg(errp, \"Backing file name too long\");\n            ret = -EINVAL;\n            goto fail;\n        }\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n            goto fail;\n        }\n        bs->backing_file[len] = '\\0';\n    }\n\n    /* Internal snapshots */\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n\n    /* Repair image if dirty */\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n\n    opt_overlap_check = qemu_opt_get(opts, \"overlap-check\") ?: \"cached\";\n    if (!strcmp(opt_overlap_check, \"none\")) {\n        overlap_check_template = 0;\n    } else if (!strcmp(opt_overlap_check, \"constant\")) {\n        overlap_check_template = QCOW2_OL_CONSTANT;\n    } else if (!strcmp(opt_overlap_check, \"cached\")) {\n        overlap_check_template = QCOW2_OL_CACHED;\n    } else if (!strcmp(opt_overlap_check, \"all\")) {\n        overlap_check_template = QCOW2_OL_ALL;\n    } else {\n        error_setg(errp, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", opt_overlap_check);\n        qemu_opts_del(opts);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->overlap_check = 0;\n    for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n        /* overlap-check defines a template bitmask, but every flag may be\n         * overwritten through the associated boolean option */\n        s->overlap_check |=\n            qemu_opt_get_bool(opts, overlap_bool_option_names[i],\n                              overlap_check_template & (1 << i)) << i;\n    }\n\n    qemu_opts_del(opts);\n\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        error_setg(errp, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return ret;\n\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    /* else pre-write overlap checks in cache_destroy may crash */\n    s->l1_table = NULL;\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    }\n    if (s->refcount_block_cache) {\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n    }\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVQcowState *s = bs->opaque;\n    unsigned int len, i;\n    int ret = 0;\n    QCowHeader header;\n    QemuOpts *opts;\n    Error *local_err = NULL;\n    uint64_t ext_end;\n    uint64_t l1_vm_state_index;\n    const char *opt_overlap_check;\n    int overlap_check_template = 0;\n\n    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read qcow2 header\");\n        goto fail;\n    }\n    be32_to_cpus(&header.magic);\n    be32_to_cpus(&header.version);\n    be64_to_cpus(&header.backing_file_offset);\n    be32_to_cpus(&header.backing_file_size);\n    be64_to_cpus(&header.size);\n    be32_to_cpus(&header.cluster_bits);\n    be32_to_cpus(&header.crypt_method);\n    be64_to_cpus(&header.l1_table_offset);\n    be32_to_cpus(&header.l1_size);\n    be64_to_cpus(&header.refcount_table_offset);\n    be32_to_cpus(&header.refcount_table_clusters);\n    be64_to_cpus(&header.snapshots_offset);\n    be32_to_cpus(&header.nb_snapshots);\n\n    if (header.magic != QCOW_MAGIC) {\n        error_setg(errp, \"Image is not in qcow2 format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    if (header.version < 2 || header.version > 3) {\n        report_unsupported(bs, errp, \"QCOW version %d\", header.version);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n\n    s->qcow_version = header.version;\n\n    /* Initialise cluster size */\n    if (header.cluster_bits < MIN_CLUSTER_BITS ||\n        header.cluster_bits > MAX_CLUSTER_BITS) {\n        error_setg(errp, \"Unsupported cluster size: 2^%i\", header.cluster_bits);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->cluster_bits = header.cluster_bits;\n    s->cluster_size = 1 << s->cluster_bits;\n    s->cluster_sectors = 1 << (s->cluster_bits - 9);\n\n    /* Initialise version 3 header fields */\n    if (header.version == 2) {\n        header.incompatible_features    = 0;\n        header.compatible_features      = 0;\n        header.autoclear_features       = 0;\n        header.refcount_order           = 4;\n        header.header_length            = 72;\n    } else {\n        be64_to_cpus(&header.incompatible_features);\n        be64_to_cpus(&header.compatible_features);\n        be64_to_cpus(&header.autoclear_features);\n        be32_to_cpus(&header.refcount_order);\n        be32_to_cpus(&header.header_length);\n\n        if (header.header_length < 104) {\n            error_setg(errp, \"qcow2 header too short\");\n            ret = -EINVAL;\n            goto fail;\n        }\n    }\n\n    if (header.header_length > s->cluster_size) {\n        error_setg(errp, \"qcow2 header exceeds cluster size\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.header_length > sizeof(header)) {\n        s->unknown_header_fields_size = header.header_length - sizeof(header);\n        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);\n        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,\n                         s->unknown_header_fields_size);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read unknown qcow2 header \"\n                             \"fields\");\n            goto fail;\n        }\n    }\n\n    if (header.backing_file_offset > s->cluster_size) {\n        error_setg(errp, \"Invalid backing file offset\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    if (header.backing_file_offset) {\n        ext_end = header.backing_file_offset;\n    } else {\n        ext_end = 1 << header.cluster_bits;\n    }\n\n    /* Handle feature bits */\n    s->incompatible_features    = header.incompatible_features;\n    s->compatible_features      = header.compatible_features;\n    s->autoclear_features       = header.autoclear_features;\n\n    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {\n        void *feature_table = NULL;\n        qcow2_read_extensions(bs, header.header_length, ext_end,\n                              &feature_table, NULL);\n        report_unsupported_feature(bs, errp, feature_table,\n                                   s->incompatible_features &\n                                   ~QCOW2_INCOMPAT_MASK);\n        ret = -ENOTSUP;\n        g_free(feature_table);\n        goto fail;\n    }\n\n    if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {\n        /* Corrupt images may not be written to unless they are being repaired\n         */\n        if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {\n            error_setg(errp, \"qcow2: Image is corrupt; cannot be opened \"\n                       \"read/write\");\n            ret = -EACCES;\n            goto fail;\n        }\n    }\n\n    /* Check support for various header values */\n    if (header.refcount_order != 4) {\n        report_unsupported(bs, errp, \"%d bit reference counts\",\n                           1 << header.refcount_order);\n        ret = -ENOTSUP;\n        goto fail;\n    }\n    s->refcount_order = header.refcount_order;\n\n    if (header.crypt_method > QCOW_CRYPT_AES) {\n        error_setg(errp, \"Unsupported encryption method: %i\",\n                   header.crypt_method);\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->crypt_method_header = header.crypt_method;\n    if (s->crypt_method_header) {\n        bs->encrypted = 1;\n    }\n\n    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */\n    s->l2_size = 1 << s->l2_bits;\n    bs->total_sectors = header.size / 512;\n    s->csize_shift = (62 - (s->cluster_bits - 8));\n    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;\n    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;\n\n    s->refcount_table_offset = header.refcount_table_offset;\n    s->refcount_table_size =\n        header.refcount_table_clusters << (s->cluster_bits - 3);\n\n    if (header.refcount_table_clusters > qcow2_max_refcount_clusters(s)) {\n        error_setg(errp, \"Reference count table too large\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, s->refcount_table_offset,\n                                s->refcount_table_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid reference count table offset\");\n        goto fail;\n    }\n\n    /* Snapshot table offset/length */\n    if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {\n        error_setg(errp, \"Too many snapshots\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.snapshots_offset,\n                                header.nb_snapshots,\n                                sizeof(QCowSnapshotHeader));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid snapshot table offset\");\n        goto fail;\n     }\n \n     /* read the level 1 table */\n//flaw_line_below:\n    if (header.l1_size > 0x2000000) {\n//flaw_line_below:\n        /* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n//flaw_line_below:\n         * (128 GB for 512 byte clusters, 2 EB for 2 MB clusters) */\n//fix_flaw_line_below:\n//    if (header.l1_size > QCOW_MAX_L1_SIZE) {\n         error_setg(errp, \"Active L1 table too large\");\n         ret = -EFBIG;\n         goto fail;\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_size = header.l1_size;\n\n    l1_vm_state_index = size_to_l1(s, header.size);\n    if (l1_vm_state_index > INT_MAX) {\n        error_setg(errp, \"Image is too big\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->l1_vm_state_index = l1_vm_state_index;\n\n    /* the L1 table must contain at least enough entries to put\n       header.size bytes */\n    if (s->l1_size < s->l1_vm_state_index) {\n        error_setg(errp, \"L1 table is too small\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    ret = validate_table_offset(bs, header.l1_table_offset,\n                                header.l1_size, sizeof(uint64_t));\n    if (ret < 0) {\n        error_setg(errp, \"Invalid L1 table offset\");\n        goto fail;\n    }\n    s->l1_table_offset = header.l1_table_offset;\n\n\n    if (s->l1_size > 0) {\n        s->l1_table = g_malloc0(\n            align_offset(s->l1_size * sizeof(uint64_t), 512));\n        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,\n                         s->l1_size * sizeof(uint64_t));\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read L1 table\");\n            goto fail;\n        }\n        for(i = 0;i < s->l1_size; i++) {\n            be64_to_cpus(&s->l1_table[i]);\n        }\n    }\n\n    /* alloc L2 table/refcount block cache */\n    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);\n    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);\n\n    s->cluster_cache = g_malloc(s->cluster_size);\n    /* one more sector for decompressed data alignment */\n    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size\n                                  + 512);\n    s->cluster_cache_offset = -1;\n    s->flags = flags;\n\n    ret = qcow2_refcount_init(bs);\n    if (ret != 0) {\n        error_setg_errno(errp, -ret, \"Could not initialize refcount handling\");\n        goto fail;\n    }\n\n    QLIST_INIT(&s->cluster_allocs);\n    QTAILQ_INIT(&s->discards);\n\n    /* read qcow2 extensions */\n    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,\n        &local_err)) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    /* read the backing file name */\n    if (header.backing_file_offset != 0) {\n        len = header.backing_file_size;\n        if (len > MIN(1023, s->cluster_size - header.backing_file_offset)) {\n            error_setg(errp, \"Backing file name too long\");\n            ret = -EINVAL;\n            goto fail;\n        }\n        ret = bdrv_pread(bs->file, header.backing_file_offset,\n                         bs->backing_file, len);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not read backing file name\");\n            goto fail;\n        }\n        bs->backing_file[len] = '\\0';\n    }\n\n    /* Internal snapshots */\n    s->snapshots_offset = header.snapshots_offset;\n    s->nb_snapshots = header.nb_snapshots;\n\n    ret = qcow2_read_snapshots(bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read snapshots\");\n        goto fail;\n    }\n\n    /* Clear unknown autoclear feature bits */\n    if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {\n        s->autoclear_features = 0;\n        ret = qcow2_update_header(bs);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not update qcow2 header\");\n            goto fail;\n        }\n    }\n\n    /* Initialise locks */\n    qemu_co_mutex_init(&s->lock);\n\n    /* Repair image if dirty */\n    if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&\n        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {\n        BdrvCheckResult result = {0};\n\n        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not repair dirty image\");\n            goto fail;\n        }\n    }\n\n    /* Enable lazy_refcounts according to image and command line options */\n    opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,\n        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));\n\n    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n                          flags & BDRV_O_UNMAP);\n    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n    s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n\n    opt_overlap_check = qemu_opt_get(opts, \"overlap-check\") ?: \"cached\";\n    if (!strcmp(opt_overlap_check, \"none\")) {\n        overlap_check_template = 0;\n    } else if (!strcmp(opt_overlap_check, \"constant\")) {\n        overlap_check_template = QCOW2_OL_CONSTANT;\n    } else if (!strcmp(opt_overlap_check, \"cached\")) {\n        overlap_check_template = QCOW2_OL_CACHED;\n    } else if (!strcmp(opt_overlap_check, \"all\")) {\n        overlap_check_template = QCOW2_OL_ALL;\n    } else {\n        error_setg(errp, \"Unsupported value '%s' for qcow2 option \"\n                   \"'overlap-check'. Allowed are either of the following: \"\n                   \"none, constant, cached, all\", opt_overlap_check);\n        qemu_opts_del(opts);\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->overlap_check = 0;\n    for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n        /* overlap-check defines a template bitmask, but every flag may be\n         * overwritten through the associated boolean option */\n        s->overlap_check |=\n            qemu_opt_get_bool(opts, overlap_bool_option_names[i],\n                              overlap_check_template & (1 << i)) << i;\n    }\n\n    qemu_opts_del(opts);\n\n    if (s->use_lazy_refcounts && s->qcow_version < 3) {\n        error_setg(errp, \"Lazy refcounts require a qcow2 image with at least \"\n                   \"qemu 1.1 compatibility level\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n#ifdef DEBUG_ALLOC\n    {\n        BdrvCheckResult result = {0};\n        qcow2_check_refcounts(bs, &result, 0);\n    }\n#endif\n    return ret;\n\n fail:\n    g_free(s->unknown_header_fields);\n    cleanup_unknown_header_ext(bs);\n    qcow2_free_snapshots(bs);\n    qcow2_refcount_close(bs);\n    g_free(s->l1_table);\n    /* else pre-write overlap checks in cache_destroy may crash */\n    s->l1_table = NULL;\n    if (s->l2_table_cache) {\n        qcow2_cache_destroy(bs, s->l2_table_cache);\n    }\n    if (s->refcount_block_cache) {\n        qcow2_cache_destroy(bs, s->refcount_block_cache);\n    }\n    g_free(s->cluster_cache);\n    qemu_vfree(s->cluster_data);\n    return ret;\n}\n",
        "linevul": 0.00021192898566368967
    },
    {
        "code": "static int qcow2_truncate(BlockDriverState *bs, int64_t offset)\n{\n    BDRVQcowState *s = bs->opaque;\n    int64_t new_l1_size;\n    int ret;\n\n    if (offset & 511) {\n        error_report(\"The new size must be a multiple of 512\");\n        return -EINVAL;\n    }\n\n    /* cannot proceed if image has snapshots */\n    if (s->nb_snapshots) {\n        error_report(\"Can't resize an image which has snapshots\");\n        return -ENOTSUP;\n    }\n\n    /* shrinking is currently not supported */\n    if (offset < bs->total_sectors * 512) {\n        error_report(\"qcow2 doesn't support shrinking images yet\");\n        return -ENOTSUP;\n    }\n\n    new_l1_size = size_to_l1(s, offset);\n    ret = qcow2_grow_l1_table(bs, new_l1_size, true);\n    if (ret < 0) {\n        return ret;\n    }\n\n    /* write updated header.size */\n    offset = cpu_to_be64(offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, size),\n                           &offset, sizeof(uint64_t));\n    if (ret < 0) {\n        return ret;\n    }\n\n    s->l1_vm_state_index = new_l1_size;\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static int qcow2_truncate(BlockDriverState *bs, int64_t offset)\n{\n    BDRVQcowState *s = bs->opaque;\n    int64_t new_l1_size;\n    int ret;\n\n    if (offset & 511) {\n        error_report(\"The new size must be a multiple of 512\");\n        return -EINVAL;\n    }\n\n    /* cannot proceed if image has snapshots */\n    if (s->nb_snapshots) {\n        error_report(\"Can't resize an image which has snapshots\");\n        return -ENOTSUP;\n    }\n\n    /* shrinking is currently not supported */\n    if (offset < bs->total_sectors * 512) {\n        error_report(\"qcow2 doesn't support shrinking images yet\");\n        return -ENOTSUP;\n    }\n\n    new_l1_size = size_to_l1(s, offset);\n    ret = qcow2_grow_l1_table(bs, new_l1_size, true);\n    if (ret < 0) {\n        return ret;\n    }\n\n    /* write updated header.size */\n    offset = cpu_to_be64(offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, size),\n                           &offset, sizeof(uint64_t));\n    if (ret < 0) {\n        return ret;\n    }\n\n    s->l1_vm_state_index = new_l1_size;\n    return 0;\n}\n",
        "linevul": 8.338647603522986e-05
    },
    {
        "code": "static void ehci_trace_guest_bug(EHCIState *s, const char *message)\n{\n    trace_usb_ehci_guest_bug(message);\n    fprintf(stderr, \"ehci warning: %s\\n\", message);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_trace_guest_bug(EHCIState *s, const char *message)\n{\n    trace_usb_ehci_guest_bug(message);\n    fprintf(stderr, \"ehci warning: %s\\n\", message);\n}\n",
        "linevul": 4.5643915655091405e-05
    },
    {
        "code": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n    struct mfi_ctrl_info info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    int num_pd_disks = 0;\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n    /*\n     * For some reason the firmware supports\n     * only up to 8 device ports.\n     * Despite supporting a far larger number\n     * of devices for the physical devices.\n     * So just display the first 8 devices\n     * in the device port list, independent\n     * of how many logical devices are actually\n     * present.\n     */\n    info.host.type = MFI_INFO_HOST_PCIE;\n    info.device.type = MFI_INFO_DEV_SAS3G;\n    info.device.port_count = 8;\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks < 8) {\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n            info.device.port_addr[num_pd_disks] =\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n        }\n        num_pd_disks++;\n    }\n\n    memcpy(info.product_name, base_class->product_name, 24);\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n    memcpy(info.image_component[0].name, \"APP\", 3);\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n             base_class->product_version);\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n    info.image_component_count = 1;\n    if (pci_dev->has_rom) {\n        uint8_t biosver[32];\n        uint8_t *ptr;\n \n         ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n         memcpy(biosver, ptr + 0x41, 31);\n         memcpy(info.image_component[1].name, \"BIOS\", 4);\n         memcpy(info.image_component[1].version, biosver,\n                strlen((const char *)biosver));\n    }\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n    info.max_arms = 32;\n    info.max_spans = 8;\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n    info.max_lds = MFI_MAX_LD;\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n    if (!megasas_is_jbod(s))\n        info.lds_present = cpu_to_le16(num_pd_disks);\n    info.pd_present = cpu_to_le16(num_pd_disks);\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n                                   MFI_INFO_HW_MEM |\n                                   MFI_INFO_HW_FLASH);\n    info.memory_size = cpu_to_le16(512);\n    info.nvram_size = cpu_to_le16(32);\n    info.flash_size = cpu_to_le16(16);\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n                               MFI_INFO_LDOPS_IO_POLICY |\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n                               MFI_INFO_LDOPS_READ_POLICY);\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n    info.stripe_sz_ops.min = 3;\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n    info.properties.rebuild_rate = 30;\n    info.properties.patrol_read_rate = 30;\n    info.properties.bgi_rate = 30;\n    info.properties.cc_rate = 30;\n    info.properties.recon_rate = 30;\n    info.properties.cache_flush_interval = 4;\n    info.properties.spinup_drv_cnt = 2;\n    info.properties.spinup_delay = 6;\n    info.properties.ecc_bucket_size = 15;\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.properties.expose_encl_devices = 1;\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n                                       MFI_INFO_PDMIX_SATA |\n                                       MFI_INFO_PDMIX_LD);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n    struct mfi_ctrl_info info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    int num_pd_disks = 0;\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n    /*\n     * For some reason the firmware supports\n     * only up to 8 device ports.\n     * Despite supporting a far larger number\n     * of devices for the physical devices.\n     * So just display the first 8 devices\n     * in the device port list, independent\n     * of how many logical devices are actually\n     * present.\n     */\n    info.host.type = MFI_INFO_HOST_PCIE;\n    info.device.type = MFI_INFO_DEV_SAS3G;\n    info.device.port_count = 8;\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks < 8) {\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n            info.device.port_addr[num_pd_disks] =\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n        }\n        num_pd_disks++;\n    }\n\n    memcpy(info.product_name, base_class->product_name, 24);\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n    memcpy(info.image_component[0].name, \"APP\", 3);\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n             base_class->product_version);\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n    info.image_component_count = 1;\n    if (pci_dev->has_rom) {\n        uint8_t biosver[32];\n        uint8_t *ptr;\n \n         ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n         memcpy(biosver, ptr + 0x41, 31);\n//fix_flaw_line_below:\n//        biosver[31] = 0;\n         memcpy(info.image_component[1].name, \"BIOS\", 4);\n         memcpy(info.image_component[1].version, biosver,\n                strlen((const char *)biosver));\n    }\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n    info.max_arms = 32;\n    info.max_spans = 8;\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n    info.max_lds = MFI_MAX_LD;\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n    if (!megasas_is_jbod(s))\n        info.lds_present = cpu_to_le16(num_pd_disks);\n    info.pd_present = cpu_to_le16(num_pd_disks);\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n                                   MFI_INFO_HW_MEM |\n                                   MFI_INFO_HW_FLASH);\n    info.memory_size = cpu_to_le16(512);\n    info.nvram_size = cpu_to_le16(32);\n    info.flash_size = cpu_to_le16(16);\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n                               MFI_INFO_LDOPS_IO_POLICY |\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n                               MFI_INFO_LDOPS_READ_POLICY);\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n    info.stripe_sz_ops.min = 3;\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n    info.properties.rebuild_rate = 30;\n    info.properties.patrol_read_rate = 30;\n    info.properties.bgi_rate = 30;\n    info.properties.cc_rate = 30;\n    info.properties.recon_rate = 30;\n    info.properties.cache_flush_interval = 4;\n    info.properties.spinup_drv_cnt = 2;\n    info.properties.spinup_delay = 6;\n    info.properties.ecc_bucket_size = 15;\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.properties.expose_encl_devices = 1;\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n                                       MFI_INFO_PDMIX_SATA |\n                                       MFI_INFO_PDMIX_LD);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
        "linevul": 0.8844549655914307
    },
    {
        "code": "void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    IDEBus *bus = opaque;\n\n#ifdef DEBUG_IDE\n    printf(\"IDE: write addr=0x%x val=0x%02x\\n\", addr, val);\n#endif\n\n    addr &= 7;\n\n    /* ignore writes to command block while busy with previous command */\n    if (addr != 7 && (idebus_active_if(bus)->status & (BUSY_STAT|DRQ_STAT)))\n        return;\n\n    switch(addr) {\n    case 0:\n        break;\n    case 1:\n\tide_clear_hob(bus);\n        /* NOTE: data is written to the two drives */\n\tbus->ifs[0].hob_feature = bus->ifs[0].feature;\n\tbus->ifs[1].hob_feature = bus->ifs[1].feature;\n        bus->ifs[0].feature = val;\n        bus->ifs[1].feature = val;\n        break;\n    case 2:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_nsector = bus->ifs[0].nsector;\n\tbus->ifs[1].hob_nsector = bus->ifs[1].nsector;\n        bus->ifs[0].nsector = val;\n        bus->ifs[1].nsector = val;\n        break;\n    case 3:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_sector = bus->ifs[0].sector;\n\tbus->ifs[1].hob_sector = bus->ifs[1].sector;\n        bus->ifs[0].sector = val;\n        bus->ifs[1].sector = val;\n        break;\n    case 4:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_lcyl = bus->ifs[0].lcyl;\n\tbus->ifs[1].hob_lcyl = bus->ifs[1].lcyl;\n        bus->ifs[0].lcyl = val;\n        bus->ifs[1].lcyl = val;\n        break;\n    case 5:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_hcyl = bus->ifs[0].hcyl;\n\tbus->ifs[1].hob_hcyl = bus->ifs[1].hcyl;\n        bus->ifs[0].hcyl = val;\n        bus->ifs[1].hcyl = val;\n        break;\n    case 6:\n\t/* FIXME: HOB readback uses bit 7 */\n        bus->ifs[0].select = (val & ~0x10) | 0xa0;\n        bus->ifs[1].select = (val | 0x10) | 0xa0;\n        /* select drive */\n        bus->unit = (val >> 4) & 1;\n        break;\n    default:\n    case 7:\n        /* command */\n        ide_exec_cmd(bus, val);\n        break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    IDEBus *bus = opaque;\n\n#ifdef DEBUG_IDE\n    printf(\"IDE: write addr=0x%x val=0x%02x\\n\", addr, val);\n#endif\n\n    addr &= 7;\n\n    /* ignore writes to command block while busy with previous command */\n    if (addr != 7 && (idebus_active_if(bus)->status & (BUSY_STAT|DRQ_STAT)))\n        return;\n\n    switch(addr) {\n    case 0:\n        break;\n    case 1:\n\tide_clear_hob(bus);\n        /* NOTE: data is written to the two drives */\n\tbus->ifs[0].hob_feature = bus->ifs[0].feature;\n\tbus->ifs[1].hob_feature = bus->ifs[1].feature;\n        bus->ifs[0].feature = val;\n        bus->ifs[1].feature = val;\n        break;\n    case 2:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_nsector = bus->ifs[0].nsector;\n\tbus->ifs[1].hob_nsector = bus->ifs[1].nsector;\n        bus->ifs[0].nsector = val;\n        bus->ifs[1].nsector = val;\n        break;\n    case 3:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_sector = bus->ifs[0].sector;\n\tbus->ifs[1].hob_sector = bus->ifs[1].sector;\n        bus->ifs[0].sector = val;\n        bus->ifs[1].sector = val;\n        break;\n    case 4:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_lcyl = bus->ifs[0].lcyl;\n\tbus->ifs[1].hob_lcyl = bus->ifs[1].lcyl;\n        bus->ifs[0].lcyl = val;\n        bus->ifs[1].lcyl = val;\n        break;\n    case 5:\n\tide_clear_hob(bus);\n\tbus->ifs[0].hob_hcyl = bus->ifs[0].hcyl;\n\tbus->ifs[1].hob_hcyl = bus->ifs[1].hcyl;\n        bus->ifs[0].hcyl = val;\n        bus->ifs[1].hcyl = val;\n        break;\n    case 6:\n\t/* FIXME: HOB readback uses bit 7 */\n        bus->ifs[0].select = (val & ~0x10) | 0xa0;\n        bus->ifs[1].select = (val | 0x10) | 0xa0;\n        /* select drive */\n        bus->unit = (val >> 4) & 1;\n        break;\n    default:\n    case 7:\n        /* command */\n        ide_exec_cmd(bus, val);\n        break;\n    }\n}\n",
        "linevul": 5.060638432041742e-05
    },
    {
        "code": "static void usb_ehci_pci_realize(PCIDevice *dev, Error **errp)\n{\n    EHCIPCIState *i = PCI_EHCI(dev);\n    EHCIState *s = &i->ehci;\n    uint8_t *pci_conf = dev->config;\n\n    pci_set_byte(&pci_conf[PCI_CLASS_PROG], 0x20);\n\n    /* capabilities pointer */\n    pci_set_byte(&pci_conf[PCI_CAPABILITY_LIST], 0x00);\n    /* pci_set_byte(&pci_conf[PCI_CAPABILITY_LIST], 0x50); */\n\n    pci_set_byte(&pci_conf[PCI_INTERRUPT_PIN], 4); /* interrupt pin D */\n    pci_set_byte(&pci_conf[PCI_MIN_GNT], 0);\n    pci_set_byte(&pci_conf[PCI_MAX_LAT], 0);\n\n    /* pci_conf[0x50] = 0x01; *//* power management caps */\n\n    pci_set_byte(&pci_conf[USB_SBRN], USB_RELEASE_2); /* release # (2.1.4) */\n    pci_set_byte(&pci_conf[0x61], 0x20);  /* frame length adjustment (2.1.5) */\n    pci_set_word(&pci_conf[0x62], 0x00);  /* port wake up capability (2.1.6) */\n\n    pci_conf[0x64] = 0x00;\n    pci_conf[0x65] = 0x00;\n    pci_conf[0x66] = 0x00;\n    pci_conf[0x67] = 0x00;\n    pci_conf[0x68] = 0x01;\n    pci_conf[0x69] = 0x00;\n    pci_conf[0x6a] = 0x00;\n    pci_conf[0x6b] = 0x00;  /* USBLEGSUP */\n    pci_conf[0x6c] = 0x00;\n    pci_conf[0x6d] = 0x00;\n    pci_conf[0x6e] = 0x00;\n    pci_conf[0x6f] = 0xc0;  /* USBLEFCTLSTS */\n\n    s->irq = pci_allocate_irq(dev);\n    s->as = pci_get_address_space(dev);\n\n    usb_ehci_realize(s, DEVICE(dev), NULL);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mem);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void usb_ehci_pci_realize(PCIDevice *dev, Error **errp)\n{\n    EHCIPCIState *i = PCI_EHCI(dev);\n    EHCIState *s = &i->ehci;\n    uint8_t *pci_conf = dev->config;\n\n    pci_set_byte(&pci_conf[PCI_CLASS_PROG], 0x20);\n\n    /* capabilities pointer */\n    pci_set_byte(&pci_conf[PCI_CAPABILITY_LIST], 0x00);\n    /* pci_set_byte(&pci_conf[PCI_CAPABILITY_LIST], 0x50); */\n\n    pci_set_byte(&pci_conf[PCI_INTERRUPT_PIN], 4); /* interrupt pin D */\n    pci_set_byte(&pci_conf[PCI_MIN_GNT], 0);\n    pci_set_byte(&pci_conf[PCI_MAX_LAT], 0);\n\n    /* pci_conf[0x50] = 0x01; *//* power management caps */\n\n    pci_set_byte(&pci_conf[USB_SBRN], USB_RELEASE_2); /* release # (2.1.4) */\n    pci_set_byte(&pci_conf[0x61], 0x20);  /* frame length adjustment (2.1.5) */\n    pci_set_word(&pci_conf[0x62], 0x00);  /* port wake up capability (2.1.6) */\n\n    pci_conf[0x64] = 0x00;\n    pci_conf[0x65] = 0x00;\n    pci_conf[0x66] = 0x00;\n    pci_conf[0x67] = 0x00;\n    pci_conf[0x68] = 0x01;\n    pci_conf[0x69] = 0x00;\n    pci_conf[0x6a] = 0x00;\n    pci_conf[0x6b] = 0x00;  /* USBLEGSUP */\n    pci_conf[0x6c] = 0x00;\n    pci_conf[0x6d] = 0x00;\n    pci_conf[0x6e] = 0x00;\n    pci_conf[0x6f] = 0xc0;  /* USBLEFCTLSTS */\n\n    s->irq = pci_allocate_irq(dev);\n    s->as = pci_get_address_space(dev);\n\n    usb_ehci_realize(s, DEVICE(dev), NULL);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mem);\n}\n",
        "linevul": 4.7745255869813263e-05
    },
    {
        "code": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ab0359a8ae182a7ac5c99609667273167703fab",
        "vul_func_with_fix": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n//fix_flaw_line_below:\n//    ncq_tfs->used = 0;\n }\n",
        "linevul": 0.13193024694919586
    },
    {
        "code": "static bool blit_region_is_unsafe(struct CirrusVGAState *s,\n                                  int32_t pitch, int32_t addr)\n{\n    if (pitch < 0) {\n        int64_t min = addr\n            + ((int64_t)s->cirrus_blt_height-1) * pitch;\n        int32_t max = addr\n            + s->cirrus_blt_width;\n        if (min < 0 || max >= s->vga.vram_size) {\n            return true;\n        }\n    } else {\n        int64_t max = addr\n            + ((int64_t)s->cirrus_blt_height-1) * pitch\n            + s->cirrus_blt_width;\n        if (max >= s->vga.vram_size) {\n            return true;\n        }\n    }\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static bool blit_region_is_unsafe(struct CirrusVGAState *s,\n                                  int32_t pitch, int32_t addr)\n{\n    if (pitch < 0) {\n        int64_t min = addr\n            + ((int64_t)s->cirrus_blt_height-1) * pitch;\n        int32_t max = addr\n            + s->cirrus_blt_width;\n        if (min < 0 || max >= s->vga.vram_size) {\n            return true;\n        }\n    } else {\n        int64_t max = addr\n            + ((int64_t)s->cirrus_blt_height-1) * pitch\n            + s->cirrus_blt_width;\n        if (max >= s->vga.vram_size) {\n            return true;\n        }\n    }\n    return false;\n}\n",
        "linevul": 5.02659531775862e-05
    },
    {
        "code": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n         v9fs_path_sprintf(target, \"%s\", name);\n     }\n     return 0;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n//flaw_line_below:\n    } else {\n//fix_flaw_line_below:\n//    } else if (strcmp(name, \"/\")) {\n         v9fs_path_sprintf(target, \"%s\", name);\n//fix_flaw_line_below:\n//    } else {\n//fix_flaw_line_below:\n//        /* We want the path of the export root to be relative, otherwise\n//fix_flaw_line_below:\n//         * \"*at()\" syscalls would treat it as \"/\" in the host.\n//fix_flaw_line_below:\n//         */\n//fix_flaw_line_below:\n//        v9fs_path_sprintf(target, \"%s\", \".\");\n     }\n     return 0;\n }\n",
        "linevul": 0.02069607935845852
    },
    {
        "code": "static void scsi_write_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n     uint32_t n;\n \n     if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n         }\n     }\n \n    n = r->iov.iov_len / 512;\n     r->sector += n;\n     r->sector_count -= n;\n     if (r->sector_count == 0) {\n         scsi_req_complete(&r->req, GOOD);\n     } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n     }\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": "static void scsi_write_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n//flaw_line_below:\n    uint32_t len;\n     uint32_t n;\n \n     if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n         }\n     }\n \n//flaw_line_below:\n    n = r->iov.iov_len / 512;\n//fix_flaw_line_below:\n//    n = r->qiov.size / 512;\n     r->sector += n;\n     r->sector_count -= n;\n     if (r->sector_count == 0) {\n         scsi_req_complete(&r->req, GOOD);\n     } else {\n//flaw_line_below:\n        len = r->sector_count * 512;\n//flaw_line_below:\n        if (len > SCSI_DMA_BUF_SIZE) {\n//flaw_line_below:\n            len = SCSI_DMA_BUF_SIZE;\n//flaw_line_below:\n        }\n//flaw_line_below:\n        r->iov.iov_len = len;\n//flaw_line_below:\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n//flaw_line_below:\n        scsi_req_data(&r->req, len);\n//fix_flaw_line_below:\n//        scsi_init_iovec(r);\n//fix_flaw_line_below:\n//        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, r->qiov.size);\n//fix_flaw_line_below:\n//        scsi_req_data(&r->req, r->qiov.size);\n     }\n }\n",
        "linevul": 0.9967549443244934
    },
    {
        "code": "static void msix_fire_vector_notifier(PCIDevice *dev,\n                                      unsigned int vector, bool is_masked)\n{\n    MSIMessage msg;\n    int ret;\n\n    if (!dev->msix_vector_use_notifier) {\n        return;\n    }\n    if (is_masked) {\n        dev->msix_vector_release_notifier(dev, vector);\n    } else {\n        msg = msix_get_message(dev, vector);\n        ret = dev->msix_vector_use_notifier(dev, vector, msg);\n        assert(ret >= 0);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285",
        "vul_func_with_fix": "static void msix_fire_vector_notifier(PCIDevice *dev,\n                                      unsigned int vector, bool is_masked)\n{\n    MSIMessage msg;\n    int ret;\n\n    if (!dev->msix_vector_use_notifier) {\n        return;\n    }\n    if (is_masked) {\n        dev->msix_vector_release_notifier(dev, vector);\n    } else {\n        msg = msix_get_message(dev, vector);\n        ret = dev->msix_vector_use_notifier(dev, vector, msg);\n        assert(ret >= 0);\n    }\n}\n",
        "linevul": 4.708538108388893e-05
    },
    {
        "code": "int vnc_zywrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    vs->zrle.type = VNC_ENCODING_ZYWRLE;\n    return zrle_send_framebuffer_update(vs, x, y, w, h);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "int vnc_zywrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    vs->zrle.type = VNC_ENCODING_ZYWRLE;\n    return zrle_send_framebuffer_update(vs, x, y, w, h);\n}\n",
        "linevul": 4.5225977373775095e-05
    },
    {
        "code": "static void coroutine_fn v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n     offset = 7;\n     err = pdu_marshal(pdu, offset, \"d\", total);\n     if (err < 0) {\n        goto out;\n     }\n     err += offset;\n     trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdfcc9aeea1492f4b819a24c94dfb678145b1bf9",
        "vul_func_with_fix": "static void coroutine_fn v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n     offset = 7;\n     err = pdu_marshal(pdu, offset, \"d\", total);\n     if (err < 0) {\n//flaw_line_below:\n        goto out;\n//fix_flaw_line_below:\n//        goto out_qiov;\n     }\n     err += offset;\n     trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.0003289544547442347
    },
    {
        "code": " static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n                                         int w, int h)\n {\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n     size_t bytes;\n     int zywrle_level;\n \n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n        if (!vs->vd->lossy || vs->tight.quality == (uint8_t)-1\n            || vs->tight.quality == 9) {\n            zywrle_level = 0;\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n        } else if (vs->tight.quality < 3) {\n            zywrle_level = 3;\n        } else if (vs->tight.quality < 6) {\n            zywrle_level = 2;\n        } else {\n            zywrle_level = 1;\n        }\n    } else {\n        zywrle_level = 0;\n    }\n \n     vnc_zrle_start(vs);\n \n    switch(vs->clientds.pf.bytes_per_pixel) {\n     case 1:\n         zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n         break;\n \n     case 2:\n        if (vs->clientds.pf.gmax > 0x1F) {\n             if (be) {\n                 zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n             } else {\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n        break;\n\n    case 4:\n    {\n        bool fits_in_ls3bytes;\n         bool fits_in_ms3bytes;\n \n         fits_in_ls3bytes =\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n \n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n                            vs->clientds.pf.gshift > 7 &&\n                            vs->clientds.pf.bshift > 7);\n \n         if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n             if (be) {\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n          }\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n            if (be) {\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n    }\n    break;\n    }\n\n    vnc_zrle_stop(vs);\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n    vnc_write_u32(vs, bytes);\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n    return 1;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": " static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n                                         int w, int h)\n {\n//flaw_line_below:\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n//fix_flaw_line_below:\n//    bool be = vs->client_be;\n     size_t bytes;\n     int zywrle_level;\n \n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n        if (!vs->vd->lossy || vs->tight.quality == (uint8_t)-1\n            || vs->tight.quality == 9) {\n            zywrle_level = 0;\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n        } else if (vs->tight.quality < 3) {\n            zywrle_level = 3;\n        } else if (vs->tight.quality < 6) {\n            zywrle_level = 2;\n        } else {\n            zywrle_level = 1;\n        }\n    } else {\n        zywrle_level = 0;\n    }\n \n     vnc_zrle_start(vs);\n \n//flaw_line_below:\n    switch(vs->clientds.pf.bytes_per_pixel) {\n//fix_flaw_line_below:\n//    switch (vs->client_pf.bytes_per_pixel) {\n     case 1:\n         zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n         break;\n \n     case 2:\n//flaw_line_below:\n        if (vs->clientds.pf.gmax > 0x1F) {\n//fix_flaw_line_below:\n//        if (vs->client_pf.gmax > 0x1F) {\n             if (be) {\n                 zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n             } else {\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n        break;\n\n    case 4:\n    {\n        bool fits_in_ls3bytes;\n         bool fits_in_ms3bytes;\n \n         fits_in_ls3bytes =\n//flaw_line_below:\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n//flaw_line_below:\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n//flaw_line_below:\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n//fix_flaw_line_below:\n//            ((vs->client_pf.rmax << vs->client_pf.rshift) < (1 << 24) &&\n//fix_flaw_line_below:\n//             (vs->client_pf.gmax << vs->client_pf.gshift) < (1 << 24) &&\n//fix_flaw_line_below:\n//             (vs->client_pf.bmax << vs->client_pf.bshift) < (1 << 24));\n \n//flaw_line_below:\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n//flaw_line_below:\n                            vs->clientds.pf.gshift > 7 &&\n//flaw_line_below:\n                            vs->clientds.pf.bshift > 7);\n//fix_flaw_line_below:\n//        fits_in_ms3bytes = (vs->client_pf.rshift > 7 &&\n//fix_flaw_line_below:\n//                            vs->client_pf.gshift > 7 &&\n//fix_flaw_line_below:\n//                            vs->client_pf.bshift > 7);\n \n         if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n             if (be) {\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n          }\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n            if (be) {\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n    }\n    break;\n    }\n\n    vnc_zrle_stop(vs);\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n    vnc_write_u32(vs, bytes);\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n    return 1;\n}\n",
        "linevul": 0.9980971217155457
    },
    {
        "code": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t *l1_table = NULL;\n    uint64_t nb_clusters;\n    uint8_t *expanded_clusters;\n    int ret;\n    int i, j;\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n                                   BDRV_SECTOR_SIZE);\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n                                     &expanded_clusters, &nb_clusters);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n     * necessary to flush the L2 table cache before trying to access the L2\n     * tables pointed to by inactive L1 entries (else we might try to expand\n     * zero clusters that have already been expanded); furthermore, it is also\n     * necessary to empty the L2 table cache, since it may contain tables which\n     * are now going to be modified directly on disk, bypassing the cache.\n     * qcow2_cache_empty() does both for us. */\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n        if (ret < 0) {\n            goto fail;\n        }\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n            be64_to_cpus(&l1_table[j]);\n        }\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n                                         &expanded_clusters, &nb_clusters);\n        if (ret < 0) {\n            goto fail;\n        }\n    }\n\n    ret = 0;\n\nfail:\n    g_free(expanded_clusters);\n    g_free(l1_table);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cab60de930684c33f67d4e32c7509b567f8c445b",
        "vul_func_with_fix": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t *l1_table = NULL;\n    uint64_t nb_clusters;\n    uint8_t *expanded_clusters;\n    int ret;\n    int i, j;\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n                                   BDRV_SECTOR_SIZE);\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n                                     &expanded_clusters, &nb_clusters);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n     * necessary to flush the L2 table cache before trying to access the L2\n     * tables pointed to by inactive L1 entries (else we might try to expand\n     * zero clusters that have already been expanded); furthermore, it is also\n     * necessary to empty the L2 table cache, since it may contain tables which\n     * are now going to be modified directly on disk, bypassing the cache.\n     * qcow2_cache_empty() does both for us. */\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n        if (ret < 0) {\n            goto fail;\n        }\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n            be64_to_cpus(&l1_table[j]);\n        }\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n                                         &expanded_clusters, &nb_clusters);\n        if (ret < 0) {\n            goto fail;\n        }\n    }\n\n    ret = 0;\n\nfail:\n    g_free(expanded_clusters);\n    g_free(l1_table);\n    return ret;\n}\n",
        "linevul": 6.079321610741317e-05
    },
    {
        "code": "static void ohci_pci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = usb_ohci_realize_pci;\n    k->exit = usb_ohci_exit;\n    k->vendor_id = PCI_VENDOR_ID_APPLE;\n    k->device_id = PCI_DEVICE_ID_APPLE_IPID_USB;\n    k->class_id = PCI_CLASS_SERIAL_USB;\n    set_bit(DEVICE_CATEGORY_USB, dc->categories);\n    dc->desc = \"Apple USB Controller\";\n    dc->props = ohci_pci_properties;\n    dc->hotpluggable = false;\n    dc->vmsd = &vmstate_ohci;\n    dc->reset = usb_ohci_reset_pci;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void ohci_pci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = usb_ohci_realize_pci;\n    k->exit = usb_ohci_exit;\n    k->vendor_id = PCI_VENDOR_ID_APPLE;\n    k->device_id = PCI_DEVICE_ID_APPLE_IPID_USB;\n    k->class_id = PCI_CLASS_SERIAL_USB;\n    set_bit(DEVICE_CATEGORY_USB, dc->categories);\n    dc->desc = \"Apple USB Controller\";\n    dc->props = ohci_pci_properties;\n    dc->hotpluggable = false;\n    dc->vmsd = &vmstate_ohci;\n    dc->reset = usb_ohci_reset_pci;\n}\n",
        "linevul": 7.523364183725789e-05
    },
    {
        "code": "iscsi_co_generic_cb(struct iscsi_context *iscsi, int status,\n                        void *command_data, void *opaque)\n{\n    struct IscsiTask *iTask = opaque;\n    struct scsi_task *task = command_data;\n\n    iTask->status = status;\n    iTask->do_retry = 0;\n    iTask->task = task;\n\n    if (status != SCSI_STATUS_GOOD) {\n        if (iTask->retries++ < ISCSI_CMD_RETRIES) {\n            if (status == SCSI_STATUS_CHECK_CONDITION\n                && task->sense.key == SCSI_SENSE_UNIT_ATTENTION) {\n                error_report(\"iSCSI CheckCondition: %s\",\n                             iscsi_get_error(iscsi));\n                iTask->do_retry = 1;\n                goto out;\n            }\n            if (status == SCSI_STATUS_BUSY ||\n                status == SCSI_STATUS_TIMEOUT ||\n                status == SCSI_STATUS_TASK_SET_FULL) {\n                unsigned retry_time =\n                    exp_random(iscsi_retry_times[iTask->retries - 1]);\n                if (status == SCSI_STATUS_TIMEOUT) {\n                    /* make sure the request is rescheduled AFTER the\n                     * reconnect is initiated */\n                    retry_time = EVENT_INTERVAL * 2;\n                    iTask->iscsilun->request_timed_out = true;\n                }\n                error_report(\"iSCSI Busy/TaskSetFull/TimeOut\"\n                             \" (retry #%u in %u ms): %s\",\n                             iTask->retries, retry_time,\n                             iscsi_get_error(iscsi));\n                aio_timer_init(iTask->iscsilun->aio_context,\n                               &iTask->retry_timer, QEMU_CLOCK_REALTIME,\n                               SCALE_MS, iscsi_retry_timer_expired, iTask);\n                timer_mod(&iTask->retry_timer,\n                          qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + retry_time);\n                iTask->do_retry = 1;\n                return;\n            }\n        }\n        iTask->err_code = iscsi_translate_sense(&task->sense);\n        error_report(\"iSCSI Failure: %s\", iscsi_get_error(iscsi));\n    }\n\nout:\n    if (iTask->co) {\n        iTask->bh = aio_bh_new(iTask->iscsilun->aio_context,\n                               iscsi_co_generic_bh_cb, iTask);\n        qemu_bh_schedule(iTask->bh);\n    } else {\n        iTask->complete = 1;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_co_generic_cb(struct iscsi_context *iscsi, int status,\n                        void *command_data, void *opaque)\n{\n    struct IscsiTask *iTask = opaque;\n    struct scsi_task *task = command_data;\n\n    iTask->status = status;\n    iTask->do_retry = 0;\n    iTask->task = task;\n\n    if (status != SCSI_STATUS_GOOD) {\n        if (iTask->retries++ < ISCSI_CMD_RETRIES) {\n            if (status == SCSI_STATUS_CHECK_CONDITION\n                && task->sense.key == SCSI_SENSE_UNIT_ATTENTION) {\n                error_report(\"iSCSI CheckCondition: %s\",\n                             iscsi_get_error(iscsi));\n                iTask->do_retry = 1;\n                goto out;\n            }\n            if (status == SCSI_STATUS_BUSY ||\n                status == SCSI_STATUS_TIMEOUT ||\n                status == SCSI_STATUS_TASK_SET_FULL) {\n                unsigned retry_time =\n                    exp_random(iscsi_retry_times[iTask->retries - 1]);\n                if (status == SCSI_STATUS_TIMEOUT) {\n                    /* make sure the request is rescheduled AFTER the\n                     * reconnect is initiated */\n                    retry_time = EVENT_INTERVAL * 2;\n                    iTask->iscsilun->request_timed_out = true;\n                }\n                error_report(\"iSCSI Busy/TaskSetFull/TimeOut\"\n                             \" (retry #%u in %u ms): %s\",\n                             iTask->retries, retry_time,\n                             iscsi_get_error(iscsi));\n                aio_timer_init(iTask->iscsilun->aio_context,\n                               &iTask->retry_timer, QEMU_CLOCK_REALTIME,\n                               SCALE_MS, iscsi_retry_timer_expired, iTask);\n                timer_mod(&iTask->retry_timer,\n                          qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + retry_time);\n                iTask->do_retry = 1;\n                return;\n            }\n        }\n        iTask->err_code = iscsi_translate_sense(&task->sense);\n        error_report(\"iSCSI Failure: %s\", iscsi_get_error(iscsi));\n    }\n\nout:\n    if (iTask->co) {\n        iTask->bh = aio_bh_new(iTask->iscsilun->aio_context,\n                               iscsi_co_generic_bh_cb, iTask);\n        qemu_bh_schedule(iTask->bh);\n    } else {\n        iTask->complete = 1;\n    }\n}\n",
        "linevul": 5.485186193254776e-05
    },
    {
        "code": "vmxnet3_indicate_packet(VMXNET3State *s)\n{\n    struct Vmxnet3_RxDesc rxd;\n    bool is_head = true;\n    uint32_t rxd_idx;\n    uint32_t rx_ridx = 0;\n\n    struct Vmxnet3_RxCompDesc rxcd;\n    uint32_t new_rxcd_gen = VMXNET3_INIT_GEN;\n    hwaddr new_rxcd_pa = 0;\n    hwaddr ready_rxcd_pa = 0;\n    struct iovec *data = vmxnet_rx_pkt_get_iovec(s->rx_pkt);\n    size_t bytes_copied = 0;\n    size_t bytes_left = vmxnet_rx_pkt_get_total_len(s->rx_pkt);\n    uint16_t num_frags = 0;\n    size_t chunk_size;\n\n    vmxnet_rx_pkt_dump(s->rx_pkt);\n\n    while (bytes_left > 0) {\n\n        /* cannot add more frags to packet */\n        if (num_frags == s->max_rx_frags) {\n            break;\n        }\n\n        new_rxcd_pa = vmxnet3_pop_rxc_descr(s, RXQ_IDX, &new_rxcd_gen);\n        if (!new_rxcd_pa) {\n            break;\n        }\n\n        if (!vmxnet3_get_next_rx_descr(s, is_head, &rxd, &rxd_idx, &rx_ridx)) {\n            break;\n        }\n\n        chunk_size = MIN(bytes_left, rxd.len);\n        vmxnet3_physical_memory_writev(data, bytes_copied,\n                                       le64_to_cpu(rxd.addr), chunk_size);\n        bytes_copied += chunk_size;\n        bytes_left -= chunk_size;\n\n        vmxnet3_dump_rx_descr(&rxd);\n\n        if (ready_rxcd_pa != 0) {\n            cpu_physical_memory_write(ready_rxcd_pa, &rxcd, sizeof(rxcd));\n        }\n\n        memset(&rxcd, 0, sizeof(struct Vmxnet3_RxCompDesc));\n        rxcd.rxdIdx = rxd_idx;\n        rxcd.len = chunk_size;\n        rxcd.sop = is_head;\n        rxcd.gen = new_rxcd_gen;\n        rxcd.rqID = RXQ_IDX + rx_ridx * s->rxq_num;\n\n        if (bytes_left == 0) {\n            vmxnet3_rx_update_descr(s->rx_pkt, &rxcd);\n        }\n\n        VMW_RIPRN(\"RX Completion descriptor: rxRing: %lu rxIdx %lu len %lu \"\n                  \"sop %d csum_correct %lu\",\n                  (unsigned long) rx_ridx,\n                  (unsigned long) rxcd.rxdIdx,\n                  (unsigned long) rxcd.len,\n                  (int) rxcd.sop,\n                  (unsigned long) rxcd.tuc);\n\n        is_head = false;\n        ready_rxcd_pa = new_rxcd_pa;\n        new_rxcd_pa = 0;\n        num_frags++;\n    }\n\n    if (ready_rxcd_pa != 0) {\n        rxcd.eop = 1;\n        rxcd.err = (bytes_left != 0);\n        cpu_physical_memory_write(ready_rxcd_pa, &rxcd, sizeof(rxcd));\n\n        /* Flush RX descriptor changes */\n        smp_wmb();\n    }\n\n    if (new_rxcd_pa != 0) {\n        vmxnet3_revert_rxc_descr(s, RXQ_IDX);\n    }\n\n    vmxnet3_trigger_interrupt(s, s->rxq_descr[RXQ_IDX].intr_idx);\n\n    if (bytes_left == 0) {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX, VMXNET3_PKT_STATUS_OK);\n        return true;\n    } else if (num_frags == s->max_rx_frags) {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX, VMXNET3_PKT_STATUS_ERROR);\n        return false;\n    } else {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX,\n                                        VMXNET3_PKT_STATUS_OUT_OF_BUF);\n        return false;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c6048f849c7e3f009786df76206e895",
        "vul_func_with_fix": "vmxnet3_indicate_packet(VMXNET3State *s)\n{\n    struct Vmxnet3_RxDesc rxd;\n    bool is_head = true;\n    uint32_t rxd_idx;\n    uint32_t rx_ridx = 0;\n\n    struct Vmxnet3_RxCompDesc rxcd;\n    uint32_t new_rxcd_gen = VMXNET3_INIT_GEN;\n    hwaddr new_rxcd_pa = 0;\n    hwaddr ready_rxcd_pa = 0;\n    struct iovec *data = vmxnet_rx_pkt_get_iovec(s->rx_pkt);\n    size_t bytes_copied = 0;\n    size_t bytes_left = vmxnet_rx_pkt_get_total_len(s->rx_pkt);\n    uint16_t num_frags = 0;\n    size_t chunk_size;\n\n    vmxnet_rx_pkt_dump(s->rx_pkt);\n\n    while (bytes_left > 0) {\n\n        /* cannot add more frags to packet */\n        if (num_frags == s->max_rx_frags) {\n            break;\n        }\n\n        new_rxcd_pa = vmxnet3_pop_rxc_descr(s, RXQ_IDX, &new_rxcd_gen);\n        if (!new_rxcd_pa) {\n            break;\n        }\n\n        if (!vmxnet3_get_next_rx_descr(s, is_head, &rxd, &rxd_idx, &rx_ridx)) {\n            break;\n        }\n\n        chunk_size = MIN(bytes_left, rxd.len);\n        vmxnet3_physical_memory_writev(data, bytes_copied,\n                                       le64_to_cpu(rxd.addr), chunk_size);\n        bytes_copied += chunk_size;\n        bytes_left -= chunk_size;\n\n        vmxnet3_dump_rx_descr(&rxd);\n\n        if (ready_rxcd_pa != 0) {\n            cpu_physical_memory_write(ready_rxcd_pa, &rxcd, sizeof(rxcd));\n        }\n\n        memset(&rxcd, 0, sizeof(struct Vmxnet3_RxCompDesc));\n        rxcd.rxdIdx = rxd_idx;\n        rxcd.len = chunk_size;\n        rxcd.sop = is_head;\n        rxcd.gen = new_rxcd_gen;\n        rxcd.rqID = RXQ_IDX + rx_ridx * s->rxq_num;\n\n        if (bytes_left == 0) {\n            vmxnet3_rx_update_descr(s->rx_pkt, &rxcd);\n        }\n\n        VMW_RIPRN(\"RX Completion descriptor: rxRing: %lu rxIdx %lu len %lu \"\n                  \"sop %d csum_correct %lu\",\n                  (unsigned long) rx_ridx,\n                  (unsigned long) rxcd.rxdIdx,\n                  (unsigned long) rxcd.len,\n                  (int) rxcd.sop,\n                  (unsigned long) rxcd.tuc);\n\n        is_head = false;\n        ready_rxcd_pa = new_rxcd_pa;\n        new_rxcd_pa = 0;\n        num_frags++;\n    }\n\n    if (ready_rxcd_pa != 0) {\n        rxcd.eop = 1;\n        rxcd.err = (bytes_left != 0);\n        cpu_physical_memory_write(ready_rxcd_pa, &rxcd, sizeof(rxcd));\n\n        /* Flush RX descriptor changes */\n        smp_wmb();\n    }\n\n    if (new_rxcd_pa != 0) {\n        vmxnet3_revert_rxc_descr(s, RXQ_IDX);\n    }\n\n    vmxnet3_trigger_interrupt(s, s->rxq_descr[RXQ_IDX].intr_idx);\n\n    if (bytes_left == 0) {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX, VMXNET3_PKT_STATUS_OK);\n        return true;\n    } else if (num_frags == s->max_rx_frags) {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX, VMXNET3_PKT_STATUS_ERROR);\n        return false;\n    } else {\n        vmxnet3_on_rx_done_update_stats(s, RXQ_IDX,\n                                        VMXNET3_PKT_STATUS_OUT_OF_BUF);\n        return false;\n    }\n}\n",
        "linevul": 0.00010083661618409678
    },
    {
        "code": "static int megasas_dcmd_get_properties(MegasasState *s, MegasasCmd *cmd)\n{\n    struct mfi_ctrl_props info;\n    size_t dcmd_size = sizeof(info);\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n    info.pred_fail_poll_interval = cpu_to_le16(300);\n    info.intr_throttle_cnt = cpu_to_le16(16);\n    info.intr_throttle_timeout = cpu_to_le16(50);\n    info.rebuild_rate = 30;\n    info.patrol_read_rate = 30;\n    info.bgi_rate = 30;\n    info.cc_rate = 30;\n    info.recon_rate = 30;\n    info.cache_flush_interval = 4;\n    info.spinup_drv_cnt = 2;\n    info.spinup_delay = 6;\n    info.ecc_bucket_size = 15;\n    info.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.expose_encl_devices = 1;\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_dcmd_get_properties(MegasasState *s, MegasasCmd *cmd)\n{\n    struct mfi_ctrl_props info;\n    size_t dcmd_size = sizeof(info);\n\n    memset(&info, 0x0, dcmd_size);\n    if (cmd->iov_size < dcmd_size) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_size);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n    info.pred_fail_poll_interval = cpu_to_le16(300);\n    info.intr_throttle_cnt = cpu_to_le16(16);\n    info.intr_throttle_timeout = cpu_to_le16(50);\n    info.rebuild_rate = 30;\n    info.patrol_read_rate = 30;\n    info.bgi_rate = 30;\n    info.cc_rate = 30;\n    info.recon_rate = 30;\n    info.cache_flush_interval = 4;\n    info.spinup_drv_cnt = 2;\n    info.spinup_delay = 6;\n    info.ecc_bucket_size = 15;\n    info.ecc_bucket_leak_rate = cpu_to_le16(1440);\n    info.expose_encl_devices = 1;\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
        "linevul": 6.433401722460985e-05
    },
    {
        "code": " void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n {\n    g_free(s->ctx.fs_root);\n     g_free(s->tag);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": " void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n {\n//flaw_line_below:\n    g_free(s->ctx.fs_root);\n     g_free(s->tag);\n//fix_flaw_line_below:\n//    g_free(s->ctx.fs_root);\n }\n",
        "linevul": 0.001299211522564292
    },
    {
        "code": "set_phy_ctrl(E1000State *s, int index, uint16_t val)\n{\n    if ((val & MII_CR_AUTO_NEG_EN) && (val & MII_CR_RESTART_AUTO_NEG)) {\n        s->nic->nc.link_down = true;\n        e1000_link_down(s);\n        s->phy_reg[PHY_STATUS] &= ~MII_SR_AUTONEG_COMPLETE;\n        DBGOUT(PHY, \"Start link auto negotiation\\n\");\n        qemu_mod_timer(s->autoneg_timer, qemu_get_clock_ms(vm_clock) + 500);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb",
        "vul_func_with_fix": "set_phy_ctrl(E1000State *s, int index, uint16_t val)\n{\n    if ((val & MII_CR_AUTO_NEG_EN) && (val & MII_CR_RESTART_AUTO_NEG)) {\n        s->nic->nc.link_down = true;\n        e1000_link_down(s);\n        s->phy_reg[PHY_STATUS] &= ~MII_SR_AUTONEG_COMPLETE;\n        DBGOUT(PHY, \"Start link auto negotiation\\n\");\n        qemu_mod_timer(s->autoneg_timer, qemu_get_clock_ms(vm_clock) + 500);\n    }\n}\n",
        "linevul": 4.941689257975668e-05
    },
    {
        "code": "MSIMessage msix_get_message(PCIDevice *dev, unsigned vector)\n{\n    uint8_t *table_entry = dev->msix_table + vector * PCI_MSIX_ENTRY_SIZE;\n    MSIMessage msg;\n\n    msg.address = pci_get_quad(table_entry + PCI_MSIX_ENTRY_LOWER_ADDR);\n    msg.data = pci_get_long(table_entry + PCI_MSIX_ENTRY_DATA);\n    return msg;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285",
        "vul_func_with_fix": "MSIMessage msix_get_message(PCIDevice *dev, unsigned vector)\n{\n    uint8_t *table_entry = dev->msix_table + vector * PCI_MSIX_ENTRY_SIZE;\n    MSIMessage msg;\n\n    msg.address = pci_get_quad(table_entry + PCI_MSIX_ENTRY_LOWER_ADDR);\n    msg.data = pci_get_long(table_entry + PCI_MSIX_ENTRY_DATA);\n    return msg;\n}\n",
        "linevul": 5.1889186579501256e-05
    },
    {
        "code": "static void esp_register_types(void)\n{\n    type_register_static(&sysbus_esp_info);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "static void esp_register_types(void)\n{\n    type_register_static(&sysbus_esp_info);\n}\n",
        "linevul": 8.767037797952071e-05
    },
    {
        "code": "static void xhci_runtime_write(void *ptr, hwaddr reg,\n                               uint64_t val, unsigned size)\n{\n    XHCIState *xhci = ptr;\n    int v = (reg - 0x20) / 0x20;\n    XHCIInterrupter *intr = &xhci->intr[v];\n    trace_usb_xhci_runtime_write(reg, val);\n\n    if (reg < 0x20) {\n        trace_usb_xhci_unimplemented(\"runtime write\", reg);\n        return;\n    }\n\n    switch (reg & 0x1f) {\n    case 0x00: /* IMAN */\n        if (val & IMAN_IP) {\n            intr->iman &= ~IMAN_IP;\n        }\n        intr->iman &= ~IMAN_IE;\n        intr->iman |= val & IMAN_IE;\n        if (v == 0) {\n            xhci_intx_update(xhci);\n        }\n        xhci_msix_update(xhci, v);\n        break;\n    case 0x04: /* IMOD */\n        intr->imod = val;\n        break;\n    case 0x08: /* ERSTSZ */\n        intr->erstsz = val & 0xffff;\n        break;\n    case 0x10: /* ERSTBA low */\n        /* XXX NEC driver bug: it doesn't align this to 64 bytes\n        intr->erstba_low = val & 0xffffffc0; */\n        intr->erstba_low = val & 0xfffffff0;\n        break;\n    case 0x14: /* ERSTBA high */\n        intr->erstba_high = val;\n        xhci_er_reset(xhci, v);\n        break;\n    case 0x18: /* ERDP low */\n        if (val & ERDP_EHB) {\n            intr->erdp_low &= ~ERDP_EHB;\n        }\n        intr->erdp_low = (val & ~ERDP_EHB) | (intr->erdp_low & ERDP_EHB);\n        break;\n    case 0x1c: /* ERDP high */\n        intr->erdp_high = val;\n        xhci_events_update(xhci, v);\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"oper write\", reg);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_runtime_write(void *ptr, hwaddr reg,\n                               uint64_t val, unsigned size)\n{\n    XHCIState *xhci = ptr;\n    int v = (reg - 0x20) / 0x20;\n    XHCIInterrupter *intr = &xhci->intr[v];\n    trace_usb_xhci_runtime_write(reg, val);\n\n    if (reg < 0x20) {\n        trace_usb_xhci_unimplemented(\"runtime write\", reg);\n        return;\n    }\n\n    switch (reg & 0x1f) {\n    case 0x00: /* IMAN */\n        if (val & IMAN_IP) {\n            intr->iman &= ~IMAN_IP;\n        }\n        intr->iman &= ~IMAN_IE;\n        intr->iman |= val & IMAN_IE;\n        if (v == 0) {\n            xhci_intx_update(xhci);\n        }\n        xhci_msix_update(xhci, v);\n        break;\n    case 0x04: /* IMOD */\n        intr->imod = val;\n        break;\n    case 0x08: /* ERSTSZ */\n        intr->erstsz = val & 0xffff;\n        break;\n    case 0x10: /* ERSTBA low */\n        /* XXX NEC driver bug: it doesn't align this to 64 bytes\n        intr->erstba_low = val & 0xffffffc0; */\n        intr->erstba_low = val & 0xfffffff0;\n        break;\n    case 0x14: /* ERSTBA high */\n        intr->erstba_high = val;\n        xhci_er_reset(xhci, v);\n        break;\n    case 0x18: /* ERDP low */\n        if (val & ERDP_EHB) {\n            intr->erdp_low &= ~ERDP_EHB;\n        }\n        intr->erdp_low = (val & ~ERDP_EHB) | (intr->erdp_low & ERDP_EHB);\n        break;\n    case 0x1c: /* ERDP high */\n        intr->erdp_high = val;\n        xhci_events_update(xhci, v);\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"oper write\", reg);\n    }\n}\n",
        "linevul": 6.185411621117964e-05
    },
    {
        "code": "static void i6300esb_timer_expired(void *vp)\n{\n    I6300State *d = vp;\n\n    i6300esb_debug(\"stage %d\\n\", d->stage);\n\n    if (d->stage == 1) {\n        /* What to do at the end of stage 1? */\n        switch (d->int_type) {\n        case INT_TYPE_IRQ:\n            fprintf(stderr, \"i6300esb_timer_expired: I would send APIC 1 INT 10 here if I knew how (XXX)\\n\");\n            break;\n        case INT_TYPE_SMI:\n            fprintf(stderr, \"i6300esb_timer_expired: I would send SMI here if I knew how (XXX)\\n\");\n            break;\n        }\n\n        /* Start the second stage. */\n        i6300esb_restart_timer(d, 2);\n    } else {\n        /* Second stage expired, reboot for real. */\n        if (d->reboot_enabled) {\n            d->previous_reboot_flag = 1;\n            watchdog_perform_action(); /* This reboots, exits, etc */\n            i6300esb_reset(&d->dev.qdev);\n        }\n\n        /* In \"free running mode\" we start stage 1 again. */\n        if (d->free_run)\n            i6300esb_restart_timer(d, 1);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eb7a20a3616085d46aa6b4b4224e15587ec67e6e",
        "vul_func_with_fix": "static void i6300esb_timer_expired(void *vp)\n{\n    I6300State *d = vp;\n\n    i6300esb_debug(\"stage %d\\n\", d->stage);\n\n    if (d->stage == 1) {\n        /* What to do at the end of stage 1? */\n        switch (d->int_type) {\n        case INT_TYPE_IRQ:\n            fprintf(stderr, \"i6300esb_timer_expired: I would send APIC 1 INT 10 here if I knew how (XXX)\\n\");\n            break;\n        case INT_TYPE_SMI:\n            fprintf(stderr, \"i6300esb_timer_expired: I would send SMI here if I knew how (XXX)\\n\");\n            break;\n        }\n\n        /* Start the second stage. */\n        i6300esb_restart_timer(d, 2);\n    } else {\n        /* Second stage expired, reboot for real. */\n        if (d->reboot_enabled) {\n            d->previous_reboot_flag = 1;\n            watchdog_perform_action(); /* This reboots, exits, etc */\n            i6300esb_reset(&d->dev.qdev);\n        }\n\n        /* In \"free running mode\" we start stage 1 again. */\n        if (d->free_run)\n            i6300esb_restart_timer(d, 1);\n    }\n}\n",
        "linevul": 4.679338599089533e-05
    },
    {
        "code": "static void ehci_queues_rip_all(EHCIState *ehci, int async)\n{\n    EHCIQueueHead *head = async ? &ehci->aqueues : &ehci->pqueues;\n    const char *warn = async ? \"guest stopped busy async schedule\" : NULL;\n    EHCIQueue *q, *tmp;\n\n    QTAILQ_FOREACH_SAFE(q, head, next, tmp) {\n        ehci_free_queue(q, warn);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_queues_rip_all(EHCIState *ehci, int async)\n{\n    EHCIQueueHead *head = async ? &ehci->aqueues : &ehci->pqueues;\n    const char *warn = async ? \"guest stopped busy async schedule\" : NULL;\n    EHCIQueue *q, *tmp;\n\n    QTAILQ_FOREACH_SAFE(q, head, next, tmp) {\n        ehci_free_queue(q, warn);\n    }\n}\n",
        "linevul": 4.694343078881502e-05
    },
    {
        "code": "static ssize_t handle_preadv(FsContext *ctx, V9fsFidOpenState *fs,\n                             const struct iovec *iov,\n                             int iovcnt, off_t offset)\n{\n#ifdef CONFIG_PREADV\n    return preadv(fs->fd, iov, iovcnt, offset);\n#else\n    int err = lseek(fs->fd, offset, SEEK_SET);\n    if (err == -1) {\n        return err;\n    } else {\n        return readv(fs->fd, iov, iovcnt);\n    }\n#endif\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static ssize_t handle_preadv(FsContext *ctx, V9fsFidOpenState *fs,\n                             const struct iovec *iov,\n                             int iovcnt, off_t offset)\n{\n#ifdef CONFIG_PREADV\n    return preadv(fs->fd, iov, iovcnt, offset);\n#else\n    int err = lseek(fs->fd, offset, SEEK_SET);\n    if (err == -1) {\n        return err;\n    } else {\n        return readv(fs->fd, iov, iovcnt);\n    }\n#endif\n}\n",
        "linevul": 6.81237070239149e-05
    },
    {
        "code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n     for (i = 0; i < 5; i++)\n         s->response[i] = qemu_get_be32(f);\n     s->arglen = qemu_get_be32(f);\n     s->response_pos = qemu_get_be32(f);\n     s->stopping = qemu_get_be32(f);\n \n     ss->cs = qemu_get_be32(f);\n    s->mode = SSI_SD_CMD;\n    dinfo = drive_get_next(IF_SD);\n    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, true);\n    if (s->sd == NULL) {\n        return -1;\n    }\n    register_savevm(dev, \"ssi_sd\", -1, 1, ssi_sd_save, ssi_sd_load, s);\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a9c380db3b8c6af19546a68145c8d1438a09c92b",
        "vul_func_with_fix": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n     for (i = 0; i < 5; i++)\n         s->response[i] = qemu_get_be32(f);\n     s->arglen = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->mode == SSI_SD_CMDARG &&\n//fix_flaw_line_below:\n//        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->response_pos = qemu_get_be32(f);\n     s->stopping = qemu_get_be32(f);\n//fix_flaw_line_below:\n//    if (s->mode == SSI_SD_RESPONSE &&\n//fix_flaw_line_below:\n//        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||\n//fix_flaw_line_below:\n//        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n \n     ss->cs = qemu_get_be32(f);\n    s->mode = SSI_SD_CMD;\n    dinfo = drive_get_next(IF_SD);\n    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, true);\n    if (s->sd == NULL) {\n        return -1;\n    }\n    register_savevm(dev, \"ssi_sd\", -1, 1, ssi_sd_save, ssi_sd_load, s);\n    return 0;\n}\n",
        "linevul": 0.9175116419792175
    },
    {
        "code": " static int ohci_bus_start(OHCIState *ohci)\n {\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                    ohci_frame_boundary,\n                    ohci);\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n     trace_usb_ohci_start(ohci->name);\n \n     /* Delay the first SOF event by one frame time as\n\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n static void ohci_bus_stop(OHCIState *ohci)\n {\n     trace_usb_ohci_stop(ohci->name);\n    if (ohci->eof_timer) {\n        timer_del(ohci->eof_timer);\n        timer_free(ohci->eof_timer);\n    }\n    ohci->eof_timer = NULL;\n }\n \n /* Sets a flag in a port status register but only set it if the port is\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fa1298c2d623522eda7b4f1f721fcb935abb7360",
        "vul_func_with_fix": " static int ohci_bus_start(OHCIState *ohci)\n {\n//flaw_line_below:\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n//flaw_line_below:\n                    ohci_frame_boundary,\n//flaw_line_below:\n                    ohci);\n//flaw_line_below:\n\n//flaw_line_below:\n    if (ohci->eof_timer == NULL) {\n//flaw_line_below:\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n//flaw_line_below:\n        ohci_die(ohci);\n//flaw_line_below:\n        return 0;\n//flaw_line_below:\n    }\n//flaw_line_below:\n\n     trace_usb_ohci_start(ohci->name);\n \n     /* Delay the first SOF event by one frame time as\n\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n static void ohci_bus_stop(OHCIState *ohci)\n {\n     trace_usb_ohci_stop(ohci->name);\n//flaw_line_below:\n    if (ohci->eof_timer) {\n//flaw_line_below:\n        timer_del(ohci->eof_timer);\n//flaw_line_below:\n        timer_free(ohci->eof_timer);\n//flaw_line_below:\n    }\n//flaw_line_below:\n    ohci->eof_timer = NULL;\n//fix_flaw_line_below:\n//    timer_del(ohci->eof_timer);\n }\n \n /* Sets a flag in a port status register but only set it if the port is\n}\n",
        "linevul": 0.9989873766899109
    },
    {
        "code": "uint64_t xbzrle_mig_bytes_transferred(void)\n{\n    return acct_info.xbzrle_bytes;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "uint64_t xbzrle_mig_bytes_transferred(void)\n{\n    return acct_info.xbzrle_bytes;\n}\n",
        "linevul": 6.788227619836107e-05
    },
    {
        "code": "static int coroutine_fn v9fs_do_readdir(V9fsPDU *pdu, V9fsFidState *fidp,\n                                        int32_t max_count)\n{\n    size_t size;\n    V9fsQID qid;\n    V9fsString name;\n    int len, err = 0;\n    int32_t count = 0;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    /* save the directory position */\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        v9fs_string_init(&name);\n        v9fs_string_sprintf(&name, \"%s\", dent->d_name);\n        if ((count + v9fs_readdir_data_size(&name)) > max_count) {\n            v9fs_readdir_unlock(&fidp->fs.dir);\n\n            /* Ran out of buffer. Set dir back to old position and return */\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_string_free(&name);\n            return count;\n        }\n        /*\n         * Fill up just the path field of qid because the client uses\n         * only that. To fill the entire qid structure we will have\n         * to stat each dirent found, which is expensive\n         */\n        size = MIN(sizeof(dent->d_ino), sizeof(qid.path));\n        memcpy(&qid.path, &dent->d_ino, size);\n        /* Fill the other fields with dummy values */\n        qid.type = 0;\n        qid.version = 0;\n\n        /* 11 = 7 + 4 (7 = start offset, 4 = space for storing count) */\n        len = pdu_marshal(pdu, 11 + count, \"Qqbs\",\n                          &qid, dent->d_off,\n                          dent->d_type, &name);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if (len < 0) {\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_string_free(&name);\n            return len;\n        }\n        count += len;\n        v9fs_string_free(&name);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn v9fs_do_readdir(V9fsPDU *pdu, V9fsFidState *fidp,\n                                        int32_t max_count)\n{\n    size_t size;\n    V9fsQID qid;\n    V9fsString name;\n    int len, err = 0;\n    int32_t count = 0;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    /* save the directory position */\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        v9fs_string_init(&name);\n        v9fs_string_sprintf(&name, \"%s\", dent->d_name);\n        if ((count + v9fs_readdir_data_size(&name)) > max_count) {\n            v9fs_readdir_unlock(&fidp->fs.dir);\n\n            /* Ran out of buffer. Set dir back to old position and return */\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_string_free(&name);\n            return count;\n        }\n        /*\n         * Fill up just the path field of qid because the client uses\n         * only that. To fill the entire qid structure we will have\n         * to stat each dirent found, which is expensive\n         */\n        size = MIN(sizeof(dent->d_ino), sizeof(qid.path));\n        memcpy(&qid.path, &dent->d_ino, size);\n        /* Fill the other fields with dummy values */\n        qid.type = 0;\n        qid.version = 0;\n\n        /* 11 = 7 + 4 (7 = start offset, 4 = space for storing count) */\n        len = pdu_marshal(pdu, 11 + count, \"Qqbs\",\n                          &qid, dent->d_off,\n                          dent->d_type, &name);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if (len < 0) {\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_string_free(&name);\n            return len;\n        }\n        count += len;\n        v9fs_string_free(&name);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n",
        "linevul": 0.00023557562963105738
    },
    {
        "code": "static uint64_t ehci_caps_read(void *ptr, hwaddr addr,\n                               unsigned size)\n{\n    EHCIState *s = ptr;\n    return s->caps[addr];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static uint64_t ehci_caps_read(void *ptr, hwaddr addr,\n                               unsigned size)\n{\n    EHCIState *s = ptr;\n    return s->caps[addr];\n}\n",
        "linevul": 4.8525416787015274e-05
    },
    {
        "code": "static inline int ohci_read_ed(OHCIState *ohci,\n                               dma_addr_t addr, struct ohci_ed *ed)\n{\n    return get_dwords(ohci, addr, (uint32_t *)ed, sizeof(*ed) >> 2);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static inline int ohci_read_ed(OHCIState *ohci,\n                               dma_addr_t addr, struct ohci_ed *ed)\n{\n    return get_dwords(ohci, addr, (uint32_t *)ed, sizeof(*ed) >> 2);\n}\n",
        "linevul": 5.318523108144291e-05
    },
    {
        "code": " static int is_rndis(USBNetState *s)\n {\n    return s->dev.config->bConfigurationValue == DEV_RNDIS_CONFIG_VALUE;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=80eecda8e5d09c442c24307f340840a5b70ea3b9",
        "vul_func_with_fix": " static int is_rndis(USBNetState *s)\n {\n//flaw_line_below:\n    return s->dev.config->bConfigurationValue == DEV_RNDIS_CONFIG_VALUE;\n//fix_flaw_line_below:\n//    return s->dev.config ?\n//fix_flaw_line_below:\n//            s->dev.config->bConfigurationValue == DEV_RNDIS_CONFIG_VALUE : 0;\n }\n",
        "linevul": 0.07318946719169617
    },
    {
        "code": "void virtio_gpu_get_display_info(VirtIOGPU *g,\n                                 struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resp_display_info display_info;\n\n    trace_virtio_gpu_cmd_get_display_info();\n    memset(&display_info, 0, sizeof(display_info));\n    display_info.hdr.type = VIRTIO_GPU_RESP_OK_DISPLAY_INFO;\n    virtio_gpu_fill_display_info(g, &display_info);\n    virtio_gpu_ctrl_response(g, cmd, &display_info.hdr,\n                             sizeof(display_info));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "void virtio_gpu_get_display_info(VirtIOGPU *g,\n                                 struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resp_display_info display_info;\n\n    trace_virtio_gpu_cmd_get_display_info();\n    memset(&display_info, 0, sizeof(display_info));\n    display_info.hdr.type = VIRTIO_GPU_RESP_OK_DISPLAY_INFO;\n    virtio_gpu_fill_display_info(g, &display_info);\n    virtio_gpu_ctrl_response(g, cmd, &display_info.hdr,\n                             sizeof(display_info));\n}\n",
        "linevul": 4.625421206583269e-05
    },
    {
        "code": "static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)\n{\n    int fd, ret;\n    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n    if (ret < 0) {\n        goto err_out;\n    }\n    ret = fchmod(fd, credp->fc_mode & 07777);\nerr_out:\n    close(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)\n{\n    int fd, ret;\n    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n    if (ret < 0) {\n        goto err_out;\n    }\n    ret = fchmod(fd, credp->fc_mode & 07777);\nerr_out:\n    close(fd);\n    return ret;\n}\n",
        "linevul": 5.5636814067838714e-05
    },
    {
        "code": "size_t mptsas_config_ioc_5(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(5, MPI_CONFIG_PAGETYPE_IOC, 0x00,\n                              \"*l*b*b*w\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_ioc_5(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(5, MPI_CONFIG_PAGETYPE_IOC, 0x00,\n                              \"*l*b*b*w\");\n}\n",
        "linevul": 5.281737321638502e-05
    },
    {
        "code": "static void rng_egd_request_entropy(RngBackend *b, size_t size,\n                                    EntropyReceiveFunc *receive_entropy,\n                                    void *opaque)\n {\n     RngEgd *s = RNG_EGD(b);\n    RngRequest *req;\n    req = g_malloc(sizeof(*req));\n    req->offset = 0;\n    req->size = size;\n    req->receive_entropy = receive_entropy;\n    req->opaque = opaque;\n    req->data = g_malloc(req->size);\n \n     while (size > 0) {\n         uint8_t header[2];\n    req = g_malloc(sizeof(*req));\n\n    req->offset = 0;\n    req->size = size;\n    req->receive_entropy = receive_entropy;\n    req->opaque = opaque;\n    req->data = g_malloc(req->size);\n \n         size -= len;\n     }\n    s->parent.requests = g_slist_append(s->parent.requests, req);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=60253ed1e6ec6d8e5ef2efe7bf755f475dce9956",
        "vul_func_with_fix": "static void rng_egd_request_entropy(RngBackend *b, size_t size,\n//flaw_line_below:\n                                    EntropyReceiveFunc *receive_entropy,\n//flaw_line_below:\n                                    void *opaque)\n//fix_flaw_line_below:\n//static void rng_egd_request_entropy(RngBackend *b, RngRequest *req)\n {\n     RngEgd *s = RNG_EGD(b);\n//flaw_line_below:\n    RngRequest *req;\n//flaw_line_below:\n\n//flaw_line_below:\n    req = g_malloc(sizeof(*req));\n//flaw_line_below:\n\n//flaw_line_below:\n    req->offset = 0;\n//flaw_line_below:\n    req->size = size;\n//flaw_line_below:\n    req->receive_entropy = receive_entropy;\n//flaw_line_below:\n    req->opaque = opaque;\n//flaw_line_below:\n    req->data = g_malloc(req->size);\n//fix_flaw_line_below:\n//    size_t size = req->size;\n \n     while (size > 0) {\n         uint8_t header[2];\n    req = g_malloc(sizeof(*req));\n\n    req->offset = 0;\n    req->size = size;\n    req->receive_entropy = receive_entropy;\n    req->opaque = opaque;\n    req->data = g_malloc(req->size);\n \n         size -= len;\n     }\n//flaw_line_below:\n\n//flaw_line_below:\n    s->parent.requests = g_slist_append(s->parent.requests, req);\n }\n",
        "linevul": 0.9990056157112122
    },
    {
        "code": "static void isa_cirrus_vga_realizefn(DeviceState *dev, Error **errp)\n{\n    ISADevice *isadev = ISA_DEVICE(dev);\n    ISACirrusVGAState *d = ISA_CIRRUS_VGA(dev);\n    VGACommonState *s = &d->cirrus_vga.vga;\n\n    /* follow real hardware, cirrus card emulated has 4 MB video memory.\n       Also accept 8 MB/16 MB for backward compatibility. */\n    if (s->vram_size_mb != 4 && s->vram_size_mb != 8 &&\n        s->vram_size_mb != 16) {\n        error_setg(errp, \"Invalid cirrus_vga ram size '%u'\",\n                   s->vram_size_mb);\n        return;\n    }\n    vga_common_init(s, OBJECT(dev), true);\n    cirrus_init_common(&d->cirrus_vga, OBJECT(dev), CIRRUS_ID_CLGD5430, 0,\n                       isa_address_space(isadev),\n                       isa_address_space_io(isadev));\n    s->con = graphic_console_init(dev, 0, s->hw_ops, s);\n    rom_add_vga(VGABIOS_CIRRUS_FILENAME);\n    /* XXX ISA-LFB support */\n    /* FIXME not qdev yet */\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static void isa_cirrus_vga_realizefn(DeviceState *dev, Error **errp)\n{\n    ISADevice *isadev = ISA_DEVICE(dev);\n    ISACirrusVGAState *d = ISA_CIRRUS_VGA(dev);\n    VGACommonState *s = &d->cirrus_vga.vga;\n\n    /* follow real hardware, cirrus card emulated has 4 MB video memory.\n       Also accept 8 MB/16 MB for backward compatibility. */\n    if (s->vram_size_mb != 4 && s->vram_size_mb != 8 &&\n        s->vram_size_mb != 16) {\n        error_setg(errp, \"Invalid cirrus_vga ram size '%u'\",\n                   s->vram_size_mb);\n        return;\n    }\n    vga_common_init(s, OBJECT(dev), true);\n    cirrus_init_common(&d->cirrus_vga, OBJECT(dev), CIRRUS_ID_CLGD5430, 0,\n                       isa_address_space(isadev),\n                       isa_address_space_io(isadev));\n    s->con = graphic_console_init(dev, 0, s->hw_ops, s);\n    rom_add_vga(VGABIOS_CIRRUS_FILENAME);\n    /* XXX ISA-LFB support */\n    /* FIXME not qdev yet */\n}\n",
        "linevul": 5.2129587857052684e-05
    },
    {
        "code": "static void mig_throttle_guest_down(void)\n{\n    CPUState *cpu;\n\n    qemu_mutex_lock_iothread();\n    CPU_FOREACH(cpu) {\n        async_run_on_cpu(cpu, mig_sleep_cpu, NULL);\n    }\n    qemu_mutex_unlock_iothread();\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static void mig_throttle_guest_down(void)\n{\n    CPUState *cpu;\n\n    qemu_mutex_lock_iothread();\n    CPU_FOREACH(cpu) {\n        async_run_on_cpu(cpu, mig_sleep_cpu, NULL);\n    }\n    qemu_mutex_unlock_iothread();\n}\n",
        "linevul": 5.404797775554471e-05
    },
    {
        "code": "static void v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n         goto out;\n     }\n     err += offset;\n     trace_v9fs_attach_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\n     /*\n     * attach could get called multiple times for the same export.\n     */\n    if (!s->migration_blocker) {\n        s->root_fid = fid;\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        migrate_add_blocker(s->migration_blocker);\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=56f101ecce0eafd09e2daf1c4eeb1377d6959261",
        "vul_func_with_fix": "static void v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n         goto out;\n     }\n     err += offset;\n//fix_flaw_line_below:\n//    memcpy(&s->root_qid, &qid, sizeof(qid));\n     trace_v9fs_attach_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\n     /*\n     * attach could get called multiple times for the same export.\n     */\n    if (!s->migration_blocker) {\n        s->root_fid = fid;\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        migrate_add_blocker(s->migration_blocker);\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}\n",
        "linevul": 0.003734417725354433
    },
    {
        "code": "VirtQueue *virtio_get_queue(VirtIODevice *vdev, int n)\n{\n    return vdev->vq + n;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "VirtQueue *virtio_get_queue(VirtIODevice *vdev, int n)\n{\n    return vdev->vq + n;\n}\n",
        "linevul": 4.833476850762963e-05
    },
    {
        "code": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n \n     p->pci_dev = pci_dev;\n \n    p->vec = g_malloc((sizeof *p->vec) *\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n \n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n \n     p->max_payload_frags = max_frags;\n     p->max_raw_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n\n    *pkt = p;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev,\n    uint32_t max_frags, bool has_virt_hdr)\n{\n    struct NetTxPkt *p = g_malloc0(sizeof *p);\n \n     p->pci_dev = pci_dev;\n \n//flaw_line_below:\n    p->vec = g_malloc((sizeof *p->vec) *\n//flaw_line_below:\n        (max_frags + NET_TX_PKT_PL_START_FRAG));\n//fix_flaw_line_below:\n//    p->vec = g_new(struct iovec, max_frags + NET_TX_PKT_PL_START_FRAG);\n \n//flaw_line_below:\n    p->raw = g_malloc((sizeof *p->raw) * max_frags);\n//fix_flaw_line_below:\n//    p->raw = g_new(struct iovec, max_frags);\n \n     p->max_payload_frags = max_frags;\n     p->max_raw_frags = max_frags;\n    p->max_raw_frags = max_frags;\n    p->has_virt_hdr = has_virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr;\n    p->vec[NET_TX_PKT_VHDR_FRAG].iov_len =\n        p->has_virt_hdr ? sizeof p->virt_hdr : 0;\n    p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr;\n    p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr;\n\n    *pkt = p;\n}\n",
        "linevul": 0.9995018243789673
    },
    {
        "code": "static int bdrv_open_common(BlockDriverState *bs, BlockDriverState *file,\n    QDict *options, int flags, BlockDriver *drv, Error **errp)\n{\n    int ret, open_flags;\n    const char *filename;\n    const char *node_name = NULL;\n    Error *local_err = NULL;\n\n    assert(drv != NULL);\n    assert(bs->file == NULL);\n    assert(options != NULL && bs->options != options);\n\n    if (file != NULL) {\n        filename = file->filename;\n    } else {\n        filename = qdict_get_try_str(options, \"filename\");\n    }\n\n    if (drv->bdrv_needs_filename && !filename) {\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n                   drv->format_name);\n        return -EINVAL;\n    }\n\n    trace_bdrv_open_common(bs, filename ?: \"\", flags, drv->format_name);\n\n    node_name = qdict_get_try_str(options, \"node-name\");\n    ret = bdrv_assign_node_name(bs, node_name, errp);\n    if (ret < 0) {\n        return ret;\n    }\n    qdict_del(options, \"node-name\");\n\n    /* bdrv_open() with directly using a protocol as drv. This layer is already\n     * opened, so assign it to bs (while file becomes a closed BlockDriverState)\n     * and return immediately. */\n    if (file != NULL && drv->bdrv_file_open) {\n        bdrv_swap(file, bs);\n        return 0;\n    }\n\n    bs->open_flags = flags;\n    bs->guest_block_size = 512;\n    bs->request_alignment = 512;\n    bs->zero_beyond_eof = true;\n    open_flags = bdrv_open_flags(bs, flags);\n    bs->read_only = !(open_flags & BDRV_O_RDWR);\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, bs->read_only)) {\n        error_setg(errp,\n                   !bs->read_only && bdrv_is_whitelisted(drv, true)\n                        ? \"Driver '%s' can only be used for read-only devices\"\n                        : \"Driver '%s' is not whitelisted\",\n                   drv->format_name);\n        return -ENOTSUP;\n    }\n\n    assert(bs->copy_on_read == 0); /* bdrv_new() and bdrv_close() make it so */\n    if (flags & BDRV_O_COPY_ON_READ) {\n        if (!bs->read_only) {\n            bdrv_enable_copy_on_read(bs);\n        } else {\n            error_setg(errp, \"Can't use copy-on-read on read-only device\");\n            return -EINVAL;\n        }\n    }\n\n    if (filename != NULL) {\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n    } else {\n        bs->filename[0] = '\\0';\n    }\n\n    bs->drv = drv;\n    bs->opaque = g_malloc0(drv->instance_size);\n\n    bs->enable_write_cache = !!(flags & BDRV_O_CACHE_WB);\n\n    /* Open the image, either directly or using a protocol */\n    if (drv->bdrv_file_open) {\n        assert(file == NULL);\n        assert(!drv->bdrv_needs_filename || filename != NULL);\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n    } else {\n        if (file == NULL) {\n            error_setg(errp, \"Can't use '%s' as a block driver for the \"\n                       \"protocol level\", drv->format_name);\n            ret = -EINVAL;\n            goto free_and_fail;\n        }\n        bs->file = file;\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n    }\n\n    if (ret < 0) {\n        if (local_err) {\n            error_propagate(errp, local_err);\n        } else if (bs->filename[0]) {\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n        } else {\n            error_setg_errno(errp, -ret, \"Could not open image\");\n        }\n        goto free_and_fail;\n    }\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n        goto free_and_fail;\n    }\n\n    bdrv_refresh_limits(bs);\n    assert(bdrv_opt_mem_align(bs) != 0);\n    assert((bs->request_alignment != 0) || bs->sg);\n\n#ifndef _WIN32\n    if (bs->is_temporary) {\n        assert(bs->filename[0] != '\\0');\n        unlink(bs->filename);\n    }\n#endif\n    return 0;\n\nfree_and_fail:\n    bs->file = NULL;\n    g_free(bs->opaque);\n    bs->opaque = NULL;\n    bs->drv = NULL;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static int bdrv_open_common(BlockDriverState *bs, BlockDriverState *file,\n    QDict *options, int flags, BlockDriver *drv, Error **errp)\n{\n    int ret, open_flags;\n    const char *filename;\n    const char *node_name = NULL;\n    Error *local_err = NULL;\n\n    assert(drv != NULL);\n    assert(bs->file == NULL);\n    assert(options != NULL && bs->options != options);\n\n    if (file != NULL) {\n        filename = file->filename;\n    } else {\n        filename = qdict_get_try_str(options, \"filename\");\n    }\n\n    if (drv->bdrv_needs_filename && !filename) {\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n                   drv->format_name);\n        return -EINVAL;\n    }\n\n    trace_bdrv_open_common(bs, filename ?: \"\", flags, drv->format_name);\n\n    node_name = qdict_get_try_str(options, \"node-name\");\n    ret = bdrv_assign_node_name(bs, node_name, errp);\n    if (ret < 0) {\n        return ret;\n    }\n    qdict_del(options, \"node-name\");\n\n    /* bdrv_open() with directly using a protocol as drv. This layer is already\n     * opened, so assign it to bs (while file becomes a closed BlockDriverState)\n     * and return immediately. */\n    if (file != NULL && drv->bdrv_file_open) {\n        bdrv_swap(file, bs);\n        return 0;\n    }\n\n    bs->open_flags = flags;\n    bs->guest_block_size = 512;\n    bs->request_alignment = 512;\n    bs->zero_beyond_eof = true;\n    open_flags = bdrv_open_flags(bs, flags);\n    bs->read_only = !(open_flags & BDRV_O_RDWR);\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, bs->read_only)) {\n        error_setg(errp,\n                   !bs->read_only && bdrv_is_whitelisted(drv, true)\n                        ? \"Driver '%s' can only be used for read-only devices\"\n                        : \"Driver '%s' is not whitelisted\",\n                   drv->format_name);\n        return -ENOTSUP;\n    }\n\n    assert(bs->copy_on_read == 0); /* bdrv_new() and bdrv_close() make it so */\n    if (flags & BDRV_O_COPY_ON_READ) {\n        if (!bs->read_only) {\n            bdrv_enable_copy_on_read(bs);\n        } else {\n            error_setg(errp, \"Can't use copy-on-read on read-only device\");\n            return -EINVAL;\n        }\n    }\n\n    if (filename != NULL) {\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n    } else {\n        bs->filename[0] = '\\0';\n    }\n\n    bs->drv = drv;\n    bs->opaque = g_malloc0(drv->instance_size);\n\n    bs->enable_write_cache = !!(flags & BDRV_O_CACHE_WB);\n\n    /* Open the image, either directly or using a protocol */\n    if (drv->bdrv_file_open) {\n        assert(file == NULL);\n        assert(!drv->bdrv_needs_filename || filename != NULL);\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n    } else {\n        if (file == NULL) {\n            error_setg(errp, \"Can't use '%s' as a block driver for the \"\n                       \"protocol level\", drv->format_name);\n            ret = -EINVAL;\n            goto free_and_fail;\n        }\n        bs->file = file;\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n    }\n\n    if (ret < 0) {\n        if (local_err) {\n            error_propagate(errp, local_err);\n        } else if (bs->filename[0]) {\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n        } else {\n            error_setg_errno(errp, -ret, \"Could not open image\");\n        }\n        goto free_and_fail;\n    }\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n        goto free_and_fail;\n    }\n\n    bdrv_refresh_limits(bs);\n    assert(bdrv_opt_mem_align(bs) != 0);\n    assert((bs->request_alignment != 0) || bs->sg);\n\n#ifndef _WIN32\n    if (bs->is_temporary) {\n        assert(bs->filename[0] != '\\0');\n        unlink(bs->filename);\n    }\n#endif\n    return 0;\n\nfree_and_fail:\n    bs->file = NULL;\n    g_free(bs->opaque);\n    bs->opaque = NULL;\n    bs->drv = NULL;\n    return ret;\n}\n",
        "linevul": 0.00014773476868867874
    },
    {
        "code": "void virtio_queue_set_rings(VirtIODevice *vdev, int n, hwaddr desc,\n                            hwaddr avail, hwaddr used)\n{\n    vdev->vq[n].vring.desc = desc;\n    vdev->vq[n].vring.avail = avail;\n    vdev->vq[n].vring.used = used;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "void virtio_queue_set_rings(VirtIODevice *vdev, int n, hwaddr desc,\n                            hwaddr avail, hwaddr used)\n{\n    vdev->vq[n].vring.desc = desc;\n    vdev->vq[n].vring.avail = avail;\n    vdev->vq[n].vring.used = used;\n}\n",
        "linevul": 4.5464763388736174e-05
    },
    {
        "code": "static void vmxnet3_process_tx_queue(VMXNET3State *s, int qidx)\n{\n    struct Vmxnet3_TxDesc txd;\n    uint32_t txd_idx;\n    uint32_t data_len;\n    hwaddr data_pa;\n\n    for (;;) {\n        if (!vmxnet3_pop_next_tx_descr(s, qidx, &txd, &txd_idx)) {\n            break;\n        }\n\n        vmxnet3_dump_tx_descr(&txd);\n\n        if (!s->skip_current_tx_pkt) {\n            data_len = (txd.len > 0) ? txd.len : VMXNET3_MAX_TX_BUF_SIZE;\n            data_pa = le64_to_cpu(txd.addr);\n\n            if (!vmxnet_tx_pkt_add_raw_fragment(s->tx_pkt,\n                                                data_pa,\n                                                data_len)) {\n                s->skip_current_tx_pkt = true;\n            }\n        }\n\n        if (s->tx_sop) {\n            vmxnet3_tx_retrieve_metadata(s, &txd);\n            s->tx_sop = false;\n         }\n \n         if (txd.eop) {\n            if (!s->skip_current_tx_pkt) {\n                vmxnet_tx_pkt_parse(s->tx_pkt);\n                 if (s->needs_vlan) {\n                     vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);\n                 }\n                    vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);\n                }\n\n                vmxnet3_send_packet(s, qidx);\n            } else {\n                vmxnet3_on_tx_done_update_stats(s, qidx,\n                                                VMXNET3_PKT_STATUS_ERROR);\n            }\n\n            vmxnet3_complete_packet(s, qidx, txd_idx);\n            s->tx_sop = true;\n            s->skip_current_tx_pkt = false;\n            vmxnet_tx_pkt_reset(s->tx_pkt);\n        }\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a7278b36fcab9af469563bd7b",
        "vul_func_with_fix": "static void vmxnet3_process_tx_queue(VMXNET3State *s, int qidx)\n{\n    struct Vmxnet3_TxDesc txd;\n    uint32_t txd_idx;\n    uint32_t data_len;\n    hwaddr data_pa;\n\n    for (;;) {\n        if (!vmxnet3_pop_next_tx_descr(s, qidx, &txd, &txd_idx)) {\n            break;\n        }\n\n        vmxnet3_dump_tx_descr(&txd);\n\n        if (!s->skip_current_tx_pkt) {\n            data_len = (txd.len > 0) ? txd.len : VMXNET3_MAX_TX_BUF_SIZE;\n            data_pa = le64_to_cpu(txd.addr);\n\n            if (!vmxnet_tx_pkt_add_raw_fragment(s->tx_pkt,\n                                                data_pa,\n                                                data_len)) {\n                s->skip_current_tx_pkt = true;\n            }\n        }\n\n        if (s->tx_sop) {\n            vmxnet3_tx_retrieve_metadata(s, &txd);\n            s->tx_sop = false;\n         }\n \n         if (txd.eop) {\n//flaw_line_below:\n            if (!s->skip_current_tx_pkt) {\n//flaw_line_below:\n                vmxnet_tx_pkt_parse(s->tx_pkt);\n//flaw_line_below:\n\n//fix_flaw_line_below:\n//            if (!s->skip_current_tx_pkt && vmxnet_tx_pkt_parse(s->tx_pkt)) {\n                 if (s->needs_vlan) {\n                     vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);\n                 }\n                    vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);\n                }\n\n                vmxnet3_send_packet(s, qidx);\n            } else {\n                vmxnet3_on_tx_done_update_stats(s, qidx,\n                                                VMXNET3_PKT_STATUS_ERROR);\n            }\n\n            vmxnet3_complete_packet(s, qidx, txd_idx);\n            s->tx_sop = true;\n            s->skip_current_tx_pkt = false;\n            vmxnet_tx_pkt_reset(s->tx_pkt);\n        }\n    }\n",
        "linevul": 9.467508061788976e-05
    },
    {
        "code": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n         }\n     }\n    return 0;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=156a2e4dbffa85997636a7a39ef12da6f1b40254",
        "vul_func_with_fix": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n//flaw_line_below:\n    uint32_t i, len, pid, dir, devaddr, endp;\n//fix_flaw_line_below:\n//    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n//fix_flaw_line_below:\n//            xfers++;\n         }\n     }\n//flaw_line_below:\n    return 0;\n//fix_flaw_line_below:\n//    return xfers ? 0 : -1;\n }\n",
        "linevul": 0.9993383288383484
    },
    {
        "code": "static void usb_ohci_realize_pci(PCIDevice *dev, Error **errp)\n{\n    Error *err = NULL;\n    OHCIPCIState *ohci = PCI_OHCI(dev);\n\n    dev->config[PCI_CLASS_PROG] = 0x10; /* OHCI */\n    dev->config[PCI_INTERRUPT_PIN] = 0x01; /* interrupt pin A */\n\n    usb_ohci_init(&ohci->state, DEVICE(dev), ohci->num_ports, 0,\n                  ohci->masterbus, ohci->firstport,\n                  pci_get_address_space(dev), &err);\n    if (err) {\n        error_propagate(errp, err);\n        return;\n    }\n\n    ohci->state.irq = pci_allocate_irq(dev);\n    pci_register_bar(dev, 0, 0, &ohci->state.mem);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void usb_ohci_realize_pci(PCIDevice *dev, Error **errp)\n{\n    Error *err = NULL;\n    OHCIPCIState *ohci = PCI_OHCI(dev);\n\n    dev->config[PCI_CLASS_PROG] = 0x10; /* OHCI */\n    dev->config[PCI_INTERRUPT_PIN] = 0x01; /* interrupt pin A */\n\n    usb_ohci_init(&ohci->state, DEVICE(dev), ohci->num_ports, 0,\n                  ohci->masterbus, ohci->firstport,\n                  pci_get_address_space(dev), &err);\n    if (err) {\n        error_propagate(errp, err);\n        return;\n    }\n\n    ohci->state.irq = pci_allocate_irq(dev);\n    pci_register_bar(dev, 0, 0, &ohci->state.mem);\n}\n",
        "linevul": 4.7666097088949755e-05
    },
    {
        "code": "static void tsc210x_timer_tick(void *opaque)\n{\n    TSC210xState *s = opaque;\n\n    /* Timer ticked -- a set of conversions has been finished.  */\n\n    if (!s->busy)\n        return;\n\n    s->busy = 0;\n    s->dav |= mode_regs[s->function];\n    tsc210x_pin_update(s);\n    qemu_irq_lower(s->davint);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f",
        "vul_func_with_fix": "static void tsc210x_timer_tick(void *opaque)\n{\n    TSC210xState *s = opaque;\n\n    /* Timer ticked -- a set of conversions has been finished.  */\n\n    if (!s->busy)\n        return;\n\n    s->busy = 0;\n    s->dav |= mode_regs[s->function];\n    tsc210x_pin_update(s);\n    qemu_irq_lower(s->davint);\n}\n",
        "linevul": 4.6330933400895447e-05
    },
    {
        "code": "void qemu_spice_destroy_update(SimpleSpiceDisplay *sdpy, SimpleSpiceUpdate *update)\n{\n    g_free(update->bitmap);\n    g_free(update);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "void qemu_spice_destroy_update(SimpleSpiceDisplay *sdpy, SimpleSpiceUpdate *update)\n{\n    g_free(update->bitmap);\n    g_free(update);\n}\n",
        "linevul": 6.11923387623392e-05
    },
    {
        "code": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    slot = &xhci->slots[slotid-1];\n\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    }\n\n    xhci_ep_nuke_xfers(xhci, slotid, epid, 0);\n\n    epctx = slot->eps[epid-1];\n\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n        usb_packet_cleanup(&epctx->transfers[i].packet);\n    }\n\n    /* only touch guest RAM if we're not resetting the HC */\n    if (xhci->dcbaap_low || xhci->dcbaap_high) {\n        xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    }\n\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n\n    return CC_SUCCESS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b53dd4495ced2432a0b652ea895e651d07336f7e",
        "vul_func_with_fix": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    slot = &xhci->slots[slotid-1];\n\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    }\n\n    xhci_ep_nuke_xfers(xhci, slotid, epid, 0);\n\n    epctx = slot->eps[epid-1];\n\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(epctx->transfers); i++) {\n        usb_packet_cleanup(&epctx->transfers[i].packet);\n    }\n\n    /* only touch guest RAM if we're not resetting the HC */\n    if (xhci->dcbaap_low || xhci->dcbaap_high) {\n        xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    }\n\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n\n    return CC_SUCCESS;\n}\n",
        "linevul": 4.6645611291751266e-05
    },
    {
        "code": "static void tsc210x_write(TSC210xState *s, uint16_t value)\n{\n    /*\n     * This is a two-state state machine for reading\n     * command and data every second time.\n     */\n    if (!s->state) {\n        s->command = value >> 15;\n        s->page = (value >> 11) & 0x0f;\n        s->offset = (value >> 5) & 0x3f;\n        s->state = 1;\n    } else {\n        if (s->command)\n            fprintf(stderr, \"tsc210x_write: SPI overrun!\\n\");\n        else\n            switch (s->page) {\n            case TSC_DATA_REGISTERS_PAGE:\n                tsc2102_data_register_write(s, s->offset, value);\n                break;\n            case TSC_CONTROL_REGISTERS_PAGE:\n                tsc2102_control_register_write(s, s->offset, value);\n                break;\n            case TSC_AUDIO_REGISTERS_PAGE:\n                tsc2102_audio_register_write(s, s->offset, value);\n                break;\n            default:\n                hw_error(\"tsc210x_write: wrong memory page\\n\");\n            }\n\n        tsc210x_pin_update(s);\n        s->state = 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f",
        "vul_func_with_fix": "static void tsc210x_write(TSC210xState *s, uint16_t value)\n{\n    /*\n     * This is a two-state state machine for reading\n     * command and data every second time.\n     */\n    if (!s->state) {\n        s->command = value >> 15;\n        s->page = (value >> 11) & 0x0f;\n        s->offset = (value >> 5) & 0x3f;\n        s->state = 1;\n    } else {\n        if (s->command)\n            fprintf(stderr, \"tsc210x_write: SPI overrun!\\n\");\n        else\n            switch (s->page) {\n            case TSC_DATA_REGISTERS_PAGE:\n                tsc2102_data_register_write(s, s->offset, value);\n                break;\n            case TSC_CONTROL_REGISTERS_PAGE:\n                tsc2102_control_register_write(s, s->offset, value);\n                break;\n            case TSC_AUDIO_REGISTERS_PAGE:\n                tsc2102_audio_register_write(s, s->offset, value);\n                break;\n            default:\n                hw_error(\"tsc210x_write: wrong memory page\\n\");\n            }\n\n        tsc210x_pin_update(s);\n        s->state = 0;\n    }\n}\n",
        "linevul": 6.460988515755162e-05
    },
    {
        "code": "hwaddr virtio_queue_get_desc_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "hwaddr virtio_queue_get_desc_addr(VirtIODevice *vdev, int n)\n{\n    return vdev->vq[n].vring.desc;\n}\n",
        "linevul": 4.860413901042193e-05
    },
    {
        "code": "static int proxy_lsetxattr(FsContext *ctx, V9fsPath *fs_path, const char *name,\n                           void *value, size_t size, int flags)\n{\n    int retval;\n    V9fsString xname, xvalue;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n\n    v9fs_string_init(&xvalue);\n    xvalue.size = size;\n    xvalue.data = g_malloc(size);\n    memcpy(xvalue.data, value, size);\n\n    retval = v9fs_request(ctx->private, T_LSETXATTR, value, fs_path, &xname,\n                          &xvalue, size, flags);\n    v9fs_string_free(&xname);\n    v9fs_string_free(&xvalue);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_lsetxattr(FsContext *ctx, V9fsPath *fs_path, const char *name,\n                           void *value, size_t size, int flags)\n{\n    int retval;\n    V9fsString xname, xvalue;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n\n    v9fs_string_init(&xvalue);\n    xvalue.size = size;\n    xvalue.data = g_malloc(size);\n    memcpy(xvalue.data, value, size);\n\n    retval = v9fs_request(ctx->private, T_LSETXATTR, value, fs_path, &xname,\n                          &xvalue, size, flags);\n    v9fs_string_free(&xname);\n    v9fs_string_free(&xvalue);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n",
        "linevul": 5.452112964121625e-05
    },
    {
        "code": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n    struct e1000_rx_desc desc;\n    dma_addr_t base;\n    unsigned int n, rdt;\n    uint32_t rdh_start;\n    uint16_t vlan_special = 0;\n    uint8_t vlan_status = 0, vlan_offset = 0;\n    uint8_t min_buf[MIN_BUF_SIZE];\n    size_t desc_offset;\n    size_t desc_size;\n    size_t total_size;\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n        return -1;\n\n    /* Pad to minimum Ethernet frame length */\n    if (size < sizeof(min_buf)) {\n        memcpy(min_buf, buf, size);\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n        buf = min_buf;\n        size = sizeof(min_buf);\n    }\n\n         size = sizeof(min_buf);\n     }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb",
        "vul_func_with_fix": "e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n    struct e1000_rx_desc desc;\n    dma_addr_t base;\n    unsigned int n, rdt;\n    uint32_t rdh_start;\n    uint16_t vlan_special = 0;\n    uint8_t vlan_status = 0, vlan_offset = 0;\n    uint8_t min_buf[MIN_BUF_SIZE];\n    size_t desc_offset;\n    size_t desc_size;\n    size_t total_size;\n\n    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))\n        return -1;\n\n    /* Pad to minimum Ethernet frame length */\n    if (size < sizeof(min_buf)) {\n        memcpy(min_buf, buf, size);\n        memset(&min_buf[size], 0, sizeof(min_buf) - size);\n        buf = min_buf;\n        size = sizeof(min_buf);\n    }\n\n         size = sizeof(min_buf);\n     }\n",
        "linevul": 0.00012009157944703475
    },
    {
        "code": "static inline void xhci_dma_write_u32s(XHCIState *xhci, dma_addr_t addr,\n                                       uint32_t *buf, size_t len)\n{\n    int i;\n    uint32_t tmp[5];\n    uint32_t n = len / sizeof(uint32_t);\n\n    assert((len % sizeof(uint32_t)) == 0);\n    assert(n <= ARRAY_SIZE(tmp));\n\n    for (i = 0; i < n; i++) {\n        tmp[i] = cpu_to_le32(buf[i]);\n    }\n    pci_dma_write(PCI_DEVICE(xhci), addr, tmp, len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static inline void xhci_dma_write_u32s(XHCIState *xhci, dma_addr_t addr,\n                                       uint32_t *buf, size_t len)\n{\n    int i;\n    uint32_t tmp[5];\n    uint32_t n = len / sizeof(uint32_t);\n\n    assert((len % sizeof(uint32_t)) == 0);\n    assert(n <= ARRAY_SIZE(tmp));\n\n    for (i = 0; i < n; i++) {\n        tmp[i] = cpu_to_le32(buf[i]);\n    }\n    pci_dma_write(PCI_DEVICE(xhci), addr, tmp, len);\n}\n",
        "linevul": 5.607786079053767e-05
    },
    {
        "code": "uint64_t xbzrle_mig_pages_cache_miss(void)\n{\n    return acct_info.xbzrle_cache_miss;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "uint64_t xbzrle_mig_pages_cache_miss(void)\n{\n    return acct_info.xbzrle_cache_miss;\n}\n",
        "linevul": 0.00012592572602443397
    },
    {
        "code": "void vga_dirty_log_stop(VGACommonState *s)\n{\n    memory_region_set_log(&s->vram, false, DIRTY_MEMORY_VGA);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "void vga_dirty_log_stop(VGACommonState *s)\n{\n    memory_region_set_log(&s->vram, false, DIRTY_MEMORY_VGA);\n}\n",
        "linevul": 4.7332807298516855e-05
    },
    {
        "code": "static int ehci_fill_queue(EHCIPacket *p)\n{\n    USBEndpoint *ep = p->packet.ep;\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd = p->qtd;\n    uint32_t qtdaddr;\n\n    for (;;) {\n        if (NLPTR_TBIT(qtd.next) != 0) {\n            break;\n        }\n        qtdaddr = qtd.next;\n        /*\n         * Detect circular td lists, Windows creates these, counting on the\n         * active bit going low after execution to make the queue stop.\n         */\n        QTAILQ_FOREACH(p, &q->packets, next) {\n            if (p->qtdaddr == qtdaddr) {\n                goto leave;\n            }\n        }\n        if (get_dwords(q->ehci, NLPTR_GET(qtdaddr),\n                       (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2) < 0) {\n            return -1;\n        }\n        ehci_trace_qtd(q, NLPTR_GET(qtdaddr), &qtd);\n        if (!(qtd.token & QTD_TOKEN_ACTIVE)) {\n            break;\n        }\n        if (!ehci_verify_pid(q, &qtd)) {\n            ehci_trace_guest_bug(q->ehci, \"guest queued token with wrong pid\");\n            break;\n        }\n        p = ehci_alloc_packet(q);\n        p->qtdaddr = qtdaddr;\n        p->qtd = qtd;\n        if (ehci_execute(p, \"queue\") == -1) {\n            return -1;\n        }\n        assert(p->packet.status == USB_RET_ASYNC);\n        p->async = EHCI_ASYNC_INFLIGHT;\n    }\nleave:\n    usb_device_flush_ep_queue(ep->dev, ep);\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_fill_queue(EHCIPacket *p)\n{\n    USBEndpoint *ep = p->packet.ep;\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd = p->qtd;\n    uint32_t qtdaddr;\n\n    for (;;) {\n        if (NLPTR_TBIT(qtd.next) != 0) {\n            break;\n        }\n        qtdaddr = qtd.next;\n        /*\n         * Detect circular td lists, Windows creates these, counting on the\n         * active bit going low after execution to make the queue stop.\n         */\n        QTAILQ_FOREACH(p, &q->packets, next) {\n            if (p->qtdaddr == qtdaddr) {\n                goto leave;\n            }\n        }\n        if (get_dwords(q->ehci, NLPTR_GET(qtdaddr),\n                       (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2) < 0) {\n            return -1;\n        }\n        ehci_trace_qtd(q, NLPTR_GET(qtdaddr), &qtd);\n        if (!(qtd.token & QTD_TOKEN_ACTIVE)) {\n            break;\n        }\n        if (!ehci_verify_pid(q, &qtd)) {\n            ehci_trace_guest_bug(q->ehci, \"guest queued token with wrong pid\");\n            break;\n        }\n        p = ehci_alloc_packet(q);\n        p->qtdaddr = qtdaddr;\n        p->qtd = qtd;\n        if (ehci_execute(p, \"queue\") == -1) {\n            return -1;\n        }\n        assert(p->packet.status == USB_RET_ASYNC);\n        p->async = EHCI_ASYNC_INFLIGHT;\n    }\nleave:\n    usb_device_flush_ep_queue(ep->dev, ep);\n    return 1;\n}\n",
        "linevul": 0.00013502560614142567
    },
    {
        "code": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n {\n     /* VPD - all zeros */\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"s256\");\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n {\n     /* VPD - all zeros */\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n//flaw_line_below:\n                              \"s256\");\n//fix_flaw_line_below:\n//                              \"*s256\");\n }\n",
        "linevul": 0.011750148609280586
    },
    {
        "code": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "vul_func_with_fix": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n//flaw_line_below:\n    if (bufoffs + buflen > length)\n//fix_flaw_line_below:\n//    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n//fix_flaw_line_below:\n//    }\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}\n",
        "linevul": 0.9988483190536499
    },
    {
        "code": "static void vnc_async_encoding_start(VncState *orig, VncState *local)\n{\n    local->vnc_encoding = orig->vnc_encoding;\n    local->features = orig->features;\n    local->ds = orig->ds;\n     local->vd = orig->vd;\n     local->lossy_rect = orig->lossy_rect;\n     local->write_pixels = orig->write_pixels;\n    local->clientds = orig->clientds;\n     local->tight = orig->tight;\n     local->zlib = orig->zlib;\n     local->hextile = orig->hextile;\n    local->output =  queue->buffer;\n    local->csock = -1; /* Don't do any network work on this thread */\n\n    buffer_reset(&local->output);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static void vnc_async_encoding_start(VncState *orig, VncState *local)\n{\n    local->vnc_encoding = orig->vnc_encoding;\n    local->features = orig->features;\n    local->ds = orig->ds;\n     local->vd = orig->vd;\n     local->lossy_rect = orig->lossy_rect;\n     local->write_pixels = orig->write_pixels;\n//flaw_line_below:\n    local->clientds = orig->clientds;\n//fix_flaw_line_below:\n//    local->client_pf = orig->client_pf;\n//fix_flaw_line_below:\n//    local->client_be = orig->client_be;\n     local->tight = orig->tight;\n     local->zlib = orig->zlib;\n     local->hextile = orig->hextile;\n    local->output =  queue->buffer;\n    local->csock = -1; /* Don't do any network work on this thread */\n\n    buffer_reset(&local->output);\n}\n",
        "linevul": 4.6067434595897794e-05
    },
    {
        "code": "static void coroutine_fn v9fs_setattr(void *opaque)\n{\n    int err = 0;\n    int32_t fid;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsIattr v9iattr;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"dI\", &fid, &v9iattr);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    trace_v9fs_setattr(pdu->tag, pdu->id, fid,\n                       v9iattr.valid, v9iattr.mode, v9iattr.uid, v9iattr.gid,\n                       v9iattr.size, v9iattr.atime_sec, v9iattr.mtime_sec);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (v9iattr.valid & P9_ATTR_MODE) {\n        err = v9fs_co_chmod(pdu, &fidp->path, v9iattr.mode);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_ATIME | P9_ATTR_MTIME)) {\n        struct timespec times[2];\n        if (v9iattr.valid & P9_ATTR_ATIME) {\n            if (v9iattr.valid & P9_ATTR_ATIME_SET) {\n                times[0].tv_sec = v9iattr.atime_sec;\n                times[0].tv_nsec = v9iattr.atime_nsec;\n            } else {\n                times[0].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9iattr.valid & P9_ATTR_MTIME) {\n            if (v9iattr.valid & P9_ATTR_MTIME_SET) {\n                times[1].tv_sec = v9iattr.mtime_sec;\n                times[1].tv_nsec = v9iattr.mtime_nsec;\n            } else {\n                times[1].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    /*\n     * If the only valid entry in iattr is ctime we can call\n     * chown(-1,-1) to update the ctime of the file\n     */\n    if ((v9iattr.valid & (P9_ATTR_UID | P9_ATTR_GID)) ||\n        ((v9iattr.valid & P9_ATTR_CTIME)\n         && !((v9iattr.valid & P9_ATTR_MASK) & ~P9_ATTR_CTIME))) {\n        if (!(v9iattr.valid & P9_ATTR_UID)) {\n            v9iattr.uid = -1;\n        }\n        if (!(v9iattr.valid & P9_ATTR_GID)) {\n            v9iattr.gid = -1;\n        }\n        err = v9fs_co_chown(pdu, &fidp->path, v9iattr.uid,\n                            v9iattr.gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_SIZE)) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9iattr.size);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\n    trace_v9fs_setattr_return(pdu->tag, pdu->id);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static void coroutine_fn v9fs_setattr(void *opaque)\n{\n    int err = 0;\n    int32_t fid;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsIattr v9iattr;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"dI\", &fid, &v9iattr);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    trace_v9fs_setattr(pdu->tag, pdu->id, fid,\n                       v9iattr.valid, v9iattr.mode, v9iattr.uid, v9iattr.gid,\n                       v9iattr.size, v9iattr.atime_sec, v9iattr.mtime_sec);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (v9iattr.valid & P9_ATTR_MODE) {\n        err = v9fs_co_chmod(pdu, &fidp->path, v9iattr.mode);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_ATIME | P9_ATTR_MTIME)) {\n        struct timespec times[2];\n        if (v9iattr.valid & P9_ATTR_ATIME) {\n            if (v9iattr.valid & P9_ATTR_ATIME_SET) {\n                times[0].tv_sec = v9iattr.atime_sec;\n                times[0].tv_nsec = v9iattr.atime_nsec;\n            } else {\n                times[0].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9iattr.valid & P9_ATTR_MTIME) {\n            if (v9iattr.valid & P9_ATTR_MTIME_SET) {\n                times[1].tv_sec = v9iattr.mtime_sec;\n                times[1].tv_nsec = v9iattr.mtime_nsec;\n            } else {\n                times[1].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    /*\n     * If the only valid entry in iattr is ctime we can call\n     * chown(-1,-1) to update the ctime of the file\n     */\n    if ((v9iattr.valid & (P9_ATTR_UID | P9_ATTR_GID)) ||\n        ((v9iattr.valid & P9_ATTR_CTIME)\n         && !((v9iattr.valid & P9_ATTR_MASK) & ~P9_ATTR_CTIME))) {\n        if (!(v9iattr.valid & P9_ATTR_UID)) {\n            v9iattr.uid = -1;\n        }\n        if (!(v9iattr.valid & P9_ATTR_GID)) {\n            v9iattr.gid = -1;\n        }\n        err = v9fs_co_chown(pdu, &fidp->path, v9iattr.uid,\n                            v9iattr.gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_SIZE)) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9iattr.size);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\n    trace_v9fs_setattr_return(pdu->tag, pdu->id);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 8.244674245361239e-05
    },
    {
        "code": "static void xhci_free_device_streams(XHCIState *xhci, unsigned int slotid,\n                                     uint32_t epmask)\n{\n    USBEndpoint *eps[30];\n    int nr_eps;\n\n    nr_eps = xhci_epmask_to_eps_with_streams(xhci, slotid, epmask, NULL, eps);\n    if (nr_eps) {\n        usb_device_free_streams(eps[0]->dev, eps, nr_eps);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_free_device_streams(XHCIState *xhci, unsigned int slotid,\n                                     uint32_t epmask)\n{\n    USBEndpoint *eps[30];\n    int nr_eps;\n\n    nr_eps = xhci_epmask_to_eps_with_streams(xhci, slotid, epmask, NULL, eps);\n    if (nr_eps) {\n        usb_device_free_streams(eps[0]->dev, eps, nr_eps);\n    }\n}\n",
        "linevul": 5.0011774874292314e-05
    },
    {
        "code": "static void virgl_cmd_resource_flush(VirtIOGPU *g,\n                                     struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_flush rf;\n    int i;\n\n    VIRTIO_GPU_FILL_CMD(rf);\n    trace_virtio_gpu_cmd_res_flush(rf.resource_id,\n                                   rf.r.width, rf.r.height, rf.r.x, rf.r.y);\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n        if (g->scanout[i].resource_id != rf.resource_id) {\n            continue;\n        }\n        virtio_gpu_rect_update(g, i, rf.r.x, rf.r.y, rf.r.width, rf.r.height);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=33243031dad02d161225ba99d782616da133f689",
        "vul_func_with_fix": "static void virgl_cmd_resource_flush(VirtIOGPU *g,\n                                     struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_flush rf;\n    int i;\n\n    VIRTIO_GPU_FILL_CMD(rf);\n    trace_virtio_gpu_cmd_res_flush(rf.resource_id,\n                                   rf.r.width, rf.r.height, rf.r.x, rf.r.y);\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n        if (g->scanout[i].resource_id != rf.resource_id) {\n            continue;\n        }\n        virtio_gpu_rect_update(g, i, rf.r.x, rf.r.y, rf.r.width, rf.r.height);\n    }\n}\n",
        "linevul": 4.858810643781908e-05
    },
    {
        "code": "static int proxy_open(FsContext *ctx, V9fsPath *fs_path,\n                      int flags, V9fsFidOpenState *fs)\n{\n    fs->fd = v9fs_request(ctx->private, T_OPEN, NULL, fs_path, flags);\n    if (fs->fd < 0) {\n        errno = -fs->fd;\n        fs->fd = -1;\n    }\n    return fs->fd;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_open(FsContext *ctx, V9fsPath *fs_path,\n                      int flags, V9fsFidOpenState *fs)\n{\n    fs->fd = v9fs_request(ctx->private, T_OPEN, NULL, fs_path, flags);\n    if (fs->fd < 0) {\n        errno = -fs->fd;\n        fs->fd = -1;\n    }\n    return fs->fd;\n}\n",
        "linevul": 5.4056072258390486e-05
    },
    {
        "code": "static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                               char *buf, size_t bufsz)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = readlinkat(fd, \"\", buf, bufsz);\n    close(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                               char *buf, size_t bufsz)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = readlinkat(fd, \"\", buf, bufsz);\n    close(fd);\n    return ret;\n}\n",
        "linevul": 7.097925845300779e-05
    },
    {
        "code": "static void v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.0010072941659018397
    },
    {
        "code": "static void ncq_finish(NCQTransferState *ncq_tfs)\n{\n    /* If we didn't error out, set our finished bit. Errored commands\n     * do not get a bit set for the SDB FIS ACT register, nor do they\n     * clear the outstanding bit in scr_act (PxSACT). */\n    if (!(ncq_tfs->drive->port_regs.scr_err & (1 << ncq_tfs->tag))) {\n        ncq_tfs->drive->finished |= (1 << ncq_tfs->tag);\n    }\n\n    ahci_write_fis_sdb(ncq_tfs->drive->hba, ncq_tfs);\n\n    DPRINTF(ncq_tfs->drive->port_no, \"NCQ transfer tag %d finished\\n\",\n            ncq_tfs->tag);\n\n    block_acct_done(blk_get_stats(ncq_tfs->drive->port.ifs[0].blk),\n                    &ncq_tfs->acct);\n    qemu_sglist_destroy(&ncq_tfs->sglist);\n    ncq_tfs->used = 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ncq_finish(NCQTransferState *ncq_tfs)\n{\n    /* If we didn't error out, set our finished bit. Errored commands\n     * do not get a bit set for the SDB FIS ACT register, nor do they\n     * clear the outstanding bit in scr_act (PxSACT). */\n    if (!(ncq_tfs->drive->port_regs.scr_err & (1 << ncq_tfs->tag))) {\n        ncq_tfs->drive->finished |= (1 << ncq_tfs->tag);\n    }\n\n    ahci_write_fis_sdb(ncq_tfs->drive->hba, ncq_tfs);\n\n    DPRINTF(ncq_tfs->drive->port_no, \"NCQ transfer tag %d finished\\n\",\n            ncq_tfs->tag);\n\n    block_acct_done(blk_get_stats(ncq_tfs->drive->port.ifs[0].blk),\n                    &ncq_tfs->acct);\n    qemu_sglist_destroy(&ncq_tfs->sglist);\n    ncq_tfs->used = 0;\n}\n",
        "linevul": 7.471807475667447e-05
    },
    {
        "code": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n     /* destroy msix memory region */\n     if (dev->msix_table && dev->msix_pba\n         && dev->msix_entry_used) {\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n     }\n \n     usb_bus_release(&xhci->bus);\n    usb_bus_release(&xhci->bus);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b53dd4495ced2432a0b652ea895e651d07336f7e",
        "vul_func_with_fix": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n     /* destroy msix memory region */\n     if (dev->msix_table && dev->msix_pba\n         && dev->msix_entry_used) {\n//flaw_line_below:\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n//flaw_line_below:\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n//fix_flaw_line_below:\n//        msix_uninit(dev, &xhci->mem, &xhci->mem);\n     }\n \n     usb_bus_release(&xhci->bus);\n    usb_bus_release(&xhci->bus);\n}\n",
        "linevul": 5.195845733396709e-05
    },
    {
        "code": "static int handle_init(FsContext *ctx)\n{\n    int ret, mnt_id;\n    struct statfs stbuf;\n    struct file_handle fh;\n    struct handle_data *data = g_malloc(sizeof(struct handle_data));\n\n    data->mountfd = open(ctx->fs_root, O_DIRECTORY);\n    if (data->mountfd < 0) {\n        ret = data->mountfd;\n        goto err_out;\n    }\n    ret = statfs(ctx->fs_root, &stbuf);\n    if (!ret) {\n        switch (stbuf.f_type) {\n        case EXT2_SUPER_MAGIC:\n        case BTRFS_SUPER_MAGIC:\n        case REISERFS_SUPER_MAGIC:\n        case XFS_SUPER_MAGIC:\n            ctx->exops.get_st_gen = handle_ioc_getversion;\n            break;\n        }\n    }\n    memset(&fh, 0, sizeof(struct file_handle));\n    ret = name_to_handle(data->mountfd, \".\", &fh, &mnt_id, 0);\n    if (ret && errno == EOVERFLOW) {\n        data->handle_bytes = fh.handle_bytes;\n        ctx->private = data;\n        ret = 0;\n        goto out;\n    }\n    /* we got 0 byte handle ? */\n    ret = -1;\n    close(data->mountfd);\nerr_out:\n    g_free(data);\nout:\n     return ret;\n }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_init(FsContext *ctx)\n{\n    int ret, mnt_id;\n    struct statfs stbuf;\n    struct file_handle fh;\n    struct handle_data *data = g_malloc(sizeof(struct handle_data));\n\n    data->mountfd = open(ctx->fs_root, O_DIRECTORY);\n    if (data->mountfd < 0) {\n        ret = data->mountfd;\n        goto err_out;\n    }\n    ret = statfs(ctx->fs_root, &stbuf);\n    if (!ret) {\n        switch (stbuf.f_type) {\n        case EXT2_SUPER_MAGIC:\n        case BTRFS_SUPER_MAGIC:\n        case REISERFS_SUPER_MAGIC:\n        case XFS_SUPER_MAGIC:\n            ctx->exops.get_st_gen = handle_ioc_getversion;\n            break;\n        }\n    }\n    memset(&fh, 0, sizeof(struct file_handle));\n    ret = name_to_handle(data->mountfd, \".\", &fh, &mnt_id, 0);\n    if (ret && errno == EOVERFLOW) {\n        data->handle_bytes = fh.handle_bytes;\n        ctx->private = data;\n        ret = 0;\n        goto out;\n    }\n    /* we got 0 byte handle ? */\n    ret = -1;\n    close(data->mountfd);\nerr_out:\n    g_free(data);\nout:\n     return ret;\n }\n",
        "linevul": 0.0003895122790709138
    },
    {
        "code": "int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n{\n    if (bs->drv->bdrv_check == NULL) {\n        return -ENOTSUP;\n    }\n\n    memset(res, 0, sizeof(*res));\n    return bs->drv->bdrv_check(bs, res, fix);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n{\n    if (bs->drv->bdrv_check == NULL) {\n        return -ENOTSUP;\n    }\n\n    memset(res, 0, sizeof(*res));\n    return bs->drv->bdrv_check(bs, res, fix);\n}\n",
        "linevul": 6.190616841195151e-05
    },
    {
        "code": "static void become_daemon(const char *pidfile)\n{\n#ifndef _WIN32\n    pid_t pid, sid;\n\n    pid = fork();\n    if (pid < 0) {\n        exit(EXIT_FAILURE);\n    }\n    if (pid > 0) {\n        exit(EXIT_SUCCESS);\n    }\n\n    if (pidfile) {\n        if (!ga_open_pidfile(pidfile)) {\n            g_critical(\"failed to create pidfile\");\n            exit(EXIT_FAILURE);\n         }\n     }\n \n    umask(0);\n     sid = setsid();\n     if (sid < 0) {\n         goto fail;\n    }\n    if ((chdir(\"/\")) < 0) {\n        goto fail;\n    }\n\n    reopen_fd_to_null(STDIN_FILENO);\n    reopen_fd_to_null(STDOUT_FILENO);\n    reopen_fd_to_null(STDERR_FILENO);\n    return;\n\nfail:\n    if (pidfile) {\n        unlink(pidfile);\n    }\n    g_critical(\"failed to daemonize\");\n    exit(EXIT_FAILURE);\n#endif\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c689b4f1bac352dcfd6ecb9a1d45337de0f1de67",
        "vul_func_with_fix": "static void become_daemon(const char *pidfile)\n{\n#ifndef _WIN32\n    pid_t pid, sid;\n\n    pid = fork();\n    if (pid < 0) {\n        exit(EXIT_FAILURE);\n    }\n    if (pid > 0) {\n        exit(EXIT_SUCCESS);\n    }\n\n    if (pidfile) {\n        if (!ga_open_pidfile(pidfile)) {\n            g_critical(\"failed to create pidfile\");\n            exit(EXIT_FAILURE);\n         }\n     }\n \n//flaw_line_below:\n    umask(0);\n//fix_flaw_line_below:\n//    umask(S_IRWXG | S_IRWXO);\n     sid = setsid();\n     if (sid < 0) {\n         goto fail;\n    }\n    if ((chdir(\"/\")) < 0) {\n        goto fail;\n    }\n\n    reopen_fd_to_null(STDIN_FILENO);\n    reopen_fd_to_null(STDOUT_FILENO);\n    reopen_fd_to_null(STDERR_FILENO);\n    return;\n\nfail:\n    if (pidfile) {\n        unlink(pidfile);\n    }\n    g_critical(\"failed to daemonize\");\n    exit(EXIT_FAILURE);\n#endif\n}\n",
        "linevul": 0.9966590404510498
    },
    {
        "code": "static int zrle_compress_data(VncState *vs, int level)\n{\n    z_streamp zstream = &vs->zrle.stream;\n\n    buffer_reset(&vs->zrle.zlib);\n\n    if (zstream->opaque != vs) {\n        int err;\n\n        zstream->zalloc = vnc_zlib_zalloc;\n        zstream->zfree = vnc_zlib_zfree;\n\n        err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n        if (err != Z_OK) {\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n            return -1;\n        }\n\n        zstream->opaque = vs;\n    }\n\n    /* reserve memory in output buffer */\n    buffer_reserve(&vs->zrle.zlib, vs->zrle.zrle.offset + 64);\n\n    /* set pointers */\n    zstream->next_in = vs->zrle.zrle.buffer;\n    zstream->avail_in = vs->zrle.zrle.offset;\n    zstream->next_out = vs->zrle.zlib.buffer + vs->zrle.zlib.offset;\n    zstream->avail_out = vs->zrle.zlib.capacity - vs->zrle.zlib.offset;\n    zstream->data_type = Z_BINARY;\n\n    /* start encoding */\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during zrle compression\\n\");\n        return -1;\n    }\n\n    vs->zrle.zlib.offset = vs->zrle.zlib.capacity - zstream->avail_out;\n    return vs->zrle.zlib.offset;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static int zrle_compress_data(VncState *vs, int level)\n{\n    z_streamp zstream = &vs->zrle.stream;\n\n    buffer_reset(&vs->zrle.zlib);\n\n    if (zstream->opaque != vs) {\n        int err;\n\n        zstream->zalloc = vnc_zlib_zalloc;\n        zstream->zfree = vnc_zlib_zfree;\n\n        err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n        if (err != Z_OK) {\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n            return -1;\n        }\n\n        zstream->opaque = vs;\n    }\n\n    /* reserve memory in output buffer */\n    buffer_reserve(&vs->zrle.zlib, vs->zrle.zrle.offset + 64);\n\n    /* set pointers */\n    zstream->next_in = vs->zrle.zrle.buffer;\n    zstream->avail_in = vs->zrle.zrle.offset;\n    zstream->next_out = vs->zrle.zlib.buffer + vs->zrle.zlib.offset;\n    zstream->avail_out = vs->zrle.zlib.capacity - vs->zrle.zlib.offset;\n    zstream->data_type = Z_BINARY;\n\n    /* start encoding */\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during zrle compression\\n\");\n        return -1;\n    }\n\n    vs->zrle.zlib.offset = vs->zrle.zlib.capacity - zstream->avail_out;\n    return vs->zrle.zlib.offset;\n}\n",
        "linevul": 5.5831551435403526e-05
    },
    {
        "code": "static int get_bool(QEMUFile *f, void *pv, size_t size)\n{\n    bool *v = pv;\n    *v = qemu_get_byte(f);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "static int get_bool(QEMUFile *f, void *pv, size_t size)\n{\n    bool *v = pv;\n    *v = qemu_get_byte(f);\n    return 0;\n}\n",
        "linevul": 6.382196443155408e-05
    },
    {
        "code": "static int tsc210x_load(QEMUFile *f, void *opaque, int version_id)\n{\n    TSC210xState *s = (TSC210xState *) opaque;\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    int i;\n\n    s->x = qemu_get_be16(f);\n    s->y = qemu_get_be16(f);\n    s->pressure = qemu_get_byte(f);\n\n    s->state = qemu_get_byte(f);\n    s->page = qemu_get_byte(f);\n    s->offset = qemu_get_byte(f);\n    s->command = qemu_get_byte(f);\n\n    s->irq = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dav);\n\n    timer_get(f, s->timer);\n     s->enabled = qemu_get_byte(f);\n     s->host_mode = qemu_get_byte(f);\n     s->function = qemu_get_byte(f);\n     s->nextfunction = qemu_get_byte(f);\n     s->precision = qemu_get_byte(f);\n     s->nextprecision = qemu_get_byte(f);\n     s->filter = qemu_get_byte(f);\n     s->pin_func = qemu_get_byte(f);\n     s->ref = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dac_power);\n\n    for (i = 0; i < 0x14; i ++)\n        qemu_get_be16s(f, &s->filter_data[i]);\n\n    s->busy = timer_pending(s->timer);\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f",
        "vul_func_with_fix": "static int tsc210x_load(QEMUFile *f, void *opaque, int version_id)\n{\n    TSC210xState *s = (TSC210xState *) opaque;\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    int i;\n\n    s->x = qemu_get_be16(f);\n    s->y = qemu_get_be16(f);\n    s->pressure = qemu_get_byte(f);\n\n    s->state = qemu_get_byte(f);\n    s->page = qemu_get_byte(f);\n    s->offset = qemu_get_byte(f);\n    s->command = qemu_get_byte(f);\n\n    s->irq = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dav);\n\n    timer_get(f, s->timer);\n     s->enabled = qemu_get_byte(f);\n     s->host_mode = qemu_get_byte(f);\n     s->function = qemu_get_byte(f);\n//fix_flaw_line_below:\n//    if (s->function < 0 || s->function >= ARRAY_SIZE(mode_regs)) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->nextfunction = qemu_get_byte(f);\n//fix_flaw_line_below:\n//    if (s->nextfunction < 0 || s->nextfunction >= ARRAY_SIZE(mode_regs)) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->precision = qemu_get_byte(f);\n//fix_flaw_line_below:\n//    if (s->precision < 0 || s->precision >= ARRAY_SIZE(resolution)) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->nextprecision = qemu_get_byte(f);\n//fix_flaw_line_below:\n//    if (s->nextprecision < 0 || s->nextprecision >= ARRAY_SIZE(resolution)) {\n//fix_flaw_line_below:\n//        return -EINVAL;\n//fix_flaw_line_below:\n//    }\n     s->filter = qemu_get_byte(f);\n     s->pin_func = qemu_get_byte(f);\n     s->ref = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dac_power);\n\n    for (i = 0; i < 0x14; i ++)\n        qemu_get_be16s(f, &s->filter_data[i]);\n\n    s->busy = timer_pending(s->timer);\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n\n    return 0;\n}\n",
        "linevul": 0.1055188849568367
    },
    {
        "code": "void vnc_zrle_clear(VncState *vs)\n{\n    if (vs->zrle.stream.opaque) {\n        deflateEnd(&vs->zrle.stream);\n    }\n    buffer_free(&vs->zrle.zrle);\n    buffer_free(&vs->zrle.fb);\n    buffer_free(&vs->zrle.zlib);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "void vnc_zrle_clear(VncState *vs)\n{\n    if (vs->zrle.stream.opaque) {\n        deflateEnd(&vs->zrle.stream);\n    }\n    buffer_free(&vs->zrle.zrle);\n    buffer_free(&vs->zrle.fb);\n    buffer_free(&vs->zrle.zlib);\n}\n",
        "linevul": 4.959676880389452e-05
    },
    {
        "code": "e1000e_mac_writereg(E1000ECore *core, int index, uint32_t val)\n{\n    core->mac[index] = val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_mac_writereg(E1000ECore *core, int index, uint32_t val)\n{\n    core->mac[index] = val;\n}\n",
        "linevul": 5.199414590606466e-05
    },
    {
        "code": "static XHCIStreamContext *xhci_find_stream(XHCIEPContext *epctx,\n                                           unsigned int streamid,\n                                           uint32_t *cc_error)\n{\n    XHCIStreamContext *sctx;\n    dma_addr_t base;\n    uint32_t ctx[2], sct;\n\n    assert(streamid != 0);\n    if (epctx->lsa) {\n        if (streamid >= epctx->nr_pstreams) {\n            *cc_error = CC_INVALID_STREAM_ID_ERROR;\n            return NULL;\n        }\n        sctx = epctx->pstreams + streamid;\n    } else {\n        FIXME(\"secondary streams not implemented yet\");\n    }\n\n    if (sctx->sct == -1) {\n        xhci_dma_read_u32s(epctx->xhci, sctx->pctx, ctx, sizeof(ctx));\n        sct = (ctx[0] >> 1) & 0x07;\n        if (epctx->lsa && sct != 1) {\n            *cc_error = CC_INVALID_STREAM_TYPE_ERROR;\n            return NULL;\n        }\n        sctx->sct = sct;\n        base = xhci_addr64(ctx[0] & ~0xf, ctx[1]);\n        xhci_ring_init(epctx->xhci, &sctx->ring, base);\n    }\n    return sctx;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static XHCIStreamContext *xhci_find_stream(XHCIEPContext *epctx,\n                                           unsigned int streamid,\n                                           uint32_t *cc_error)\n{\n    XHCIStreamContext *sctx;\n    dma_addr_t base;\n    uint32_t ctx[2], sct;\n\n    assert(streamid != 0);\n    if (epctx->lsa) {\n        if (streamid >= epctx->nr_pstreams) {\n            *cc_error = CC_INVALID_STREAM_ID_ERROR;\n            return NULL;\n        }\n        sctx = epctx->pstreams + streamid;\n    } else {\n        FIXME(\"secondary streams not implemented yet\");\n    }\n\n    if (sctx->sct == -1) {\n        xhci_dma_read_u32s(epctx->xhci, sctx->pctx, ctx, sizeof(ctx));\n        sct = (ctx[0] >> 1) & 0x07;\n        if (epctx->lsa && sct != 1) {\n            *cc_error = CC_INVALID_STREAM_TYPE_ERROR;\n            return NULL;\n        }\n        sctx->sct = sct;\n        base = xhci_addr64(ctx[0] & ~0xf, ctx[1]);\n        xhci_ring_init(epctx->xhci, &sctx->ring, base);\n    }\n    return sctx;\n}\n",
        "linevul": 0.001290898653678596
    },
    {
        "code": "iscsi_aio_cancel(BlockAIOCB *blockacb)\n{\n    IscsiAIOCB *acb = (IscsiAIOCB *)blockacb;\n    IscsiLun *iscsilun = acb->iscsilun;\n\n    if (acb->status != -EINPROGRESS) {\n        return;\n    }\n\n    /* send a task mgmt call to the target to cancel the task on the target */\n    iscsi_task_mgmt_abort_task_async(iscsilun->iscsi, acb->task,\n                                     iscsi_abort_task_cb, acb);\n\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_aio_cancel(BlockAIOCB *blockacb)\n{\n    IscsiAIOCB *acb = (IscsiAIOCB *)blockacb;\n    IscsiLun *iscsilun = acb->iscsilun;\n\n    if (acb->status != -EINPROGRESS) {\n        return;\n    }\n\n    /* send a task mgmt call to the target to cancel the task on the target */\n    iscsi_task_mgmt_abort_task_async(iscsilun->iscsi, acb->task,\n                                     iscsi_abort_task_cb, acb);\n\n}\n",
        "linevul": 4.8722107749199495e-05
    },
    {
        "code": "static void xhci_stall_ep(XHCITransfer *xfer)\n{\n    XHCIState *xhci = xfer->xhci;\n    XHCISlot *slot = &xhci->slots[xfer->slotid-1];\n    XHCIEPContext *epctx = slot->eps[xfer->epid-1];\n    uint32_t err;\n    XHCIStreamContext *sctx;\n\n    if (epctx->nr_pstreams) {\n        sctx = xhci_find_stream(epctx, xfer->streamid, &err);\n        if (sctx == NULL) {\n            return;\n        }\n        sctx->ring.dequeue = xfer->trbs[0].addr;\n        sctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, sctx, EP_HALTED);\n    } else {\n        epctx->ring.dequeue = xfer->trbs[0].addr;\n        epctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_HALTED);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b53dd4495ced2432a0b652ea895e651d07336f7e",
        "vul_func_with_fix": "static void xhci_stall_ep(XHCITransfer *xfer)\n{\n    XHCIState *xhci = xfer->xhci;\n    XHCISlot *slot = &xhci->slots[xfer->slotid-1];\n    XHCIEPContext *epctx = slot->eps[xfer->epid-1];\n    uint32_t err;\n    XHCIStreamContext *sctx;\n\n    if (epctx->nr_pstreams) {\n        sctx = xhci_find_stream(epctx, xfer->streamid, &err);\n        if (sctx == NULL) {\n            return;\n        }\n        sctx->ring.dequeue = xfer->trbs[0].addr;\n        sctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, sctx, EP_HALTED);\n    } else {\n        epctx->ring.dequeue = xfer->trbs[0].addr;\n        epctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_HALTED);\n    }\n}\n",
        "linevul": 4.6671942982356995e-05
    },
    {
        "code": "iscsi_process_write(void *arg)\n{\n    IscsiLun *iscsilun = arg;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    iscsi_service(iscsi, POLLOUT);\n    iscsi_set_events(iscsilun);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_process_write(void *arg)\n{\n    IscsiLun *iscsilun = arg;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n\n    iscsi_service(iscsi, POLLOUT);\n    iscsi_set_events(iscsilun);\n}\n",
        "linevul": 4.591252945829183e-05
    },
    {
        "code": "static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,\n                int x0, int y0, int x1, int y1, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    uint8_t *vram = s->vga.vram_ptr;\n    int bypl = surface_stride(surface);\n    int bypp = surface_bytes_per_pixel(surface);\n    int width = bypp * w;\n    int line = h;\n    uint8_t *ptr[2];\n\n    if (!vmsvga_verify_rect(surface, \"vmsvga_copy_rect/src\", x0, y0, w, h)) {\n        return -1;\n    }\n    if (!vmsvga_verify_rect(surface, \"vmsvga_copy_rect/dst\", x1, y1, w, h)) {\n        return -1;\n    }\n\n    if (y1 > y0) {\n        ptr[0] = vram + bypp * x0 + bypl * (y0 + h - 1);\n        ptr[1] = vram + bypp * x1 + bypl * (y1 + h - 1);\n        for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl) {\n            memmove(ptr[1], ptr[0], width);\n        }\n    } else {\n        ptr[0] = vram + bypp * x0 + bypl * y0;\n        ptr[1] = vram + bypp * x1 + bypl * y1;\n        for (; line > 0; line --, ptr[0] += bypl, ptr[1] += bypl) {\n            memmove(ptr[1], ptr[0], width);\n        }\n    }\n\n    vmsvga_update_rect_delayed(s, x1, y1, w, h);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static inline int vmsvga_copy_rect(struct vmsvga_state_s *s,\n                int x0, int y0, int x1, int y1, int w, int h)\n{\n    DisplaySurface *surface = qemu_console_surface(s->vga.con);\n    uint8_t *vram = s->vga.vram_ptr;\n    int bypl = surface_stride(surface);\n    int bypp = surface_bytes_per_pixel(surface);\n    int width = bypp * w;\n    int line = h;\n    uint8_t *ptr[2];\n\n    if (!vmsvga_verify_rect(surface, \"vmsvga_copy_rect/src\", x0, y0, w, h)) {\n        return -1;\n    }\n    if (!vmsvga_verify_rect(surface, \"vmsvga_copy_rect/dst\", x1, y1, w, h)) {\n        return -1;\n    }\n\n    if (y1 > y0) {\n        ptr[0] = vram + bypp * x0 + bypl * (y0 + h - 1);\n        ptr[1] = vram + bypp * x1 + bypl * (y1 + h - 1);\n        for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl) {\n            memmove(ptr[1], ptr[0], width);\n        }\n    } else {\n        ptr[0] = vram + bypp * x0 + bypl * y0;\n        ptr[1] = vram + bypp * x1 + bypl * y1;\n        for (; line > 0; line --, ptr[0] += bypl, ptr[1] += bypl) {\n            memmove(ptr[1], ptr[0], width);\n        }\n    }\n\n    vmsvga_update_rect_delayed(s, x1, y1, w, h);\n    return 0;\n}\n",
        "linevul": 6.0299669712549075e-05
    },
    {
        "code": "int kvm_available(void)\n{\n#ifdef CONFIG_KVM\n    return 1;\n#else\n    return 0;\n#endif\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "int kvm_available(void)\n{\n#ifdef CONFIG_KVM\n    return 1;\n#else\n    return 0;\n#endif\n}\n",
        "linevul": 4.9176058382727206e-05
    },
    {
        "code": "static void put_uint16(QEMUFile *f, void *pv, size_t size)\n{\n    uint16_t *v = pv;\n    qemu_put_be16s(f, v);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "static void put_uint16(QEMUFile *f, void *pv, size_t size)\n{\n    uint16_t *v = pv;\n    qemu_put_be16s(f, v);\n}\n",
        "linevul": 7.005056977504864e-05
    },
    {
        "code": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIStreamContext *stctx;\n    XHCIEPContext *epctx;\n    XHCIRing *ring;\n    USBEndpoint *ep = NULL;\n    uint64_t mfindex;\n    int length;\n    int i;\n\n    trace_usb_xhci_ep_kick(slotid, epid, streamid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n    }\n\n    /* If the device has been detached, but the guest has not noticed this\n       yet the 2 above checks will succeed, but we must NOT continue */\n    if (!xhci->slots[slotid - 1].uport ||\n        !xhci->slots[slotid - 1].uport->dev ||\n        !xhci->slots[slotid - 1].uport->dev->attached) {\n        return;\n    }\n\n    if (epctx->retry) {\n        XHCITransfer *xfer = epctx->retry;\n\n        trace_usb_xhci_xfer_retry(xfer);\n        assert(xfer->running_retry);\n        if (xfer->timed_xfer) {\n            /* time to kick the transfer? */\n            mfindex = xhci_mfindex_get(xhci);\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n            if (xfer->running_retry) {\n                return;\n            }\n            xfer->timed_xfer = 0;\n            xfer->running_retry = 1;\n        }\n        if (xfer->iso_xfer) {\n            /* retry iso transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            assert(xfer->packet.status != USB_RET_NAK);\n            xhci_complete_packet(xfer);\n        } else {\n            /* retry nak'ed transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            if (xfer->packet.status == USB_RET_NAK) {\n                return;\n            }\n            xhci_complete_packet(xfer);\n        }\n        assert(!xfer->running_retry);\n        epctx->retry = NULL;\n    }\n\n    if (epctx->state == EP_HALTED) {\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n        return;\n    }\n\n\n    if (epctx->nr_pstreams) {\n        uint32_t err;\n        stctx = xhci_find_stream(epctx, streamid, &err);\n        if (stctx == NULL) {\n            return;\n        }\n        ring = &stctx->ring;\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n    } else {\n        ring = &epctx->ring;\n        streamid = 0;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n    }\n    assert(ring->dequeue != 0);\n\n    while (1) {\n        XHCITransfer *xfer = &epctx->transfers[epctx->next_xfer];\n        if (xfer->running_async || xfer->running_retry) {\n            break;\n        }\n        length = xhci_ring_chain_length(xhci, ring);\n        if (length < 0) {\n            break;\n        } else if (length == 0) {\n            break;\n        }\n        if (xfer->trbs && xfer->trb_alloced < length) {\n            xfer->trb_count = 0;\n            xfer->trb_alloced = 0;\n            g_free(xfer->trbs);\n            xfer->trbs = NULL;\n        }\n        if (!xfer->trbs) {\n            xfer->trbs = g_malloc(sizeof(XHCITRB) * length);\n            xfer->trb_alloced = length;\n        }\n        xfer->trb_count = length;\n\n        for (i = 0; i < length; i++) {\n            assert(xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL));\n        }\n        xfer->streamid = streamid;\n\n        if (epid == 1) {\n            if (xhci_fire_ctl_transfer(xhci, xfer) >= 0) {\n                epctx->next_xfer = (epctx->next_xfer + 1) % TD_QUEUE;\n                ep = xfer->packet.ep;\n            } else {\n                DPRINTF(\"xhci: error firing CTL transfer\\n\");\n            }\n        } else {\n            if (xhci_fire_transfer(xhci, xfer, epctx) >= 0) {\n                epctx->next_xfer = (epctx->next_xfer + 1) % TD_QUEUE;\n            } else {\n                if (!xfer->timed_xfer) {\n                    DPRINTF(\"xhci: error firing data transfer\\n\");\n                }\n            }\n        }\n\n        if (epctx->state == EP_HALTED) {\n            break;\n        }\n        if (xfer->running_retry) {\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n            epctx->retry = xfer;\n            break;\n        }\n    }\n\n    ep = xhci_epid_to_usbep(xhci, slotid, epid);\n    if (ep) {\n        usb_device_flush_ep_queue(ep->dev, ep);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3afca1d6d413592c2b78cf28f52fa24a586d8f56",
        "vul_func_with_fix": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIStreamContext *stctx;\n    XHCIEPContext *epctx;\n    XHCIRing *ring;\n    USBEndpoint *ep = NULL;\n    uint64_t mfindex;\n    int length;\n    int i;\n\n    trace_usb_xhci_ep_kick(slotid, epid, streamid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n    }\n\n    /* If the device has been detached, but the guest has not noticed this\n       yet the 2 above checks will succeed, but we must NOT continue */\n    if (!xhci->slots[slotid - 1].uport ||\n        !xhci->slots[slotid - 1].uport->dev ||\n        !xhci->slots[slotid - 1].uport->dev->attached) {\n        return;\n    }\n\n    if (epctx->retry) {\n        XHCITransfer *xfer = epctx->retry;\n\n        trace_usb_xhci_xfer_retry(xfer);\n        assert(xfer->running_retry);\n        if (xfer->timed_xfer) {\n            /* time to kick the transfer? */\n            mfindex = xhci_mfindex_get(xhci);\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n            if (xfer->running_retry) {\n                return;\n            }\n            xfer->timed_xfer = 0;\n            xfer->running_retry = 1;\n        }\n        if (xfer->iso_xfer) {\n            /* retry iso transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            assert(xfer->packet.status != USB_RET_NAK);\n            xhci_complete_packet(xfer);\n        } else {\n            /* retry nak'ed transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            if (xfer->packet.status == USB_RET_NAK) {\n                return;\n            }\n            xhci_complete_packet(xfer);\n        }\n        assert(!xfer->running_retry);\n        epctx->retry = NULL;\n    }\n\n    if (epctx->state == EP_HALTED) {\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n        return;\n    }\n\n\n    if (epctx->nr_pstreams) {\n        uint32_t err;\n        stctx = xhci_find_stream(epctx, streamid, &err);\n        if (stctx == NULL) {\n            return;\n        }\n        ring = &stctx->ring;\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n    } else {\n        ring = &epctx->ring;\n        streamid = 0;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n    }\n    assert(ring->dequeue != 0);\n\n    while (1) {\n        XHCITransfer *xfer = &epctx->transfers[epctx->next_xfer];\n        if (xfer->running_async || xfer->running_retry) {\n            break;\n        }\n        length = xhci_ring_chain_length(xhci, ring);\n        if (length < 0) {\n            break;\n        } else if (length == 0) {\n            break;\n        }\n        if (xfer->trbs && xfer->trb_alloced < length) {\n            xfer->trb_count = 0;\n            xfer->trb_alloced = 0;\n            g_free(xfer->trbs);\n            xfer->trbs = NULL;\n        }\n        if (!xfer->trbs) {\n            xfer->trbs = g_malloc(sizeof(XHCITRB) * length);\n            xfer->trb_alloced = length;\n        }\n        xfer->trb_count = length;\n\n        for (i = 0; i < length; i++) {\n            assert(xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL));\n        }\n        xfer->streamid = streamid;\n\n        if (epid == 1) {\n            if (xhci_fire_ctl_transfer(xhci, xfer) >= 0) {\n                epctx->next_xfer = (epctx->next_xfer + 1) % TD_QUEUE;\n                ep = xfer->packet.ep;\n            } else {\n                DPRINTF(\"xhci: error firing CTL transfer\\n\");\n            }\n        } else {\n            if (xhci_fire_transfer(xhci, xfer, epctx) >= 0) {\n                epctx->next_xfer = (epctx->next_xfer + 1) % TD_QUEUE;\n            } else {\n                if (!xfer->timed_xfer) {\n                    DPRINTF(\"xhci: error firing data transfer\\n\");\n                }\n            }\n        }\n\n        if (epctx->state == EP_HALTED) {\n            break;\n        }\n        if (xfer->running_retry) {\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n            epctx->retry = xfer;\n            break;\n        }\n    }\n\n    ep = xhci_epid_to_usbep(xhci, slotid, epid);\n    if (ep) {\n        usb_device_flush_ep_queue(ep->dev, ep);\n    }\n}\n",
        "linevul": 7.076351903378963e-05
    },
    {
        "code": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n{\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    /* Check that the transport told us it was going to do this\n     * (so a buggy transport will immediately assert rather than\n     * silently failing to migrate this state)\n     */\n    assert(k->has_variable_vring_alignment);\n\n    vdev->vq[n].vring.align = align;\n    virtqueue_init(&vdev->vq[n]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n{\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    /* Check that the transport told us it was going to do this\n     * (so a buggy transport will immediately assert rather than\n     * silently failing to migrate this state)\n     */\n    assert(k->has_variable_vring_alignment);\n\n    vdev->vq[n].vring.align = align;\n    virtqueue_init(&vdev->vq[n]);\n}\n",
        "linevul": 4.5235210563987494e-05
    },
    {
        "code": "static void vnc_client_cache_addr(VncState *client)\n{\n    QDict *qdict;\n\n    qdict = qdict_new();\n    if (vnc_qdict_remote_addr(qdict, client->csock) < 0) {\n        QDECREF(qdict);\n        /* XXX: how to report the error? */\n        return;\n    }\n\n    client->info = QOBJECT(qdict);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static void vnc_client_cache_addr(VncState *client)\n{\n    QDict *qdict;\n\n    qdict = qdict_new();\n    if (vnc_qdict_remote_addr(qdict, client->csock) < 0) {\n        QDECREF(qdict);\n        /* XXX: how to report the error? */\n        return;\n    }\n\n    client->info = QOBJECT(qdict);\n}\n",
        "linevul": 5.368736310629174e-05
    },
    {
        "code": "static void lsi_script_scsi_interrupt(LSIState *s, int stat0, int stat1)\n{\n    uint32_t mask0;\n    uint32_t mask1;\n\n    trace_lsi_script_scsi_interrupt(stat1, stat0, s->sist1, s->sist0);\n    s->sist0 |= stat0;\n    s->sist1 |= stat1;\n    /* Stop processor on fatal or unmasked interrupt.  As a special hack\n       we don't stop processing when raising STO.  Instead continue\n       execution and stop at the next insn that accesses the SCSI bus.  */\n    mask0 = s->sien0 | ~(LSI_SIST0_CMP | LSI_SIST0_SEL | LSI_SIST0_RSL);\n    mask1 = s->sien1 | ~(LSI_SIST1_GEN | LSI_SIST1_HTH);\n    mask1 &= ~LSI_SIST1_STO;\n    if (s->sist0 & mask0 || s->sist1 & mask1) {\n        lsi_stop_script(s);\n    }\n    lsi_update_irq(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08",
        "vul_func_with_fix": "static void lsi_script_scsi_interrupt(LSIState *s, int stat0, int stat1)\n{\n    uint32_t mask0;\n    uint32_t mask1;\n\n    trace_lsi_script_scsi_interrupt(stat1, stat0, s->sist1, s->sist0);\n    s->sist0 |= stat0;\n    s->sist1 |= stat1;\n    /* Stop processor on fatal or unmasked interrupt.  As a special hack\n       we don't stop processing when raising STO.  Instead continue\n       execution and stop at the next insn that accesses the SCSI bus.  */\n    mask0 = s->sien0 | ~(LSI_SIST0_CMP | LSI_SIST0_SEL | LSI_SIST0_RSL);\n    mask1 = s->sien1 | ~(LSI_SIST1_GEN | LSI_SIST1_HTH);\n    mask1 &= ~LSI_SIST1_STO;\n    if (s->sist0 & mask0 || s->sist1 & mask1) {\n        lsi_stop_script(s);\n    }\n    lsi_update_irq(s);\n}\n",
        "linevul": 4.771676685777493e-05
    },
    {
        "code": "static int get_uint32_equal(QEMUFile *f, void *pv, size_t size)\n{\n    uint32_t *v = pv;\n    uint32_t v2;\n    qemu_get_be32s(f, &v2);\n\n    if (*v == v2) {\n        return 0;\n    }\n    return -EINVAL;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "static int get_uint32_equal(QEMUFile *f, void *pv, size_t size)\n{\n    uint32_t *v = pv;\n    uint32_t v2;\n    qemu_get_be32s(f, &v2);\n\n    if (*v == v2) {\n        return 0;\n    }\n    return -EINVAL;\n}\n",
        "linevul": 5.255215000943281e-05
    },
    {
        "code": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n                                  int64_t size)\n{\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n    if (ret < 0) {\n        return ret;\n    } else if (ret > 0) {\n        int metadata_ol_bitnr = ffs(ret) - 1;\n        char *message;\n        QObject *data;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n        fprintf(stderr, \"qcow2: Preventing invalid write on metadata (overlaps \"\n                \"with %s); image marked as corrupt.\\n\",\n                metadata_ol_names[metadata_ol_bitnr]);\n        message = g_strdup_printf(\"Prevented %s overwrite\",\n                metadata_ol_names[metadata_ol_bitnr]);\n        data = qobject_from_jsonf(\"{ 'device': %s, 'msg': %s, 'offset': %\"\n                PRId64 \", 'size': %\" PRId64 \" }\", bs->device_name, message,\n                offset, size);\n        monitor_protocol_event(QEVENT_BLOCK_IMAGE_CORRUPTED, data);\n        g_free(message);\n        qobject_decref(data);\n\n        qcow2_mark_corrupt(bs);\n        bs->drv = NULL; /* make BDS unusable */\n        return -EIO;\n    }\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": "int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n                                  int64_t size)\n{\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n    if (ret < 0) {\n        return ret;\n    } else if (ret > 0) {\n        int metadata_ol_bitnr = ffs(ret) - 1;\n        char *message;\n        QObject *data;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n        fprintf(stderr, \"qcow2: Preventing invalid write on metadata (overlaps \"\n                \"with %s); image marked as corrupt.\\n\",\n                metadata_ol_names[metadata_ol_bitnr]);\n        message = g_strdup_printf(\"Prevented %s overwrite\",\n                metadata_ol_names[metadata_ol_bitnr]);\n        data = qobject_from_jsonf(\"{ 'device': %s, 'msg': %s, 'offset': %\"\n                PRId64 \", 'size': %\" PRId64 \" }\", bs->device_name, message,\n                offset, size);\n        monitor_protocol_event(QEVENT_BLOCK_IMAGE_CORRUPTED, data);\n        g_free(message);\n        qobject_decref(data);\n\n        qcow2_mark_corrupt(bs);\n        bs->drv = NULL; /* make BDS unusable */\n        return -EIO;\n    }\n\n    return 0;\n}\n",
        "linevul": 6.0035279602743685e-05
    },
    {
        "code": "virtio_gpu_resource_attach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(ab);\n    trace_virtio_gpu_cmd_res_back_attach(ab.resource_id);\n\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    res->iov_cnt = ab.nr_entries;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "virtio_gpu_resource_attach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(ab);\n    trace_virtio_gpu_cmd_res_back_attach(ab.resource_id);\n\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    res->iov_cnt = ab.nr_entries;\n}\n",
        "linevul": 6.389802001649514e-05
    },
    {
        "code": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4c1586787ff43c9acd18a56c12d720e3e6be9f7c",
        "vul_func_with_fix": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n//fix_flaw_line_below:\n//    put_fid(pdu, oldfidp);\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 8.934652578318492e-05
    },
    {
        "code": "void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "void vnc_read_when(VncState *vs, VncReadEvent *func, size_t expecting)\n{\n    vs->read_handler = func;\n    vs->read_handler_expect = expecting;\n}\n",
        "linevul": 4.6897617721697316e-05
    },
    {
        "code": "MemTxResult address_space_read(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,\n                               uint8_t *buf, int len)\n{\n    return address_space_rw(as, addr, attrs, buf, len, false);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b242e0e0e2969c044a318e56f7988bbd84de1f63",
        "vul_func_with_fix": "MemTxResult address_space_read(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,\n                               uint8_t *buf, int len)\n{\n    return address_space_rw(as, addr, attrs, buf, len, false);\n}\n",
        "linevul": 6.149077671580017e-05
    },
    {
        "code": "static uint64_t megasas_port_read(void *opaque, hwaddr addr,\n                                  unsigned size)\n{\n    return megasas_mmio_read(opaque, addr & 0xff, size);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static uint64_t megasas_port_read(void *opaque, hwaddr addr,\n                                  unsigned size)\n{\n    return megasas_mmio_read(opaque, addr & 0xff, size);\n}\n",
        "linevul": 5.001626050216146e-05
    },
    {
        "code": "static void put_int32(QEMUFile *f, void *pv, size_t size)\n{\n    int32_t *v = pv;\n    qemu_put_sbe32s(f, v);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "static void put_int32(QEMUFile *f, void *pv, size_t size)\n{\n    int32_t *v = pv;\n    qemu_put_sbe32s(f, v);\n}\n",
        "linevul": 6.951912655495107e-05
    },
    {
        "code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n//fix_flaw_line_below:\n//    if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {\n//fix_flaw_line_below:\n//        return -EIO;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }\n",
        "linevul": 0.9982567429542542
    },
    {
        "code": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n         if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n             qemu_get_buffer(f, n->mac_table.macs,\n                             n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n             n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n             n->mac_table.in_use = 0;\n         }\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=98f93ddd84800f207889491e0b5d851386b459cf",
        "vul_func_with_fix": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n         if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n             qemu_get_buffer(f, n->mac_table.macs,\n                             n->mac_table.in_use * ETH_ALEN);\n//flaw_line_below:\n        } else if (n->mac_table.in_use) {\n//flaw_line_below:\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n//flaw_line_below:\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n//flaw_line_below:\n            g_free(buf);\n//fix_flaw_line_below:\n//        } else {\n//fix_flaw_line_below:\n//            int64_t i;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//            /* Overflow detected - can happen if source has a larger MAC table.\n//fix_flaw_line_below:\n//             * We simply set overflow flag so there's no need to maintain the\n//fix_flaw_line_below:\n//             * table of addresses, discard them all.\n//fix_flaw_line_below:\n//             * Note: 64 bit math to avoid integer overflow.\n//fix_flaw_line_below:\n//             */\n//fix_flaw_line_below:\n//            for (i = 0; i < (int64_t)n->mac_table.in_use * ETH_ALEN; ++i) {\n//fix_flaw_line_below:\n//                qemu_get_byte(f);\n//fix_flaw_line_below:\n//            }\n             n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n             n->mac_table.in_use = 0;\n         }\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n",
        "linevul": 6.0256450524320826e-05
    },
    {
        "code": "static int proxy_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n{\n    V9fsString fullname;\n\n    v9fs_string_init(&fullname);\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    fs->fd = v9fs_request(fs_ctx->private, T_CREATE, NULL, &fullname, flags,\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n    v9fs_string_free(&fullname);\n    if (fs->fd < 0) {\n        errno = -fs->fd;\n        fs->fd = -1;\n    }\n    return fs->fd;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n{\n    V9fsString fullname;\n\n    v9fs_string_init(&fullname);\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    fs->fd = v9fs_request(fs_ctx->private, T_CREATE, NULL, &fullname, flags,\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n    v9fs_string_free(&fullname);\n    if (fs->fd < 0) {\n        errno = -fs->fd;\n        fs->fd = -1;\n    }\n    return fs->fd;\n}\n",
        "linevul": 5.657950896420516e-05
    },
    {
        "code": "static inline TCGMemOp mo_stacksize(DisasContext *s)\n{\n    return CODE64(s) ? MO_64 : s->ss32 ? MO_32 : MO_16;\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline TCGMemOp mo_stacksize(DisasContext *s)\n{\n    return CODE64(s) ? MO_64 : s->ss32 ? MO_32 : MO_16;\n}\n",
        "linevul": 5.227803558227606e-05
    },
    {
        "code": "static int mptsas_post_load(void *opaque, int version_id)\n{\n    MPTSASState *s = opaque;\n\n    if (s->doorbell_idx > s->doorbell_cnt ||\n        s->doorbell_cnt > ARRAY_SIZE(s->doorbell_msg) ||\n        s->doorbell_reply_idx > s->doorbell_reply_size ||\n        s->doorbell_reply_size > ARRAY_SIZE(s->doorbell_reply) ||\n        MPTSAS_FIFO_INVALID(s, request_post) ||\n        MPTSAS_FIFO_INVALID(s, reply_post) ||\n        MPTSAS_FIFO_INVALID(s, reply_free) ||\n        s->diagnostic_idx > 4) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static int mptsas_post_load(void *opaque, int version_id)\n{\n    MPTSASState *s = opaque;\n\n    if (s->doorbell_idx > s->doorbell_cnt ||\n        s->doorbell_cnt > ARRAY_SIZE(s->doorbell_msg) ||\n        s->doorbell_reply_idx > s->doorbell_reply_size ||\n        s->doorbell_reply_size > ARRAY_SIZE(s->doorbell_reply) ||\n        MPTSAS_FIFO_INVALID(s, request_post) ||\n        MPTSAS_FIFO_INVALID(s, reply_post) ||\n        MPTSAS_FIFO_INVALID(s, reply_free) ||\n        s->diagnostic_idx > 4) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n",
        "linevul": 0.0005050929612480104
    },
    {
        "code": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n     struct stat stbuf;\n     V9fsFidState *fidp;\n     V9fsPDU *pdu = opaque;\n \n     v9fs_stat_init(&v9stat);\n     err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n        goto out_nofid;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n     struct stat stbuf;\n     V9fsFidState *fidp;\n     V9fsPDU *pdu = opaque;\n//fix_flaw_line_below:\n//    V9fsState *s = pdu->s;\n \n     v9fs_stat_init(&v9stat);\n     err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n        goto out_nofid;\n    }\n",
        "linevul": 0.9955767393112183
    },
    {
        "code": "static unsigned virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,\n                                         hwaddr desc_pa, unsigned int max)\n{\n    unsigned int next;\n\n    /* If this descriptor says it doesn't chain, we're done. */\n    if (!(desc->flags & VRING_DESC_F_NEXT)) {\n        return max;\n    }\n\n    /* Check they're not leading us off end of descriptors. */\n    next = desc->next;\n    /* Make sure compiler knows to grab that: we don't want it changing! */\n    smp_wmb();\n\n    if (next >= max) {\n        error_report(\"Desc next is %u\", next);\n        exit(1);\n    }\n\n    vring_desc_read(vdev, desc, desc_pa, next);\n    return next;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static unsigned virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,\n                                         hwaddr desc_pa, unsigned int max)\n{\n    unsigned int next;\n\n    /* If this descriptor says it doesn't chain, we're done. */\n    if (!(desc->flags & VRING_DESC_F_NEXT)) {\n        return max;\n    }\n\n    /* Check they're not leading us off end of descriptors. */\n    next = desc->next;\n    /* Make sure compiler knows to grab that: we don't want it changing! */\n    smp_wmb();\n\n    if (next >= max) {\n        error_report(\"Desc next is %u\", next);\n        exit(1);\n    }\n\n    vring_desc_read(vdev, desc, desc_pa, next);\n    return next;\n}\n",
        "linevul": 5.0310074584558606e-05
    },
    {
        "code": "static int xhci_epmask_to_eps_with_streams(XHCIState *xhci,\n                                           unsigned int slotid,\n                                           uint32_t epmask,\n                                           XHCIEPContext **epctxs,\n                                           USBEndpoint **eps)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    USBEndpoint *ep;\n    int i, j;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    slot = &xhci->slots[slotid - 1];\n\n    for (i = 2, j = 0; i <= 31; i++) {\n        if (!(epmask & (1 << i))) {\n            continue;\n        }\n\n        epctx = slot->eps[i - 1];\n        ep = xhci_epid_to_usbep(xhci, slotid, i);\n        if (!epctx || !epctx->nr_pstreams || !ep) {\n            continue;\n        }\n\n        if (epctxs) {\n            epctxs[j] = epctx;\n        }\n        eps[j++] = ep;\n    }\n    return j;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=3afca1d6d413592c2b78cf28f52fa24a586d8f56",
        "vul_func_with_fix": "static int xhci_epmask_to_eps_with_streams(XHCIState *xhci,\n                                           unsigned int slotid,\n                                           uint32_t epmask,\n                                           XHCIEPContext **epctxs,\n                                           USBEndpoint **eps)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    USBEndpoint *ep;\n    int i, j;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    slot = &xhci->slots[slotid - 1];\n\n    for (i = 2, j = 0; i <= 31; i++) {\n        if (!(epmask & (1 << i))) {\n            continue;\n        }\n\n        epctx = slot->eps[i - 1];\n        ep = xhci_epid_to_usbep(xhci, slotid, i);\n        if (!epctx || !epctx->nr_pstreams || !ep) {\n            continue;\n        }\n\n        if (epctxs) {\n            epctxs[j] = epctx;\n        }\n        eps[j++] = ep;\n    }\n    return j;\n}\n",
        "linevul": 8.545986202079803e-05
    },
    {
        "code": "static int ohci_port_set_if_connected(OHCIState *ohci, int i, uint32_t val)\n{\n    int ret = 1;\n\n    /* writing a 0 has no effect */\n    if (val == 0)\n        return 0;\n\n    /* If CurrentConnectStatus is cleared we set\n     * ConnectStatusChange\n     */\n    if (!(ohci->rhport[i].ctrl & OHCI_PORT_CCS)) {\n        ohci->rhport[i].ctrl |= OHCI_PORT_CSC;\n        if (ohci->rhstatus & OHCI_RHS_DRWE) {\n            /* TODO: CSC is a wakeup event */\n        }\n        return 0;\n    }\n\n    if (ohci->rhport[i].ctrl & val)\n        ret = 0;\n\n    /* set the bit */\n    ohci->rhport[i].ctrl |= val;\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static int ohci_port_set_if_connected(OHCIState *ohci, int i, uint32_t val)\n{\n    int ret = 1;\n\n    /* writing a 0 has no effect */\n    if (val == 0)\n        return 0;\n\n    /* If CurrentConnectStatus is cleared we set\n     * ConnectStatusChange\n     */\n    if (!(ohci->rhport[i].ctrl & OHCI_PORT_CCS)) {\n        ohci->rhport[i].ctrl |= OHCI_PORT_CSC;\n        if (ohci->rhstatus & OHCI_RHS_DRWE) {\n            /* TODO: CSC is a wakeup event */\n        }\n        return 0;\n    }\n\n    if (ohci->rhport[i].ctrl & val)\n        ret = 0;\n\n    /* set the bit */\n    ohci->rhport[i].ctrl |= val;\n\n    return ret;\n}\n",
        "linevul": 4.852782149100676e-05
    },
    {
        "code": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n     uint32_t addr;\n     mcf_fec_bd bd;\n     int frame_size;\n    int len;\n     uint8_t frame[FEC_MAX_FRAME_SIZE];\n     uint8_t *ptr;\n \n    ptr = frame;\n     ptr = frame;\n     frame_size = 0;\n     addr = s->tx_descriptor;\n    while (1) {\n         mcf_fec_read_bd(&bd, addr);\n         DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                 addr, bd.flags, bd.length, bd.data);\n            /* Run out of descriptors to transmit.  */\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            /* Last buffer in frame.  */\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        /* Write back the modified descriptor.  */\n        mcf_fec_write_bd(&bd, addr);\n        /* Advance to the next descriptor.  */\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=070c4b92b8cd5390889716677a0b92444d6e087a",
        "vul_func_with_fix": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n     uint32_t addr;\n     mcf_fec_bd bd;\n     int frame_size;\n//flaw_line_below:\n    int len;\n//fix_flaw_line_below:\n//    int len, descnt = 0;\n     uint8_t frame[FEC_MAX_FRAME_SIZE];\n     uint8_t *ptr;\n \n    ptr = frame;\n     ptr = frame;\n     frame_size = 0;\n     addr = s->tx_descriptor;\n//flaw_line_below:\n    while (1) {\n//fix_flaw_line_below:\n//    while (descnt++ < FEC_MAX_DESC) {\n         mcf_fec_read_bd(&bd, addr);\n         DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                 addr, bd.flags, bd.length, bd.data);\n            /* Run out of descriptors to transmit.  */\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            /* Last buffer in frame.  */\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        /* Write back the modified descriptor.  */\n        mcf_fec_write_bd(&bd, addr);\n        /* Advance to the next descriptor.  */\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n",
        "linevul": 0.9927020072937012
    },
    {
        "code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n        if (s->ti_size > 0) {\n             s->ti_size--;\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n                /* Data out.  */\n                qemu_log_mask(LOG_UNIMP,\n                              \"esp: PIO data read not implemented\\n\");\n                s->rregs[ESP_FIFO] = 0;\n            } else {\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            }\n             esp_raise_irq(s);\n         }\n        if (s->ti_size == 0) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
        "vul_func_with_fix": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n//flaw_line_below:\n        if (s->ti_size > 0) {\n//fix_flaw_line_below:\n//        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n//fix_flaw_line_below:\n//            /* Data out.  */\n//fix_flaw_line_below:\n//            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n//fix_flaw_line_below:\n//            s->rregs[ESP_FIFO] = 0;\n//fix_flaw_line_below:\n//            esp_raise_irq(s);\n//fix_flaw_line_below:\n//        } else if (s->ti_rptr < s->ti_wptr) {\n             s->ti_size--;\n//flaw_line_below:\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n//flaw_line_below:\n                /* Data out.  */\n//flaw_line_below:\n                qemu_log_mask(LOG_UNIMP,\n//flaw_line_below:\n                              \"esp: PIO data read not implemented\\n\");\n//flaw_line_below:\n                s->rregs[ESP_FIFO] = 0;\n//flaw_line_below:\n            } else {\n//flaw_line_below:\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n//flaw_line_below:\n            }\n//fix_flaw_line_below:\n//            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n             esp_raise_irq(s);\n         }\n//flaw_line_below:\n        if (s->ti_size == 0) {\n//fix_flaw_line_below:\n//        if (s->ti_rptr == s->ti_wptr) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n",
        "linevul": 0.00035389832919463515
    },
    {
        "code": "void ide_data_writel(void *opaque, uint32_t addr, uint32_t val)\n{\n    IDEBus *bus = opaque;\n    IDEState *s = idebus_active_if(bus);\n    uint8_t *p;\n\n    /* PIO data access allowed only when DRQ bit is set. The result of a write\n     * during PIO out is indeterminate, just ignore it. */\n    if (!(s->status & DRQ_STAT) || ide_is_pio_out(s)) {\n        return;\n    }\n\n    p = s->data_ptr;\n    *(uint32_t *)p = le32_to_cpu(val);\n    p += 4;\n    s->data_ptr = p;\n    if (p >= s->data_end)\n        s->end_transfer_func(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "void ide_data_writel(void *opaque, uint32_t addr, uint32_t val)\n{\n    IDEBus *bus = opaque;\n    IDEState *s = idebus_active_if(bus);\n    uint8_t *p;\n\n    /* PIO data access allowed only when DRQ bit is set. The result of a write\n     * during PIO out is indeterminate, just ignore it. */\n    if (!(s->status & DRQ_STAT) || ide_is_pio_out(s)) {\n        return;\n    }\n\n    p = s->data_ptr;\n    *(uint32_t *)p = le32_to_cpu(val);\n    p += 4;\n    s->data_ptr = p;\n    if (p >= s->data_end)\n        s->end_transfer_func(s);\n}\n",
        "linevul": 5.374960528570227e-05
    },
    {
        "code": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n     len = s->dma_left;\n     if (s->do_cmd) {\n         trace_esp_do_dma(s->cmdlen, len);\n         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n         return;\n     }\n        return;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11",
        "vul_func_with_fix": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n     len = s->dma_left;\n     if (s->do_cmd) {\n         trace_esp_do_dma(s->cmdlen, len);\n//fix_flaw_line_below:\n//        assert (s->cmdlen <= sizeof(s->cmdbuf) &&\n//fix_flaw_line_below:\n//                len <= sizeof(s->cmdbuf) - s->cmdlen);\n         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n         return;\n     }\n        return;\n    }\n",
        "linevul": 0.9237066507339478
    },
    {
        "code": "static USBEndpoint *xhci_epid_to_usbep(XHCIState *xhci,\n                                       unsigned int slotid, unsigned int epid)\n{\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    if (!xhci->slots[slotid - 1].uport) {\n        return NULL;\n    }\n\n    return usb_ep_get(xhci->slots[slotid - 1].uport->dev,\n                      (epid & 1) ? USB_TOKEN_IN : USB_TOKEN_OUT, epid >> 1);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=b53dd4495ced2432a0b652ea895e651d07336f7e",
        "vul_func_with_fix": "static USBEndpoint *xhci_epid_to_usbep(XHCIState *xhci,\n                                       unsigned int slotid, unsigned int epid)\n{\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    if (!xhci->slots[slotid - 1].uport) {\n        return NULL;\n    }\n\n    return usb_ep_get(xhci->slots[slotid - 1].uport->dev,\n                      (epid & 1) ? USB_TOKEN_IN : USB_TOKEN_OUT, epid >> 1);\n}\n",
        "linevul": 4.914704186376184e-05
    },
    {
        "code": "e1000e_phy_reg_write(E1000ECore *core, uint8_t page,\n                     uint32_t addr, uint16_t data)\n{\n    assert(page < E1000E_PHY_PAGES);\n    assert(addr < E1000E_PHY_PAGE_SIZE);\n\n    if (e1000e_phyreg_writeops[page][addr]) {\n        e1000e_phyreg_writeops[page][addr](core, addr, data);\n    } else {\n        core->phy[page][addr] = data;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_phy_reg_write(E1000ECore *core, uint8_t page,\n                     uint32_t addr, uint16_t data)\n{\n    assert(page < E1000E_PHY_PAGES);\n    assert(addr < E1000E_PHY_PAGE_SIZE);\n\n    if (e1000e_phyreg_writeops[page][addr]) {\n        e1000e_phyreg_writeops[page][addr](core, addr, data);\n    } else {\n        core->phy[page][addr] = data;\n    }\n}\n",
        "linevul": 4.9599515477893874e-05
    },
    {
        "code": "static void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n{\n    int i;\n    unsigned int enc = 0;\n\n    vs->features = 0;\n    vs->vnc_encoding = 0;\n    vs->tight.compression = 9;\n    vs->tight.quality = -1; /* Lossless by default */\n    vs->absolute = -1;\n\n    /*\n     * Start from the end because the encodings are sent in order of preference.\n     * This way the preferred encoding (first encoding defined in the array)\n     * will be set at the end of the loop.\n     */\n    for (i = n_encodings - 1; i >= 0; i--) {\n        enc = encodings[i];\n        switch (enc) {\n        case VNC_ENCODING_RAW:\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_COPYRECT:\n            vs->features |= VNC_FEATURE_COPYRECT_MASK;\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vs->features |= VNC_FEATURE_HEXTILE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_TIGHT:\n            vs->features |= VNC_FEATURE_TIGHT_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#ifdef CONFIG_VNC_PNG\n        case VNC_ENCODING_TIGHT_PNG:\n            vs->features |= VNC_FEATURE_TIGHT_PNG_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#endif\n        case VNC_ENCODING_ZLIB:\n            vs->features |= VNC_FEATURE_ZLIB_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZRLE:\n            vs->features |= VNC_FEATURE_ZRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            vs->features |= VNC_FEATURE_ZYWRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_DESKTOPRESIZE:\n            vs->features |= VNC_FEATURE_RESIZE_MASK;\n            break;\n        case VNC_ENCODING_POINTER_TYPE_CHANGE:\n            vs->features |= VNC_FEATURE_POINTER_TYPE_CHANGE_MASK;\n            break;\n        case VNC_ENCODING_RICH_CURSOR:\n            vs->features |= VNC_FEATURE_RICH_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_EXT_KEY_EVENT:\n            send_ext_key_event_ack(vs);\n            break;\n        case VNC_ENCODING_AUDIO:\n            send_ext_audio_ack(vs);\n            break;\n        case VNC_ENCODING_WMVi:\n            vs->features |= VNC_FEATURE_WMVI_MASK;\n            break;\n        case VNC_ENCODING_LED_STATE:\n            vs->features |= VNC_FEATURE_LED_STATE_MASK;\n            break;\n        case VNC_ENCODING_COMPRESSLEVEL0 ... VNC_ENCODING_COMPRESSLEVEL0 + 9:\n            vs->tight.compression = (enc & 0x0F);\n            break;\n        case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9:\n            if (vs->vd->lossy) {\n                vs->tight.quality = (enc & 0x0F);\n            }\n            break;\n        default:\n            VNC_DEBUG(\"Unknown encoding: %d (0x%.8x): %d\\n\", i, enc, enc);\n            break;\n        }\n    }\n    vnc_desktop_resize(vs);\n    check_pointer_type_change(&vs->mouse_mode_notifier, NULL);\n    vnc_led_state_change(vs);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n{\n    int i;\n    unsigned int enc = 0;\n\n    vs->features = 0;\n    vs->vnc_encoding = 0;\n    vs->tight.compression = 9;\n    vs->tight.quality = -1; /* Lossless by default */\n    vs->absolute = -1;\n\n    /*\n     * Start from the end because the encodings are sent in order of preference.\n     * This way the preferred encoding (first encoding defined in the array)\n     * will be set at the end of the loop.\n     */\n    for (i = n_encodings - 1; i >= 0; i--) {\n        enc = encodings[i];\n        switch (enc) {\n        case VNC_ENCODING_RAW:\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_COPYRECT:\n            vs->features |= VNC_FEATURE_COPYRECT_MASK;\n            break;\n        case VNC_ENCODING_HEXTILE:\n            vs->features |= VNC_FEATURE_HEXTILE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_TIGHT:\n            vs->features |= VNC_FEATURE_TIGHT_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#ifdef CONFIG_VNC_PNG\n        case VNC_ENCODING_TIGHT_PNG:\n            vs->features |= VNC_FEATURE_TIGHT_PNG_MASK;\n            vs->vnc_encoding = enc;\n            break;\n#endif\n        case VNC_ENCODING_ZLIB:\n            vs->features |= VNC_FEATURE_ZLIB_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZRLE:\n            vs->features |= VNC_FEATURE_ZRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_ZYWRLE:\n            vs->features |= VNC_FEATURE_ZYWRLE_MASK;\n            vs->vnc_encoding = enc;\n            break;\n        case VNC_ENCODING_DESKTOPRESIZE:\n            vs->features |= VNC_FEATURE_RESIZE_MASK;\n            break;\n        case VNC_ENCODING_POINTER_TYPE_CHANGE:\n            vs->features |= VNC_FEATURE_POINTER_TYPE_CHANGE_MASK;\n            break;\n        case VNC_ENCODING_RICH_CURSOR:\n            vs->features |= VNC_FEATURE_RICH_CURSOR_MASK;\n            break;\n        case VNC_ENCODING_EXT_KEY_EVENT:\n            send_ext_key_event_ack(vs);\n            break;\n        case VNC_ENCODING_AUDIO:\n            send_ext_audio_ack(vs);\n            break;\n        case VNC_ENCODING_WMVi:\n            vs->features |= VNC_FEATURE_WMVI_MASK;\n            break;\n        case VNC_ENCODING_LED_STATE:\n            vs->features |= VNC_FEATURE_LED_STATE_MASK;\n            break;\n        case VNC_ENCODING_COMPRESSLEVEL0 ... VNC_ENCODING_COMPRESSLEVEL0 + 9:\n            vs->tight.compression = (enc & 0x0F);\n            break;\n        case VNC_ENCODING_QUALITYLEVEL0 ... VNC_ENCODING_QUALITYLEVEL0 + 9:\n            if (vs->vd->lossy) {\n                vs->tight.quality = (enc & 0x0F);\n            }\n            break;\n        default:\n            VNC_DEBUG(\"Unknown encoding: %d (0x%.8x): %d\\n\", i, enc, enc);\n            break;\n        }\n    }\n    vnc_desktop_resize(vs);\n    check_pointer_type_change(&vs->mouse_mode_notifier, NULL);\n    vnc_led_state_change(vs);\n}\n",
        "linevul": 4.8484522267244756e-05
    },
    {
        "code": "static int handle_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchmod(fd, credp->fc_mode);\n    close(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = fchmod(fd, credp->fc_mode);\n    close(fd);\n    return ret;\n}\n",
        "linevul": 5.395723565015942e-05
    },
    {
        "code": "static void vmxnet3_set_events(VMXNET3State *s, uint32_t val)\n{\n    uint32_t events;\n\n    VMW_CBPRN(\"Setting events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(s->drv_shmem, ecr) | val;\n    VMXNET3_WRITE_DRV_SHARED32(s->drv_shmem, ecr, events);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484",
        "vul_func_with_fix": "static void vmxnet3_set_events(VMXNET3State *s, uint32_t val)\n{\n    uint32_t events;\n\n    VMW_CBPRN(\"Setting events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(s->drv_shmem, ecr) | val;\n    VMXNET3_WRITE_DRV_SHARED32(s->drv_shmem, ecr, events);\n}\n",
        "linevul": 4.6290395403048024e-05
    },
    {
        "code": "void ide_dma_cb(void *opaque, int ret)\n{\n    IDEState *s = opaque;\n    int n;\n    int64_t sector_num;\n    bool stay_active = false;\n\n    if (ret == -ECANCELED) {\n        return;\n    }\n    if (ret < 0) {\n        int op = IDE_RETRY_DMA;\n\n        if (s->dma_cmd == IDE_DMA_READ)\n            op |= IDE_RETRY_READ;\n        else if (s->dma_cmd == IDE_DMA_TRIM)\n            op |= IDE_RETRY_TRIM;\n\n        if (ide_handle_rw_error(s, -ret, op)) {\n            return;\n        }\n    }\n\n    n = s->io_buffer_size >> 9;\n    if (n > s->nsector) {\n        /* The PRDs were longer than needed for this request. Shorten them so\n         * we don't get a negative remainder. The Active bit must remain set\n         * after the request completes. */\n        n = s->nsector;\n        stay_active = true;\n    }\n\n    sector_num = ide_get_sector(s);\n    if (n > 0) {\n        assert(s->io_buffer_size == s->sg.size);\n        dma_buf_commit(s, s->io_buffer_size);\n        sector_num += n;\n        ide_set_sector(s, sector_num);\n        s->nsector -= n;\n    }\n\n    /* end of transfer ? */\n    if (s->nsector == 0) {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_set_irq(s->bus);\n        goto eot;\n    }\n\n    /* launch next transfer */\n     n = s->nsector;\n     s->io_buffer_index = 0;\n     s->io_buffer_size = n * 512;\n    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n         /* The PRDs were too short. Reset the Active bit, but don't raise an\n          * interrupt. */\n         s->status = READY_STAT | SEEK_STAT;\n         goto eot;\n     }\n \n    printf(\"ide_dma_cb: sector_num=%\" PRId64 \" n=%d, cmd_cmd=%d\\n\",\n           sector_num, n, s->dma_cmd);\n#endif\n\n    if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) &&\n        !ide_sect_range_ok(s, sector_num, n)) {\n        ide_dma_error(s);\n        return;\n    }\n\n    switch (s->dma_cmd) {\n    case IDE_DMA_READ:\n        s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num,\n                                          ide_dma_cb, s);\n        break;\n    case IDE_DMA_WRITE:\n        s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num,\n                                           ide_dma_cb, s);\n        break;\n    case IDE_DMA_TRIM:\n        s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num,\n                                        ide_issue_trim, ide_dma_cb, s,\n                                        DMA_DIRECTION_TO_DEVICE);\n        break;\n    }\n    return;\n\neot:\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n    }\n    ide_set_inactive(s, stay_active);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "void ide_dma_cb(void *opaque, int ret)\n{\n    IDEState *s = opaque;\n    int n;\n    int64_t sector_num;\n    bool stay_active = false;\n\n    if (ret == -ECANCELED) {\n        return;\n    }\n    if (ret < 0) {\n        int op = IDE_RETRY_DMA;\n\n        if (s->dma_cmd == IDE_DMA_READ)\n            op |= IDE_RETRY_READ;\n        else if (s->dma_cmd == IDE_DMA_TRIM)\n            op |= IDE_RETRY_TRIM;\n\n        if (ide_handle_rw_error(s, -ret, op)) {\n            return;\n        }\n    }\n\n    n = s->io_buffer_size >> 9;\n    if (n > s->nsector) {\n        /* The PRDs were longer than needed for this request. Shorten them so\n         * we don't get a negative remainder. The Active bit must remain set\n         * after the request completes. */\n        n = s->nsector;\n        stay_active = true;\n    }\n\n    sector_num = ide_get_sector(s);\n    if (n > 0) {\n        assert(s->io_buffer_size == s->sg.size);\n        dma_buf_commit(s, s->io_buffer_size);\n        sector_num += n;\n        ide_set_sector(s, sector_num);\n        s->nsector -= n;\n    }\n\n    /* end of transfer ? */\n    if (s->nsector == 0) {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_set_irq(s->bus);\n        goto eot;\n    }\n\n    /* launch next transfer */\n     n = s->nsector;\n     s->io_buffer_index = 0;\n     s->io_buffer_size = n * 512;\n//flaw_line_below:\n    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n//fix_flaw_line_below:\n//    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) < 512) {\n         /* The PRDs were too short. Reset the Active bit, but don't raise an\n          * interrupt. */\n         s->status = READY_STAT | SEEK_STAT;\n//fix_flaw_line_below:\n//        dma_buf_commit(s, 0);\n         goto eot;\n     }\n \n    printf(\"ide_dma_cb: sector_num=%\" PRId64 \" n=%d, cmd_cmd=%d\\n\",\n           sector_num, n, s->dma_cmd);\n#endif\n\n    if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) &&\n        !ide_sect_range_ok(s, sector_num, n)) {\n        ide_dma_error(s);\n        return;\n    }\n\n    switch (s->dma_cmd) {\n    case IDE_DMA_READ:\n        s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num,\n                                          ide_dma_cb, s);\n        break;\n    case IDE_DMA_WRITE:\n        s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num,\n                                           ide_dma_cb, s);\n        break;\n    case IDE_DMA_TRIM:\n        s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num,\n                                        ide_issue_trim, ide_dma_cb, s,\n                                        DMA_DIRECTION_TO_DEVICE);\n        break;\n    }\n    return;\n\neot:\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n    }\n    ide_set_inactive(s, stay_active);\n}\n",
        "linevul": 7.972119055921212e-05
    },
    {
        "code": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n{\n    struct ohci_ed ed;\n    uint32_t next_ed;\n    uint32_t cur;\n    int active;\n\n    active = 0;\n\n    if (head == 0)\n        return 0;\n\n    for (cur = head; cur; cur = next_ed) {\n        if (ohci_read_ed(ohci, cur, &ed)) {\n            trace_usb_ohci_ed_read_error(cur);\n            ohci_die(ohci);\n            return 0;\n        }\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n            uint32_t addr;\n            /* Cancel pending packets for ED that have been paused.  */\n            addr = ed.head & OHCI_DPTR_MASK;\n            if (ohci->async_td && addr == ohci->async_td) {\n                usb_cancel_packet(&ohci->usb_packet);\n                ohci->async_td = 0;\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n                                      ohci->usb_packet.ep);\n            }\n            continue;\n        }\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n            trace_usb_ohci_ed_pkt_flags(\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n                    OHCI_BM(ed.flags, ED_MPS));\n\n            active = 1;\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n                if (ohci_service_td(ohci, &ed))\n                    break;\n            } else {\n                /* Handle isochronous endpoints */\n                if (ohci_service_iso_td(ohci, &ed, completion))\n                    break;\n            }\n        }\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n            ohci_die(ohci);\n            return 0;\n        }\n    }\n\n    return active;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n{\n    struct ohci_ed ed;\n    uint32_t next_ed;\n    uint32_t cur;\n    int active;\n\n    active = 0;\n\n    if (head == 0)\n        return 0;\n\n    for (cur = head; cur; cur = next_ed) {\n        if (ohci_read_ed(ohci, cur, &ed)) {\n            trace_usb_ohci_ed_read_error(cur);\n            ohci_die(ohci);\n            return 0;\n        }\n\n        next_ed = ed.next & OHCI_DPTR_MASK;\n\n        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n            uint32_t addr;\n            /* Cancel pending packets for ED that have been paused.  */\n            addr = ed.head & OHCI_DPTR_MASK;\n            if (ohci->async_td && addr == ohci->async_td) {\n                usb_cancel_packet(&ohci->usb_packet);\n                ohci->async_td = 0;\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n                                      ohci->usb_packet.ep);\n            }\n            continue;\n        }\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n            trace_usb_ohci_ed_pkt_flags(\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n                    OHCI_BM(ed.flags, ED_MPS));\n\n            active = 1;\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n                if (ohci_service_td(ohci, &ed))\n                    break;\n            } else {\n                /* Handle isochronous endpoints */\n                if (ohci_service_iso_td(ohci, &ed, completion))\n                    break;\n            }\n        }\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n            ohci_die(ohci);\n            return 0;\n        }\n    }\n\n    return active;\n}\n",
        "linevul": 6.039687286829576e-05
    },
    {
        "code": "static void virgl_cmd_create_resource_3d(VirtIOGPU *g,\n                                         struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_create_3d c3d;\n    struct virgl_renderer_resource_create_args args;\n\n    VIRTIO_GPU_FILL_CMD(c3d);\n    trace_virtio_gpu_cmd_res_create_3d(c3d.resource_id, c3d.format,\n                                       c3d.width, c3d.height, c3d.depth);\n\n    args.handle = c3d.resource_id;\n    args.target = c3d.target;\n    args.format = c3d.format;\n    args.bind = c3d.bind;\n    args.width = c3d.width;\n    args.height = c3d.height;\n    args.depth = c3d.depth;\n    args.array_size = c3d.array_size;\n    args.last_level = c3d.last_level;\n    args.nr_samples = c3d.nr_samples;\n    args.flags = c3d.flags;\n    virgl_renderer_resource_create(&args, NULL, 0);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=33243031dad02d161225ba99d782616da133f689",
        "vul_func_with_fix": "static void virgl_cmd_create_resource_3d(VirtIOGPU *g,\n                                         struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_create_3d c3d;\n    struct virgl_renderer_resource_create_args args;\n\n    VIRTIO_GPU_FILL_CMD(c3d);\n    trace_virtio_gpu_cmd_res_create_3d(c3d.resource_id, c3d.format,\n                                       c3d.width, c3d.height, c3d.depth);\n\n    args.handle = c3d.resource_id;\n    args.target = c3d.target;\n    args.format = c3d.format;\n    args.bind = c3d.bind;\n    args.width = c3d.width;\n    args.height = c3d.height;\n    args.depth = c3d.depth;\n    args.array_size = c3d.array_size;\n    args.last_level = c3d.last_level;\n    args.nr_samples = c3d.nr_samples;\n    args.flags = c3d.flags;\n    virgl_renderer_resource_create(&args, NULL, 0);\n}\n",
        "linevul": 4.8305919335689396e-05
    },
    {
        "code": "static void fdctrl_handle_relative_seek_in(FDCtrl *fdctrl, int direction)\n{\n    FDrive *cur_drv;\n\n    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);\n    cur_drv = get_cur_drv(fdctrl);\n    if (fdctrl->fifo[2] + cur_drv->track >= cur_drv->max_track) {\n        fd_seek(cur_drv, cur_drv->head, cur_drv->max_track - 1,\n                cur_drv->sect, 1);\n    } else {\n        fd_seek(cur_drv, cur_drv->head,\n                cur_drv->track + fdctrl->fifo[2], cur_drv->sect, 1);\n    }\n    fdctrl_reset_fifo(fdctrl);\n    /* Raise Interrupt */\n    fdctrl->status0 |= FD_SR0_SEEK;\n    fdctrl_raise_irq(fdctrl);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static void fdctrl_handle_relative_seek_in(FDCtrl *fdctrl, int direction)\n{\n    FDrive *cur_drv;\n\n    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);\n    cur_drv = get_cur_drv(fdctrl);\n    if (fdctrl->fifo[2] + cur_drv->track >= cur_drv->max_track) {\n        fd_seek(cur_drv, cur_drv->head, cur_drv->max_track - 1,\n                cur_drv->sect, 1);\n    } else {\n        fd_seek(cur_drv, cur_drv->head,\n                cur_drv->track + fdctrl->fifo[2], cur_drv->sect, 1);\n    }\n    fdctrl_reset_fifo(fdctrl);\n    /* Raise Interrupt */\n    fdctrl->status0 |= FD_SR0_SEEK;\n    fdctrl_raise_irq(fdctrl);\n}\n",
        "linevul": 4.654456643038429e-05
    },
    {
        "code": "static int stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                            const struct stat *stbuf,\n                            V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static int stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                            const struct stat *stbuf,\n                            V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n",
        "linevul": 0.00012786690786015242
    },
    {
        "code": "static int coroutine_fn put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "linevul": 0.00012201473873574287
    },
    {
        "code": " static void usb_ehci_pci_exit(PCIDevice *dev)\n {\n     EHCIPCIState *i = PCI_EHCI(dev);\nstatic void usb_ehci_pci_reset(DeviceState *dev)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n    EHCIPCIState *i = PCI_EHCI(pci_dev);\n    EHCIState *s = &i->ehci;\n\n    ehci_reset(s);\n}\n\nstatic void usb_ehci_pci_write_config(PCIDevice *dev, uint32_t addr,\n                                      uint32_t val, int l)\n{\n    EHCIPCIState *i = PCI_EHCI(dev);\n    bool busmaster;\n\n    pci_default_write_config(dev, addr, val, l);\n\n    if (!range_covers_byte(addr, l, PCI_COMMAND)) {\n        return;\n    }\n    busmaster = pci_get_word(dev->config + PCI_COMMAND) & PCI_COMMAND_MASTER;\n    i->ehci.as = busmaster ? pci_get_address_space(dev) : &address_space_memory;\n}\n\nstatic Property ehci_pci_properties[] = {\n    DEFINE_PROP_UINT32(\"maxframes\", EHCIPCIState, ehci.maxframes, 128),\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic const VMStateDescription vmstate_ehci_pci = {\n    .name        = \"ehci\",\n    .version_id  = 2,\n    .minimum_version_id  = 1,\n    .fields = (VMStateField[]) {\n        VMSTATE_PCI_DEVICE(pcidev, EHCIPCIState),\n        VMSTATE_STRUCT(ehci, EHCIPCIState, 2, vmstate_ehci, EHCIState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic void ehci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = usb_ehci_pci_realize;\n    k->exit = usb_ehci_pci_exit;\n    k->class_id = PCI_CLASS_SERIAL_USB;\n    k->config_write = usb_ehci_pci_write_config;\n    dc->vmsd = &vmstate_ehci_pci;\n    dc->props = ehci_pci_properties;\n    dc->reset = usb_ehci_pci_reset;\n}\n\nstatic const TypeInfo ehci_pci_type_info = {\n    .name = TYPE_PCI_EHCI,\n    .parent = TYPE_PCI_DEVICE,\n    .instance_size = sizeof(EHCIPCIState),\n    .instance_init = usb_ehci_pci_init,\n    .abstract = true,\n    .class_init = ehci_class_init,\n};\n\nstatic void ehci_data_class_init(ObjectClass *klass, void *data)\n     .parent = TYPE_PCI_DEVICE,\n     .instance_size = sizeof(EHCIPCIState),\n     .instance_init = usb_ehci_pci_init,\n     .abstract = true,\n     .class_init = ehci_class_init,\n };\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": " static void usb_ehci_pci_exit(PCIDevice *dev)\n {\n     EHCIPCIState *i = PCI_EHCI(dev);\nstatic void usb_ehci_pci_reset(DeviceState *dev)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n    EHCIPCIState *i = PCI_EHCI(pci_dev);\n    EHCIState *s = &i->ehci;\n\n    ehci_reset(s);\n}\n\nstatic void usb_ehci_pci_write_config(PCIDevice *dev, uint32_t addr,\n                                      uint32_t val, int l)\n{\n    EHCIPCIState *i = PCI_EHCI(dev);\n    bool busmaster;\n\n    pci_default_write_config(dev, addr, val, l);\n\n    if (!range_covers_byte(addr, l, PCI_COMMAND)) {\n        return;\n    }\n    busmaster = pci_get_word(dev->config + PCI_COMMAND) & PCI_COMMAND_MASTER;\n    i->ehci.as = busmaster ? pci_get_address_space(dev) : &address_space_memory;\n}\n\nstatic Property ehci_pci_properties[] = {\n    DEFINE_PROP_UINT32(\"maxframes\", EHCIPCIState, ehci.maxframes, 128),\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic const VMStateDescription vmstate_ehci_pci = {\n    .name        = \"ehci\",\n    .version_id  = 2,\n    .minimum_version_id  = 1,\n    .fields = (VMStateField[]) {\n        VMSTATE_PCI_DEVICE(pcidev, EHCIPCIState),\n        VMSTATE_STRUCT(ehci, EHCIPCIState, 2, vmstate_ehci, EHCIState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic void ehci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->realize = usb_ehci_pci_realize;\n    k->exit = usb_ehci_pci_exit;\n    k->class_id = PCI_CLASS_SERIAL_USB;\n    k->config_write = usb_ehci_pci_write_config;\n    dc->vmsd = &vmstate_ehci_pci;\n    dc->props = ehci_pci_properties;\n    dc->reset = usb_ehci_pci_reset;\n}\n\nstatic const TypeInfo ehci_pci_type_info = {\n    .name = TYPE_PCI_EHCI,\n    .parent = TYPE_PCI_DEVICE,\n    .instance_size = sizeof(EHCIPCIState),\n    .instance_init = usb_ehci_pci_init,\n    .abstract = true,\n    .class_init = ehci_class_init,\n};\n\nstatic void ehci_data_class_init(ObjectClass *klass, void *data)\n     .parent = TYPE_PCI_DEVICE,\n     .instance_size = sizeof(EHCIPCIState),\n     .instance_init = usb_ehci_pci_init,\n//fix_flaw_line_below:\n//    .instance_finalize = usb_ehci_pci_finalize,\n     .abstract = true,\n     .class_init = ehci_class_init,\n };\n",
        "linevul": 0.0019219997338950634
    },
    {
        "code": " void ahci_uninit(AHCIState *s)\n {\n     g_free(s->dev);\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": " void ahci_uninit(AHCIState *s)\n {\n//fix_flaw_line_below:\n//    int i, j;\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    for (i = 0; i < s->ports; i++) {\n//fix_flaw_line_below:\n//        AHCIDevice *ad = &s->dev[i];\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//        for (j = 0; j < 2; j++) {\n//fix_flaw_line_below:\n//            IDEState *s = &ad->port.ifs[j];\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//            ide_exit(s);\n//fix_flaw_line_below:\n//        }\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     g_free(s->dev);\n }\n",
        "linevul": 0.00016877018788363785
    },
    {
        "code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}\n",
        "linevul": 4.5867978769820184e-05
    },
    {
        "code": "static void i6300esb_realize(PCIDevice *dev, Error **errp)\n{\n    I6300State *d = WATCHDOG_I6300ESB_DEVICE(dev);\n\n    i6300esb_debug(\"I6300State = %p\\n\", d);\n\n    d->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, i6300esb_timer_expired, d);\n    d->previous_reboot_flag = 0;\n\n    memory_region_init_io(&d->io_mem, OBJECT(d), &i6300esb_ops, d,\n                          \"i6300esb\", 0x10);\n    pci_register_bar(&d->dev, 0, 0, &d->io_mem);\n     /* qemu_register_coalesced_mmio (addr, 0x10); ? */\n }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eb7a20a3616085d46aa6b4b4224e15587ec67e6e",
        "vul_func_with_fix": "static void i6300esb_realize(PCIDevice *dev, Error **errp)\n{\n    I6300State *d = WATCHDOG_I6300ESB_DEVICE(dev);\n\n    i6300esb_debug(\"I6300State = %p\\n\", d);\n\n    d->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, i6300esb_timer_expired, d);\n    d->previous_reboot_flag = 0;\n\n    memory_region_init_io(&d->io_mem, OBJECT(d), &i6300esb_ops, d,\n                          \"i6300esb\", 0x10);\n    pci_register_bar(&d->dev, 0, 0, &d->io_mem);\n     /* qemu_register_coalesced_mmio (addr, 0x10); ? */\n }\n",
        "linevul": 0.00012346506991889328
    },
    {
        "code": "static void pcnet_init(PCNetState *s)\n{\n    int rlen, tlen;\n    uint16_t padr[3], ladrf[4], mode;\n    uint32_t rdra, tdra;\n\n    trace_pcnet_init(s, PHYSADDR(s, CSR_IADR(s)));\n\n    if (BCR_SSIZE32(s)) {\n        struct pcnet_initblk32 initblk;\n        s->phys_mem_read(s->dma_opaque, PHYSADDR(s,CSR_IADR(s)),\n                (uint8_t *)&initblk, sizeof(initblk), 0);\n        mode = le16_to_cpu(initblk.mode);\n        rlen = initblk.rlen >> 4;\n        tlen = initblk.tlen >> 4;\n\tladrf[0] = le16_to_cpu(initblk.ladrf[0]);\n\tladrf[1] = le16_to_cpu(initblk.ladrf[1]);\n\tladrf[2] = le16_to_cpu(initblk.ladrf[2]);\n\tladrf[3] = le16_to_cpu(initblk.ladrf[3]);\n\tpadr[0] = le16_to_cpu(initblk.padr[0]);\n\tpadr[1] = le16_to_cpu(initblk.padr[1]);\n\tpadr[2] = le16_to_cpu(initblk.padr[2]);\n        rdra = le32_to_cpu(initblk.rdra);\n        tdra = le32_to_cpu(initblk.tdra);\n    } else {\n        struct pcnet_initblk16 initblk;\n        s->phys_mem_read(s->dma_opaque, PHYSADDR(s,CSR_IADR(s)),\n                (uint8_t *)&initblk, sizeof(initblk), 0);\n        mode = le16_to_cpu(initblk.mode);\n\tladrf[0] = le16_to_cpu(initblk.ladrf[0]);\n\tladrf[1] = le16_to_cpu(initblk.ladrf[1]);\n\tladrf[2] = le16_to_cpu(initblk.ladrf[2]);\n\tladrf[3] = le16_to_cpu(initblk.ladrf[3]);\n\tpadr[0] = le16_to_cpu(initblk.padr[0]);\n\tpadr[1] = le16_to_cpu(initblk.padr[1]);\n\tpadr[2] = le16_to_cpu(initblk.padr[2]);\n        rdra = le32_to_cpu(initblk.rdra);\n        tdra = le32_to_cpu(initblk.tdra);\n        rlen = rdra >> 29;\n        tlen = tdra >> 29;\n        rdra &= 0x00ffffff;\n        tdra &= 0x00ffffff;\n    }\n\n    trace_pcnet_rlen_tlen(s, rlen, tlen);\n\n    CSR_RCVRL(s) = (rlen < 9) ? (1 << rlen) : 512;\n    CSR_XMTRL(s) = (tlen < 9) ? (1 << tlen) : 512;\n    s->csr[ 6] = (tlen << 12) | (rlen << 8);\n    s->csr[15] = mode;\n    s->csr[ 8] = ladrf[0];\n    s->csr[ 9] = ladrf[1];\n    s->csr[10] = ladrf[2];\n    s->csr[11] = ladrf[3];\n    s->csr[12] = padr[0];\n    s->csr[13] = padr[1];\n    s->csr[14] = padr[2];\n    s->rdra = PHYSADDR(s, rdra);\n    s->tdra = PHYSADDR(s, tdra);\n\n    CSR_RCVRC(s) = CSR_RCVRL(s);\n    CSR_XMTRC(s) = CSR_XMTRL(s);\n\n    trace_pcnet_ss32_rdra_tdra(s, BCR_SSIZE32(s),\n                               s->rdra, CSR_RCVRL(s), s->tdra, CSR_XMTRL(s));\n\n    s->csr[0] |= 0x0101;\n    s->csr[0] &= ~0x0004;       /* clear STOP bit */\n\n    qemu_flush_queued_packets(qemu_get_queue(s->nic));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "static void pcnet_init(PCNetState *s)\n{\n    int rlen, tlen;\n    uint16_t padr[3], ladrf[4], mode;\n    uint32_t rdra, tdra;\n\n    trace_pcnet_init(s, PHYSADDR(s, CSR_IADR(s)));\n\n    if (BCR_SSIZE32(s)) {\n        struct pcnet_initblk32 initblk;\n        s->phys_mem_read(s->dma_opaque, PHYSADDR(s,CSR_IADR(s)),\n                (uint8_t *)&initblk, sizeof(initblk), 0);\n        mode = le16_to_cpu(initblk.mode);\n        rlen = initblk.rlen >> 4;\n        tlen = initblk.tlen >> 4;\n\tladrf[0] = le16_to_cpu(initblk.ladrf[0]);\n\tladrf[1] = le16_to_cpu(initblk.ladrf[1]);\n\tladrf[2] = le16_to_cpu(initblk.ladrf[2]);\n\tladrf[3] = le16_to_cpu(initblk.ladrf[3]);\n\tpadr[0] = le16_to_cpu(initblk.padr[0]);\n\tpadr[1] = le16_to_cpu(initblk.padr[1]);\n\tpadr[2] = le16_to_cpu(initblk.padr[2]);\n        rdra = le32_to_cpu(initblk.rdra);\n        tdra = le32_to_cpu(initblk.tdra);\n    } else {\n        struct pcnet_initblk16 initblk;\n        s->phys_mem_read(s->dma_opaque, PHYSADDR(s,CSR_IADR(s)),\n                (uint8_t *)&initblk, sizeof(initblk), 0);\n        mode = le16_to_cpu(initblk.mode);\n\tladrf[0] = le16_to_cpu(initblk.ladrf[0]);\n\tladrf[1] = le16_to_cpu(initblk.ladrf[1]);\n\tladrf[2] = le16_to_cpu(initblk.ladrf[2]);\n\tladrf[3] = le16_to_cpu(initblk.ladrf[3]);\n\tpadr[0] = le16_to_cpu(initblk.padr[0]);\n\tpadr[1] = le16_to_cpu(initblk.padr[1]);\n\tpadr[2] = le16_to_cpu(initblk.padr[2]);\n        rdra = le32_to_cpu(initblk.rdra);\n        tdra = le32_to_cpu(initblk.tdra);\n        rlen = rdra >> 29;\n        tlen = tdra >> 29;\n        rdra &= 0x00ffffff;\n        tdra &= 0x00ffffff;\n    }\n\n    trace_pcnet_rlen_tlen(s, rlen, tlen);\n\n    CSR_RCVRL(s) = (rlen < 9) ? (1 << rlen) : 512;\n    CSR_XMTRL(s) = (tlen < 9) ? (1 << tlen) : 512;\n    s->csr[ 6] = (tlen << 12) | (rlen << 8);\n    s->csr[15] = mode;\n    s->csr[ 8] = ladrf[0];\n    s->csr[ 9] = ladrf[1];\n    s->csr[10] = ladrf[2];\n    s->csr[11] = ladrf[3];\n    s->csr[12] = padr[0];\n    s->csr[13] = padr[1];\n    s->csr[14] = padr[2];\n    s->rdra = PHYSADDR(s, rdra);\n    s->tdra = PHYSADDR(s, tdra);\n\n    CSR_RCVRC(s) = CSR_RCVRL(s);\n    CSR_XMTRC(s) = CSR_XMTRL(s);\n\n    trace_pcnet_ss32_rdra_tdra(s, BCR_SSIZE32(s),\n                               s->rdra, CSR_RCVRL(s), s->tdra, CSR_XMTRL(s));\n\n    s->csr[0] |= 0x0101;\n    s->csr[0] &= ~0x0004;       /* clear STOP bit */\n\n    qemu_flush_queued_packets(qemu_get_queue(s->nic));\n}\n",
        "linevul": 5.821238664793782e-05
    },
    {
        "code": "static void vnc_colordepth(VncState *vs)\n{\n    if (vnc_has_feature(vs, VNC_FEATURE_WMVI)) {\n        /* Sending a WMVi message to notify the client*/\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1); /* number of rects */\n        vnc_framebuffer_update(vs, 0, 0,\n                               pixman_image_get_width(vs->vd->server),\n                               pixman_image_get_height(vs->vd->server),\n                               VNC_ENCODING_WMVi);\n        pixel_format_message(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    } else {\n        set_pixel_conversion(vs);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void vnc_colordepth(VncState *vs)\n{\n    if (vnc_has_feature(vs, VNC_FEATURE_WMVI)) {\n        /* Sending a WMVi message to notify the client*/\n        vnc_lock_output(vs);\n        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n        vnc_write_u8(vs, 0);\n        vnc_write_u16(vs, 1); /* number of rects */\n        vnc_framebuffer_update(vs, 0, 0,\n                               pixman_image_get_width(vs->vd->server),\n                               pixman_image_get_height(vs->vd->server),\n                               VNC_ENCODING_WMVi);\n        pixel_format_message(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    } else {\n        set_pixel_conversion(vs);\n    }\n}\n",
        "linevul": 6.169364496599883e-05
    },
    {
        "code": "static int in_same_refcount_block(BDRVQcowState *s, uint64_t offset_a,\n    uint64_t offset_b)\n{\n    uint64_t block_a = offset_a >> (2 * s->cluster_bits - REFCOUNT_SHIFT);\n    uint64_t block_b = offset_b >> (2 * s->cluster_bits - REFCOUNT_SHIFT);\n\n    return (block_a == block_b);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": "static int in_same_refcount_block(BDRVQcowState *s, uint64_t offset_a,\n    uint64_t offset_b)\n{\n    uint64_t block_a = offset_a >> (2 * s->cluster_bits - REFCOUNT_SHIFT);\n    uint64_t block_b = offset_b >> (2 * s->cluster_bits - REFCOUNT_SHIFT);\n\n    return (block_a == block_b);\n}\n",
        "linevul": 4.8861558752832934e-05
    },
    {
        "code": "int v9fs_remove_xattr(FsContext *ctx,\n                      const char *path, const char *name)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->removexattr(ctx, path, name);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "int v9fs_remove_xattr(FsContext *ctx,\n                      const char *path, const char *name)\n{\n    XattrOperations *xops = get_xattr_operations(ctx->xops, name);\n    if (xops) {\n        return xops->removexattr(ctx, path, name);\n    }\n    errno = EOPNOTSUPP;\n    return -1;\n\n}\n",
        "linevul": 5.381828304962255e-05
    },
    {
        "code": "static int ne2000_buffer_full(NE2000State *s)\n{\n    int avail, index, boundary;\n\n    index = s->curpag << 8;\n    boundary = s->boundary << 8;\n    if (index < boundary)\n        avail = boundary - index;\n    else\n        avail = (s->stop - s->start) - (index - boundary);\n    if (avail < (MAX_ETH_FRAME_SIZE + 4))\n        return 1;\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=7aa2bcad0ca837dd6d4bf4fa38a80314b4a6b755",
        "vul_func_with_fix": "static int ne2000_buffer_full(NE2000State *s)\n{\n    int avail, index, boundary;\n\n    index = s->curpag << 8;\n    boundary = s->boundary << 8;\n    if (index < boundary)\n        avail = boundary - index;\n    else\n        avail = (s->stop - s->start) - (index - boundary);\n    if (avail < (MAX_ETH_FRAME_SIZE + 4))\n        return 1;\n    return 0;\n}\n",
        "linevul": 6.20306163909845e-05
    },
    {
        "code": "static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n    NetClientState *nc)\n{\n    struct iovec fragment[NET_MAX_FRAG_SG_LIST];\n    size_t fragment_len = 0;\n    bool more_frags = false;\n\n    /* some pointers for shorter code */\n    void *l2_iov_base, *l3_iov_base;\n    size_t l2_iov_len, l3_iov_len;\n    int src_idx =  NET_TX_PKT_PL_START_FRAG, dst_idx;\n    size_t src_offset = 0;\n    size_t fragment_offset = 0;\n\n    l2_iov_base = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base;\n    l2_iov_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len;\n    l3_iov_base = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    l3_iov_len = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n\n    /* Copy headers */\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base = l2_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len = l2_iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base = l3_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len = l3_iov_len;\n\n\n    /* Put as much data as possible and send */\n    do {\n        fragment_len = net_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset,\n            fragment, &dst_idx);\n\n        more_frags = (fragment_offset + fragment_len < pkt->payload_len);\n\n        eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base,\n            l3_iov_len, fragment_len, fragment_offset, more_frags);\n\n        eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);\n\n        net_tx_pkt_sendv(pkt, nc, fragment, dst_idx);\n \n         fragment_offset += fragment_len;\n \n    } while (more_frags);\n \n     return true;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ead315e43ea0c2ca3491209c6c8db8ce3f2bbe05",
        "vul_func_with_fix": "static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n    NetClientState *nc)\n{\n    struct iovec fragment[NET_MAX_FRAG_SG_LIST];\n    size_t fragment_len = 0;\n    bool more_frags = false;\n\n    /* some pointers for shorter code */\n    void *l2_iov_base, *l3_iov_base;\n    size_t l2_iov_len, l3_iov_len;\n    int src_idx =  NET_TX_PKT_PL_START_FRAG, dst_idx;\n    size_t src_offset = 0;\n    size_t fragment_offset = 0;\n\n    l2_iov_base = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base;\n    l2_iov_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len;\n    l3_iov_base = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    l3_iov_len = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n\n    /* Copy headers */\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base = l2_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len = l2_iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base = l3_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len = l3_iov_len;\n\n\n    /* Put as much data as possible and send */\n    do {\n        fragment_len = net_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset,\n            fragment, &dst_idx);\n\n        more_frags = (fragment_offset + fragment_len < pkt->payload_len);\n\n        eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base,\n            l3_iov_len, fragment_len, fragment_offset, more_frags);\n\n        eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);\n\n        net_tx_pkt_sendv(pkt, nc, fragment, dst_idx);\n \n         fragment_offset += fragment_len;\n \n//flaw_line_below:\n    } while (more_frags);\n//fix_flaw_line_below:\n//    } while (fragment_len && more_frags);\n \n     return true;\n }\n",
        "linevul": 6.0369697166606784e-05
    },
    {
        "code": "void virtio_gpu_ctrl_response_nodata(VirtIOGPU *g,\n                                     struct virtio_gpu_ctrl_command *cmd,\n                                     enum virtio_gpu_ctrl_type type)\n{\n    struct virtio_gpu_ctrl_hdr resp;\n\n    memset(&resp, 0, sizeof(resp));\n    resp.type = type;\n    virtio_gpu_ctrl_response(g, cmd, &resp, sizeof(resp));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "void virtio_gpu_ctrl_response_nodata(VirtIOGPU *g,\n                                     struct virtio_gpu_ctrl_command *cmd,\n                                     enum virtio_gpu_ctrl_type type)\n{\n    struct virtio_gpu_ctrl_hdr resp;\n\n    memset(&resp, 0, sizeof(resp));\n    resp.type = type;\n    virtio_gpu_ctrl_response(g, cmd, &resp, sizeof(resp));\n}\n",
        "linevul": 4.733858804684132e-05
    },
    {
        "code": "static inline void vring_used_flags_unset_bit(VirtQueue *vq, int mask)\n{\n    hwaddr pa;\n    pa = vq->vring.used + offsetof(VRingUsed, flags);\n    stw_phys(&address_space_memory,\n             pa, lduw_phys(&address_space_memory, pa) & ~mask);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "static inline void vring_used_flags_unset_bit(VirtQueue *vq, int mask)\n{\n    hwaddr pa;\n    pa = vq->vring.used + offsetof(VRingUsed, flags);\n    stw_phys(&address_space_memory,\n             pa, lduw_phys(&address_space_memory, pa) & ~mask);\n}\n",
        "linevul": 4.897813778370619e-05
    },
    {
        "code": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n                                        int y, int w, int h)\n{\n     int i, j;\n     int has_fg, has_bg;\n     uint8_t *last_fg, *last_bg;\n    VncDisplay *vd = vs->vd;\n \n    last_fg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n    last_bg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n     has_fg = has_bg = 0;\n     for (j = y; j < (y + h); j += 16) {\n         for (i = x; i < (x + w); i += 16) {\n        for (i = x; i < (x + w); i += 16) {\n            vs->hextile.send_tile(vs, i, j,\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n                                  last_bg, last_fg, &has_bg, &has_fg);\n        }\n    }\n    g_free(last_fg);\n    g_free(last_bg);\n\n    return 1;\n}\n void vnc_hextile_set_pixel_conversion(VncState *vs, int generic)\n {\n     if (!generic) {\n        switch (vs->ds->surface->pf.bits_per_pixel) {\n            case 8:\n                vs->hextile.send_tile = send_hextile_tile_8;\n                break;\n            case 16:\n                vs->hextile.send_tile = send_hextile_tile_16;\n                break;\n            case 32:\n                vs->hextile.send_tile = send_hextile_tile_32;\n                break;\n         }\n     } else {\n        switch (vs->ds->surface->pf.bits_per_pixel) {\n            case 8:\n                vs->hextile.send_tile = send_hextile_tile_generic_8;\n                break;\n            case 16:\n                vs->hextile.send_tile = send_hextile_tile_generic_16;\n                break;\n            case 32:\n                vs->hextile.send_tile = send_hextile_tile_generic_32;\n                break;\n         }\n     }\n }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n                                        int y, int w, int h)\n{\n     int i, j;\n     int has_fg, has_bg;\n     uint8_t *last_fg, *last_bg;\n//flaw_line_below:\n    VncDisplay *vd = vs->vd;\n \n//flaw_line_below:\n    last_fg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n//flaw_line_below:\n    last_bg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n//fix_flaw_line_below:\n//    last_fg = (uint8_t *) g_malloc(VNC_SERVER_FB_BYTES);\n//fix_flaw_line_below:\n//    last_bg = (uint8_t *) g_malloc(VNC_SERVER_FB_BYTES);\n     has_fg = has_bg = 0;\n     for (j = y; j < (y + h); j += 16) {\n         for (i = x; i < (x + w); i += 16) {\n        for (i = x; i < (x + w); i += 16) {\n            vs->hextile.send_tile(vs, i, j,\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n                                  last_bg, last_fg, &has_bg, &has_fg);\n        }\n    }\n    g_free(last_fg);\n    g_free(last_bg);\n\n    return 1;\n}\n void vnc_hextile_set_pixel_conversion(VncState *vs, int generic)\n {\n     if (!generic) {\n//flaw_line_below:\n        switch (vs->ds->surface->pf.bits_per_pixel) {\n//flaw_line_below:\n            case 8:\n//flaw_line_below:\n                vs->hextile.send_tile = send_hextile_tile_8;\n//flaw_line_below:\n                break;\n//flaw_line_below:\n            case 16:\n//flaw_line_below:\n                vs->hextile.send_tile = send_hextile_tile_16;\n//flaw_line_below:\n                break;\n//flaw_line_below:\n            case 32:\n//flaw_line_below:\n                vs->hextile.send_tile = send_hextile_tile_32;\n//flaw_line_below:\n                break;\n//fix_flaw_line_below:\n//        switch (VNC_SERVER_FB_BITS) {\n//fix_flaw_line_below:\n//        case 8:\n//fix_flaw_line_below:\n//            vs->hextile.send_tile = send_hextile_tile_8;\n//fix_flaw_line_below:\n//            break;\n//fix_flaw_line_below:\n//        case 16:\n//fix_flaw_line_below:\n//            vs->hextile.send_tile = send_hextile_tile_16;\n//fix_flaw_line_below:\n//            break;\n//fix_flaw_line_below:\n//        case 32:\n//fix_flaw_line_below:\n//            vs->hextile.send_tile = send_hextile_tile_32;\n//fix_flaw_line_below:\n//            break;\n         }\n     } else {\n//flaw_line_below:\n        switch (vs->ds->surface->pf.bits_per_pixel) {\n//flaw_line_below:\n            case 8:\n//flaw_line_below:\n                vs->hextile.send_tile = send_hextile_tile_generic_8;\n//flaw_line_below:\n                break;\n//flaw_line_below:\n            case 16:\n//flaw_line_below:\n                vs->hextile.send_tile = send_hextile_tile_generic_16;\n//flaw_line_below:\n                break;\n//flaw_line_below:\n            case 32:\n//flaw_line_below:\n                vs->hextile.send_tile = send_hextile_tile_generic_32;\n//flaw_line_below:\n                break;\n//fix_flaw_line_below:\n//        switch (VNC_SERVER_FB_BITS) {\n//fix_flaw_line_below:\n//        case 8:\n//fix_flaw_line_below:\n//            vs->hextile.send_tile = send_hextile_tile_generic_8;\n//fix_flaw_line_below:\n//            break;\n//fix_flaw_line_below:\n//        case 16:\n//fix_flaw_line_below:\n//            vs->hextile.send_tile = send_hextile_tile_generic_16;\n//fix_flaw_line_below:\n//            break;\n//fix_flaw_line_below:\n//        case 32:\n//fix_flaw_line_below:\n//            vs->hextile.send_tile = send_hextile_tile_generic_32;\n//fix_flaw_line_below:\n//            break;\n         }\n     }\n }\n}\n",
        "linevul": 0.9954232573509216
    },
    {
        "code": "static void tsc210x_pin_update(TSC210xState *s)\n{\n    int64_t expires;\n    int pin_state;\n\n    switch (s->pin_func) {\n    case 0:\n        pin_state = s->pressure;\n        break;\n    case 1:\n        pin_state = !!s->dav;\n        break;\n    case 2:\n    default:\n        pin_state = s->pressure && !s->dav;\n    }\n\n    if (!s->enabled)\n        pin_state = 0;\n\n    if (pin_state != s->irq) {\n        s->irq = pin_state;\n        qemu_set_irq(s->pint, !s->irq);\n    }\n\n    switch (s->nextfunction) {\n    case TSC_MODE_XY_SCAN:\n    case TSC_MODE_XYZ_SCAN:\n        if (!s->pressure)\n            return;\n        break;\n\n    case TSC_MODE_X:\n    case TSC_MODE_Y:\n    case TSC_MODE_Z:\n        if (!s->pressure)\n            return;\n        /* Fall through */\n    case TSC_MODE_BAT1:\n    case TSC_MODE_BAT2:\n    case TSC_MODE_AUX:\n    case TSC_MODE_TEMP1:\n    case TSC_MODE_TEMP2:\n        if (s->dav)\n            s->enabled = 0;\n        break;\n\n    case TSC_MODE_AUX_SCAN:\n    case TSC_MODE_PORT_SCAN:\n        break;\n\n    case TSC_MODE_NO_SCAN:\n    case TSC_MODE_XX_DRV:\n    case TSC_MODE_YY_DRV:\n    case TSC_MODE_YX_DRV:\n    default:\n        return;\n    }\n\n    if (!s->enabled || s->busy || s->dav)\n        return;\n\n    s->busy = 1;\n    s->precision = s->nextprecision;\n    s->function = s->nextfunction;\n    expires = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + (get_ticks_per_sec() >> 10);\n    timer_mod(s->timer, expires);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=5193be3be35f29a35bc465036cd64ad60d43385f",
        "vul_func_with_fix": "static void tsc210x_pin_update(TSC210xState *s)\n{\n    int64_t expires;\n    int pin_state;\n\n    switch (s->pin_func) {\n    case 0:\n        pin_state = s->pressure;\n        break;\n    case 1:\n        pin_state = !!s->dav;\n        break;\n    case 2:\n    default:\n        pin_state = s->pressure && !s->dav;\n    }\n\n    if (!s->enabled)\n        pin_state = 0;\n\n    if (pin_state != s->irq) {\n        s->irq = pin_state;\n        qemu_set_irq(s->pint, !s->irq);\n    }\n\n    switch (s->nextfunction) {\n    case TSC_MODE_XY_SCAN:\n    case TSC_MODE_XYZ_SCAN:\n        if (!s->pressure)\n            return;\n        break;\n\n    case TSC_MODE_X:\n    case TSC_MODE_Y:\n    case TSC_MODE_Z:\n        if (!s->pressure)\n            return;\n        /* Fall through */\n    case TSC_MODE_BAT1:\n    case TSC_MODE_BAT2:\n    case TSC_MODE_AUX:\n    case TSC_MODE_TEMP1:\n    case TSC_MODE_TEMP2:\n        if (s->dav)\n            s->enabled = 0;\n        break;\n\n    case TSC_MODE_AUX_SCAN:\n    case TSC_MODE_PORT_SCAN:\n        break;\n\n    case TSC_MODE_NO_SCAN:\n    case TSC_MODE_XX_DRV:\n    case TSC_MODE_YY_DRV:\n    case TSC_MODE_YX_DRV:\n    default:\n        return;\n    }\n\n    if (!s->enabled || s->busy || s->dav)\n        return;\n\n    s->busy = 1;\n    s->precision = s->nextprecision;\n    s->function = s->nextfunction;\n    expires = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + (get_ticks_per_sec() >> 10);\n    timer_mod(s->timer, expires);\n}\n",
        "linevul": 4.7736884880578145e-05
    },
    {
        "code": "e1000e_update_interrupt_state(E1000ECore *core)\n{\n    bool interrupts_pending;\n    bool is_msix = msix_enabled(core->owner);\n\n    /* Set ICR[OTHER] for MSI-X */\n    if (is_msix) {\n        if (core->mac[ICR] & E1000_ICR_OTHER_CAUSES) {\n            core->mac[ICR] |= E1000_ICR_OTHER;\n            trace_e1000e_irq_add_msi_other(core->mac[ICR]);\n        }\n    }\n\n    e1000e_fix_icr_asserted(core);\n\n    /*\n     * Make sure ICR and ICS registers have the same value.\n     * The spec says that the ICS register is write-only.  However in practice,\n     * on real hardware ICS is readable, and for reads it has the same value as\n     * ICR (except that ICS does not have the clear on read behaviour of ICR).\n     *\n     * The VxWorks PRO/1000 driver uses this behaviour.\n     */\n    core->mac[ICS] = core->mac[ICR];\n\n    interrupts_pending = (core->mac[IMS] & core->mac[ICR]) ? true : false;\n\n    trace_e1000e_irq_pending_interrupts(core->mac[ICR] & core->mac[IMS],\n                                        core->mac[ICR], core->mac[IMS]);\n\n    if (is_msix || msi_enabled(core->owner)) {\n        if (interrupts_pending) {\n            e1000e_send_msi(core, is_msix);\n        }\n    } else {\n        if (interrupts_pending) {\n            if (!e1000e_itr_should_postpone(core)) {\n                e1000e_raise_legacy_irq(core);\n            }\n        } else {\n            e1000e_lower_legacy_irq(core);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_update_interrupt_state(E1000ECore *core)\n{\n    bool interrupts_pending;\n    bool is_msix = msix_enabled(core->owner);\n\n    /* Set ICR[OTHER] for MSI-X */\n    if (is_msix) {\n        if (core->mac[ICR] & E1000_ICR_OTHER_CAUSES) {\n            core->mac[ICR] |= E1000_ICR_OTHER;\n            trace_e1000e_irq_add_msi_other(core->mac[ICR]);\n        }\n    }\n\n    e1000e_fix_icr_asserted(core);\n\n    /*\n     * Make sure ICR and ICS registers have the same value.\n     * The spec says that the ICS register is write-only.  However in practice,\n     * on real hardware ICS is readable, and for reads it has the same value as\n     * ICR (except that ICS does not have the clear on read behaviour of ICR).\n     *\n     * The VxWorks PRO/1000 driver uses this behaviour.\n     */\n    core->mac[ICS] = core->mac[ICR];\n\n    interrupts_pending = (core->mac[IMS] & core->mac[ICR]) ? true : false;\n\n    trace_e1000e_irq_pending_interrupts(core->mac[ICR] & core->mac[IMS],\n                                        core->mac[ICR], core->mac[IMS]);\n\n    if (is_msix || msi_enabled(core->owner)) {\n        if (interrupts_pending) {\n            e1000e_send_msi(core, is_msix);\n        }\n    } else {\n        if (interrupts_pending) {\n            if (!e1000e_itr_should_postpone(core)) {\n                e1000e_raise_legacy_irq(core);\n            }\n        } else {\n            e1000e_lower_legacy_irq(core);\n        }\n    }\n}\n",
        "linevul": 5.071915438747965e-05
    },
    {
        "code": "static void vmxnet3_realize(DeviceState *qdev, Error **errp)\n{\n    VMXNET3Class *vc = VMXNET3_DEVICE_GET_CLASS(qdev);\n    PCIDevice *pci_dev = PCI_DEVICE(qdev);\n    VMXNET3State *s = VMXNET3(qdev);\n\n    if (!(s->compat_flags & VMXNET3_COMPAT_FLAG_DISABLE_PCIE)) {\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n    }\n\n    vc->parent_dc_realize(qdev, errp);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_realize(DeviceState *qdev, Error **errp)\n{\n    VMXNET3Class *vc = VMXNET3_DEVICE_GET_CLASS(qdev);\n    PCIDevice *pci_dev = PCI_DEVICE(qdev);\n    VMXNET3State *s = VMXNET3(qdev);\n\n    if (!(s->compat_flags & VMXNET3_COMPAT_FLAG_DISABLE_PCIE)) {\n        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;\n    }\n\n    vc->parent_dc_realize(qdev, errp);\n}\n",
        "linevul": 4.741466909763403e-05
    },
    {
        "code": "static uint64_t vmxnet3_get_mac_low(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[0]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[1]) |\n           VMXNET3_MAKE_BYTE(2, addr->a[2]) |\n           VMXNET3_MAKE_BYTE(3, addr->a[3]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static uint64_t vmxnet3_get_mac_low(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[0]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[1]) |\n           VMXNET3_MAKE_BYTE(2, addr->a[2]) |\n           VMXNET3_MAKE_BYTE(3, addr->a[3]);\n}\n",
        "linevul": 4.902421642327681e-05
    },
    {
        "code": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n \n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        /* No feature defined yet */\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n\n    return val;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fa365d7cd11185237471823a5a33d36765454e16",
        "vul_func_with_fix": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n \n//flaw_line_below:\n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n//fix_flaw_line_below:\n//    if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        /* No feature defined yet */\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n\n    return val;\n}\n",
        "linevul": 0.9973174929618835
    },
    {
        "code": "static void virtio_net_set_mrg_rx_bufs(VirtIONet *n, int mergeable_rx_bufs)\n{\n    int i;\n    NetClientState *nc;\n\n    n->mergeable_rx_bufs = mergeable_rx_bufs;\n\n    n->guest_hdr_len = n->mergeable_rx_bufs ?\n        sizeof(struct virtio_net_hdr_mrg_rxbuf) : sizeof(struct virtio_net_hdr);\n\n    for (i = 0; i < n->max_queues; i++) {\n        nc = qemu_get_subqueue(n->nic, i);\n\n        if (peer_has_vnet_hdr(n) &&\n            qemu_has_vnet_hdr_len(nc->peer, n->guest_hdr_len)) {\n            qemu_set_vnet_hdr_len(nc->peer, n->guest_hdr_len);\n            n->host_hdr_len = n->guest_hdr_len;\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_set_mrg_rx_bufs(VirtIONet *n, int mergeable_rx_bufs)\n{\n    int i;\n    NetClientState *nc;\n\n    n->mergeable_rx_bufs = mergeable_rx_bufs;\n\n    n->guest_hdr_len = n->mergeable_rx_bufs ?\n        sizeof(struct virtio_net_hdr_mrg_rxbuf) : sizeof(struct virtio_net_hdr);\n\n    for (i = 0; i < n->max_queues; i++) {\n        nc = qemu_get_subqueue(n->nic, i);\n\n        if (peer_has_vnet_hdr(n) &&\n            qemu_has_vnet_hdr_len(nc->peer, n->guest_hdr_len)) {\n            qemu_set_vnet_hdr_len(nc->peer, n->guest_hdr_len);\n            n->host_hdr_len = n->guest_hdr_len;\n        }\n    }\n}\n",
        "linevul": 4.706620893557556e-05
    },
    {
        "code": "e1000e_set_pbaclr(E1000ECore *core, int index, uint32_t val)\n{\n    int i;\n\n    core->mac[PBACLR] = val & E1000_PBACLR_VALID_MASK;\n\n    if (!msix_enabled(core->owner)) {\n        return;\n    }\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        if (core->mac[PBACLR] & BIT(i)) {\n            msix_clr_pending(core->owner, i);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_set_pbaclr(E1000ECore *core, int index, uint32_t val)\n{\n    int i;\n\n    core->mac[PBACLR] = val & E1000_PBACLR_VALID_MASK;\n\n    if (!msix_enabled(core->owner)) {\n        return;\n    }\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        if (core->mac[PBACLR] & BIT(i)) {\n            msix_clr_pending(core->owner, i);\n        }\n    }\n}\n",
        "linevul": 4.996563075110316e-05
    },
    {
        "code": "static const char *vnc_auth_name(VncDisplay *vd) {\n    switch (vd->auth) {\n    case VNC_AUTH_INVALID:\n        return \"invalid\";\n    case VNC_AUTH_NONE:\n        return \"none\";\n    case VNC_AUTH_VNC:\n        return \"vnc\";\n    case VNC_AUTH_RA2:\n        return \"ra2\";\n    case VNC_AUTH_RA2NE:\n        return \"ra2ne\";\n    case VNC_AUTH_TIGHT:\n        return \"tight\";\n    case VNC_AUTH_ULTRA:\n        return \"ultra\";\n    case VNC_AUTH_TLS:\n        return \"tls\";\n    case VNC_AUTH_VENCRYPT:\n#ifdef CONFIG_VNC_TLS\n        switch (vd->subauth) {\n        case VNC_AUTH_VENCRYPT_PLAIN:\n            return \"vencrypt+plain\";\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n            return \"vencrypt+tls+none\";\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n            return \"vencrypt+tls+vnc\";\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n            return \"vencrypt+tls+plain\";\n        case VNC_AUTH_VENCRYPT_X509NONE:\n            return \"vencrypt+x509+none\";\n        case VNC_AUTH_VENCRYPT_X509VNC:\n            return \"vencrypt+x509+vnc\";\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n            return \"vencrypt+x509+plain\";\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n            return \"vencrypt+tls+sasl\";\n        case VNC_AUTH_VENCRYPT_X509SASL:\n            return \"vencrypt+x509+sasl\";\n        default:\n            return \"vencrypt\";\n        }\n#else\n        return \"vencrypt\";\n#endif\n    case VNC_AUTH_SASL:\n        return \"sasl\";\n    }\n    return \"unknown\";\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static const char *vnc_auth_name(VncDisplay *vd) {\n    switch (vd->auth) {\n    case VNC_AUTH_INVALID:\n        return \"invalid\";\n    case VNC_AUTH_NONE:\n        return \"none\";\n    case VNC_AUTH_VNC:\n        return \"vnc\";\n    case VNC_AUTH_RA2:\n        return \"ra2\";\n    case VNC_AUTH_RA2NE:\n        return \"ra2ne\";\n    case VNC_AUTH_TIGHT:\n        return \"tight\";\n    case VNC_AUTH_ULTRA:\n        return \"ultra\";\n    case VNC_AUTH_TLS:\n        return \"tls\";\n    case VNC_AUTH_VENCRYPT:\n#ifdef CONFIG_VNC_TLS\n        switch (vd->subauth) {\n        case VNC_AUTH_VENCRYPT_PLAIN:\n            return \"vencrypt+plain\";\n        case VNC_AUTH_VENCRYPT_TLSNONE:\n            return \"vencrypt+tls+none\";\n        case VNC_AUTH_VENCRYPT_TLSVNC:\n            return \"vencrypt+tls+vnc\";\n        case VNC_AUTH_VENCRYPT_TLSPLAIN:\n            return \"vencrypt+tls+plain\";\n        case VNC_AUTH_VENCRYPT_X509NONE:\n            return \"vencrypt+x509+none\";\n        case VNC_AUTH_VENCRYPT_X509VNC:\n            return \"vencrypt+x509+vnc\";\n        case VNC_AUTH_VENCRYPT_X509PLAIN:\n            return \"vencrypt+x509+plain\";\n        case VNC_AUTH_VENCRYPT_TLSSASL:\n            return \"vencrypt+tls+sasl\";\n        case VNC_AUTH_VENCRYPT_X509SASL:\n            return \"vencrypt+x509+sasl\";\n        default:\n            return \"vencrypt\";\n        }\n#else\n        return \"vencrypt\";\n#endif\n    case VNC_AUTH_SASL:\n        return \"sasl\";\n    }\n    return \"unknown\";\n}\n",
        "linevul": 5.2023959142388776e-05
    },
    {
        "code": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n{\n    ssize_t ret;\n    guint watch;\n    assert(qemu_in_coroutine());\n    /* Negotiation are always in main loop. */\n    watch = qio_channel_add_watch(ioc,\n                                  G_IO_OUT,\n                                  nbd_negotiate_continue,\n                                  qemu_coroutine_self(),\n                                  NULL);\n    ret = nbd_write(ioc, buffer, size, NULL);\n    g_source_remove(watch);\n    return ret;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=2b0bbc4f8809c972bad134bc1a2570dbb01dea0b",
        "vul_func_with_fix": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n//flaw_line_below:\n{\n//flaw_line_below:\n    ssize_t ret;\n//flaw_line_below:\n    guint watch;\n//flaw_line_below:\n\n//flaw_line_below:\n    assert(qemu_in_coroutine());\n//flaw_line_below:\n    /* Negotiation are always in main loop. */\n//flaw_line_below:\n    watch = qio_channel_add_watch(ioc,\n//flaw_line_below:\n                                  G_IO_OUT,\n//flaw_line_below:\n                                  nbd_negotiate_continue,\n//flaw_line_below:\n                                  qemu_coroutine_self(),\n//flaw_line_below:\n                                  NULL);\n//flaw_line_below:\n    ret = nbd_write(ioc, buffer, size, NULL);\n//flaw_line_below:\n    g_source_remove(watch);\n//flaw_line_below:\n    return ret;\n//flaw_line_below:\n}\n",
        "linevul": 8.159638673532754e-05
    },
    {
        "code": "static uint32_t virtio_net_get_features(VirtIODevice *vdev, uint32_t features)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    features |= (1 << VIRTIO_NET_F_MAC);\n\n    if (!peer_has_vnet_hdr(n)) {\n        features &= ~(0x1 << VIRTIO_NET_F_CSUM);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_TSO4);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_TSO6);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_ECN);\n\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_CSUM);\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_TSO4);\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_TSO6);\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_ECN);\n    }\n\n    if (!peer_has_vnet_hdr(n) || !peer_has_ufo(n)) {\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_UFO);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_UFO);\n    }\n\n    if (!nc->peer || nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {\n        return features;\n    }\n    if (!tap_get_vhost_net(nc->peer)) {\n        return features;\n    }\n    return vhost_net_get_features(tap_get_vhost_net(nc->peer), features);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static uint32_t virtio_net_get_features(VirtIODevice *vdev, uint32_t features)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    features |= (1 << VIRTIO_NET_F_MAC);\n\n    if (!peer_has_vnet_hdr(n)) {\n        features &= ~(0x1 << VIRTIO_NET_F_CSUM);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_TSO4);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_TSO6);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_ECN);\n\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_CSUM);\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_TSO4);\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_TSO6);\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_ECN);\n    }\n\n    if (!peer_has_vnet_hdr(n) || !peer_has_ufo(n)) {\n        features &= ~(0x1 << VIRTIO_NET_F_GUEST_UFO);\n        features &= ~(0x1 << VIRTIO_NET_F_HOST_UFO);\n    }\n\n    if (!nc->peer || nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {\n        return features;\n    }\n    if (!tap_get_vhost_net(nc->peer)) {\n        return features;\n    }\n    return vhost_net_get_features(tap_get_vhost_net(nc->peer), features);\n}\n",
        "linevul": 4.547881326288916e-05
    },
    {
        "code": "void vnc_write_u32(VncState *vs, uint32_t value)\n{\n    uint8_t buf[4];\n\n    buf[0] = (value >> 24) & 0xFF;\n    buf[1] = (value >> 16) & 0xFF;\n    buf[2] = (value >>  8) & 0xFF;\n    buf[3] = value & 0xFF;\n\n    vnc_write(vs, buf, 4);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "void vnc_write_u32(VncState *vs, uint32_t value)\n{\n    uint8_t buf[4];\n\n    buf[0] = (value >> 24) & 0xFF;\n    buf[1] = (value >> 16) & 0xFF;\n    buf[2] = (value >>  8) & 0xFF;\n    buf[3] = value & 0xFF;\n\n    vnc_write(vs, buf, 4);\n}\n",
        "linevul": 4.596163489622995e-05
    },
    {
        "code": "static void *rndis_queue_response(USBNetState *s, unsigned int length)\n{\n    struct rndis_response *r =\n            g_malloc0(sizeof(struct rndis_response) + length);\n\n    if (QTAILQ_EMPTY(&s->rndis_resp)) {\n        usb_wakeup(s->intr, 0);\n    }\n\n    QTAILQ_INSERT_TAIL(&s->rndis_resp, r, entries);\n    r->length = length;\n\n    return &r->buf[0];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "vul_func_with_fix": "static void *rndis_queue_response(USBNetState *s, unsigned int length)\n{\n    struct rndis_response *r =\n            g_malloc0(sizeof(struct rndis_response) + length);\n\n    if (QTAILQ_EMPTY(&s->rndis_resp)) {\n        usb_wakeup(s->intr, 0);\n    }\n\n    QTAILQ_INSERT_TAIL(&s->rndis_resp, r, entries);\n    r->length = length;\n\n    return &r->buf[0];\n}\n",
        "linevul": 0.00029861280927434564
    },
    {
        "code": "static int handle_symlink(FsContext *fs_ctx, const char *oldpath,\n                          V9fsPath *dir_path, const char *name, FsCred *credp)\n{\n    int fd, dirfd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    ret = symlinkat(oldpath, dirfd, name);\n    if (!ret) {\n        fd = openat(dirfd, name, O_PATH | O_NOFOLLOW);\n        if (fd < 0) {\n            ret = fd;\n            goto err_out;\n        }\n        ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n        close(fd);\n    }\nerr_out:\n    close(dirfd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_symlink(FsContext *fs_ctx, const char *oldpath,\n                          V9fsPath *dir_path, const char *name, FsCred *credp)\n{\n    int fd, dirfd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    dirfd = open_by_handle(data->mountfd, dir_path->data, O_PATH);\n    if (dirfd < 0) {\n        return dirfd;\n    }\n    ret = symlinkat(oldpath, dirfd, name);\n    if (!ret) {\n        fd = openat(dirfd, name, O_PATH | O_NOFOLLOW);\n        if (fd < 0) {\n            ret = fd;\n            goto err_out;\n        }\n        ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n        close(fd);\n    }\nerr_out:\n    close(dirfd);\n    return ret;\n}\n",
        "linevul": 0.00014385163376573473
    },
    {
        "code": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n                             const E1000E_RxRing *rxr,\n                             const E1000E_RSSInfo *rss_info)\n{\n    PCIDevice *d = core->owner;\n    dma_addr_t base;\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n    size_t desc_size;\n    size_t desc_offset = 0;\n    size_t iov_ofs = 0;\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n    size_t size = net_rx_pkt_get_total_len(pkt);\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n    const E1000E_RingInfo *rxi;\n    size_t ps_hdr_len = 0;\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n    bool is_first = true;\n\n    rxi = rxr->i;\n\n    do {\n        hwaddr ba[MAX_PS_BUFFERS];\n        e1000e_ba_state bastate = { { 0 } };\n        bool is_last = false;\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > core->rx_desc_buf_size) {\n            desc_size = core->rx_desc_buf_size;\n             desc_size = core->rx_desc_buf_size;\n         }\n \n         base = e1000e_ring_head_descr(core, rxi);\n \n         pci_dma_read(d, base, &desc, core->rx_desc_len);\n        if (ba[0]) {\n            if (desc_offset < size) {\n                static const uint32_t fcs_pad;\n                size_t iov_copy;\n                size_t copy_size = size - desc_offset;\n                if (copy_size > core->rx_desc_buf_size) {\n                    copy_size = core->rx_desc_buf_size;\n                }\n\n                /* For PS mode copy the packet header first */\n                if (do_ps) {\n                    if (is_first) {\n                        size_t ps_hdr_copied = 0;\n                        do {\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n                                           iov->iov_len - iov_ofs);\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                      iov->iov_base, iov_copy);\n\n                            copy_size -= iov_copy;\n                            ps_hdr_copied += iov_copy;\n\n                            iov_ofs += iov_copy;\n                            if (iov_ofs == iov->iov_len) {\n                                iov++;\n                                iov_ofs = 0;\n                            }\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n                        is_first = false;\n                    } else {\n                        /* Leave buffer 0 of each descriptor except first */\n                        /* empty as per spec 7.1.5.1                      */\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                       NULL, 0);\n                    }\n                }\n\n                /* Copy packet payload */\n                while (copy_size) {\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n                    iov_ofs += iov_copy;\n                    if (iov_ofs == iov->iov_len) {\n                        iov++;\n                        iov_ofs = 0;\n                    }\n                }\n\n                if (desc_offset + desc_size >= total_size) {\n                    /* Simulate FCS checksum presence in the last descriptor */\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n                }\n            }\n            desc_offset += desc_size;\n            if (desc_offset >= total_size) {\n                is_last = true;\n            }\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n            trace_e1000e_rx_null_descriptor();\n        }\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n        e1000e_ring_advance(core, rxi,\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n    } while (desc_offset < total_size);\n\n    e1000e_update_rx_stats(core, size, total_size);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n                             const E1000E_RxRing *rxr,\n                             const E1000E_RSSInfo *rss_info)\n{\n    PCIDevice *d = core->owner;\n    dma_addr_t base;\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n    size_t desc_size;\n    size_t desc_offset = 0;\n    size_t iov_ofs = 0;\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n    size_t size = net_rx_pkt_get_total_len(pkt);\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n    const E1000E_RingInfo *rxi;\n    size_t ps_hdr_len = 0;\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n    bool is_first = true;\n\n    rxi = rxr->i;\n\n    do {\n        hwaddr ba[MAX_PS_BUFFERS];\n        e1000e_ba_state bastate = { { 0 } };\n        bool is_last = false;\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > core->rx_desc_buf_size) {\n            desc_size = core->rx_desc_buf_size;\n             desc_size = core->rx_desc_buf_size;\n         }\n \n//fix_flaw_line_below:\n//        if (e1000e_ring_empty(core, rxi)) {\n//fix_flaw_line_below:\n//            return;\n//fix_flaw_line_below:\n//        }\n//fix_flaw_line_below:\n//\n         base = e1000e_ring_head_descr(core, rxi);\n \n         pci_dma_read(d, base, &desc, core->rx_desc_len);\n        if (ba[0]) {\n            if (desc_offset < size) {\n                static const uint32_t fcs_pad;\n                size_t iov_copy;\n                size_t copy_size = size - desc_offset;\n                if (copy_size > core->rx_desc_buf_size) {\n                    copy_size = core->rx_desc_buf_size;\n                }\n\n                /* For PS mode copy the packet header first */\n                if (do_ps) {\n                    if (is_first) {\n                        size_t ps_hdr_copied = 0;\n                        do {\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n                                           iov->iov_len - iov_ofs);\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                      iov->iov_base, iov_copy);\n\n                            copy_size -= iov_copy;\n                            ps_hdr_copied += iov_copy;\n\n                            iov_ofs += iov_copy;\n                            if (iov_ofs == iov->iov_len) {\n                                iov++;\n                                iov_ofs = 0;\n                            }\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n                        is_first = false;\n                    } else {\n                        /* Leave buffer 0 of each descriptor except first */\n                        /* empty as per spec 7.1.5.1                      */\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                       NULL, 0);\n                    }\n                }\n\n                /* Copy packet payload */\n                while (copy_size) {\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n                    iov_ofs += iov_copy;\n                    if (iov_ofs == iov->iov_len) {\n                        iov++;\n                        iov_ofs = 0;\n                    }\n                }\n\n                if (desc_offset + desc_size >= total_size) {\n                    /* Simulate FCS checksum presence in the last descriptor */\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n                }\n            }\n            desc_offset += desc_size;\n            if (desc_offset >= total_size) {\n                is_last = true;\n            }\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n            trace_e1000e_rx_null_descriptor();\n        }\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n        e1000e_ring_advance(core, rxi,\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n    } while (desc_offset < total_size);\n\n    e1000e_update_rx_stats(core, size, total_size);\n}\n",
        "linevul": 0.30307674407958984
    },
    {
        "code": "static int path_has_protocol(const char *path)\n{\n    const char *p;\n\n#ifdef _WIN32\n    if (is_windows_drive(path) ||\n        is_windows_drive_prefix(path)) {\n        return 0;\n    }\n    p = path + strcspn(path, \":/\\\\\");\n#else\n    p = path + strcspn(path, \":/\");\n#endif\n\n    return *p == ':';\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static int path_has_protocol(const char *path)\n{\n    const char *p;\n\n#ifdef _WIN32\n    if (is_windows_drive(path) ||\n        is_windows_drive_prefix(path)) {\n        return 0;\n    }\n    p = path + strcspn(path, \":/\\\\\");\n#else\n    p = path + strcspn(path, \":/\");\n#endif\n\n    return *p == ':';\n}\n",
        "linevul": 7.069203275023028e-05
    },
    {
        "code": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n    size_t len, size_t buflen)\n{\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n    if (buflen < ext_len) {\n        return -ENOSPC;\n    }\n\n    *ext_backing_fmt = (QCowExtension) {\n        .magic  = cpu_to_be32(magic),\n        .len    = cpu_to_be32(len),\n    };\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n    return ext_len;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9",
        "vul_func_with_fix": "static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n    size_t len, size_t buflen)\n{\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n    if (buflen < ext_len) {\n        return -ENOSPC;\n    }\n\n    *ext_backing_fmt = (QCowExtension) {\n        .magic  = cpu_to_be32(magic),\n        .len    = cpu_to_be32(len),\n    };\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n    return ext_len;\n}\n",
        "linevul": 5.8529221860226244e-05
    },
    {
        "code": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n {\n     SCSIRequest *req = &r->req;\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n     uint64_t nb_sectors;\n     int buflen = 0;\n \n     switch (req->cmd.buf[0]) {\n     case TEST_UNIT_READY:\n         if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n//fix_flaw_line_below:\n//static int scsi_disk_emulate_command(SCSIDiskReq *r)\n {\n     SCSIRequest *req = &r->req;\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n     uint64_t nb_sectors;\n//fix_flaw_line_below:\n//    uint8_t *outbuf;\n     int buflen = 0;\n \n//fix_flaw_line_below:\n//    if (!r->iov.iov_base) {\n//fix_flaw_line_below:\n//        /*\n//fix_flaw_line_below:\n//         * FIXME: we shouldn't return anything bigger than 4k, but the code\n//fix_flaw_line_below:\n//         * requires the buffer to be as big as req->cmd.xfer in several\n//fix_flaw_line_below:\n//         * places.  So, do not allow CDBs with a very large ALLOCATION\n//fix_flaw_line_below:\n//         * LENGTH.  The real fix would be to modify scsi_read_data and\n//fix_flaw_line_below:\n//         * dma_buf_read, so that they return data beyond the buflen\n//fix_flaw_line_below:\n//         * as all zeros.\n//fix_flaw_line_below:\n//         */\n//fix_flaw_line_below:\n//        if (req->cmd.xfer > 65536) {\n//fix_flaw_line_below:\n//            goto illegal_request;\n//fix_flaw_line_below:\n//        }\n//fix_flaw_line_below:\n//        r->buflen = MAX(4096, req->cmd.xfer);\n//fix_flaw_line_below:\n//        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    outbuf = r->iov.iov_base;\n     switch (req->cmd.buf[0]) {\n     case TEST_UNIT_READY:\n         if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n",
        "linevul": 0.99874347448349
    },
    {
        "code": "int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n                        bool exact_size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int new_l1_size2, ret, i;\n    uint64_t *new_l1_table;\n    int64_t old_l1_table_offset, old_l1_size;\n    int64_t new_l1_table_offset, new_l1_size;\n    uint8_t data[12];\n\n    if (min_size <= s->l1_size)\n        return 0;\n\n    if (exact_size) {\n        new_l1_size = min_size;\n    } else {\n        /* Bump size up to reduce the number of times we have to grow */\n        new_l1_size = s->l1_size;\n        if (new_l1_size == 0) {\n            new_l1_size = 1;\n        }\n        while (min_size > new_l1_size) {\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n         }\n     }\n \n    if (new_l1_size > INT_MAX) {\n         return -EFBIG;\n     }\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"grow l1_table from %d to %\" PRId64 \"\\n\",\n            s->l1_size, new_l1_size);\n#endif\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n    /* write new table (align to cluster) */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n    if (new_l1_table_offset < 0) {\n        g_free(new_l1_table);\n        return new_l1_table_offset;\n    }\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* the L1 position has not yet been updated, so these clusters must\n     * indeed be completely free */\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_l1_table_offset,\n                                        new_l1_size2);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n    if (ret < 0)\n        goto fail;\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n    /* set new table */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n    stq_be_p(data + 4, new_l1_table_offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n    if (ret < 0) {\n        goto fail;\n    }\n    g_free(s->l1_table);\n    old_l1_table_offset = s->l1_table_offset;\n    s->l1_table_offset = new_l1_table_offset;\n    s->l1_table = new_l1_table;\n    old_l1_size = s->l1_size;\n    s->l1_size = new_l1_size;\n    qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    return 0;\n fail:\n    g_free(new_l1_table);\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n                        QCOW2_DISCARD_OTHER);\n    return ret;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cab60de930684c33f67d4e32c7509b567f8c445b",
        "vul_func_with_fix": "int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n                        bool exact_size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int new_l1_size2, ret, i;\n    uint64_t *new_l1_table;\n    int64_t old_l1_table_offset, old_l1_size;\n    int64_t new_l1_table_offset, new_l1_size;\n    uint8_t data[12];\n\n    if (min_size <= s->l1_size)\n        return 0;\n\n    if (exact_size) {\n        new_l1_size = min_size;\n    } else {\n        /* Bump size up to reduce the number of times we have to grow */\n        new_l1_size = s->l1_size;\n        if (new_l1_size == 0) {\n            new_l1_size = 1;\n        }\n        while (min_size > new_l1_size) {\n            new_l1_size = (new_l1_size * 3 + 1) / 2;\n         }\n     }\n \n//flaw_line_below:\n    if (new_l1_size > INT_MAX) {\n//fix_flaw_line_below:\n//    if (new_l1_size > INT_MAX / sizeof(uint64_t)) {\n         return -EFBIG;\n     }\n#ifdef DEBUG_ALLOC2\n    fprintf(stderr, \"grow l1_table from %d to %\" PRId64 \"\\n\",\n            s->l1_size, new_l1_size);\n#endif\n\n    new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n    new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n    memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n\n    /* write new table (align to cluster) */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n    new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n    if (new_l1_table_offset < 0) {\n        g_free(new_l1_table);\n        return new_l1_table_offset;\n    }\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /* the L1 position has not yet been updated, so these clusters must\n     * indeed be completely free */\n    ret = qcow2_pre_write_overlap_check(bs, 0, new_l1_table_offset,\n                                        new_l1_size2);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n    ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n    if (ret < 0)\n        goto fail;\n    for(i = 0; i < s->l1_size; i++)\n        new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n\n    /* set new table */\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n    cpu_to_be32w((uint32_t*)data, new_l1_size);\n    stq_be_p(data + 4, new_l1_table_offset);\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n    if (ret < 0) {\n        goto fail;\n    }\n    g_free(s->l1_table);\n    old_l1_table_offset = s->l1_table_offset;\n    s->l1_table_offset = new_l1_table_offset;\n    s->l1_table = new_l1_table;\n    old_l1_size = s->l1_size;\n    s->l1_size = new_l1_size;\n    qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * sizeof(uint64_t),\n                        QCOW2_DISCARD_OTHER);\n    return 0;\n fail:\n    g_free(new_l1_table);\n    qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n                        QCOW2_DISCARD_OTHER);\n    return ret;\n}\n",
        "linevul": 0.31555941700935364
    },
    {
        "code": "vmxnet3_on_interrupt_mask_changed(VMXNET3State *s, int lidx, bool is_masked)\n{\n    s->interrupt_states[lidx].is_masked = is_masked;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_on_interrupt_mask_changed(VMXNET3State *s, int lidx, bool is_masked)\n{\n    s->interrupt_states[lidx].is_masked = is_masked;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n",
        "linevul": 5.657146539306268e-05
    },
    {
        "code": "void bdrv_emit_qmp_error_event(const BlockDriverState *bdrv,\n                               enum MonitorEvent ev,\n                               BlockErrorAction action, bool is_read)\n{\n    QObject *data;\n    const char *action_str;\n\n    switch (action) {\n    case BDRV_ACTION_REPORT:\n        action_str = \"report\";\n        break;\n    case BDRV_ACTION_IGNORE:\n        action_str = \"ignore\";\n        break;\n    case BDRV_ACTION_STOP:\n        action_str = \"stop\";\n        break;\n    default:\n        abort();\n    }\n\n    data = qobject_from_jsonf(\"{ 'device': %s, 'action': %s, 'operation': %s }\",\n                              bdrv->device_name,\n                              action_str,\n                              is_read ? \"read\" : \"write\");\n    monitor_protocol_event(ev, data);\n\n    qobject_decref(data);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "void bdrv_emit_qmp_error_event(const BlockDriverState *bdrv,\n                               enum MonitorEvent ev,\n                               BlockErrorAction action, bool is_read)\n{\n    QObject *data;\n    const char *action_str;\n\n    switch (action) {\n    case BDRV_ACTION_REPORT:\n        action_str = \"report\";\n        break;\n    case BDRV_ACTION_IGNORE:\n        action_str = \"ignore\";\n        break;\n    case BDRV_ACTION_STOP:\n        action_str = \"stop\";\n        break;\n    default:\n        abort();\n    }\n\n    data = qobject_from_jsonf(\"{ 'device': %s, 'action': %s, 'operation': %s }\",\n                              bdrv->device_name,\n                              action_str,\n                              is_read ? \"read\" : \"write\");\n    monitor_protocol_event(ev, data);\n\n    qobject_decref(data);\n}\n",
        "linevul": 0.0001491103757871315
    },
    {
        "code": "e1000e_write_ps_rx_descr(E1000ECore *core, uint8_t *desc,\n                         struct NetRxPkt *pkt,\n                         const E1000E_RSSInfo *rss_info,\n                         size_t ps_hdr_len,\n                         uint16_t(*written)[MAX_PS_BUFFERS])\n{\n    int i;\n    union e1000_rx_desc_packet_split *d =\n        (union e1000_rx_desc_packet_split *) desc;\n\n    memset(&d->wb, 0, sizeof(d->wb));\n\n    d->wb.middle.length0 = cpu_to_le16((*written)[0]);\n\n    for (i = 0; i < PS_PAGE_BUFFERS; i++) {\n        d->wb.upper.length[i] = cpu_to_le16((*written)[i + 1]);\n    }\n\n    e1000e_build_rx_metadata(core, pkt, pkt != NULL,\n                             rss_info,\n                             &d->wb.lower.hi_dword.rss,\n                             &d->wb.lower.mrq,\n                             &d->wb.middle.status_error,\n                             &d->wb.lower.hi_dword.csum_ip.ip_id,\n                             &d->wb.middle.vlan);\n\n    d->wb.upper.header_status =\n        cpu_to_le16(ps_hdr_len | (ps_hdr_len ? E1000_RXDPS_HDRSTAT_HDRSP : 0));\n\n    trace_e1000e_rx_desc_ps_write((*written)[0], (*written)[1],\n                                  (*written)[2], (*written)[3]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_write_ps_rx_descr(E1000ECore *core, uint8_t *desc,\n                         struct NetRxPkt *pkt,\n                         const E1000E_RSSInfo *rss_info,\n                         size_t ps_hdr_len,\n                         uint16_t(*written)[MAX_PS_BUFFERS])\n{\n    int i;\n    union e1000_rx_desc_packet_split *d =\n        (union e1000_rx_desc_packet_split *) desc;\n\n    memset(&d->wb, 0, sizeof(d->wb));\n\n    d->wb.middle.length0 = cpu_to_le16((*written)[0]);\n\n    for (i = 0; i < PS_PAGE_BUFFERS; i++) {\n        d->wb.upper.length[i] = cpu_to_le16((*written)[i + 1]);\n    }\n\n    e1000e_build_rx_metadata(core, pkt, pkt != NULL,\n                             rss_info,\n                             &d->wb.lower.hi_dword.rss,\n                             &d->wb.lower.mrq,\n                             &d->wb.middle.status_error,\n                             &d->wb.lower.hi_dword.csum_ip.ip_id,\n                             &d->wb.middle.vlan);\n\n    d->wb.upper.header_status =\n        cpu_to_le16(ps_hdr_len | (ps_hdr_len ? E1000_RXDPS_HDRSTAT_HDRSP : 0));\n\n    trace_e1000e_rx_desc_ps_write((*written)[0], (*written)[1],\n                                  (*written)[2], (*written)[3]);\n}\n",
        "linevul": 6.909506919328123e-05
    },
    {
        "code": "e1000e_set_rx_control(E1000ECore *core, int index, uint32_t val)\n{\n    core->mac[RCTL] = val;\n    trace_e1000e_rx_set_rctl(core->mac[RCTL]);\n\n    if (val & E1000_RCTL_EN) {\n        e1000e_parse_rxbufsize(core);\n        e1000e_calc_rxdesclen(core);\n        core->rxbuf_min_shift = ((val / E1000_RCTL_RDMTS_QUAT) & 3) + 1 +\n                                E1000_RING_DESC_LEN_SHIFT;\n\n        e1000e_start_recv(core);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_set_rx_control(E1000ECore *core, int index, uint32_t val)\n{\n    core->mac[RCTL] = val;\n    trace_e1000e_rx_set_rctl(core->mac[RCTL]);\n\n    if (val & E1000_RCTL_EN) {\n        e1000e_parse_rxbufsize(core);\n        e1000e_calc_rxdesclen(core);\n        core->rxbuf_min_shift = ((val / E1000_RCTL_RDMTS_QUAT) & 3) + 1 +\n                                E1000_RING_DESC_LEN_SHIFT;\n\n        e1000e_start_recv(core);\n    }\n}\n",
        "linevul": 4.615384023054503e-05
    },
    {
        "code": "vmxnet3_read_next_rx_descr(VMXNET3State *s, int qidx, int ridx,\n                           struct Vmxnet3_RxDesc *dbuf, uint32_t *didx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    Vmxnet3Ring *ring = &s->rxq_descr[qidx].rx_ring[ridx];\n    *didx = vmxnet3_ring_curr_cell_idx(ring);\n    vmxnet3_ring_read_curr_cell(d, ring, dbuf);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_read_next_rx_descr(VMXNET3State *s, int qidx, int ridx,\n                           struct Vmxnet3_RxDesc *dbuf, uint32_t *didx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n\n    Vmxnet3Ring *ring = &s->rxq_descr[qidx].rx_ring[ridx];\n    *didx = vmxnet3_ring_curr_cell_idx(ring);\n    vmxnet3_ring_read_curr_cell(d, ring, dbuf);\n}\n",
        "linevul": 4.896376049146056e-05
    },
    {
        "code": "static int proxy_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n{\n    int retval;\n    retval = v9fs_request(fs_ctx->private, T_LSTAT, stbuf, fs_path);\n    if (retval < 0) {\n        errno = -retval;\n        return -1;\n    }\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n{\n    int retval;\n    retval = v9fs_request(fs_ctx->private, T_LSTAT, stbuf, fs_path);\n    if (retval < 0) {\n        errno = -retval;\n        return -1;\n    }\n    return retval;\n}\n",
        "linevul": 5.4523523431271315e-05
    },
    {
        "code": "static void ohci_mem_write(void *opaque,\n                           hwaddr addr,\n                           uint64_t val,\n                           unsigned size)\n{\n    OHCIState *ohci = opaque;\n\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        trace_usb_ohci_mem_write_unaligned(addr);\n        return;\n    }\n\n    if (addr >= 0x54 && addr < 0x54 + ohci->num_ports * 4) {\n        /* HcRhPortStatus */\n        ohci_port_set_status(ohci, (addr - 0x54) >> 2, val);\n        return;\n    }\n\n    switch (addr >> 2) {\n    case 1: /* HcControl */\n        ohci_set_ctl(ohci, val);\n        break;\n\n    case 2: /* HcCommandStatus */\n        /* SOC is read-only */\n        val = (val & ~OHCI_STATUS_SOC);\n\n        /* Bits written as '0' remain unchanged in the register */\n        ohci->status |= val;\n\n        if (ohci->status & OHCI_STATUS_HCR)\n            ohci_soft_reset(ohci);\n        break;\n\n    case 3: /* HcInterruptStatus */\n        ohci->intr_status &= ~val;\n        ohci_intr_update(ohci);\n        break;\n\n    case 4: /* HcInterruptEnable */\n        ohci->intr |= val;\n        ohci_intr_update(ohci);\n        break;\n\n    case 5: /* HcInterruptDisable */\n        ohci->intr &= ~val;\n        ohci_intr_update(ohci);\n        break;\n\n    case 6: /* HcHCCA */\n        ohci->hcca = val & OHCI_HCCA_MASK;\n        break;\n\n    case 7: /* HcPeriodCurrentED */\n        /* Ignore writes to this read-only register, Linux does them */\n        break;\n\n    case 8: /* HcControlHeadED */\n        ohci->ctrl_head = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 9: /* HcControlCurrentED */\n        ohci->ctrl_cur = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 10: /* HcBulkHeadED */\n        ohci->bulk_head = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 11: /* HcBulkCurrentED */\n        ohci->bulk_cur = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 13: /* HcFmInterval */\n        ohci->fsmps = (val & OHCI_FMI_FSMPS) >> 16;\n        ohci->fit = (val & OHCI_FMI_FIT) >> 31;\n        ohci_set_frame_interval(ohci, val);\n        break;\n\n    case 15: /* HcFmNumber */\n        break;\n\n    case 16: /* HcPeriodicStart */\n        ohci->pstart = val & 0xffff;\n        break;\n\n    case 17: /* HcLSThreshold */\n        ohci->lst = val & 0xffff;\n        break;\n\n    case 18: /* HcRhDescriptorA */\n        ohci->rhdesc_a &= ~OHCI_RHA_RW_MASK;\n        ohci->rhdesc_a |= val & OHCI_RHA_RW_MASK;\n        break;\n\n    case 19: /* HcRhDescriptorB */\n        break;\n\n    case 20: /* HcRhStatus */\n        ohci_set_hub_status(ohci, val);\n        break;\n\n    /* PXA27x specific registers */\n    case 24: /* HcStatus */\n        ohci->hstatus &= ~(val & ohci->hmask);\n        break;\n\n    case 25: /* HcHReset */\n        ohci->hreset = val & ~OHCI_HRESET_FSBIR;\n        if (val & OHCI_HRESET_FSBIR)\n            ohci_hard_reset(ohci);\n        break;\n\n    case 26: /* HcHInterruptEnable */\n        ohci->hmask = val;\n        break;\n\n    case 27: /* HcHInterruptTest */\n        ohci->htest = val;\n        break;\n\n    default:\n        trace_usb_ohci_mem_write_bad_offset(addr);\n        break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void ohci_mem_write(void *opaque,\n                           hwaddr addr,\n                           uint64_t val,\n                           unsigned size)\n{\n    OHCIState *ohci = opaque;\n\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        trace_usb_ohci_mem_write_unaligned(addr);\n        return;\n    }\n\n    if (addr >= 0x54 && addr < 0x54 + ohci->num_ports * 4) {\n        /* HcRhPortStatus */\n        ohci_port_set_status(ohci, (addr - 0x54) >> 2, val);\n        return;\n    }\n\n    switch (addr >> 2) {\n    case 1: /* HcControl */\n        ohci_set_ctl(ohci, val);\n        break;\n\n    case 2: /* HcCommandStatus */\n        /* SOC is read-only */\n        val = (val & ~OHCI_STATUS_SOC);\n\n        /* Bits written as '0' remain unchanged in the register */\n        ohci->status |= val;\n\n        if (ohci->status & OHCI_STATUS_HCR)\n            ohci_soft_reset(ohci);\n        break;\n\n    case 3: /* HcInterruptStatus */\n        ohci->intr_status &= ~val;\n        ohci_intr_update(ohci);\n        break;\n\n    case 4: /* HcInterruptEnable */\n        ohci->intr |= val;\n        ohci_intr_update(ohci);\n        break;\n\n    case 5: /* HcInterruptDisable */\n        ohci->intr &= ~val;\n        ohci_intr_update(ohci);\n        break;\n\n    case 6: /* HcHCCA */\n        ohci->hcca = val & OHCI_HCCA_MASK;\n        break;\n\n    case 7: /* HcPeriodCurrentED */\n        /* Ignore writes to this read-only register, Linux does them */\n        break;\n\n    case 8: /* HcControlHeadED */\n        ohci->ctrl_head = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 9: /* HcControlCurrentED */\n        ohci->ctrl_cur = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 10: /* HcBulkHeadED */\n        ohci->bulk_head = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 11: /* HcBulkCurrentED */\n        ohci->bulk_cur = val & OHCI_EDPTR_MASK;\n        break;\n\n    case 13: /* HcFmInterval */\n        ohci->fsmps = (val & OHCI_FMI_FSMPS) >> 16;\n        ohci->fit = (val & OHCI_FMI_FIT) >> 31;\n        ohci_set_frame_interval(ohci, val);\n        break;\n\n    case 15: /* HcFmNumber */\n        break;\n\n    case 16: /* HcPeriodicStart */\n        ohci->pstart = val & 0xffff;\n        break;\n\n    case 17: /* HcLSThreshold */\n        ohci->lst = val & 0xffff;\n        break;\n\n    case 18: /* HcRhDescriptorA */\n        ohci->rhdesc_a &= ~OHCI_RHA_RW_MASK;\n        ohci->rhdesc_a |= val & OHCI_RHA_RW_MASK;\n        break;\n\n    case 19: /* HcRhDescriptorB */\n        break;\n\n    case 20: /* HcRhStatus */\n        ohci_set_hub_status(ohci, val);\n        break;\n\n    /* PXA27x specific registers */\n    case 24: /* HcStatus */\n        ohci->hstatus &= ~(val & ohci->hmask);\n        break;\n\n    case 25: /* HcHReset */\n        ohci->hreset = val & ~OHCI_HRESET_FSBIR;\n        if (val & OHCI_HRESET_FSBIR)\n            ohci_hard_reset(ohci);\n        break;\n\n    case 26: /* HcHInterruptEnable */\n        ohci->hmask = val;\n        break;\n\n    case 27: /* HcHInterruptTest */\n        ohci->htest = val;\n        break;\n\n    default:\n        trace_usb_ohci_mem_write_bad_offset(addr);\n        break;\n    }\n}\n",
        "linevul": 5.931506893830374e-05
    },
    {
        "code": " static void vmxnet3_activate_device(VMXNET3State *s)\n {\n     int i;\n    VMW_CFPRN(\"MTU is %u\", s->mtu);\n\n    s->max_rx_frags =\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.misc.maxNumRxSG);\n\n    if (s->max_rx_frags == 0) {\n        s->max_rx_frags = 1;\n    }\n\n    VMW_CFPRN(\"Max RX fragments is %u\", s->max_rx_frags);\n\n    s->event_int_idx =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.eventIntrIdx);\n    assert(vmxnet3_verify_intx(s, s->event_int_idx));\n    VMW_CFPRN(\"Events interrupt line is %u\", s->event_int_idx);\n\n    s->auto_int_masking =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.autoMask);\n    VMW_CFPRN(\"Automatic interrupt masking is %d\", (int)s->auto_int_masking);\n\n    s->txq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numTxQueues);\n    s->rxq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n\n    VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n\n    qdescr_table_pa =\n        VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n    VMW_CFPRN(\"TX queues descriptors table is at 0x%\" PRIx64, qdescr_table_pa);\n\n    /*\n     * Worst-case scenario is a packet that holds all TX rings space so\n     * we calculate total size of all TX rings for max TX fragments number\n     */\n    s->max_tx_frags = 0;\n\n    /* TX queues */\n    for (i = 0; i < s->txq_num; i++) {\n         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n \n     VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n \n     qdescr_table_pa =\n         VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n\n        VMW_CFPRN(\"TX Queue %d interrupt: %d\", i, s->txq_descr[i].intr_idx);\n\n        /* Read rings memory locations for TX queues */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.txRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.txRingSize);\n\n        vmxnet3_ring_init(&s->txq_descr[i].tx_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxDesc), false);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TX\", i, &s->txq_descr[i].tx_ring);\n\n        s->max_tx_frags += size;\n\n        /* TXC ring */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->txq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxCompDesc), true);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TXC\", i, &s->txq_descr[i].comp_ring);\n\n        s->txq_descr[i].tx_stats_pa =\n            qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);\n\n        memset(&s->txq_descr[i].txq_stats, 0,\n               sizeof(s->txq_descr[i].txq_stats));\n\n        /* Fill device-managed parameters for queues */\n        VMXNET3_WRITE_TX_QUEUE_DESCR32(qdescr_pa,\n                                       ctrl.txThreshold,\n                                       VMXNET3_DEF_TX_THRESHOLD);\n    }\n\n    /* Preallocate TX packet wrapper */\n    VMW_CFPRN(\"Max TX fragments is %u\", s->max_tx_frags);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    /* Read rings memory locations for RX queues */\n    for (i = 0; i < s->rxq_num; i++) {\n        int j;\n        hwaddr qd_pa =\n            qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +\n            i * sizeof(struct Vmxnet3_RxQueueDesc);\n\n        /* Read interrupt number for this RX queue */\n        s->rxq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(qd_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"RX Queue %d interrupt: %d\", i, s->rxq_descr[i].intr_idx);\n\n        /* Read rings memory locations */\n        for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {\n            /* RX rings */\n            pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.rxRingBasePA[j]);\n            size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.rxRingSize[j]);\n            vmxnet3_ring_init(&s->rxq_descr[i].rx_ring[j], pa, size,\n                              sizeof(struct Vmxnet3_RxDesc), false);\n            VMW_CFPRN(\"RX queue %d:%d: Base: %\" PRIx64 \", Size: %d\",\n                      i, j, pa, size);\n        }\n\n        /* RXC ring */\n        pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->rxq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_RxCompDesc), true);\n        VMW_CFPRN(\"RXC queue %d: Base: %\" PRIx64 \", Size: %d\", i, pa, size);\n\n        s->rxq_descr[i].rx_stats_pa =\n            qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);\n        memset(&s->rxq_descr[i].rxq_stats, 0,\n               sizeof(s->rxq_descr[i].rxq_stats));\n    }\n\n    vmxnet3_validate_interrupts(s);\n\n    /* Make sure everything is in place before device activation */\n    smp_wmb();\n\n    vmxnet3_reset_mac(s);\n\n    s->device_active = true;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=9878d173f574df74bde0ff50b2f81009fbee81bb",
        "vul_func_with_fix": " static void vmxnet3_activate_device(VMXNET3State *s)\n {\n     int i;\n    VMW_CFPRN(\"MTU is %u\", s->mtu);\n\n    s->max_rx_frags =\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.misc.maxNumRxSG);\n\n    if (s->max_rx_frags == 0) {\n        s->max_rx_frags = 1;\n    }\n\n    VMW_CFPRN(\"Max RX fragments is %u\", s->max_rx_frags);\n\n    s->event_int_idx =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.eventIntrIdx);\n    assert(vmxnet3_verify_intx(s, s->event_int_idx));\n    VMW_CFPRN(\"Events interrupt line is %u\", s->event_int_idx);\n\n    s->auto_int_masking =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.autoMask);\n    VMW_CFPRN(\"Automatic interrupt masking is %d\", (int)s->auto_int_masking);\n\n    s->txq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numTxQueues);\n    s->rxq_num =\n        VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n\n    VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n\n    qdescr_table_pa =\n        VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n    VMW_CFPRN(\"TX queues descriptors table is at 0x%\" PRIx64, qdescr_table_pa);\n\n    /*\n     * Worst-case scenario is a packet that holds all TX rings space so\n     * we calculate total size of all TX rings for max TX fragments number\n     */\n    s->max_tx_frags = 0;\n\n    /* TX queues */\n    for (i = 0; i < s->txq_num; i++) {\n         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n \n     VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);\n//flaw_line_below:\n    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n//fix_flaw_line_below:\n//    vmxnet3_validate_queues(s);\n \n     qdescr_table_pa =\n         VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n\n        VMW_CFPRN(\"TX Queue %d interrupt: %d\", i, s->txq_descr[i].intr_idx);\n\n        /* Read rings memory locations for TX queues */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.txRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.txRingSize);\n\n        vmxnet3_ring_init(&s->txq_descr[i].tx_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxDesc), false);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TX\", i, &s->txq_descr[i].tx_ring);\n\n        s->max_tx_frags += size;\n\n        /* TXC ring */\n        pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->txq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_TxCompDesc), true);\n        VMXNET3_RING_DUMP(VMW_CFPRN, \"TXC\", i, &s->txq_descr[i].comp_ring);\n\n        s->txq_descr[i].tx_stats_pa =\n            qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);\n\n        memset(&s->txq_descr[i].txq_stats, 0,\n               sizeof(s->txq_descr[i].txq_stats));\n\n        /* Fill device-managed parameters for queues */\n        VMXNET3_WRITE_TX_QUEUE_DESCR32(qdescr_pa,\n                                       ctrl.txThreshold,\n                                       VMXNET3_DEF_TX_THRESHOLD);\n    }\n\n    /* Preallocate TX packet wrapper */\n    VMW_CFPRN(\"Max TX fragments is %u\", s->max_tx_frags);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    /* Read rings memory locations for RX queues */\n    for (i = 0; i < s->rxq_num; i++) {\n        int j;\n        hwaddr qd_pa =\n            qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +\n            i * sizeof(struct Vmxnet3_RxQueueDesc);\n\n        /* Read interrupt number for this RX queue */\n        s->rxq_descr[i].intr_idx =\n            VMXNET3_READ_TX_QUEUE_DESCR8(qd_pa, conf.intrIdx);\n        assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));\n\n        VMW_CFPRN(\"RX Queue %d interrupt: %d\", i, s->rxq_descr[i].intr_idx);\n\n        /* Read rings memory locations */\n        for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {\n            /* RX rings */\n            pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.rxRingBasePA[j]);\n            size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.rxRingSize[j]);\n            vmxnet3_ring_init(&s->rxq_descr[i].rx_ring[j], pa, size,\n                              sizeof(struct Vmxnet3_RxDesc), false);\n            VMW_CFPRN(\"RX queue %d:%d: Base: %\" PRIx64 \", Size: %d\",\n                      i, j, pa, size);\n        }\n\n        /* RXC ring */\n        pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.compRingBasePA);\n        size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.compRingSize);\n        vmxnet3_ring_init(&s->rxq_descr[i].comp_ring, pa, size,\n                          sizeof(struct Vmxnet3_RxCompDesc), true);\n        VMW_CFPRN(\"RXC queue %d: Base: %\" PRIx64 \", Size: %d\", i, pa, size);\n\n        s->rxq_descr[i].rx_stats_pa =\n            qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);\n        memset(&s->rxq_descr[i].rxq_stats, 0,\n               sizeof(s->rxq_descr[i].rxq_stats));\n    }\n\n    vmxnet3_validate_interrupts(s);\n\n    /* Make sure everything is in place before device activation */\n    smp_wmb();\n\n    vmxnet3_reset_mac(s);\n\n    s->device_active = true;\n}\n",
        "linevul": 4.8476518713869154e-05
    },
    {
        "code": "static int mode_sense_page(SCSIDiskState *s, int page, uint8_t **p_outbuf,\n                           int page_control)\n{\n    BlockDriverState *bdrv = s->bs;\n    int cylinders, heads, secs;\n    uint8_t *p = *p_outbuf;\n\n    /*\n     * If Changeable Values are requested, a mask denoting those mode parameters\n     * that are changeable shall be returned. As we currently don't support\n     * parameter changes via MODE_SELECT all bits are returned set to zero.\n     * The buffer was already menset to zero by the caller of this function.\n     */\n    switch (page) {\n    case 4: /* Rigid disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 4;\n        p[1] = 0x16;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[2] = (cylinders >> 16) & 0xff;\n        p[3] = (cylinders >> 8) & 0xff;\n        p[4] = cylinders & 0xff;\n        p[5] = heads & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[6] = (cylinders >> 16) & 0xff;\n        p[7] = (cylinders >> 8) & 0xff;\n        p[8] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[9] = (cylinders >> 16) & 0xff;\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Device step rate [ns], 200ns */\n        p[12] = 0;\n        p[13] = 200;\n        /* Landing zone cylinder */\n        p[14] = 0xff;\n        p[15] =  0xff;\n        p[16] = 0xff;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[20] = (5400 >> 8) & 0xff;\n        p[21] = 5400 & 0xff;\n        break;\n\n    case 5: /* Flexible disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 5;\n        p[1] = 0x1e;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* Transfer rate [kbit/s], 5Mbit/s */\n        p[2] = 5000 >> 8;\n        p[3] = 5000 & 0xff;\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[4] = heads & 0xff;\n        p[5] = secs & 0xff;\n        p[6] = s->cluster_size * 2;\n        p[8] = (cylinders >> 8) & 0xff;\n        p[9] = cylinders & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[12] = (cylinders >> 8) & 0xff;\n        p[13] = cylinders & 0xff;\n        /* Device step rate [100us], 100us */\n        p[14] = 0;\n        p[15] = 1;\n        /* Device step pulse width [us], 1us */\n        p[16] = 1;\n        /* Device head settle delay [100us], 100us */\n        p[17] = 0;\n        p[18] = 1;\n        /* Motor on delay [0.1s], 0.1s */\n        p[19] = 1;\n        /* Motor off delay [0.1s], 0.1s */\n        p[20] = 1;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[28] = (5400 >> 8) & 0xff;\n        p[29] = 5400 & 0xff;\n        break;\n\n    case 8: /* Caching page.  */\n        p[0] = 8;\n        p[1] = 0x12;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        if (bdrv_enable_write_cache(s->bs)) {\n            p[2] = 4; /* WCE */\n        }\n        break;\n\n    case 0x2a: /* CD Capabilities and Mechanical Status page. */\n        if (s->qdev.type != TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 0x2a;\n        p[1] = 0x14;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        p[2] = 3; // CD-R & CD-RW read\n        p[3] = 0; // Writing not supported\n        p[4] = 0x7f; /* Audio, composite, digital out,\n                        mode 2 form 1&2, multi session */\n        p[5] = 0xff; /* CD DA, DA accurate, RW supported,\n                        RW corrected, C2 errors, ISRC,\n                        UPC, Bar code */\n        p[6] = 0x2d | (s->tray_locked ? 2 : 0);\n        /* Locking supported, jumper present, eject, tray */\n        p[7] = 0; /* no volume & mute control, no\n                     changer */\n        p[8] = (50 * 176) >> 8; // 50x read speed\n        p[9] = (50 * 176) & 0xff;\n        p[10] = 0 >> 8; // No volume\n        p[11] = 0 & 0xff;\n        p[12] = 2048 >> 8; // 2M buffer\n        p[13] = 2048 & 0xff;\n        p[14] = (16 * 176) >> 8; // 16x read speed current\n        p[15] = (16 * 176) & 0xff;\n        p[18] = (16 * 176) >> 8; // 16x write speed\n        p[19] = (16 * 176) & 0xff;\n        p[20] = (16 * 176) >> 8; // 16x write speed current\n        p[21] = (16 * 176) & 0xff;\n        break;\n\n    default:\n        return -1;\n    }\n\n    *p_outbuf += p[1] + 2;\n    return p[1] + 2;\n}\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static int mode_sense_page(SCSIDiskState *s, int page, uint8_t **p_outbuf,\n                           int page_control)\n{\n    BlockDriverState *bdrv = s->bs;\n    int cylinders, heads, secs;\n    uint8_t *p = *p_outbuf;\n\n    /*\n     * If Changeable Values are requested, a mask denoting those mode parameters\n     * that are changeable shall be returned. As we currently don't support\n     * parameter changes via MODE_SELECT all bits are returned set to zero.\n     * The buffer was already menset to zero by the caller of this function.\n     */\n    switch (page) {\n    case 4: /* Rigid disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 4;\n        p[1] = 0x16;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[2] = (cylinders >> 16) & 0xff;\n        p[3] = (cylinders >> 8) & 0xff;\n        p[4] = cylinders & 0xff;\n        p[5] = heads & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[6] = (cylinders >> 16) & 0xff;\n        p[7] = (cylinders >> 8) & 0xff;\n        p[8] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[9] = (cylinders >> 16) & 0xff;\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Device step rate [ns], 200ns */\n        p[12] = 0;\n        p[13] = 200;\n        /* Landing zone cylinder */\n        p[14] = 0xff;\n        p[15] =  0xff;\n        p[16] = 0xff;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[20] = (5400 >> 8) & 0xff;\n        p[21] = 5400 & 0xff;\n        break;\n\n    case 5: /* Flexible disk device geometry page. */\n        if (s->qdev.type == TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 5;\n        p[1] = 0x1e;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        /* Transfer rate [kbit/s], 5Mbit/s */\n        p[2] = 5000 >> 8;\n        p[3] = 5000 & 0xff;\n        /* if a geometry hint is available, use it */\n        bdrv_get_geometry_hint(bdrv, &cylinders, &heads, &secs);\n        p[4] = heads & 0xff;\n        p[5] = secs & 0xff;\n        p[6] = s->cluster_size * 2;\n        p[8] = (cylinders >> 8) & 0xff;\n        p[9] = cylinders & 0xff;\n        /* Write precomp start cylinder, disabled */\n        p[10] = (cylinders >> 8) & 0xff;\n        p[11] = cylinders & 0xff;\n        /* Reduced current start cylinder, disabled */\n        p[12] = (cylinders >> 8) & 0xff;\n        p[13] = cylinders & 0xff;\n        /* Device step rate [100us], 100us */\n        p[14] = 0;\n        p[15] = 1;\n        /* Device step pulse width [us], 1us */\n        p[16] = 1;\n        /* Device head settle delay [100us], 100us */\n        p[17] = 0;\n        p[18] = 1;\n        /* Motor on delay [0.1s], 0.1s */\n        p[19] = 1;\n        /* Motor off delay [0.1s], 0.1s */\n        p[20] = 1;\n        /* Medium rotation rate [rpm], 5400 rpm */\n        p[28] = (5400 >> 8) & 0xff;\n        p[29] = 5400 & 0xff;\n        break;\n\n    case 8: /* Caching page.  */\n        p[0] = 8;\n        p[1] = 0x12;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        if (bdrv_enable_write_cache(s->bs)) {\n            p[2] = 4; /* WCE */\n        }\n        break;\n\n    case 0x2a: /* CD Capabilities and Mechanical Status page. */\n        if (s->qdev.type != TYPE_ROM) {\n            return -1;\n        }\n        p[0] = 0x2a;\n        p[1] = 0x14;\n        if (page_control == 1) { /* Changeable Values */\n            break;\n        }\n        p[2] = 3; // CD-R & CD-RW read\n        p[3] = 0; // Writing not supported\n        p[4] = 0x7f; /* Audio, composite, digital out,\n                        mode 2 form 1&2, multi session */\n        p[5] = 0xff; /* CD DA, DA accurate, RW supported,\n                        RW corrected, C2 errors, ISRC,\n                        UPC, Bar code */\n        p[6] = 0x2d | (s->tray_locked ? 2 : 0);\n        /* Locking supported, jumper present, eject, tray */\n        p[7] = 0; /* no volume & mute control, no\n                     changer */\n        p[8] = (50 * 176) >> 8; // 50x read speed\n        p[9] = (50 * 176) & 0xff;\n        p[10] = 0 >> 8; // No volume\n        p[11] = 0 & 0xff;\n        p[12] = 2048 >> 8; // 2M buffer\n        p[13] = 2048 & 0xff;\n        p[14] = (16 * 176) >> 8; // 16x read speed current\n        p[15] = (16 * 176) & 0xff;\n        p[18] = (16 * 176) >> 8; // 16x write speed\n        p[19] = (16 * 176) & 0xff;\n        p[20] = (16 * 176) >> 8; // 16x write speed current\n        p[21] = (16 * 176) & 0xff;\n        break;\n\n    default:\n        return -1;\n    }\n\n    *p_outbuf += p[1] + 2;\n    return p[1] + 2;\n}\n",
        "linevul": 6.98329386068508e-05
    },
    {
        "code": "static void peer_test_vnet_hdr(VirtIONet *n)\n{\n    NetClientState *nc = qemu_get_queue(n->nic);\n    if (!nc->peer) {\n        return;\n    }\n\n    n->has_vnet_hdr = qemu_has_vnet_hdr(nc->peer);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void peer_test_vnet_hdr(VirtIONet *n)\n{\n    NetClientState *nc = qemu_get_queue(n->nic);\n    if (!nc->peer) {\n        return;\n    }\n\n    n->has_vnet_hdr = qemu_has_vnet_hdr(nc->peer);\n}\n",
        "linevul": 4.7328114305855706e-05
    },
    {
        "code": "e1000e_intrmgr_delay_tx_causes(E1000ECore *core, uint32_t *causes)\n{\n    static const uint32_t delayable_causes = E1000_ICR_TXQ0 |\n                                             E1000_ICR_TXQ1 |\n                                             E1000_ICR_TXQE |\n                                             E1000_ICR_TXDW;\n\n    if (msix_enabled(core->owner)) {\n        return false;\n    }\n\n    /* Clean up all causes that may be delayed */\n    core->delayed_causes |= *causes & delayable_causes;\n    *causes &= ~delayable_causes;\n\n    /* If there are causes that cannot be delayed */\n    if (*causes != 0) {\n        return false;\n    }\n\n    /* All causes delayed */\n    e1000e_intrmgr_rearm_timer(&core->tidv);\n\n    if (!core->tadv.running && (core->mac[TADV] != 0)) {\n        e1000e_intrmgr_rearm_timer(&core->tadv);\n    }\n\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_intrmgr_delay_tx_causes(E1000ECore *core, uint32_t *causes)\n{\n    static const uint32_t delayable_causes = E1000_ICR_TXQ0 |\n                                             E1000_ICR_TXQ1 |\n                                             E1000_ICR_TXQE |\n                                             E1000_ICR_TXDW;\n\n    if (msix_enabled(core->owner)) {\n        return false;\n    }\n\n    /* Clean up all causes that may be delayed */\n    core->delayed_causes |= *causes & delayable_causes;\n    *causes &= ~delayable_causes;\n\n    /* If there are causes that cannot be delayed */\n    if (*causes != 0) {\n        return false;\n    }\n\n    /* All causes delayed */\n    e1000e_intrmgr_rearm_timer(&core->tidv);\n\n    if (!core->tadv.running && (core->mac[TADV] != 0)) {\n        e1000e_intrmgr_rearm_timer(&core->tadv);\n    }\n\n    return true;\n}\n",
        "linevul": 5.385246913647279e-05
    },
    {
        "code": "static void virtqueue_map_iovec(struct iovec *sg, hwaddr *addr,\n                                unsigned int *num_sg, unsigned int max_size,\n                                int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    /* Note: this function MUST validate input, some callers\n     * are passing in num_sg values received over the network.\n     */\n    /* TODO: teach all callers that this can fail, and return failure instead\n     * of asserting here.\n     * When we do, we might be able to re-enable NDEBUG below.\n     */\n#ifdef NDEBUG\n#error building with NDEBUG is not supported\n#endif\n    assert(*num_sg <= max_size);\n\n    for (i = 0; i < *num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (!sg[i].iov_base) {\n            error_report(\"virtio: error trying to map MMIO memory\");\n            exit(1);\n        }\n        if (len != sg[i].iov_len) {\n            error_report(\"virtio: unexpected memory split\");\n            exit(1);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtqueue_map_iovec(struct iovec *sg, hwaddr *addr,\n                                unsigned int *num_sg, unsigned int max_size,\n                                int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    /* Note: this function MUST validate input, some callers\n     * are passing in num_sg values received over the network.\n     */\n    /* TODO: teach all callers that this can fail, and return failure instead\n     * of asserting here.\n     * When we do, we might be able to re-enable NDEBUG below.\n     */\n#ifdef NDEBUG\n#error building with NDEBUG is not supported\n#endif\n    assert(*num_sg <= max_size);\n\n    for (i = 0; i < *num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (!sg[i].iov_base) {\n            error_report(\"virtio: error trying to map MMIO memory\");\n            exit(1);\n        }\n        if (len != sg[i].iov_len) {\n            error_report(\"virtio: unexpected memory split\");\n            exit(1);\n        }\n    }\n}\n",
        "linevul": 9.936777496477589e-05
    },
    {
        "code": "static VncServerInfo *vnc_server_info_get(void)\n{\n    VncServerInfo *info;\n    VncBasicInfo *bi = vnc_basic_info_get_from_server_addr(vnc_display->lsock);\n    if (!bi) {\n        return NULL;\n    }\n\n    info = g_malloc(sizeof(*info));\n    info->base = bi;\n    info->has_auth = true;\n    info->auth = g_strdup(vnc_auth_name(vnc_display));\n    return info;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static VncServerInfo *vnc_server_info_get(void)\n{\n    VncServerInfo *info;\n    VncBasicInfo *bi = vnc_basic_info_get_from_server_addr(vnc_display->lsock);\n    if (!bi) {\n        return NULL;\n    }\n\n    info = g_malloc(sizeof(*info));\n    info->base = bi;\n    info->has_auth = true;\n    info->auth = g_strdup(vnc_auth_name(vnc_display));\n    return info;\n}\n",
        "linevul": 5.131516809342429e-05
    },
    {
        "code": "e1000e_msix_clear(E1000ECore *core, uint32_t causes)\n{\n    if (causes & E1000_ICR_RXQ0) {\n        e1000e_msix_clear_one(core, E1000_ICR_RXQ0,\n                              E1000_IVAR_RXQ0(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_RXQ1) {\n        e1000e_msix_clear_one(core, E1000_ICR_RXQ1,\n                              E1000_IVAR_RXQ1(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_TXQ0) {\n        e1000e_msix_clear_one(core, E1000_ICR_TXQ0,\n                              E1000_IVAR_TXQ0(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_TXQ1) {\n        e1000e_msix_clear_one(core, E1000_ICR_TXQ1,\n                              E1000_IVAR_TXQ1(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_OTHER) {\n        e1000e_msix_clear_one(core, E1000_ICR_OTHER,\n                              E1000_IVAR_OTHER(core->mac[IVAR]));\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_msix_clear(E1000ECore *core, uint32_t causes)\n{\n    if (causes & E1000_ICR_RXQ0) {\n        e1000e_msix_clear_one(core, E1000_ICR_RXQ0,\n                              E1000_IVAR_RXQ0(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_RXQ1) {\n        e1000e_msix_clear_one(core, E1000_ICR_RXQ1,\n                              E1000_IVAR_RXQ1(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_TXQ0) {\n        e1000e_msix_clear_one(core, E1000_ICR_TXQ0,\n                              E1000_IVAR_TXQ0(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_TXQ1) {\n        e1000e_msix_clear_one(core, E1000_ICR_TXQ1,\n                              E1000_IVAR_TXQ1(core->mac[IVAR]));\n    }\n\n    if (causes & E1000_ICR_OTHER) {\n        e1000e_msix_clear_one(core, E1000_ICR_OTHER,\n                              E1000_IVAR_OTHER(core->mac[IVAR]));\n    }\n}\n",
        "linevul": 4.752421591547318e-05
    },
    {
        "code": "e1000e_set_16bit(E1000ECore *core, int index, uint32_t val)\n{\n    core->mac[index] = val & 0xffff;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_set_16bit(E1000ECore *core, int index, uint32_t val)\n{\n    core->mac[index] = val & 0xffff;\n}\n",
        "linevul": 5.9064630477223545e-05
    },
    {
        "code": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n",
        "linevul": 4.547967910184525e-05
    },
    {
        "code": "static void megasas_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);\n    MegasasBaseClass *e = MEGASAS_DEVICE_CLASS(oc);\n    const MegasasInfo *info = data;\n\n    pc->realize = megasas_scsi_realize;\n    pc->exit = megasas_scsi_uninit;\n    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;\n    pc->device_id = info->device_id;\n    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;\n    pc->subsystem_id = info->subsystem_id;\n    pc->class_id = PCI_CLASS_STORAGE_RAID;\n    pc->is_express = info->is_express;\n    e->mmio_bar = info->mmio_bar;\n    e->ioport_bar = info->ioport_bar;\n    e->osts = info->osts;\n    e->product_name = info->product_name;\n    e->product_version = info->product_version;\n    dc->props = info->props;\n    dc->reset = megasas_scsi_reset;\n    dc->vmsd = info->vmsd;\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n    dc->desc = info->desc;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static void megasas_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);\n    MegasasBaseClass *e = MEGASAS_DEVICE_CLASS(oc);\n    const MegasasInfo *info = data;\n\n    pc->realize = megasas_scsi_realize;\n    pc->exit = megasas_scsi_uninit;\n    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;\n    pc->device_id = info->device_id;\n    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;\n    pc->subsystem_id = info->subsystem_id;\n    pc->class_id = PCI_CLASS_STORAGE_RAID;\n    pc->is_express = info->is_express;\n    e->mmio_bar = info->mmio_bar;\n    e->ioport_bar = info->ioport_bar;\n    e->osts = info->osts;\n    e->product_name = info->product_name;\n    e->product_version = info->product_version;\n    dc->props = info->props;\n    dc->reset = megasas_scsi_reset;\n    dc->vmsd = info->vmsd;\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n    dc->desc = info->desc;\n}\n",
        "linevul": 0.00034132073051296175
    },
    {
        "code": "static int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n{\n    vs->has_dirty += has_dirty;\n    if (vs->need_update && vs->csock != -1) {\n        VncDisplay *vd = vs->vd;\n        VncJob *job;\n        int y;\n        int height, width;\n        int n = 0;\n\n        if (vs->output.offset && !vs->audio_cap && !vs->force_update)\n            /* kernel send buffers are full -> drop frames to throttle */\n            return 0;\n\n        if (!vs->has_dirty && !vs->audio_cap && !vs->force_update)\n            return 0;\n\n        /*\n         * Send screen updates to the vnc client using the server\n         * surface and server dirty map.  guest surface updates\n         * happening in parallel don't disturb us, the next pass will\n         * send them to the client.\n         */\n        job = vnc_job_new(vs);\n\n        height = pixman_image_get_height(vd->server);\n        width = pixman_image_get_width(vd->server);\n\n        y = 0;\n        for (;;) {\n            int x, h;\n            unsigned long x2;\n            unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n                                                 height * VNC_DIRTY_BPL(vs),\n                                                 y * VNC_DIRTY_BPL(vs));\n            if (offset == height * VNC_DIRTY_BPL(vs)) {\n                /* no more dirty bits */\n                break;\n            }\n            y = offset / VNC_DIRTY_BPL(vs);\n            x = offset % VNC_DIRTY_BPL(vs);\n            x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n                                    VNC_DIRTY_BPL(vs), x);\n            bitmap_clear(vs->dirty[y], x, x2 - x);\n            h = find_and_clear_dirty_height(vs, y, x, x2, height);\n            x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n            if (x2 > x) {\n                n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n                                      (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n            }\n        }\n\n        vnc_job_push(job);\n        if (sync) {\n            vnc_jobs_join(vs);\n        }\n        vs->force_update = 0;\n        vs->has_dirty = 0;\n        return n;\n    }\n\n    if (vs->csock == -1) {\n        vnc_disconnect_finish(vs);\n    } else if (sync) {\n        vnc_jobs_join(vs);\n    }\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n{\n    vs->has_dirty += has_dirty;\n    if (vs->need_update && vs->csock != -1) {\n        VncDisplay *vd = vs->vd;\n        VncJob *job;\n        int y;\n        int height, width;\n        int n = 0;\n\n        if (vs->output.offset && !vs->audio_cap && !vs->force_update)\n            /* kernel send buffers are full -> drop frames to throttle */\n            return 0;\n\n        if (!vs->has_dirty && !vs->audio_cap && !vs->force_update)\n            return 0;\n\n        /*\n         * Send screen updates to the vnc client using the server\n         * surface and server dirty map.  guest surface updates\n         * happening in parallel don't disturb us, the next pass will\n         * send them to the client.\n         */\n        job = vnc_job_new(vs);\n\n        height = pixman_image_get_height(vd->server);\n        width = pixman_image_get_width(vd->server);\n\n        y = 0;\n        for (;;) {\n            int x, h;\n            unsigned long x2;\n            unsigned long offset = find_next_bit((unsigned long *) &vs->dirty,\n                                                 height * VNC_DIRTY_BPL(vs),\n                                                 y * VNC_DIRTY_BPL(vs));\n            if (offset == height * VNC_DIRTY_BPL(vs)) {\n                /* no more dirty bits */\n                break;\n            }\n            y = offset / VNC_DIRTY_BPL(vs);\n            x = offset % VNC_DIRTY_BPL(vs);\n            x2 = find_next_zero_bit((unsigned long *) &vs->dirty[y],\n                                    VNC_DIRTY_BPL(vs), x);\n            bitmap_clear(vs->dirty[y], x, x2 - x);\n            h = find_and_clear_dirty_height(vs, y, x, x2, height);\n            x2 = MIN(x2, width / VNC_DIRTY_PIXELS_PER_BIT);\n            if (x2 > x) {\n                n += vnc_job_add_rect(job, x * VNC_DIRTY_PIXELS_PER_BIT, y,\n                                      (x2 - x) * VNC_DIRTY_PIXELS_PER_BIT, h);\n            }\n        }\n\n        vnc_job_push(job);\n        if (sync) {\n            vnc_jobs_join(vs);\n        }\n        vs->force_update = 0;\n        vs->has_dirty = 0;\n        return n;\n    }\n\n    if (vs->csock == -1) {\n        vnc_disconnect_finish(vs);\n    } else if (sync) {\n        vnc_jobs_join(vs);\n    }\n\n    return 0;\n}\n",
        "linevul": 0.00021021334396209568
    },
    {
        "code": "static void megasas_copy_sense(MegasasCmd *cmd)\n{\n    uint8_t sense_buf[SCSI_SENSE_BUF_SIZE];\n    uint8_t sense_len;\n\n    sense_len = scsi_req_get_sense(cmd->req, sense_buf,\n                                   SCSI_SENSE_BUF_SIZE);\n    megasas_build_sense(cmd, sense_buf, sense_len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static void megasas_copy_sense(MegasasCmd *cmd)\n{\n    uint8_t sense_buf[SCSI_SENSE_BUF_SIZE];\n    uint8_t sense_len;\n\n    sense_len = scsi_req_get_sense(cmd->req, sense_buf,\n                                   SCSI_SENSE_BUF_SIZE);\n    megasas_build_sense(cmd, sense_buf, sense_len);\n}\n",
        "linevul": 4.732283196062781e-05
    },
    {
        "code": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* Make the file fid point to xattr */\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    xattr_fidp->fs.xattr.value = g_malloc(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n out_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eb687602853b4ae656e9236ee4222609f3a6887d",
        "vul_func_with_fix": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* Make the file fid point to xattr */\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n//flaw_line_below:\n    xattr_fidp->fs.xattr.value = g_malloc(size);\n//fix_flaw_line_below:\n//    xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n out_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "linevul": 0.0016609113663434982
    },
    {
        "code": "static void v9fs_version(void *opaque)\n{\n    ssize_t err;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsString version;\n    size_t offset = 7;\n\n    v9fs_string_init(&version);\n    err = pdu_unmarshal(pdu, offset, \"ds\", &s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);\n\n    virtfs_reset(pdu);\n\n    if (!strcmp(version.data, \"9P2000.u\")) {\n        s->proto_version = V9FS_PROTO_2000U;\n    } else if (!strcmp(version.data, \"9P2000.L\")) {\n        s->proto_version = V9FS_PROTO_2000L;\n    } else {\n        v9fs_string_sprintf(&version, \"unknown\");\n    }\n\n    err = pdu_marshal(pdu, offset, \"ds\", s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    offset += err;\n    trace_v9fs_version_return(pdu->tag, pdu->id, s->msize, version.data);\nout:\n    pdu_complete(pdu, offset);\n    v9fs_string_free(&version);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_version(void *opaque)\n{\n    ssize_t err;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsString version;\n    size_t offset = 7;\n\n    v9fs_string_init(&version);\n    err = pdu_unmarshal(pdu, offset, \"ds\", &s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);\n\n    virtfs_reset(pdu);\n\n    if (!strcmp(version.data, \"9P2000.u\")) {\n        s->proto_version = V9FS_PROTO_2000U;\n    } else if (!strcmp(version.data, \"9P2000.L\")) {\n        s->proto_version = V9FS_PROTO_2000L;\n    } else {\n        v9fs_string_sprintf(&version, \"unknown\");\n    }\n\n    err = pdu_marshal(pdu, offset, \"ds\", s->msize, &version);\n    if (err < 0) {\n        offset = err;\n        goto out;\n    }\n    offset += err;\n    trace_v9fs_version_return(pdu->tag, pdu->id, s->msize, version.data);\nout:\n    pdu_complete(pdu, offset);\n    v9fs_string_free(&version);\n}\n",
        "linevul": 0.000596996396780014
    },
    {
        "code": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_stat_init(&v9stat);\n    err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_wstat(pdu->tag, pdu->id, fid,\n                     v9stat.mode, v9stat.atime, v9stat.mtime);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* do we need to sync the file? */\n    if (donttouch_stat(&v9stat)) {\n        err = v9fs_co_fsync(pdu, fidp, 0);\n        goto out;\n    }\n    if (v9stat.mode != -1) {\n        uint32_t v9_mode;\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        v9_mode = stat_to_v9mode(&stbuf);\n        if ((v9stat.mode & P9_STAT_MODE_TYPE_BITS) !=\n            (v9_mode & P9_STAT_MODE_TYPE_BITS)) {\n            /* Attempting to change the type */\n            err = -EIO;\n            goto out;\n        }\n        err = v9fs_co_chmod(pdu, &fidp->path,\n                            v9mode_to_mode(v9stat.mode,\n                                           &v9stat.extension));\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.mtime != -1 || v9stat.atime != -1) {\n        struct timespec times[2];\n        if (v9stat.atime != -1) {\n            times[0].tv_sec = v9stat.atime;\n            times[0].tv_nsec = 0;\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9stat.mtime != -1) {\n            times[1].tv_sec = v9stat.mtime;\n            times[1].tv_nsec = 0;\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.n_gid != -1 || v9stat.n_uid != -1) {\n        err = v9fs_co_chown(pdu, &fidp->path, v9stat.n_uid, v9stat.n_gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.name.size != 0) {\n        err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.length != -1) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9stat.length);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    v9fs_stat_free(&v9stat);\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_stat_init(&v9stat);\n    err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_wstat(pdu->tag, pdu->id, fid,\n                     v9stat.mode, v9stat.atime, v9stat.mtime);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* do we need to sync the file? */\n    if (donttouch_stat(&v9stat)) {\n        err = v9fs_co_fsync(pdu, fidp, 0);\n        goto out;\n    }\n    if (v9stat.mode != -1) {\n        uint32_t v9_mode;\n        err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        v9_mode = stat_to_v9mode(&stbuf);\n        if ((v9stat.mode & P9_STAT_MODE_TYPE_BITS) !=\n            (v9_mode & P9_STAT_MODE_TYPE_BITS)) {\n            /* Attempting to change the type */\n            err = -EIO;\n            goto out;\n        }\n        err = v9fs_co_chmod(pdu, &fidp->path,\n                            v9mode_to_mode(v9stat.mode,\n                                           &v9stat.extension));\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.mtime != -1 || v9stat.atime != -1) {\n        struct timespec times[2];\n        if (v9stat.atime != -1) {\n            times[0].tv_sec = v9stat.atime;\n            times[0].tv_nsec = 0;\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9stat.mtime != -1) {\n            times[1].tv_sec = v9stat.mtime;\n            times[1].tv_nsec = 0;\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.n_gid != -1 || v9stat.n_uid != -1) {\n        err = v9fs_co_chown(pdu, &fidp->path, v9stat.n_uid, v9stat.n_gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.name.size != 0) {\n        err = v9fs_complete_rename(pdu, fidp, -1, &v9stat.name);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9stat.length != -1) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9stat.length);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    v9fs_stat_free(&v9stat);\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 7.39592214813456e-05
    },
    {
        "code": "static void megasas_port_write(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    megasas_mmio_write(opaque, addr & 0xff, val, size);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static void megasas_port_write(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    megasas_mmio_write(opaque, addr & 0xff, val, size);\n}\n",
        "linevul": 5.0225415179738775e-05
    },
    {
        "code": "static void check_guest_throttling(void)\n{\n    static int64_t t0;\n    int64_t        t1;\n\n    if (!mig_throttle_on) {\n        return;\n    }\n\n    if (!t0)  {\n        t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n        return;\n    }\n\n    t1 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    /* If it has been more than 40 ms since the last time the guest\n     * was throttled then do it again.\n     */\n    if (40 < (t1-t0)/1000000) {\n        mig_throttle_guest_down();\n        t0 = t1;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static void check_guest_throttling(void)\n{\n    static int64_t t0;\n    int64_t        t1;\n\n    if (!mig_throttle_on) {\n        return;\n    }\n\n    if (!t0)  {\n        t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n        return;\n    }\n\n    t1 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    /* If it has been more than 40 ms since the last time the guest\n     * was throttled then do it again.\n     */\n    if (40 < (t1-t0)/1000000) {\n        mig_throttle_guest_down();\n        t0 = t1;\n    }\n}\n",
        "linevul": 4.7104240366024897e-05
    },
    {
        "code": "void buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "void buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n",
        "linevul": 6.717040378134698e-05
    },
    {
        "code": " static void scsi_free_request(SCSIRequest *req)\n {\n     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n \n    qemu_vfree(r->iov.iov_base);\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": " static void scsi_free_request(SCSIRequest *req)\n {\n     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n \n//flaw_line_below:\n    qemu_vfree(r->iov.iov_base);\n//fix_flaw_line_below:\n//    if (r->iov.iov_base) {\n//fix_flaw_line_below:\n//        qemu_vfree(r->iov.iov_base);\n//fix_flaw_line_below:\n//    }\n }\n",
        "linevul": 0.985595703125
    },
    {
        "code": "tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)\n{\n    uint32_t *buf32;\n    uint32_t pix32;\n    int shift[3];\n    int *prev;\n    int here[3], upper[3], left[3], upperleft[3];\n    int prediction;\n    int x, y, c;\n\n     buf32 = (uint32_t *)buf;\n     memset(vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));\n \n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n        shift[0] = vs->clientds.pf.rshift;\n        shift[1] = vs->clientds.pf.gshift;\n        shift[2] = vs->clientds.pf.bshift;\n     } else {\n        shift[0] = 24 - vs->clientds.pf.rshift;\n        shift[1] = 24 - vs->clientds.pf.gshift;\n        shift[2] = 24 - vs->clientds.pf.bshift;\n     }\n \n     for (y = 0; y < h; y++) {\n        for (c = 0; c < 3; c++) {\n            upper[c] = 0;\n            here[c] = 0;\n        }\n        prev = (int *)vs->tight.gradient.buffer;\n        for (x = 0; x < w; x++) {\n            pix32 = *buf32++;\n            for (c = 0; c < 3; c++) {\n                upperleft[c] = upper[c];\n                left[c] = here[c];\n                upper[c] = *prev;\n                here[c] = (int)(pix32 >> shift[c] & 0xFF);\n                *prev++ = here[c];\n\n                prediction = left[c] + upper[c] - upperleft[c];\n                if (prediction < 0) {\n                    prediction = 0;\n                } else if (prediction > 0xFF) {\n                    prediction = 0xFF;\n                }\n                *buf++ = (char)(here[c] - prediction);\n            }\n        }\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)\n{\n    uint32_t *buf32;\n    uint32_t pix32;\n    int shift[3];\n    int *prev;\n    int here[3], upper[3], left[3], upperleft[3];\n    int prediction;\n    int x, y, c;\n\n     buf32 = (uint32_t *)buf;\n     memset(vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));\n \n//flaw_line_below:\n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n//flaw_line_below:\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n//flaw_line_below:\n        shift[0] = vs->clientds.pf.rshift;\n//flaw_line_below:\n        shift[1] = vs->clientds.pf.gshift;\n//flaw_line_below:\n        shift[2] = vs->clientds.pf.bshift;\n//fix_flaw_line_below:\n//    if (1 /* FIXME: (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n//fix_flaw_line_below:\n//             (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG) */) {\n//fix_flaw_line_below:\n//        shift[0] = vs->client_pf.rshift;\n//fix_flaw_line_below:\n//        shift[1] = vs->client_pf.gshift;\n//fix_flaw_line_below:\n//        shift[2] = vs->client_pf.bshift;\n     } else {\n//flaw_line_below:\n        shift[0] = 24 - vs->clientds.pf.rshift;\n//flaw_line_below:\n        shift[1] = 24 - vs->clientds.pf.gshift;\n//flaw_line_below:\n        shift[2] = 24 - vs->clientds.pf.bshift;\n//fix_flaw_line_below:\n//        shift[0] = 24 - vs->client_pf.rshift;\n//fix_flaw_line_below:\n//        shift[1] = 24 - vs->client_pf.gshift;\n//fix_flaw_line_below:\n//        shift[2] = 24 - vs->client_pf.bshift;\n     }\n \n     for (y = 0; y < h; y++) {\n        for (c = 0; c < 3; c++) {\n            upper[c] = 0;\n            here[c] = 0;\n        }\n        prev = (int *)vs->tight.gradient.buffer;\n        for (x = 0; x < w; x++) {\n            pix32 = *buf32++;\n            for (c = 0; c < 3; c++) {\n                upperleft[c] = upper[c];\n                left[c] = here[c];\n                upper[c] = *prev;\n                here[c] = (int)(pix32 >> shift[c] & 0xFF);\n                *prev++ = here[c];\n\n                prediction = left[c] + upper[c] - upperleft[c];\n                if (prediction < 0) {\n                    prediction = 0;\n                } else if (prediction > 0xFF) {\n                    prediction = 0xFF;\n                }\n                *buf++ = (char)(here[c] - prediction);\n            }\n        }\n    }\n}\n",
        "linevul": 0.995902955532074
    },
    {
        "code": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}\n",
        "linevul": 5.495563164004125e-05
    },
    {
        "code": "static int megasas_next_index(MegasasState *s, int index, int limit)\n{\n    index++;\n    if (index == limit) {\n        index = 0;\n    }\n    return index;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_next_index(MegasasState *s, int index, int limit)\n{\n    index++;\n    if (index == limit) {\n        index = 0;\n    }\n    return index;\n}\n",
        "linevul": 5.378883361117914e-05
    },
    {
        "code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n\n    assert(bs->read_only);\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n \n     /* Allocate and read in the snapshot's L1 table */\n    new_l1_bytes = s->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n \n     ret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\n    if (ret < 0) {\n        error_setg(errp, \"Failed to read l1 table for snapshot\");\n        g_free(new_l1_table);\n        return ret;\n    }\n\n    /* Switch the L1 table */\n    g_free(s->l1_table);\n\n    s->l1_size = sn->l1_size;\n    s->l1_table_offset = sn->l1_table_offset;\n    s->l1_table = new_l1_table;\n\n    for(i = 0;i < s->l1_size; i++) {\n        be64_to_cpus(&s->l1_table[i]);\n    }\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c05e4667be91b46ab42b5a11babf8e84d476cc6b",
        "vul_func_with_fix": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n\n    assert(bs->read_only);\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n \n     /* Allocate and read in the snapshot's L1 table */\n//flaw_line_below:\n    new_l1_bytes = s->l1_size * sizeof(uint64_t);\n//fix_flaw_line_below:\n//    new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n \n     ret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\n    if (ret < 0) {\n        error_setg(errp, \"Failed to read l1 table for snapshot\");\n        g_free(new_l1_table);\n        return ret;\n    }\n\n    /* Switch the L1 table */\n    g_free(s->l1_table);\n\n    s->l1_size = sn->l1_size;\n    s->l1_table_offset = sn->l1_table_offset;\n    s->l1_table = new_l1_table;\n\n    for(i = 0;i < s->l1_size; i++) {\n        be64_to_cpus(&s->l1_table[i]);\n    }\n\n    return 0;\n}\n",
        "linevul": 0.00010562539682723582
    },
    {
        "code": "static void msix_clr_pending(PCIDevice *dev, int vector)\n{\n    *msix_pending_byte(dev, vector) &= ~msix_pending_mask(vector);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285",
        "vul_func_with_fix": "static void msix_clr_pending(PCIDevice *dev, int vector)\n{\n    *msix_pending_byte(dev, vector) &= ~msix_pending_mask(vector);\n}\n",
        "linevul": 5.292900823405944e-05
    },
    {
        "code": "static int ohci_bus_start(OHCIState *ohci)\n{\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n     * linux driver is not ready to receive it and\n     * can meet some race conditions\n     */\n\n    ohci_eof_timer(ohci);\n\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static int ohci_bus_start(OHCIState *ohci)\n{\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n     * linux driver is not ready to receive it and\n     * can meet some race conditions\n     */\n\n    ohci_eof_timer(ohci);\n\n    return 1;\n}\n",
        "linevul": 4.5858483645133674e-05
    },
    {
        "code": "static inline bool is_zero_range(uint8_t *p, uint64_t size)\n{\n    return buffer_find_nonzero_offset(p, size) == size;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static inline bool is_zero_range(uint8_t *p, uint64_t size)\n{\n    return buffer_find_nonzero_offset(p, size) == size;\n}\n",
        "linevul": 0.0002826321870088577
    },
    {
        "code": "static void ram_migration_cancel(void *opaque)\n{\n    migration_end();\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static void ram_migration_cancel(void *opaque)\n{\n    migration_end();\n}\n",
        "linevul": 5.020472963224165e-05
    },
    {
        "code": "static void virtio_gpu_device_unrealize(DeviceState *qdev, Error **errp)\n{\n    VirtIOGPU *g = VIRTIO_GPU(qdev);\n    if (g->migration_blocker) {\n        migrate_del_blocker(g->migration_blocker);\n        error_free(g->migration_blocker);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static void virtio_gpu_device_unrealize(DeviceState *qdev, Error **errp)\n{\n    VirtIOGPU *g = VIRTIO_GPU(qdev);\n    if (g->migration_blocker) {\n        migrate_del_blocker(g->migration_blocker);\n        error_free(g->migration_blocker);\n    }\n}\n",
        "linevul": 4.942688610753976e-05
    },
    {
        "code": "static void nbd_recv_coroutines_enter_all(NBDClientSession *s)\n {\n     int i;\n \n     for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n            qemu_coroutine_enter(s->recv_coroutine[i]);\n             qemu_coroutine_enter(s->recv_coroutine[i]);\n         }\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "static void nbd_recv_coroutines_enter_all(NBDClientSession *s)\n//fix_flaw_line_below:\n//static void nbd_recv_coroutines_enter_all(BlockDriverState *bs)\n {\n//fix_flaw_line_below:\n//    NBDClientSession *s = nbd_get_client_session(bs);\n     int i;\n \n     for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n            qemu_coroutine_enter(s->recv_coroutine[i]);\n             qemu_coroutine_enter(s->recv_coroutine[i]);\n         }\n     }\n",
        "linevul": 0.9980279803276062
    },
    {
        "code": "static void ahci_restart(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    int i;\n\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];\n        if (ncq_tfs->halt) {\n            execute_ncq_command(ncq_tfs);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_restart(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    int i;\n\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];\n        if (ncq_tfs->halt) {\n            execute_ncq_command(ncq_tfs);\n        }\n    }\n}\n",
        "linevul": 4.940493454341777e-05
    },
    {
        "code": "static int ram_save_iterate(QEMUFile *f, void *opaque)\n{\n    int ret;\n    int i;\n    int64_t t0;\n    int total_sent = 0;\n\n    qemu_mutex_lock_ramlist();\n\n    if (ram_list.version != last_version) {\n        reset_ram_globals();\n    }\n\n    ram_control_before_iterate(f, RAM_CONTROL_ROUND);\n\n    t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n    i = 0;\n    while ((ret = qemu_file_rate_limit(f)) == 0) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, false);\n        /* no more blocks to sent */\n        if (bytes_sent == 0) {\n            break;\n        }\n        total_sent += bytes_sent;\n        acct_info.iterations++;\n        check_guest_throttling();\n        /* we want to check in the 1st loop, just in case it was the 1st time\n           and we had to sync the dirty bitmap.\n           qemu_get_clock_ns() is a bit expensive, so we only check each some\n           iterations\n        */\n        if ((i & 63) == 0) {\n            uint64_t t1 = (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - t0) / 1000000;\n            if (t1 > MAX_WAIT) {\n                DPRINTF(\"big wait: %\" PRIu64 \" milliseconds, %d iterations\\n\",\n                        t1, i);\n                break;\n            }\n        }\n        i++;\n    }\n\n    qemu_mutex_unlock_ramlist();\n\n    /*\n     * Must occur before EOS (or any QEMUFile operation)\n     * because of RDMA protocol.\n     */\n    ram_control_after_iterate(f, RAM_CONTROL_ROUND);\n\n    bytes_transferred += total_sent;\n\n    /*\n     * Do not count these 8 bytes into total_sent, so that we can\n     * return 0 if no page had been dirtied.\n     */\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n    bytes_transferred += 8;\n\n    ret = qemu_file_get_error(f);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return total_sent;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static int ram_save_iterate(QEMUFile *f, void *opaque)\n{\n    int ret;\n    int i;\n    int64_t t0;\n    int total_sent = 0;\n\n    qemu_mutex_lock_ramlist();\n\n    if (ram_list.version != last_version) {\n        reset_ram_globals();\n    }\n\n    ram_control_before_iterate(f, RAM_CONTROL_ROUND);\n\n    t0 = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n    i = 0;\n    while ((ret = qemu_file_rate_limit(f)) == 0) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, false);\n        /* no more blocks to sent */\n        if (bytes_sent == 0) {\n            break;\n        }\n        total_sent += bytes_sent;\n        acct_info.iterations++;\n        check_guest_throttling();\n        /* we want to check in the 1st loop, just in case it was the 1st time\n           and we had to sync the dirty bitmap.\n           qemu_get_clock_ns() is a bit expensive, so we only check each some\n           iterations\n        */\n        if ((i & 63) == 0) {\n            uint64_t t1 = (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - t0) / 1000000;\n            if (t1 > MAX_WAIT) {\n                DPRINTF(\"big wait: %\" PRIu64 \" milliseconds, %d iterations\\n\",\n                        t1, i);\n                break;\n            }\n        }\n        i++;\n    }\n\n    qemu_mutex_unlock_ramlist();\n\n    /*\n     * Must occur before EOS (or any QEMUFile operation)\n     * because of RDMA protocol.\n     */\n    ram_control_after_iterate(f, RAM_CONTROL_ROUND);\n\n    bytes_transferred += total_sent;\n\n    /*\n     * Do not count these 8 bytes into total_sent, so that we can\n     * return 0 if no page had been dirtied.\n     */\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n    bytes_transferred += 8;\n\n    ret = qemu_file_get_error(f);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return total_sent;\n}\n",
        "linevul": 6.195044988999143e-05
    },
    {
        "code": "static inline bool ehci_async_enabled(EHCIState *s)\n{\n    return ehci_enabled(s) && (s->usbcmd & USBCMD_ASE);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static inline bool ehci_async_enabled(EHCIState *s)\n{\n    return ehci_enabled(s) && (s->usbcmd & USBCMD_ASE);\n}\n",
        "linevul": 5.169833457330242e-05
    },
    {
        "code": "static int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int width = MIN(pixman_image_get_width(vd->guest.fb),\n                    pixman_image_get_width(vd->server));\n    int height = MIN(pixman_image_get_height(vd->guest.fb),\n                     pixman_image_get_height(vd->server));\n    int cmp_bytes, server_stride, min_stride, guest_stride, y = 0;\n    uint8_t *guest_row0 = NULL, *server_row0;\n    VncState *vs;\n    int has_dirty = 0;\n    pixman_image_t *tmpbuf = NULL;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    /*\n     * Walk through the guest dirty map.\n     * Check and copy modified bits from guest to server surface.\n     * Update server dirty map.\n     */\n    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n    server_stride = guest_stride = pixman_image_get_stride(vd->server);\n    cmp_bytes = MIN(VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES,\n                    server_stride);\n    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n        int width = pixman_image_get_width(vd->server);\n        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n    } else {\n        guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n        guest_stride = pixman_image_get_stride(vd->guest.fb);\n    }\n    min_stride = MIN(server_stride, guest_stride);\n\n    for (;;) {\n        int x;\n        uint8_t *guest_ptr, *server_ptr;\n        unsigned long offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                                             height * VNC_DIRTY_BPL(&vd->guest),\n                                             y * VNC_DIRTY_BPL(&vd->guest));\n        if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n            /* no more dirty bits */\n            break;\n        }\n        y = offset / VNC_DIRTY_BPL(&vd->guest);\n        x = offset % VNC_DIRTY_BPL(&vd->guest);\n\n        server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n\n        if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n            qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, 0, y);\n            guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n        } else {\n            guest_ptr = guest_row0 + y * guest_stride;\n        }\n        guest_ptr += x * cmp_bytes;\n\n        for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n             x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n            int _cmp_bytes = cmp_bytes;\n            if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                continue;\n            }\n            if ((x + 1) * cmp_bytes > min_stride) {\n                _cmp_bytes = min_stride - x * cmp_bytes;\n            }\n            if (memcmp(server_ptr, guest_ptr, _cmp_bytes) == 0) {\n                continue;\n            }\n            memcpy(server_ptr, guest_ptr, _cmp_bytes);\n            if (!vd->non_adaptive) {\n                vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                 y, &tv);\n            }\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                set_bit(x, vs->dirty[y]);\n            }\n            has_dirty++;\n        }\n\n        y++;\n    }\n    qemu_pixman_image_unref(tmpbuf);\n    return has_dirty;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int width = MIN(pixman_image_get_width(vd->guest.fb),\n                    pixman_image_get_width(vd->server));\n    int height = MIN(pixman_image_get_height(vd->guest.fb),\n                     pixman_image_get_height(vd->server));\n    int cmp_bytes, server_stride, min_stride, guest_stride, y = 0;\n    uint8_t *guest_row0 = NULL, *server_row0;\n    VncState *vs;\n    int has_dirty = 0;\n    pixman_image_t *tmpbuf = NULL;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    /*\n     * Walk through the guest dirty map.\n     * Check and copy modified bits from guest to server surface.\n     * Update server dirty map.\n     */\n    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n    server_stride = guest_stride = pixman_image_get_stride(vd->server);\n    cmp_bytes = MIN(VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES,\n                    server_stride);\n    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n        int width = pixman_image_get_width(vd->server);\n        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n    } else {\n        guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n        guest_stride = pixman_image_get_stride(vd->guest.fb);\n    }\n    min_stride = MIN(server_stride, guest_stride);\n\n    for (;;) {\n        int x;\n        uint8_t *guest_ptr, *server_ptr;\n        unsigned long offset = find_next_bit((unsigned long *) &vd->guest.dirty,\n                                             height * VNC_DIRTY_BPL(&vd->guest),\n                                             y * VNC_DIRTY_BPL(&vd->guest));\n        if (offset == height * VNC_DIRTY_BPL(&vd->guest)) {\n            /* no more dirty bits */\n            break;\n        }\n        y = offset / VNC_DIRTY_BPL(&vd->guest);\n        x = offset % VNC_DIRTY_BPL(&vd->guest);\n\n        server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n\n        if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n            qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, 0, y);\n            guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n        } else {\n            guest_ptr = guest_row0 + y * guest_stride;\n        }\n        guest_ptr += x * cmp_bytes;\n\n        for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n             x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n            int _cmp_bytes = cmp_bytes;\n            if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                continue;\n            }\n            if ((x + 1) * cmp_bytes > min_stride) {\n                _cmp_bytes = min_stride - x * cmp_bytes;\n            }\n            if (memcmp(server_ptr, guest_ptr, _cmp_bytes) == 0) {\n                continue;\n            }\n            memcpy(server_ptr, guest_ptr, _cmp_bytes);\n            if (!vd->non_adaptive) {\n                vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                 y, &tv);\n            }\n            QTAILQ_FOREACH(vs, &vd->clients, next) {\n                set_bit(x, vs->dirty[y]);\n            }\n            has_dirty++;\n        }\n\n        y++;\n    }\n    qemu_pixman_image_unref(tmpbuf);\n    return has_dirty;\n}\n",
        "linevul": 6.265997944865376e-05
    },
    {
        "code": "void pcnet_set_link_status(NetClientState *nc)\n{\n    PCNetState *d = qemu_get_nic_opaque(nc);\n\n    d->lnkst = nc->link_down ? 0 : 0x40;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "void pcnet_set_link_status(NetClientState *nc)\n{\n    PCNetState *d = qemu_get_nic_opaque(nc);\n\n    d->lnkst = nc->link_down ? 0 : 0x40;\n}\n",
        "linevul": 5.243916166364215e-05
    },
    {
        "code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                 scsi_write_data(&r->req);\n                 break;\n             case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                 if (ret == 0) {\n                     scsi_req_complete(&r->req, GOOD);\n                 }\n            }\n        }\n    }\n}\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                 scsi_write_data(&r->req);\n                 break;\n             case SCSI_REQ_STATUS_RETRY_FLUSH:\n//flaw_line_below:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n//fix_flaw_line_below:\n//                ret = scsi_disk_emulate_command(r);\n                 if (ret == 0) {\n                     scsi_req_complete(&r->req, GOOD);\n                 }\n            }\n        }\n    }\n}\n",
        "linevul": 6.500721792690456e-05
    },
    {
        "code": "static void handle_s_without_atn(ESPState *s)\n{\n    uint8_t buf[32];\n    int len;\n\n    if (s->dma && !s->dma_enabled) {\n        s->dma_cb = handle_s_without_atn;\n        return;\n    }\n    len = get_cmd(s, buf, sizeof(buf));\n    if (len) {\n        do_busid_cmd(s, buf, 0);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11",
        "vul_func_with_fix": "static void handle_s_without_atn(ESPState *s)\n{\n    uint8_t buf[32];\n    int len;\n\n    if (s->dma && !s->dma_enabled) {\n        s->dma_cb = handle_s_without_atn;\n        return;\n    }\n    len = get_cmd(s, buf, sizeof(buf));\n    if (len) {\n        do_busid_cmd(s, buf, 0);\n    }\n}\n",
        "linevul": 5.2200273785274476e-05
    },
    {
        "code": " void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n {\n     QXLDevSurfaceCreate surface;\n \n     memset(&surface, 0, sizeof(surface));\n \n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n           surface_width(ssd->ds), surface_height(ssd->ds));\n \n     surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n     surface.width      = surface_width(ssd->ds);\n{\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    qemu_spice_destroy_primary_surface(ssd, 0, QXL_SYNC);\n}\n\nvoid qemu_spice_display_init_common(SimpleSpiceDisplay *ssd)\n{\n    qemu_mutex_init(&ssd->lock);\n    QTAILQ_INIT(&ssd->updates);\n    ssd->mouse_x = -1;\n    ssd->mouse_y = -1;\n    if (ssd->num_surfaces == 0) {\n        ssd->num_surfaces = 1024;\n    }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n}\n\n/* display listener callbacks */\n\nvoid qemu_spice_display_update(SimpleSpiceDisplay *ssd,\n                               int x, int y, int w, int h)\n{\n     if (ssd->num_surfaces == 0) {\n         ssd->num_surfaces = 1024;\n     }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n }\n \n /* display listener callbacks */\n    update_area.top = y;\n    update_area.bottom = y + h;\n\n    if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n        ssd->notify++;\n    }\n    qemu_spice_rect_union(&ssd->dirty, &update_area);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": " void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n {\n     QXLDevSurfaceCreate surface;\n//fix_flaw_line_below:\n//    uint64_t surface_size;\n \n     memset(&surface, 0, sizeof(surface));\n \n//flaw_line_below:\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n//flaw_line_below:\n           surface_width(ssd->ds), surface_height(ssd->ds));\n//fix_flaw_line_below:\n//    surface_size = (uint64_t) surface_width(ssd->ds) *\n//fix_flaw_line_below:\n//        surface_height(ssd->ds) * 4;\n//fix_flaw_line_below:\n//    assert(surface_size > 0);\n//fix_flaw_line_below:\n//    assert(surface_size < INT_MAX);\n//fix_flaw_line_below:\n//    if (ssd->bufsize < surface_size) {\n//fix_flaw_line_below:\n//        ssd->bufsize = surface_size;\n//fix_flaw_line_below:\n//        g_free(ssd->buf);\n//fix_flaw_line_below:\n//        ssd->buf = g_malloc(ssd->bufsize);\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    dprint(1, \"%s/%d: %ux%u (size %\" PRIu64 \"/%d)\\n\", __func__, ssd->qxl.id,\n//fix_flaw_line_below:\n//           surface_width(ssd->ds), surface_height(ssd->ds),\n//fix_flaw_line_below:\n//           surface_size, ssd->bufsize);\n \n     surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n     surface.width      = surface_width(ssd->ds);\n{\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    qemu_spice_destroy_primary_surface(ssd, 0, QXL_SYNC);\n}\n\nvoid qemu_spice_display_init_common(SimpleSpiceDisplay *ssd)\n{\n    qemu_mutex_init(&ssd->lock);\n    QTAILQ_INIT(&ssd->updates);\n    ssd->mouse_x = -1;\n    ssd->mouse_y = -1;\n    if (ssd->num_surfaces == 0) {\n        ssd->num_surfaces = 1024;\n    }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n}\n\n/* display listener callbacks */\n\nvoid qemu_spice_display_update(SimpleSpiceDisplay *ssd,\n                               int x, int y, int w, int h)\n{\n     if (ssd->num_surfaces == 0) {\n         ssd->num_surfaces = 1024;\n     }\n//flaw_line_below:\n    ssd->bufsize = (16 * 1024 * 1024);\n//flaw_line_below:\n    ssd->buf = g_malloc(ssd->bufsize);\n }\n \n /* display listener callbacks */\n    update_area.top = y;\n    update_area.bottom = y + h;\n\n    if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n        ssd->notify++;\n    }\n    qemu_spice_rect_union(&ssd->dirty, &update_area);\n}\n",
        "linevul": 0.9987967014312744
    },
    {
        "code": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n{\n    int i, ret;\n    uint32_t num;\n    uint32_t features;\n    uint32_t supported_features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n     qemu_get_8s(f, &vdev->status);\n     qemu_get_8s(f, &vdev->isr);\n     qemu_get_be16s(f, &vdev->queue_sel);\n     qemu_get_be32s(f, &features);\n \n     if (virtio_set_features(vdev, features) < 0) {\n        return -1;\n    }\n    vdev->config_len = qemu_get_be32(f);\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n    num = qemu_get_be32(f);\n\n    if (num > VIRTIO_PCI_QUEUE_MAX) {\n        error_report(\"Invalid number of PCI queues: 0x%x\", num);\n        return -1;\n    }\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4b53c2c72cb5541cf394033b528a6fe2a86c0ac1",
        "vul_func_with_fix": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n{\n    int i, ret;\n    uint32_t num;\n    uint32_t features;\n    uint32_t supported_features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n     qemu_get_8s(f, &vdev->status);\n     qemu_get_8s(f, &vdev->isr);\n     qemu_get_be16s(f, &vdev->queue_sel);\n//fix_flaw_line_below:\n//    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {\n//fix_flaw_line_below:\n//        return -1;\n//fix_flaw_line_below:\n//    }\n     qemu_get_be32s(f, &features);\n \n     if (virtio_set_features(vdev, features) < 0) {\n        return -1;\n    }\n    vdev->config_len = qemu_get_be32(f);\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n    num = qemu_get_be32(f);\n\n    if (num > VIRTIO_PCI_QUEUE_MAX) {\n        error_report(\"Invalid number of PCI queues: 0x%x\", num);\n        return -1;\n    }\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}\n",
        "linevul": 5.2872808737447485e-05
    },
    {
        "code": "void vga_dirty_log_start(VGACommonState *s)\n{\n    memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "void vga_dirty_log_start(VGACommonState *s)\n{\n    memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);\n}\n",
        "linevul": 4.717832780443132e-05
    },
    {
        "code": " static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)\n {\n     FDrive *cur_drv = get_cur_drv(fdctrl);\n \n    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {\n         /* Command parameters done */\n        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {\n             fdctrl->fifo[0] = fdctrl->fifo[1];\n             fdctrl->fifo[2] = 0;\n             fdctrl->fifo[3] = 0;\n        }\n    } else if (fdctrl->data_len > 7) {\n        /* ERROR */\n        fdctrl->fifo[0] = 0x80 |\n            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);\n        fdctrl_set_fifo(fdctrl, 1);\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": " static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)\n {\n     FDrive *cur_drv = get_cur_drv(fdctrl);\n//fix_flaw_line_below:\n//    uint32_t pos;\n \n//flaw_line_below:\n    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {\n//fix_flaw_line_below:\n//    pos = fdctrl->data_pos - 1;\n//fix_flaw_line_below:\n//    pos %= FD_SECTOR_LEN;\n//fix_flaw_line_below:\n//    if (fdctrl->fifo[pos] & 0x80) {\n         /* Command parameters done */\n//flaw_line_below:\n        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {\n//fix_flaw_line_below:\n//        if (fdctrl->fifo[pos] & 0x40) {\n             fdctrl->fifo[0] = fdctrl->fifo[1];\n             fdctrl->fifo[2] = 0;\n             fdctrl->fifo[3] = 0;\n        }\n    } else if (fdctrl->data_len > 7) {\n        /* ERROR */\n        fdctrl->fifo[0] = 0x80 |\n            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);\n        fdctrl_set_fifo(fdctrl, 1);\n    }\n}\n",
        "linevul": 0.9988810420036316
    },
    {
        "code": "void virtio_net_set_config_size(VirtIONet *n, uint32_t host_features)\n{\n    int i, config_size = 0;\n    host_features |= (1 << VIRTIO_NET_F_MAC);\n    for (i = 0; feature_sizes[i].flags != 0; i++) {\n        if (host_features & feature_sizes[i].flags) {\n            config_size = MAX(feature_sizes[i].end, config_size);\n        }\n    }\n    n->config_size = config_size;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "void virtio_net_set_config_size(VirtIONet *n, uint32_t host_features)\n{\n    int i, config_size = 0;\n    host_features |= (1 << VIRTIO_NET_F_MAC);\n    for (i = 0; feature_sizes[i].flags != 0; i++) {\n        if (host_features & feature_sizes[i].flags) {\n            config_size = MAX(feature_sizes[i].end, config_size);\n        }\n    }\n    n->config_size = config_size;\n}\n",
        "linevul": 5.0807157094823197e-05
    },
    {
        "code": "static void lsi_execute_script(LSIState *s)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    uint32_t insn;\n    uint32_t addr, addr_high;\n    int opcode;\n    int insn_processed = 0;\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\nagain:\n \n     s->istat1 |= LSI_ISTAT1_SRUN;\n again:\n    insn_processed++;\n     insn = read_dword(s, s->dsp);\n     if (!insn) {\n         /* If we receive an empty opcode increment the DSP by 4 bytes\n        s->dbc = insn & 0xffffff;\n        s->rbc = s->dbc;\n        /* ??? Set ESA.  */\n        s->ia = s->dsp - 8;\n        if (insn & (1 << 29)) {\n            /* Indirect addressing.  */\n            addr = read_dword(s, addr);\n        } else if (insn & (1 << 28)) {\n            uint32_t buf[2];\n            int32_t offset;\n            /* Table indirect addressing.  */\n\n            /* 32-bit Table indirect */\n            offset = sextract32(addr, 0, 24);\n            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);\n            /* byte count is stored in bits 0:23 only */\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n            s->rbc = s->dbc;\n            addr = cpu_to_le32(buf[1]);\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n             * table, bits [31:24] */\n            if (lsi_dma_40bit(s))\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n            else if (lsi_dma_ti64bit(s)) {\n                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\n                switch (selector) {\n                case 0 ... 0x0f:\n                    /* offset index into scratch registers since\n                     * TI64 mode can use registers C to R */\n                    addr_high = s->scratch[2 + selector];\n                    break;\n                case 0x10:\n                    addr_high = s->mmrs;\n                    break;\n                case 0x11:\n                    addr_high = s->mmws;\n                    break;\n                case 0x12:\n                    addr_high = s->sfs;\n                    break;\n                case 0x13:\n                    addr_high = s->drs;\n                    break;\n                case 0x14:\n                    addr_high = s->sbms;\n                    break;\n                case 0x15:\n                    addr_high = s->dbms;\n                    break;\n                default:\n                    qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n                          \"for 64-bit DMA block move\", selector);\n                    break;\n                }\n            }\n        } else if (lsi_dma_64bit(s)) {\n            /* fetch a 3rd dword if 64-bit direct move is enabled and\n               only if we're not doing table indirect or indirect addressing */\n            s->dbms = read_dword(s, s->dsp);\n            s->dsp += 4;\n            s->ia = s->dsp - 12;\n        }\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n            trace_lsi_execute_script_blockmove_badphase(\n                    scsi_phase_name(s->sstat1),\n                    scsi_phase_name(insn >> 24));\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n            break;\n        }\n        s->dnad = addr;\n        s->dnad64 = addr_high;\n        switch (s->sstat1 & 0x7) {\n        case PHASE_DO:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 1);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_DI:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 0);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_CMD:\n            lsi_do_command(s);\n            break;\n        case PHASE_ST:\n            lsi_do_status(s);\n            break;\n        case PHASE_MO:\n            lsi_do_msgout(s);\n            break;\n        case PHASE_MI:\n            lsi_do_msgin(s);\n            break;\n        default:\n            qemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\n                          scsi_phase_name(s->sstat1));\n        }\n        s->dfifo = s->dbc & 0xff;\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n        s->sbc = s->dbc;\n        s->rbc -= s->dbc;\n        s->ua = addr + s->dbc;\n        break;\n\n    case 1: /* IO or Read/Write instruction.  */\n        opcode = (insn >> 27) & 7;\n        if (opcode < 5) {\n            uint32_t id;\n\n            if (insn & (1 << 25)) {\n                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n            } else {\n                id = insn;\n            }\n            id = (id >> 16) & 0xf;\n            if (insn & (1 << 26)) {\n                addr = s->dsp + sextract32(addr, 0, 24);\n            }\n            s->dnad = addr;\n            switch (opcode) {\n            case 0: /* Select */\n                s->sdid = id;\n                if (s->scntl1 & LSI_SCNTL1_CON) {\n                    trace_lsi_execute_script_io_alreadyreselected();\n                    s->dsp = s->dnad;\n                    break;\n                }\n                s->sstat0 |= LSI_SSTAT0_WOA;\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n                if (!scsi_device_find(&s->bus, 0, id, 0)) {\n                    lsi_bad_selection(s, id);\n                    break;\n                }\n                trace_lsi_execute_script_io_selected(id,\n                                             insn & (1 << 3) ? \" ATN\" : \"\");\n                /* ??? Linux drivers compain when this is set.  Maybe\n                   it only applies in low-level mode (unimplemented).\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n                s->select_tag = id << 8;\n                s->scntl1 |= LSI_SCNTL1_CON;\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                }\n                s->sbcl |= LSI_SBCL_BSY;\n                lsi_set_phase(s, PHASE_MO);\n                s->waiting = LSI_NOWAIT;\n                break;\n            case 1: /* Disconnect */\n                trace_lsi_execute_script_io_disconnect();\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n                /* FIXME: this is not entirely correct; the target need not ask\n                 * for reselection until it has to send data, while here we force a\n                 * reselection as soon as the bus is free.  The correct flow would\n                 * reselect before lsi_transfer_data and disconnect as soon as\n                 * DMA ends.\n                 */\n                if (!s->current) {\n                    lsi_request *p = get_pending_req(s);\n                    if (p) {\n                        lsi_reselect(s, p);\n                    }\n                }\n                break;\n            case 2: /* Wait Reselect */\n                if (s->istat0 & LSI_ISTAT0_SIGP) {\n                    s->dsp = s->dnad;\n                } else if (!lsi_irq_on_rsl(s)) {\n                        lsi_wait_reselect(s);\n                }\n                break;\n            case 3: /* Set */\n                trace_lsi_execute_script_io_set(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                    lsi_set_phase(s, PHASE_MO);\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl |= LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 9)) {\n                    qemu_log_mask(LOG_UNIMP,\n                        \"lsi_scsi: Target mode not implemented\\n\");\n                }\n                if (insn & (1 << 10))\n                    s->carry = 1;\n                break;\n            case 4: /* Clear */\n                trace_lsi_execute_script_io_clear(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl &= ~LSI_SOCL_ATN;\n                    s->sbcl &= ~LSI_SBCL_ATN;\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl &= ~LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 10))\n                    s->carry = 0;\n                break;\n            }\n        } else {\n            uint8_t op0;\n            uint8_t op1;\n            uint8_t data8;\n            int reg;\n            int operator;\n\n            static const char *opcode_names[3] =\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n            static const char *operator_names[8] =\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n            data8 = (insn >> 8) & 0xff;\n            opcode = (insn >> 27) & 7;\n            operator = (insn >> 24) & 7;\n            trace_lsi_execute_script_io_opcode(\n                    opcode_names[opcode - 5], reg,\n                    operator_names[operator], data8, s->sfbr,\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n            op0 = op1 = 0;\n            switch (opcode) {\n            case 5: /* From SFBR */\n                op0 = s->sfbr;\n                op1 = data8;\n                break;\n            case 6: /* To SFBR */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                op1 = data8;\n                break;\n            case 7: /* Read-modify-write */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                if (insn & (1 << 23)) {\n                    op1 = s->sfbr;\n                } else {\n                    op1 = data8;\n                }\n                break;\n            }\n\n            switch (operator) {\n            case 0: /* move */\n                op0 = op1;\n                break;\n            case 1: /* Shift left */\n                op1 = op0 >> 7;\n                op0 = (op0 << 1) | s->carry;\n                s->carry = op1;\n                break;\n            case 2: /* OR */\n                op0 |= op1;\n                break;\n            case 3: /* XOR */\n                op0 ^= op1;\n                break;\n            case 4: /* AND */\n                op0 &= op1;\n                break;\n            case 5: /* SHR */\n                op1 = op0 & 1;\n                op0 = (op0 >> 1) | (s->carry << 7);\n                s->carry = op1;\n                break;\n            case 6: /* ADD */\n                op0 += op1;\n                s->carry = op0 < op1;\n                break;\n            case 7: /* ADC */\n                op0 += op1 + s->carry;\n                if (s->carry)\n                    s->carry = op0 <= op1;\n                else\n                    s->carry = op0 < op1;\n                break;\n            }\n\n            switch (opcode) {\n            case 5: /* From SFBR */\n            case 7: /* Read-modify-write */\n                lsi_reg_writeb(s, reg, op0);\n                break;\n            case 6: /* To SFBR */\n                s->sfbr = op0;\n                break;\n            }\n        }\n        break;\n\n    case 2: /* Transfer Control.  */\n        {\n            int cond;\n            int jmp;\n\n            if ((insn & 0x002e0000) == 0) {\n                trace_lsi_execute_script_tc_nop();\n                break;\n            }\n            if (s->sist1 & LSI_SIST1_STO) {\n                trace_lsi_execute_script_tc_delayedselect_timeout();\n                lsi_stop_script(s);\n                break;\n            }\n            cond = jmp = (insn & (1 << 19)) != 0;\n            if (cond == jmp && (insn & (1 << 21))) {\n                trace_lsi_execute_script_tc_compc(s->carry == jmp);\n                cond = s->carry != 0;\n            }\n            if (cond == jmp && (insn & (1 << 17))) {\n                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\n                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n            }\n            if (cond == jmp && (insn & (1 << 18))) {\n                uint8_t mask;\n\n                mask = (~insn >> 8) & 0xff;\n                trace_lsi_execute_script_tc_compd(\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n                cond = (s->sfbr & mask) == (insn & mask);\n            }\n            if (cond == jmp) {\n                if (insn & (1 << 23)) {\n                    /* Relative address.  */\n                    addr = s->dsp + sextract32(addr, 0, 24);\n                }\n                switch ((insn >> 27) & 7) {\n                case 0: /* Jump */\n                    trace_lsi_execute_script_tc_jump(addr);\n                    s->adder = addr;\n                    s->dsp = addr;\n                    break;\n                case 1: /* Call */\n                    trace_lsi_execute_script_tc_call(addr);\n                    s->temp = s->dsp;\n                    s->dsp = addr;\n                    break;\n                case 2: /* Return */\n                    trace_lsi_execute_script_tc_return(s->temp);\n                    s->dsp = s->temp;\n                    break;\n                case 3: /* Interrupt */\n                    trace_lsi_execute_script_tc_interrupt(s->dsps);\n                    if ((insn & (1 << 20)) != 0) {\n                        s->istat0 |= LSI_ISTAT0_INTF;\n                        lsi_update_irq(s);\n                    } else {\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n                    }\n                    break;\n                default:\n                    trace_lsi_execute_script_tc_illegal();\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n                    break;\n                }\n            } else {\n                trace_lsi_execute_script_tc_cc_failed();\n            }\n        }\n        break;\n\n    case 3:\n        if ((insn & (1 << 29)) == 0) {\n            /* Memory move.  */\n            uint32_t dest;\n            /* ??? The docs imply the destination address is loaded into\n               the TEMP register.  However the Linux drivers rely on\n               the value being presrved.  */\n            dest = read_dword(s, s->dsp);\n            s->dsp += 4;\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n        } else {\n            uint8_t data[7];\n            int reg;\n            int n;\n            int i;\n\n            if (insn & (1 << 28)) {\n                addr = s->dsa + sextract32(addr, 0, 24);\n            }\n            n = (insn & 7);\n            reg = (insn >> 16) & 0xff;\n            if (insn & (1 << 24)) {\n                pci_dma_read(pci_dev, addr, data, n);\n                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\n                for (i = 0; i < n; i++) {\n                    lsi_reg_writeb(s, reg + i, data[i]);\n                }\n            } else {\n                trace_lsi_execute_script_mm_store(reg, n, addr);\n                for (i = 0; i < n; i++) {\n                    data[i] = lsi_reg_readb(s, reg + i);\n                }\n                pci_dma_write(pci_dev, addr, data, n);\n            }\n        }\n    }\n    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\n        /* Some windows drivers make the device spin waiting for a memory\n           location to change.  If we have been executed a lot of code then\n           assume this is the case and force an unexpected device disconnect.\n           This is apparently sufficient to beat the drivers into submission.\n         */\n        if (!(s->sien0 & LSI_SIST0_UDC)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: inf. loop with UDC masked\");\n        }\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n        lsi_disconnect(s);\n    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n        if (s->dcntl & LSI_DCNTL_SSM) {\n             }\n         }\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08",
        "vul_func_with_fix": "static void lsi_execute_script(LSIState *s)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    uint32_t insn;\n    uint32_t addr, addr_high;\n    int opcode;\n    int insn_processed = 0;\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\nagain:\n \n     s->istat1 |= LSI_ISTAT1_SRUN;\n again:\n//flaw_line_below:\n    insn_processed++;\n//fix_flaw_line_below:\n//    if (++insn_processed > LSI_MAX_INSN) {\n//fix_flaw_line_below:\n//        /* Some windows drivers make the device spin waiting for a memory\n//fix_flaw_line_below:\n//           location to change.  If we have been executed a lot of code then\n//fix_flaw_line_below:\n//           assume this is the case and force an unexpected device disconnect.\n//fix_flaw_line_below:\n//           This is apparently sufficient to beat the drivers into submission.\n//fix_flaw_line_below:\n//         */\n//fix_flaw_line_below:\n//        if (!(s->sien0 & LSI_SIST0_UDC)) {\n//fix_flaw_line_below:\n//            qemu_log_mask(LOG_GUEST_ERROR,\n//fix_flaw_line_below:\n//                          \"lsi_scsi: inf. loop with UDC masked\");\n//fix_flaw_line_below:\n//        }\n//fix_flaw_line_below:\n//        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n//fix_flaw_line_below:\n//        lsi_disconnect(s);\n//fix_flaw_line_below:\n//        trace_lsi_execute_script_stop();\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n     insn = read_dword(s, s->dsp);\n     if (!insn) {\n         /* If we receive an empty opcode increment the DSP by 4 bytes\n        s->dbc = insn & 0xffffff;\n        s->rbc = s->dbc;\n        /* ??? Set ESA.  */\n        s->ia = s->dsp - 8;\n        if (insn & (1 << 29)) {\n            /* Indirect addressing.  */\n            addr = read_dword(s, addr);\n        } else if (insn & (1 << 28)) {\n            uint32_t buf[2];\n            int32_t offset;\n            /* Table indirect addressing.  */\n\n            /* 32-bit Table indirect */\n            offset = sextract32(addr, 0, 24);\n            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);\n            /* byte count is stored in bits 0:23 only */\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n            s->rbc = s->dbc;\n            addr = cpu_to_le32(buf[1]);\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n             * table, bits [31:24] */\n            if (lsi_dma_40bit(s))\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n            else if (lsi_dma_ti64bit(s)) {\n                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\n                switch (selector) {\n                case 0 ... 0x0f:\n                    /* offset index into scratch registers since\n                     * TI64 mode can use registers C to R */\n                    addr_high = s->scratch[2 + selector];\n                    break;\n                case 0x10:\n                    addr_high = s->mmrs;\n                    break;\n                case 0x11:\n                    addr_high = s->mmws;\n                    break;\n                case 0x12:\n                    addr_high = s->sfs;\n                    break;\n                case 0x13:\n                    addr_high = s->drs;\n                    break;\n                case 0x14:\n                    addr_high = s->sbms;\n                    break;\n                case 0x15:\n                    addr_high = s->dbms;\n                    break;\n                default:\n                    qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n                          \"for 64-bit DMA block move\", selector);\n                    break;\n                }\n            }\n        } else if (lsi_dma_64bit(s)) {\n            /* fetch a 3rd dword if 64-bit direct move is enabled and\n               only if we're not doing table indirect or indirect addressing */\n            s->dbms = read_dword(s, s->dsp);\n            s->dsp += 4;\n            s->ia = s->dsp - 12;\n        }\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n            trace_lsi_execute_script_blockmove_badphase(\n                    scsi_phase_name(s->sstat1),\n                    scsi_phase_name(insn >> 24));\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n            break;\n        }\n        s->dnad = addr;\n        s->dnad64 = addr_high;\n        switch (s->sstat1 & 0x7) {\n        case PHASE_DO:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 1);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_DI:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 0);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_CMD:\n            lsi_do_command(s);\n            break;\n        case PHASE_ST:\n            lsi_do_status(s);\n            break;\n        case PHASE_MO:\n            lsi_do_msgout(s);\n            break;\n        case PHASE_MI:\n            lsi_do_msgin(s);\n            break;\n        default:\n            qemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\n                          scsi_phase_name(s->sstat1));\n        }\n        s->dfifo = s->dbc & 0xff;\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n        s->sbc = s->dbc;\n        s->rbc -= s->dbc;\n        s->ua = addr + s->dbc;\n        break;\n\n    case 1: /* IO or Read/Write instruction.  */\n        opcode = (insn >> 27) & 7;\n        if (opcode < 5) {\n            uint32_t id;\n\n            if (insn & (1 << 25)) {\n                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n            } else {\n                id = insn;\n            }\n            id = (id >> 16) & 0xf;\n            if (insn & (1 << 26)) {\n                addr = s->dsp + sextract32(addr, 0, 24);\n            }\n            s->dnad = addr;\n            switch (opcode) {\n            case 0: /* Select */\n                s->sdid = id;\n                if (s->scntl1 & LSI_SCNTL1_CON) {\n                    trace_lsi_execute_script_io_alreadyreselected();\n                    s->dsp = s->dnad;\n                    break;\n                }\n                s->sstat0 |= LSI_SSTAT0_WOA;\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n                if (!scsi_device_find(&s->bus, 0, id, 0)) {\n                    lsi_bad_selection(s, id);\n                    break;\n                }\n                trace_lsi_execute_script_io_selected(id,\n                                             insn & (1 << 3) ? \" ATN\" : \"\");\n                /* ??? Linux drivers compain when this is set.  Maybe\n                   it only applies in low-level mode (unimplemented).\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n                s->select_tag = id << 8;\n                s->scntl1 |= LSI_SCNTL1_CON;\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                }\n                s->sbcl |= LSI_SBCL_BSY;\n                lsi_set_phase(s, PHASE_MO);\n                s->waiting = LSI_NOWAIT;\n                break;\n            case 1: /* Disconnect */\n                trace_lsi_execute_script_io_disconnect();\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n                /* FIXME: this is not entirely correct; the target need not ask\n                 * for reselection until it has to send data, while here we force a\n                 * reselection as soon as the bus is free.  The correct flow would\n                 * reselect before lsi_transfer_data and disconnect as soon as\n                 * DMA ends.\n                 */\n                if (!s->current) {\n                    lsi_request *p = get_pending_req(s);\n                    if (p) {\n                        lsi_reselect(s, p);\n                    }\n                }\n                break;\n            case 2: /* Wait Reselect */\n                if (s->istat0 & LSI_ISTAT0_SIGP) {\n                    s->dsp = s->dnad;\n                } else if (!lsi_irq_on_rsl(s)) {\n                        lsi_wait_reselect(s);\n                }\n                break;\n            case 3: /* Set */\n                trace_lsi_execute_script_io_set(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                    lsi_set_phase(s, PHASE_MO);\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl |= LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 9)) {\n                    qemu_log_mask(LOG_UNIMP,\n                        \"lsi_scsi: Target mode not implemented\\n\");\n                }\n                if (insn & (1 << 10))\n                    s->carry = 1;\n                break;\n            case 4: /* Clear */\n                trace_lsi_execute_script_io_clear(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl &= ~LSI_SOCL_ATN;\n                    s->sbcl &= ~LSI_SBCL_ATN;\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl &= ~LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 10))\n                    s->carry = 0;\n                break;\n            }\n        } else {\n            uint8_t op0;\n            uint8_t op1;\n            uint8_t data8;\n            int reg;\n            int operator;\n\n            static const char *opcode_names[3] =\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n            static const char *operator_names[8] =\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n            data8 = (insn >> 8) & 0xff;\n            opcode = (insn >> 27) & 7;\n            operator = (insn >> 24) & 7;\n            trace_lsi_execute_script_io_opcode(\n                    opcode_names[opcode - 5], reg,\n                    operator_names[operator], data8, s->sfbr,\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n            op0 = op1 = 0;\n            switch (opcode) {\n            case 5: /* From SFBR */\n                op0 = s->sfbr;\n                op1 = data8;\n                break;\n            case 6: /* To SFBR */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                op1 = data8;\n                break;\n            case 7: /* Read-modify-write */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                if (insn & (1 << 23)) {\n                    op1 = s->sfbr;\n                } else {\n                    op1 = data8;\n                }\n                break;\n            }\n\n            switch (operator) {\n            case 0: /* move */\n                op0 = op1;\n                break;\n            case 1: /* Shift left */\n                op1 = op0 >> 7;\n                op0 = (op0 << 1) | s->carry;\n                s->carry = op1;\n                break;\n            case 2: /* OR */\n                op0 |= op1;\n                break;\n            case 3: /* XOR */\n                op0 ^= op1;\n                break;\n            case 4: /* AND */\n                op0 &= op1;\n                break;\n            case 5: /* SHR */\n                op1 = op0 & 1;\n                op0 = (op0 >> 1) | (s->carry << 7);\n                s->carry = op1;\n                break;\n            case 6: /* ADD */\n                op0 += op1;\n                s->carry = op0 < op1;\n                break;\n            case 7: /* ADC */\n                op0 += op1 + s->carry;\n                if (s->carry)\n                    s->carry = op0 <= op1;\n                else\n                    s->carry = op0 < op1;\n                break;\n            }\n\n            switch (opcode) {\n            case 5: /* From SFBR */\n            case 7: /* Read-modify-write */\n                lsi_reg_writeb(s, reg, op0);\n                break;\n            case 6: /* To SFBR */\n                s->sfbr = op0;\n                break;\n            }\n        }\n        break;\n\n    case 2: /* Transfer Control.  */\n        {\n            int cond;\n            int jmp;\n\n            if ((insn & 0x002e0000) == 0) {\n                trace_lsi_execute_script_tc_nop();\n                break;\n            }\n            if (s->sist1 & LSI_SIST1_STO) {\n                trace_lsi_execute_script_tc_delayedselect_timeout();\n                lsi_stop_script(s);\n                break;\n            }\n            cond = jmp = (insn & (1 << 19)) != 0;\n            if (cond == jmp && (insn & (1 << 21))) {\n                trace_lsi_execute_script_tc_compc(s->carry == jmp);\n                cond = s->carry != 0;\n            }\n            if (cond == jmp && (insn & (1 << 17))) {\n                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\n                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n            }\n            if (cond == jmp && (insn & (1 << 18))) {\n                uint8_t mask;\n\n                mask = (~insn >> 8) & 0xff;\n                trace_lsi_execute_script_tc_compd(\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n                cond = (s->sfbr & mask) == (insn & mask);\n            }\n            if (cond == jmp) {\n                if (insn & (1 << 23)) {\n                    /* Relative address.  */\n                    addr = s->dsp + sextract32(addr, 0, 24);\n                }\n                switch ((insn >> 27) & 7) {\n                case 0: /* Jump */\n                    trace_lsi_execute_script_tc_jump(addr);\n                    s->adder = addr;\n                    s->dsp = addr;\n                    break;\n                case 1: /* Call */\n                    trace_lsi_execute_script_tc_call(addr);\n                    s->temp = s->dsp;\n                    s->dsp = addr;\n                    break;\n                case 2: /* Return */\n                    trace_lsi_execute_script_tc_return(s->temp);\n                    s->dsp = s->temp;\n                    break;\n                case 3: /* Interrupt */\n                    trace_lsi_execute_script_tc_interrupt(s->dsps);\n                    if ((insn & (1 << 20)) != 0) {\n                        s->istat0 |= LSI_ISTAT0_INTF;\n                        lsi_update_irq(s);\n                    } else {\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n                    }\n                    break;\n                default:\n                    trace_lsi_execute_script_tc_illegal();\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n                    break;\n                }\n            } else {\n                trace_lsi_execute_script_tc_cc_failed();\n            }\n        }\n        break;\n\n    case 3:\n        if ((insn & (1 << 29)) == 0) {\n            /* Memory move.  */\n            uint32_t dest;\n            /* ??? The docs imply the destination address is loaded into\n               the TEMP register.  However the Linux drivers rely on\n               the value being presrved.  */\n            dest = read_dword(s, s->dsp);\n            s->dsp += 4;\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n        } else {\n            uint8_t data[7];\n            int reg;\n            int n;\n            int i;\n\n            if (insn & (1 << 28)) {\n                addr = s->dsa + sextract32(addr, 0, 24);\n            }\n            n = (insn & 7);\n            reg = (insn >> 16) & 0xff;\n            if (insn & (1 << 24)) {\n                pci_dma_read(pci_dev, addr, data, n);\n                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\n                for (i = 0; i < n; i++) {\n                    lsi_reg_writeb(s, reg + i, data[i]);\n                }\n            } else {\n                trace_lsi_execute_script_mm_store(reg, n, addr);\n                for (i = 0; i < n; i++) {\n                    data[i] = lsi_reg_readb(s, reg + i);\n                }\n                pci_dma_write(pci_dev, addr, data, n);\n            }\n        }\n    }\n    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\n        /* Some windows drivers make the device spin waiting for a memory\n           location to change.  If we have been executed a lot of code then\n           assume this is the case and force an unexpected device disconnect.\n           This is apparently sufficient to beat the drivers into submission.\n         */\n        if (!(s->sien0 & LSI_SIST0_UDC)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: inf. loop with UDC masked\");\n        }\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n        lsi_disconnect(s);\n    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n        if (s->dcntl & LSI_DCNTL_SSM) {\n             }\n         }\n     }\n",
        "linevul": 0.9943327903747559
    },
    {
        "code": "static void ehci_frame_timer(void *opaque)\n{\n    EHCIState *ehci = opaque;\n    int need_timer = 0;\n    int64_t expire_time, t_now;\n    uint64_t ns_elapsed;\n    int uframes, skipped_uframes;\n    int i;\n\n    t_now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    ns_elapsed = t_now - ehci->last_run_ns;\n    uframes = ns_elapsed / UFRAME_TIMER_NS;\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n        need_timer++;\n\n        if (uframes > (ehci->maxframes * 8)) {\n            skipped_uframes = uframes - (ehci->maxframes * 8);\n            ehci_update_frindex(ehci, skipped_uframes);\n            ehci->last_run_ns += UFRAME_TIMER_NS * skipped_uframes;\n            uframes -= skipped_uframes;\n            DPRINTF(\"WARNING - EHCI skipped %d uframes\\n\", skipped_uframes);\n        }\n\n        for (i = 0; i < uframes; i++) {\n            /*\n             * If we're running behind schedule, we should not catch up\n             * too fast, as that will make some guests unhappy:\n             * 1) We must process a minimum of MIN_UFR_PER_TICK frames,\n             *    otherwise we will never catch up\n             * 2) Process frames until the guest has requested an irq (IOC)\n             */\n            if (i >= MIN_UFR_PER_TICK) {\n                ehci_commit_irq(ehci);\n                if ((ehci->usbsts & USBINTR_MASK) & ehci->usbintr) {\n                    break;\n                }\n            }\n            if (ehci->periodic_sched_active) {\n                ehci->periodic_sched_active--;\n            }\n            ehci_update_frindex(ehci, 1);\n            if ((ehci->frindex & 7) == 0) {\n                ehci_advance_periodic_state(ehci);\n            }\n            ehci->last_run_ns += UFRAME_TIMER_NS;\n        }\n    } else {\n        ehci->periodic_sched_active = 0;\n        ehci_update_frindex(ehci, uframes);\n        ehci->last_run_ns += UFRAME_TIMER_NS * uframes;\n    }\n\n    if (ehci->periodic_sched_active) {\n        ehci->async_stepdown = 0;\n    } else if (ehci->async_stepdown < ehci->maxframes / 2) {\n        ehci->async_stepdown++;\n    }\n\n    /*  Async is not inside loop since it executes everything it can once\n     *  called\n     */\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n        need_timer++;\n        ehci_advance_async_state(ehci);\n    }\n\n    ehci_commit_irq(ehci);\n    if (ehci->usbsts_pending) {\n        need_timer++;\n        ehci->async_stepdown = 0;\n    }\n\n    if (ehci_enabled(ehci) && (ehci->usbintr & USBSTS_FLR)) {\n        need_timer++;\n    }\n\n    if (need_timer) {\n        /* If we've raised int, we speed up the timer, so that we quickly\n         * notice any new packets queued up in response */\n        if (ehci->int_req_by_async && (ehci->usbsts & USBSTS_INT)) {\n            expire_time = t_now +\n                NANOSECONDS_PER_SECOND / (FRAME_TIMER_FREQ * 4);\n            ehci->int_req_by_async = false;\n        } else {\n            expire_time = t_now + (NANOSECONDS_PER_SECOND\n                               * (ehci->async_stepdown+1) / FRAME_TIMER_FREQ);\n        }\n        timer_mod(ehci->frame_timer, expire_time);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_frame_timer(void *opaque)\n{\n    EHCIState *ehci = opaque;\n    int need_timer = 0;\n    int64_t expire_time, t_now;\n    uint64_t ns_elapsed;\n    int uframes, skipped_uframes;\n    int i;\n\n    t_now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    ns_elapsed = t_now - ehci->last_run_ns;\n    uframes = ns_elapsed / UFRAME_TIMER_NS;\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n        need_timer++;\n\n        if (uframes > (ehci->maxframes * 8)) {\n            skipped_uframes = uframes - (ehci->maxframes * 8);\n            ehci_update_frindex(ehci, skipped_uframes);\n            ehci->last_run_ns += UFRAME_TIMER_NS * skipped_uframes;\n            uframes -= skipped_uframes;\n            DPRINTF(\"WARNING - EHCI skipped %d uframes\\n\", skipped_uframes);\n        }\n\n        for (i = 0; i < uframes; i++) {\n            /*\n             * If we're running behind schedule, we should not catch up\n             * too fast, as that will make some guests unhappy:\n             * 1) We must process a minimum of MIN_UFR_PER_TICK frames,\n             *    otherwise we will never catch up\n             * 2) Process frames until the guest has requested an irq (IOC)\n             */\n            if (i >= MIN_UFR_PER_TICK) {\n                ehci_commit_irq(ehci);\n                if ((ehci->usbsts & USBINTR_MASK) & ehci->usbintr) {\n                    break;\n                }\n            }\n            if (ehci->periodic_sched_active) {\n                ehci->periodic_sched_active--;\n            }\n            ehci_update_frindex(ehci, 1);\n            if ((ehci->frindex & 7) == 0) {\n                ehci_advance_periodic_state(ehci);\n            }\n            ehci->last_run_ns += UFRAME_TIMER_NS;\n        }\n    } else {\n        ehci->periodic_sched_active = 0;\n        ehci_update_frindex(ehci, uframes);\n        ehci->last_run_ns += UFRAME_TIMER_NS * uframes;\n    }\n\n    if (ehci->periodic_sched_active) {\n        ehci->async_stepdown = 0;\n    } else if (ehci->async_stepdown < ehci->maxframes / 2) {\n        ehci->async_stepdown++;\n    }\n\n    /*  Async is not inside loop since it executes everything it can once\n     *  called\n     */\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n        need_timer++;\n        ehci_advance_async_state(ehci);\n    }\n\n    ehci_commit_irq(ehci);\n    if (ehci->usbsts_pending) {\n        need_timer++;\n        ehci->async_stepdown = 0;\n    }\n\n    if (ehci_enabled(ehci) && (ehci->usbintr & USBSTS_FLR)) {\n        need_timer++;\n    }\n\n    if (need_timer) {\n        /* If we've raised int, we speed up the timer, so that we quickly\n         * notice any new packets queued up in response */\n        if (ehci->int_req_by_async && (ehci->usbsts & USBSTS_INT)) {\n            expire_time = t_now +\n                NANOSECONDS_PER_SECOND / (FRAME_TIMER_FREQ * 4);\n            ehci->int_req_by_async = false;\n        } else {\n            expire_time = t_now + (NANOSECONDS_PER_SECOND\n                               * (ehci->async_stepdown+1) / FRAME_TIMER_FREQ);\n        }\n        timer_mod(ehci->frame_timer, expire_time);\n    }\n}\n",
        "linevul": 6.541652692249045e-05
    },
    {
        "code": "static void i6300esb_restart_timer(I6300State *d, int stage)\n{\n    int64_t timeout;\n\n    if (!d->enabled)\n        return;\n\n    d->stage = stage;\n\n    if (d->stage <= 1)\n        timeout = d->timer1_preload;\n    else\n        timeout = d->timer2_preload;\n\n    if (d->clock_scale == CLOCK_SCALE_1KHZ)\n        timeout <<= 15;\n    else\n        timeout <<= 5;\n\n    /* Get the timeout in nanoseconds. */\n\n    timeout = timeout * 30; /* on a PCI bus, 1 tick is 30 ns*/\n\n    i6300esb_debug(\"stage %d, timeout %\" PRIi64 \"\\n\", d->stage, timeout);\n\n    timer_mod(d->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + timeout);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eb7a20a3616085d46aa6b4b4224e15587ec67e6e",
        "vul_func_with_fix": "static void i6300esb_restart_timer(I6300State *d, int stage)\n{\n    int64_t timeout;\n\n    if (!d->enabled)\n        return;\n\n    d->stage = stage;\n\n    if (d->stage <= 1)\n        timeout = d->timer1_preload;\n    else\n        timeout = d->timer2_preload;\n\n    if (d->clock_scale == CLOCK_SCALE_1KHZ)\n        timeout <<= 15;\n    else\n        timeout <<= 5;\n\n    /* Get the timeout in nanoseconds. */\n\n    timeout = timeout * 30; /* on a PCI bus, 1 tick is 30 ns*/\n\n    i6300esb_debug(\"stage %d, timeout %\" PRIi64 \"\\n\", d->stage, timeout);\n\n    timer_mod(d->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + timeout);\n}\n",
        "linevul": 4.734635149361566e-05
    },
    {
        "code": "static void interface_set_mm_time(QXLInstance *sin, uint32_t mm_time)\n{\n    dprint(3, \"%s/%d:\\n\", __func__, sin->id);\n    /* nothing to do */\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "static void interface_set_mm_time(QXLInstance *sin, uint32_t mm_time)\n{\n    dprint(3, \"%s/%d:\\n\", __func__, sin->id);\n    /* nothing to do */\n}\n",
        "linevul": 4.914137389278039e-05
    },
    {
        "code": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n     n = s->next_packet + s->np;\n     if (n >= 31)\n         n -= 31;\n    s->np++;\n \n     s->rx[n].len = size + 6;\n     p = s->rx[n].data;\n     *(p++) = (size + 6);\n        memset(p, 0, (6 - size) & 3);\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3a15cc0e1ee7168db0782133d2607a6bfa422d66",
        "vul_func_with_fix": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n     n = s->next_packet + s->np;\n     if (n >= 31)\n         n -= 31;\n//flaw_line_below:\n    s->np++;\n \n//fix_flaw_line_below:\n//    if (size >= sizeof(s->rx[n].data) - 6) {\n//fix_flaw_line_below:\n//        /* If the packet won't fit into the\n//fix_flaw_line_below:\n//         * emulated 2K RAM, this is reported\n//fix_flaw_line_below:\n//         * as a FIFO overrun error.\n//fix_flaw_line_below:\n//         */\n//fix_flaw_line_below:\n//        s->ris |= SE_INT_FOV;\n//fix_flaw_line_below:\n//        stellaris_enet_update(s);\n//fix_flaw_line_below:\n//        return -1;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    s->np++;\n     s->rx[n].len = size + 6;\n     p = s->rx[n].data;\n     *(p++) = (size + 6);\n        memset(p, 0, (6 - size) & 3);\n    }\n",
        "linevul": 0.997222900390625
    },
    {
        "code": "void msix_set_message(PCIDevice *dev, int vector, struct MSIMessage msg)\n{\n    uint8_t *table_entry = dev->msix_table + vector * PCI_MSIX_ENTRY_SIZE;\n\n    pci_set_quad(table_entry + PCI_MSIX_ENTRY_LOWER_ADDR, msg.address);\n    pci_set_long(table_entry + PCI_MSIX_ENTRY_DATA, msg.data);\n    table_entry[PCI_MSIX_ENTRY_VECTOR_CTRL] &= ~PCI_MSIX_ENTRY_CTRL_MASKBIT;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285",
        "vul_func_with_fix": "void msix_set_message(PCIDevice *dev, int vector, struct MSIMessage msg)\n{\n    uint8_t *table_entry = dev->msix_table + vector * PCI_MSIX_ENTRY_SIZE;\n\n    pci_set_quad(table_entry + PCI_MSIX_ENTRY_LOWER_ADDR, msg.address);\n    pci_set_long(table_entry + PCI_MSIX_ENTRY_DATA, msg.data);\n    table_entry[PCI_MSIX_ENTRY_VECTOR_CTRL] &= ~PCI_MSIX_ENTRY_CTRL_MASKBIT;\n}\n",
        "linevul": 4.822904884349555e-05
    },
    {
        "code": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n                            void (*handle_output)(VirtIODevice *, VirtQueue *))\n{\n    int i;\n\n    for (i = 0; i < VIRTIO_PCI_QUEUE_MAX; i++) {\n        if (vdev->vq[i].vring.num == 0)\n            break;\n    }\n\n    if (i == VIRTIO_PCI_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)\n        abort();\n\n    vdev->vq[i].vring.num = queue_size;\n    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;\n    vdev->vq[i].handle_output = handle_output;\n\n    return &vdev->vq[i];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n                            void (*handle_output)(VirtIODevice *, VirtQueue *))\n{\n    int i;\n\n    for (i = 0; i < VIRTIO_PCI_QUEUE_MAX; i++) {\n        if (vdev->vq[i].vring.num == 0)\n            break;\n    }\n\n    if (i == VIRTIO_PCI_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)\n        abort();\n\n    vdev->vq[i].vring.num = queue_size;\n    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;\n    vdev->vq[i].handle_output = handle_output;\n\n    return &vdev->vq[i];\n}\n",
        "linevul": 4.6870209189364687e-05
    },
    {
        "code": "static void scsi_disk_reset(DeviceState *dev)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n    uint64_t nb_sectors;\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    nb_sectors /= s->cluster_size;\n    if (nb_sectors) {\n        nb_sectors--;\n    }\n    s->max_lba = nb_sectors;\n}\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static void scsi_disk_reset(DeviceState *dev)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n    uint64_t nb_sectors;\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n    nb_sectors /= s->cluster_size;\n    if (nb_sectors) {\n        nb_sectors--;\n    }\n    s->max_lba = nb_sectors;\n}\n",
        "linevul": 5.0440932682249695e-05
    },
    {
        "code": "static inline int svm_is_rep(int prefixes)\n{\n    return ((prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) ? 8 : 0);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline int svm_is_rep(int prefixes)\n{\n    return ((prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) ? 8 : 0);\n}\n",
        "linevul": 5.338024129741825e-05
    },
    {
        "code": "static uint8_t vga_precise_retrace(VGACommonState *s)\n{\n    struct vga_precise_retrace *r = &s->retrace_info.precise;\n    uint8_t val = s->st01 & ~(ST01_V_RETRACE | ST01_DISP_ENABLE);\n\n    if (r->total_chars) {\n        int cur_line, cur_line_char, cur_char;\n        int64_t cur_tick;\n\n        cur_tick = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n        cur_char = (cur_tick / r->ticks_per_char) % r->total_chars;\n        cur_line = cur_char / r->htotal;\n\n        if (cur_line >= r->vstart && cur_line <= r->vend) {\n            val |= ST01_V_RETRACE | ST01_DISP_ENABLE;\n        } else {\n            cur_line_char = cur_char % r->htotal;\n            if (cur_line_char >= r->hstart && cur_line_char <= r->hend) {\n                val |= ST01_DISP_ENABLE;\n            }\n        }\n\n        return val;\n    } else {\n        return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "static uint8_t vga_precise_retrace(VGACommonState *s)\n{\n    struct vga_precise_retrace *r = &s->retrace_info.precise;\n    uint8_t val = s->st01 & ~(ST01_V_RETRACE | ST01_DISP_ENABLE);\n\n    if (r->total_chars) {\n        int cur_line, cur_line_char, cur_char;\n        int64_t cur_tick;\n\n        cur_tick = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n        cur_char = (cur_tick / r->ticks_per_char) % r->total_chars;\n        cur_line = cur_char / r->htotal;\n\n        if (cur_line >= r->vstart && cur_line <= r->vend) {\n            val |= ST01_V_RETRACE | ST01_DISP_ENABLE;\n        } else {\n            cur_line_char = cur_char % r->htotal;\n            if (cur_line_char >= r->hstart && cur_line_char <= r->hend) {\n                val |= ST01_DISP_ENABLE;\n            }\n        }\n\n        return val;\n    } else {\n        return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);\n    }\n}\n",
        "linevul": 4.853392965742387e-05
    },
    {
        "code": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n     return 0;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484",
        "vul_func_with_fix": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n \n//fix_flaw_line_below:\n//    vmxnet3_validate_interrupts(s);\n//fix_flaw_line_below:\n//\n     return 0;\n }\n",
        "linevul": 6.855283572804183e-05
    },
    {
        "code": "static void pcnet_csr_writew(PCNetState *s, uint32_t rap, uint32_t new_value)\n{\n    uint16_t val = new_value;\n#ifdef PCNET_DEBUG_CSR\n    printf(\"pcnet_csr_writew rap=%d val=0x%04x\\n\", rap, val);\n#endif\n    switch (rap) {\n    case 0:\n        s->csr[0] &= ~(val & 0x7f00); /* Clear any interrupt flags */\n\n        s->csr[0] = (s->csr[0] & ~0x0040) | (val & 0x0048);\n\n        val = (val & 0x007f) | (s->csr[0] & 0x7f00);\n\n        /* IFF STOP, STRT and INIT are set, clear STRT and INIT */\n        if ((val&7) == 7)\n          val &= ~3;\n\n        if (!CSR_STOP(s) && (val & 4))\n            pcnet_stop(s);\n\n        if (!CSR_INIT(s) && (val & 1))\n            pcnet_init(s);\n\n        if (!CSR_STRT(s) && (val & 2))\n            pcnet_start(s);\n\n        if (CSR_TDMD(s))\n            pcnet_transmit(s);\n\n        return;\n    case 1:\n    case 2:\n    case 8:\n    case 9:\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n    case 18: /* CRBAL */\n    case 19: /* CRBAU */\n    case 20: /* CXBAL */\n    case 21: /* CXBAU */\n    case 22: /* NRBAU */\n    case 23: /* NRBAU */\n    case 24:\n    case 25:\n    case 26:\n    case 27:\n    case 28:\n    case 29:\n    case 30:\n    case 31:\n    case 32:\n    case 33:\n    case 34:\n    case 35:\n    case 36:\n    case 37:\n    case 38:\n    case 39:\n    case 40: /* CRBC */\n    case 41:\n    case 42: /* CXBC */\n    case 43:\n    case 44:\n    case 45:\n    case 46: /* POLL */\n    case 47: /* POLLINT */\n    case 72:\n    case 74:\n    case 76: /* RCVRL */\n    case 78: /* XMTRL */\n    case 112:\n       if (CSR_STOP(s) || CSR_SPND(s))\n           break;\n       return;\n    case 3:\n        break;\n    case 4:\n        s->csr[4] &= ~(val & 0x026a);\n        val &= ~0x026a; val |= s->csr[4] & 0x026a;\n        break;\n    case 5:\n        s->csr[5] &= ~(val & 0x0a90);\n        val &= ~0x0a90; val |= s->csr[5] & 0x0a90;\n        break;\n    case 16:\n        pcnet_csr_writew(s,1,val);\n        return;\n    case 17:\n        pcnet_csr_writew(s,2,val);\n        return;\n    case 58:\n        pcnet_bcr_writew(s,BCR_SWS,val);\n        break;\n    default:\n        return;\n    }\n    s->csr[rap] = val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "static void pcnet_csr_writew(PCNetState *s, uint32_t rap, uint32_t new_value)\n{\n    uint16_t val = new_value;\n#ifdef PCNET_DEBUG_CSR\n    printf(\"pcnet_csr_writew rap=%d val=0x%04x\\n\", rap, val);\n#endif\n    switch (rap) {\n    case 0:\n        s->csr[0] &= ~(val & 0x7f00); /* Clear any interrupt flags */\n\n        s->csr[0] = (s->csr[0] & ~0x0040) | (val & 0x0048);\n\n        val = (val & 0x007f) | (s->csr[0] & 0x7f00);\n\n        /* IFF STOP, STRT and INIT are set, clear STRT and INIT */\n        if ((val&7) == 7)\n          val &= ~3;\n\n        if (!CSR_STOP(s) && (val & 4))\n            pcnet_stop(s);\n\n        if (!CSR_INIT(s) && (val & 1))\n            pcnet_init(s);\n\n        if (!CSR_STRT(s) && (val & 2))\n            pcnet_start(s);\n\n        if (CSR_TDMD(s))\n            pcnet_transmit(s);\n\n        return;\n    case 1:\n    case 2:\n    case 8:\n    case 9:\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n    case 18: /* CRBAL */\n    case 19: /* CRBAU */\n    case 20: /* CXBAL */\n    case 21: /* CXBAU */\n    case 22: /* NRBAU */\n    case 23: /* NRBAU */\n    case 24:\n    case 25:\n    case 26:\n    case 27:\n    case 28:\n    case 29:\n    case 30:\n    case 31:\n    case 32:\n    case 33:\n    case 34:\n    case 35:\n    case 36:\n    case 37:\n    case 38:\n    case 39:\n    case 40: /* CRBC */\n    case 41:\n    case 42: /* CXBC */\n    case 43:\n    case 44:\n    case 45:\n    case 46: /* POLL */\n    case 47: /* POLLINT */\n    case 72:\n    case 74:\n    case 76: /* RCVRL */\n    case 78: /* XMTRL */\n    case 112:\n       if (CSR_STOP(s) || CSR_SPND(s))\n           break;\n       return;\n    case 3:\n        break;\n    case 4:\n        s->csr[4] &= ~(val & 0x026a);\n        val &= ~0x026a; val |= s->csr[4] & 0x026a;\n        break;\n    case 5:\n        s->csr[5] &= ~(val & 0x0a90);\n        val &= ~0x0a90; val |= s->csr[5] & 0x0a90;\n        break;\n    case 16:\n        pcnet_csr_writew(s,1,val);\n        return;\n    case 17:\n        pcnet_csr_writew(s,2,val);\n        return;\n    case 58:\n        pcnet_bcr_writew(s,BCR_SWS,val);\n        break;\n    default:\n        return;\n    }\n    s->csr[rap] = val;\n}\n",
        "linevul": 5.826303095091134e-05
    },
    {
        "code": "void vga_init_vbe(VGACommonState *s, Object *obj, MemoryRegion *system_memory)\n{\n    /* With pc-0.12 and below we map both the PCI BAR and the fixed VBE region,\n     * so use an alias to avoid double-mapping the same region.\n     */\n    memory_region_init_alias(&s->vram_vbe, obj, \"vram.vbe\",\n                             &s->vram, 0, memory_region_size(&s->vram));\n    /* XXX: use optimized standard vga accesses */\n    memory_region_add_subregion(system_memory,\n                                VBE_DISPI_LFB_PHYSICAL_ADDRESS,\n                                &s->vram_vbe);\n    s->vbe_mapped = 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "void vga_init_vbe(VGACommonState *s, Object *obj, MemoryRegion *system_memory)\n{\n    /* With pc-0.12 and below we map both the PCI BAR and the fixed VBE region,\n     * so use an alias to avoid double-mapping the same region.\n     */\n    memory_region_init_alias(&s->vram_vbe, obj, \"vram.vbe\",\n                             &s->vram, 0, memory_region_size(&s->vram));\n    /* XXX: use optimized standard vga accesses */\n    memory_region_add_subregion(system_memory,\n                                VBE_DISPI_LFB_PHYSICAL_ADDRESS,\n                                &s->vram_vbe);\n    s->vbe_mapped = 1;\n}\n",
        "linevul": 5.6082135415636e-05
    },
    {
        "code": "void vnc_jobs_join(VncState *vs)\n{\n    vnc_lock_queue(queue);\n    while (vnc_has_job_locked(vs)) {\n        qemu_cond_wait(&queue->cond, &queue->mutex);\n    }\n    vnc_unlock_queue(queue);\n    vnc_jobs_consume_buffer(vs);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "void vnc_jobs_join(VncState *vs)\n{\n    vnc_lock_queue(queue);\n    while (vnc_has_job_locked(vs)) {\n        qemu_cond_wait(&queue->cond, &queue->mutex);\n    }\n    vnc_unlock_queue(queue);\n    vnc_jobs_consume_buffer(vs);\n}\n",
        "linevul": 5.580897777690552e-05
    },
    {
        "code": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n         return;\n     }\n \n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n     if (s->tray_open) {\n         scsi_read_complete(r, -ENOMEDIUM);\n     }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n     r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                               scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n         return;\n     }\n \n//flaw_line_below:\n    n = r->sector_count;\n//flaw_line_below:\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n//flaw_line_below:\n        n = SCSI_DMA_BUF_SIZE / 512;\n//flaw_line_below:\n\n     if (s->tray_open) {\n         scsi_read_complete(r, -ENOMEDIUM);\n     }\n//flaw_line_below:\n    r->iov.iov_len = n * 512;\n//flaw_line_below:\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n//flaw_line_below:\n\n//fix_flaw_line_below:\n//    n = scsi_init_iovec(r);\n     bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n     r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                               scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}\n",
        "linevul": 0.00013489330012816936
    },
    {
        "code": "fcs_len(E1000State *s)\n{\n    return (s->mac_reg[RCTL] & E1000_RCTL_SECRC) ? 0 : 4;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb",
        "vul_func_with_fix": "fcs_len(E1000State *s)\n{\n    return (s->mac_reg[RCTL] & E1000_RCTL_SECRC) ? 0 : 4;\n}\n",
        "linevul": 5.813149982714094e-05
    },
    {
        "code": "static AHCICmdHdr *get_cmd_header(AHCIState *s, uint8_t port, uint8_t slot)\n{\n    if (port >= s->ports || slot >= AHCI_MAX_CMDS) {\n        return NULL;\n    }\n\n    return s->dev[port].lst ? &((AHCICmdHdr *)s->dev[port].lst)[slot] : NULL;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static AHCICmdHdr *get_cmd_header(AHCIState *s, uint8_t port, uint8_t slot)\n{\n    if (port >= s->ports || slot >= AHCI_MAX_CMDS) {\n        return NULL;\n    }\n\n    return s->dev[port].lst ? &((AHCICmdHdr *)s->dev[port].lst)[slot] : NULL;\n}\n",
        "linevul": 4.704839375335723e-05
    },
    {
        "code": "static void map_page(uint8_t **ptr, uint64_t addr, uint32_t wanted)\n{\n    hwaddr len = wanted;\n\n    if (*ptr) {\n        cpu_physical_memory_unmap(*ptr, len, 1, len);\n    }\n\n    *ptr = cpu_physical_memory_map(addr, &len, 1);\n    if (len < wanted) {\n        cpu_physical_memory_unmap(*ptr, len, 1, len);\n        *ptr = NULL;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static void map_page(uint8_t **ptr, uint64_t addr, uint32_t wanted)\n{\n    hwaddr len = wanted;\n\n    if (*ptr) {\n        cpu_physical_memory_unmap(*ptr, len, 1, len);\n    }\n\n    *ptr = cpu_physical_memory_map(addr, &len, 1);\n    if (len < wanted) {\n        cpu_physical_memory_unmap(*ptr, len, 1, len);\n        *ptr = NULL;\n    }\n}\n",
        "linevul": 6.127420056145638e-05
    },
    {
        "code": "static coroutine_fn int bochs_co_read(BlockDriverState *bs, int64_t sector_num,\n                                      uint8_t *buf, int nb_sectors)\n{\n    int ret;\n    BDRVBochsState *s = bs->opaque;\n    qemu_co_mutex_lock(&s->lock);\n    ret = bochs_read(bs, sector_num, buf, nb_sectors);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e3737b820b45e54b059656dc3f914f895ac7a88b",
        "vul_func_with_fix": "static coroutine_fn int bochs_co_read(BlockDriverState *bs, int64_t sector_num,\n                                      uint8_t *buf, int nb_sectors)\n{\n    int ret;\n    BDRVBochsState *s = bs->opaque;\n    qemu_co_mutex_lock(&s->lock);\n    ret = bochs_read(bs, sector_num, buf, nb_sectors);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n",
        "linevul": 6.348409806378186e-05
    },
    {
        "code": "void ahci_init(AHCIState *s, DeviceState *qdev)\n{\n    s->container = qdev;\n    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */\n    memory_region_init_io(&s->mem, OBJECT(qdev), &ahci_mem_ops, s,\n                          \"ahci\", AHCI_MEM_BAR_SIZE);\n    memory_region_init_io(&s->idp, OBJECT(qdev), &ahci_idp_ops, s,\n                          \"ahci-idp\", 32);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "void ahci_init(AHCIState *s, DeviceState *qdev)\n{\n    s->container = qdev;\n    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */\n    memory_region_init_io(&s->mem, OBJECT(qdev), &ahci_mem_ops, s,\n                          \"ahci\", AHCI_MEM_BAR_SIZE);\n    memory_region_init_io(&s->idp, OBJECT(qdev), &ahci_idp_ops, s,\n                          \"ahci-idp\", 32);\n}\n",
        "linevul": 5.6587545259390026e-05
    },
    {
        "code": "static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,\n                                   size_t size)\n{\n    int64_t len;\n\n    if (!bdrv_is_inserted(bs))\n        return -ENOMEDIUM;\n\n    if (bs->growable)\n        return 0;\n\n    len = bdrv_getlength(bs);\n\n    if (offset < 0)\n        return -EIO;\n\n    if ((offset > len) || (len - offset < size))\n        return -EIO;\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static int bdrv_check_byte_request(BlockDriverState *bs, int64_t offset,\n                                   size_t size)\n{\n    int64_t len;\n\n    if (!bdrv_is_inserted(bs))\n        return -ENOMEDIUM;\n\n    if (bs->growable)\n        return 0;\n\n    len = bdrv_getlength(bs);\n\n    if (offset < 0)\n        return -EIO;\n\n    if ((offset > len) || (len - offset < size))\n        return -EIO;\n\n    return 0;\n}\n",
        "linevul": 5.121401773067191e-05
    },
    {
        "code": "static void *mptsas_load_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    SCSIBus *bus = sreq->bus;\n    MPTSASState *s = container_of(bus, MPTSASState, bus);\n    PCIDevice *pci = PCI_DEVICE(s);\n    MPTSASRequest *req;\n    int i, n;\n\n    req = g_new(MPTSASRequest, 1);\n    qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n\n    n = qemu_get_be32(f);\n    /* TODO: add a way for SCSIBusInfo's load_request to fail,\n     * and fail migration instead of asserting here.\n     * When we do, we might be able to re-enable NDEBUG below.\n     */\n#ifdef NDEBUG\n#error building with NDEBUG is not supported\n#endif\n    assert(n >= 0);\n\n    pci_dma_sglist_init(&req->qsg, pci, n);\n    for (i = 0; i < n; i++) {\n        uint64_t base = qemu_get_be64(f);\n        uint64_t len = qemu_get_be64(f);\n        qemu_sglist_add(&req->qsg, base, len);\n    }\n\n    scsi_req_ref(sreq);\n    req->sreq = sreq;\n    req->dev = s;\n\n    return req;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static void *mptsas_load_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    SCSIBus *bus = sreq->bus;\n    MPTSASState *s = container_of(bus, MPTSASState, bus);\n    PCIDevice *pci = PCI_DEVICE(s);\n    MPTSASRequest *req;\n    int i, n;\n\n    req = g_new(MPTSASRequest, 1);\n    qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));\n\n    n = qemu_get_be32(f);\n    /* TODO: add a way for SCSIBusInfo's load_request to fail,\n     * and fail migration instead of asserting here.\n     * When we do, we might be able to re-enable NDEBUG below.\n     */\n#ifdef NDEBUG\n#error building with NDEBUG is not supported\n#endif\n    assert(n >= 0);\n\n    pci_dma_sglist_init(&req->qsg, pci, n);\n    for (i = 0; i < n; i++) {\n        uint64_t base = qemu_get_be64(f);\n        uint64_t len = qemu_get_be64(f);\n        qemu_sglist_add(&req->qsg, base, len);\n    }\n\n    scsi_req_ref(sreq);\n    req->sreq = sreq;\n    req->dev = s;\n\n    return req;\n}\n",
        "linevul": 6.423520244425163e-05
    },
    {
        "code": "static bool vmxnet3_verify_driver_magic(PCIDevice *d, hwaddr dshmem)\n{\n    return (VMXNET3_READ_DRV_SHARED32(d, dshmem, magic) == VMXNET3_REV1_MAGIC);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static bool vmxnet3_verify_driver_magic(PCIDevice *d, hwaddr dshmem)\n{\n    return (VMXNET3_READ_DRV_SHARED32(d, dshmem, magic) == VMXNET3_REV1_MAGIC);\n}\n",
        "linevul": 4.906518734060228e-05
    },
    {
        "code": "static int iscsi_reopen_prepare(BDRVReopenState *state,\n                                BlockReopenQueue *queue, Error **errp)\n{\n    IscsiLun *iscsilun = state->bs->opaque;\n\n    if (state->flags & BDRV_O_RDWR && iscsilun->write_protected) {\n        error_setg(errp, \"Cannot open a write protected LUN as read-write\");\n        return -EACCES;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static int iscsi_reopen_prepare(BDRVReopenState *state,\n                                BlockReopenQueue *queue, Error **errp)\n{\n    IscsiLun *iscsilun = state->bs->opaque;\n\n    if (state->flags & BDRV_O_RDWR && iscsilun->write_protected) {\n        error_setg(errp, \"Cannot open a write protected LUN as read-write\");\n        return -EACCES;\n    }\n    return 0;\n}\n",
        "linevul": 5.159638385521248e-05
    },
    {
        "code": "static bool cmd_verify(IDEState *s, uint8_t cmd)\n{\n    bool lba48 = (cmd == WIN_VERIFY_EXT);\n\n    /* do sector number check ? */\n    ide_cmd_lba48_transform(s, lba48);\n\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_verify(IDEState *s, uint8_t cmd)\n{\n    bool lba48 = (cmd == WIN_VERIFY_EXT);\n\n    /* do sector number check ? */\n    ide_cmd_lba48_transform(s, lba48);\n\n    return true;\n}\n",
        "linevul": 4.798004374606535e-05
    },
    {
        "code": "int bdrv_open_backing_file(BlockDriverState *bs, QDict *options, Error **errp)\n{\n    char backing_filename[PATH_MAX];\n    int back_flags, ret;\n    BlockDriver *back_drv = NULL;\n    Error *local_err = NULL;\n\n    if (bs->backing_hd != NULL) {\n        QDECREF(options);\n        return 0;\n    }\n\n    /* NULL means an empty set of options */\n    if (options == NULL) {\n        options = qdict_new();\n    }\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n    if (qdict_haskey(options, \"file.filename\")) {\n        backing_filename[0] = '\\0';\n    } else if (bs->backing_file[0] == '\\0' && qdict_size(options) == 0) {\n        QDECREF(options);\n        return 0;\n    } else {\n        bdrv_get_full_backing_filename(bs, backing_filename,\n                                       sizeof(backing_filename));\n    }\n\n    if (bs->backing_format[0] != '\\0') {\n        back_drv = bdrv_find_format(bs->backing_format);\n    }\n\n    /* backing files always opened read-only */\n    back_flags = bs->open_flags & ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT |\n                                    BDRV_O_COPY_ON_READ);\n\n    assert(bs->backing_hd == NULL);\n    ret = bdrv_open(&bs->backing_hd,\n                    *backing_filename ? backing_filename : NULL, NULL, options,\n                    back_flags, back_drv, &local_err);\n    if (ret < 0) {\n        bs->backing_hd = NULL;\n        bs->open_flags |= BDRV_O_NO_BACKING;\n        error_setg(errp, \"Could not open backing file: %s\",\n                   error_get_pretty(local_err));\n        error_free(local_err);\n        return ret;\n    }\n\n    if (bs->backing_hd->file) {\n        pstrcpy(bs->backing_file, sizeof(bs->backing_file),\n                bs->backing_hd->file->filename);\n    }\n\n    /* Recalculate the BlockLimits with the backing file */\n    bdrv_refresh_limits(bs);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "int bdrv_open_backing_file(BlockDriverState *bs, QDict *options, Error **errp)\n{\n    char backing_filename[PATH_MAX];\n    int back_flags, ret;\n    BlockDriver *back_drv = NULL;\n    Error *local_err = NULL;\n\n    if (bs->backing_hd != NULL) {\n        QDECREF(options);\n        return 0;\n    }\n\n    /* NULL means an empty set of options */\n    if (options == NULL) {\n        options = qdict_new();\n    }\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n    if (qdict_haskey(options, \"file.filename\")) {\n        backing_filename[0] = '\\0';\n    } else if (bs->backing_file[0] == '\\0' && qdict_size(options) == 0) {\n        QDECREF(options);\n        return 0;\n    } else {\n        bdrv_get_full_backing_filename(bs, backing_filename,\n                                       sizeof(backing_filename));\n    }\n\n    if (bs->backing_format[0] != '\\0') {\n        back_drv = bdrv_find_format(bs->backing_format);\n    }\n\n    /* backing files always opened read-only */\n    back_flags = bs->open_flags & ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT |\n                                    BDRV_O_COPY_ON_READ);\n\n    assert(bs->backing_hd == NULL);\n    ret = bdrv_open(&bs->backing_hd,\n                    *backing_filename ? backing_filename : NULL, NULL, options,\n                    back_flags, back_drv, &local_err);\n    if (ret < 0) {\n        bs->backing_hd = NULL;\n        bs->open_flags |= BDRV_O_NO_BACKING;\n        error_setg(errp, \"Could not open backing file: %s\",\n                   error_get_pretty(local_err));\n        error_free(local_err);\n        return ret;\n    }\n\n    if (bs->backing_hd->file) {\n        pstrcpy(bs->backing_file, sizeof(bs->backing_file),\n                bs->backing_hd->file->filename);\n    }\n\n    /* Recalculate the BlockLimits with the backing file */\n    bdrv_refresh_limits(bs);\n\n    return 0;\n}\n",
        "linevul": 7.025648665148765e-05
    },
    {
        "code": "ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n{\n    PCNetState *s = qemu_get_nic_opaque(nc);\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n    uint8_t buf1[60];\n    int remaining;\n    int crc_err = 0;\n    int size = size_;\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size ||\n        (CSR_LOOP(s) && !s->looptest)) {\n        return -1;\n    }\n#ifdef PCNET_DEBUG\n    printf(\"pcnet_receive size=%d\\n\", size);\n#endif\n\n    /* if too small buffer, then expand it */\n    if (size < MIN_BUF_SIZE) {\n        memcpy(buf1, buf, size);\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n        buf = buf1;\n        size = MIN_BUF_SIZE;\n    }\n\n    if (CSR_PROM(s)\n        || (is_padr=padr_match(s, buf, size))\n        || (is_bcast=padr_bcast(s, buf, size))\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n        pcnet_rdte_poll(s);\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n            struct pcnet_RMD rmd;\n            int rcvrc = CSR_RCVRC(s)-1,i;\n            hwaddr nrda;\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n                if (rcvrc <= 1)\n                    rcvrc = CSR_RCVRL(s);\n                nrda = s->rdra +\n                    (CSR_RCVRL(s) - rcvrc) *\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n                RMDLOAD(&rmd, nrda);\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n#ifdef PCNET_DEBUG_RMD\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n                                rcvrc, CSR_RCVRC(s));\n#endif\n                    CSR_RCVRC(s) = rcvrc;\n                    pcnet_rdte_poll(s);\n                    break;\n                }\n            }\n        }\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n#ifdef PCNET_DEBUG_RMD\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n#endif\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n            CSR_MISSC(s)++;\n        } else {\n            uint8_t *src = s->buffer;\n            hwaddr crda = CSR_CRDA(s);\n            struct pcnet_RMD rmd;\n             int pktcount = 0;\n \n             if (!s->looptest) {\n                 memcpy(src, buf, size);\n                 /* no need to compute the CRC */\n                 src[size] = 0;\n                uint32_t fcs = ~0;\n                uint8_t *p = src;\n\n                while (p != &src[size])\n                    CRC(fcs, *p++);\n                *(uint32_t *)p = htonl(fcs);\n                size += 4;\n            } else {\n                uint32_t fcs = ~0;\n                uint8_t *p = src;\n\n                while (p != &src[size])\n                    CRC(fcs, *p++);\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n            }\n\n#ifdef PCNET_DEBUG_MATCH\n            PRINT_PKTHDR(buf);\n#endif\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n            /*if (!CSR_LAPPEN(s))*/\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n#define PCNET_RECV_STORE() do {                                 \\\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n    hwaddr rbadr = PHYSADDR(s, rmd.rbadr);          \\\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n    src += count; remaining -= count;                           \\\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n    pktcount++;                                                 \\\n} while (0)\n\n            remaining = size;\n            PCNET_RECV_STORE();\n            if ((remaining > 0) && CSR_NRDA(s)) {\n                hwaddr nrda = CSR_NRDA(s);\n#ifdef PCNET_DEBUG_RMD\n                PRINT_RMD(&rmd);\n#endif\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n                    crda = nrda;\n                    PCNET_RECV_STORE();\n#ifdef PCNET_DEBUG_RMD\n                    PRINT_RMD(&rmd);\n#endif\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n                            crda = nrda;\n                            PCNET_RECV_STORE();\n                        }\n                    }\n                }\n            }\n\n#undef PCNET_RECV_STORE\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n            if (remaining == 0) {\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n                if (crc_err) {\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n                }\n            } else {\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n            }\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n            s->csr[0] |= 0x0400;\n\n#ifdef PCNET_DEBUG\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n#endif\n#ifdef PCNET_DEBUG_RMD\n            PRINT_RMD(&rmd);\n#endif\n\n            while (pktcount--) {\n                if (CSR_RCVRC(s) <= 1)\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n                else\n                    CSR_RCVRC(s)--;\n            }\n\n            pcnet_rdte_poll(s);\n\n        }\n    }\n\n    pcnet_poll(s);\n    pcnet_update_irq(s);\n\n    return size_;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n{\n    PCNetState *s = qemu_get_nic_opaque(nc);\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n    uint8_t buf1[60];\n    int remaining;\n    int crc_err = 0;\n    int size = size_;\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size ||\n        (CSR_LOOP(s) && !s->looptest)) {\n        return -1;\n    }\n#ifdef PCNET_DEBUG\n    printf(\"pcnet_receive size=%d\\n\", size);\n#endif\n\n    /* if too small buffer, then expand it */\n    if (size < MIN_BUF_SIZE) {\n        memcpy(buf1, buf, size);\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n        buf = buf1;\n        size = MIN_BUF_SIZE;\n    }\n\n    if (CSR_PROM(s)\n        || (is_padr=padr_match(s, buf, size))\n        || (is_bcast=padr_bcast(s, buf, size))\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n        pcnet_rdte_poll(s);\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n            struct pcnet_RMD rmd;\n            int rcvrc = CSR_RCVRC(s)-1,i;\n            hwaddr nrda;\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n                if (rcvrc <= 1)\n                    rcvrc = CSR_RCVRL(s);\n                nrda = s->rdra +\n                    (CSR_RCVRL(s) - rcvrc) *\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n                RMDLOAD(&rmd, nrda);\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n#ifdef PCNET_DEBUG_RMD\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n                                rcvrc, CSR_RCVRC(s));\n#endif\n                    CSR_RCVRC(s) = rcvrc;\n                    pcnet_rdte_poll(s);\n                    break;\n                }\n            }\n        }\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n#ifdef PCNET_DEBUG_RMD\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n#endif\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n            CSR_MISSC(s)++;\n        } else {\n            uint8_t *src = s->buffer;\n            hwaddr crda = CSR_CRDA(s);\n            struct pcnet_RMD rmd;\n             int pktcount = 0;\n \n             if (!s->looptest) {\n//fix_flaw_line_below:\n//                if (size > 4092) {\n//fix_flaw_line_below:\n//#ifdef PCNET_DEBUG_RMD\n//fix_flaw_line_below:\n//                    fprintf(stderr, \"pcnet: truncates rx packet.\\n\");\n//fix_flaw_line_below:\n//#endif\n//fix_flaw_line_below:\n//                    size = 4092;\n//fix_flaw_line_below:\n//                }\n                 memcpy(src, buf, size);\n                 /* no need to compute the CRC */\n                 src[size] = 0;\n                uint32_t fcs = ~0;\n                uint8_t *p = src;\n\n                while (p != &src[size])\n                    CRC(fcs, *p++);\n                *(uint32_t *)p = htonl(fcs);\n                size += 4;\n            } else {\n                uint32_t fcs = ~0;\n                uint8_t *p = src;\n\n                while (p != &src[size])\n                    CRC(fcs, *p++);\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n            }\n\n#ifdef PCNET_DEBUG_MATCH\n            PRINT_PKTHDR(buf);\n#endif\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n            /*if (!CSR_LAPPEN(s))*/\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n#define PCNET_RECV_STORE() do {                                 \\\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n    hwaddr rbadr = PHYSADDR(s, rmd.rbadr);          \\\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n    src += count; remaining -= count;                           \\\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n    pktcount++;                                                 \\\n} while (0)\n\n            remaining = size;\n            PCNET_RECV_STORE();\n            if ((remaining > 0) && CSR_NRDA(s)) {\n                hwaddr nrda = CSR_NRDA(s);\n#ifdef PCNET_DEBUG_RMD\n                PRINT_RMD(&rmd);\n#endif\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n                    crda = nrda;\n                    PCNET_RECV_STORE();\n#ifdef PCNET_DEBUG_RMD\n                    PRINT_RMD(&rmd);\n#endif\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n                            crda = nrda;\n                            PCNET_RECV_STORE();\n                        }\n                    }\n                }\n            }\n\n#undef PCNET_RECV_STORE\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n            if (remaining == 0) {\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n                if (crc_err) {\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n                }\n            } else {\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n            }\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n            s->csr[0] |= 0x0400;\n\n#ifdef PCNET_DEBUG\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n#endif\n#ifdef PCNET_DEBUG_RMD\n            PRINT_RMD(&rmd);\n#endif\n\n            while (pktcount--) {\n                if (CSR_RCVRC(s) <= 1)\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n                else\n                    CSR_RCVRC(s)--;\n            }\n\n            pcnet_rdte_poll(s);\n\n        }\n    }\n\n    pcnet_poll(s);\n    pcnet_update_irq(s);\n\n    return size_;\n}\n",
        "linevul": 5.655130007653497e-05
    },
    {
        "code": "static bool cmd_check_power_mode(IDEState *s, uint8_t cmd)\n{\n    s->nsector = 0xff; /* device active or idle */\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_check_power_mode(IDEState *s, uint8_t cmd)\n{\n    s->nsector = 0xff; /* device active or idle */\n    return true;\n}\n",
        "linevul": 4.943560634274036e-05
    },
    {
        "code": "e1000e_update_rx_offloads(E1000ECore *core)\n{\n    int cso_state = e1000e_rx_l4_cso_enabled(core);\n\n    trace_e1000e_rx_set_cso(cso_state);\n\n    if (core->has_vnet) {\n        qemu_set_offload(qemu_get_queue(core->owner_nic)->peer,\n                         cso_state, 0, 0, 0, 0);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_update_rx_offloads(E1000ECore *core)\n{\n    int cso_state = e1000e_rx_l4_cso_enabled(core);\n\n    trace_e1000e_rx_set_cso(cso_state);\n\n    if (core->has_vnet) {\n        qemu_set_offload(qemu_get_queue(core->owner_nic)->peer,\n                         cso_state, 0, 0, 0, 0);\n    }\n}\n",
        "linevul": 4.8395460908068344e-05
    },
    {
        "code": "static int megasas_dcmd_pd_get_list(MegasasState *s, MegasasCmd *cmd)\n{\n    struct mfi_pd_list info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    uint32_t offset, dcmd_limit, num_pd_disks = 0, max_pd_disks;\n\n    memset(&info, 0, dcmd_size);\n    offset = 8;\n    dcmd_limit = offset + sizeof(struct mfi_pd_address);\n    if (cmd->iov_size < dcmd_limit) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_limit);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    max_pd_disks = (cmd->iov_size - offset) / sizeof(struct mfi_pd_address);\n    if (max_pd_disks > MFI_MAX_SYS_PDS) {\n        max_pd_disks = MFI_MAX_SYS_PDS;\n    }\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks >= max_pd_disks)\n            break;\n\n        pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n        info.addr[num_pd_disks].device_id = cpu_to_le16(pd_id);\n        info.addr[num_pd_disks].encl_device_id = 0xFFFF;\n        info.addr[num_pd_disks].encl_index = 0;\n        info.addr[num_pd_disks].slot_number = sdev->id & 0xFF;\n        info.addr[num_pd_disks].scsi_dev_type = sdev->type;\n        info.addr[num_pd_disks].connect_port_bitmap = 0x1;\n        info.addr[num_pd_disks].sas_addr[0] =\n            cpu_to_le64(megasas_get_sata_addr(pd_id));\n        num_pd_disks++;\n        offset += sizeof(struct mfi_pd_address);\n    }\n    trace_megasas_dcmd_pd_get_list(cmd->index, num_pd_disks,\n                                   max_pd_disks, offset);\n\n    info.size = cpu_to_le32(offset);\n    info.count = cpu_to_le32(num_pd_disks);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, offset, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_dcmd_pd_get_list(MegasasState *s, MegasasCmd *cmd)\n{\n    struct mfi_pd_list info;\n    size_t dcmd_size = sizeof(info);\n    BusChild *kid;\n    uint32_t offset, dcmd_limit, num_pd_disks = 0, max_pd_disks;\n\n    memset(&info, 0, dcmd_size);\n    offset = 8;\n    dcmd_limit = offset + sizeof(struct mfi_pd_address);\n    if (cmd->iov_size < dcmd_limit) {\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n                                            dcmd_limit);\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    max_pd_disks = (cmd->iov_size - offset) / sizeof(struct mfi_pd_address);\n    if (max_pd_disks > MFI_MAX_SYS_PDS) {\n        max_pd_disks = MFI_MAX_SYS_PDS;\n    }\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n        SCSIDevice *sdev = SCSI_DEVICE(kid->child);\n        uint16_t pd_id;\n\n        if (num_pd_disks >= max_pd_disks)\n            break;\n\n        pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n        info.addr[num_pd_disks].device_id = cpu_to_le16(pd_id);\n        info.addr[num_pd_disks].encl_device_id = 0xFFFF;\n        info.addr[num_pd_disks].encl_index = 0;\n        info.addr[num_pd_disks].slot_number = sdev->id & 0xFF;\n        info.addr[num_pd_disks].scsi_dev_type = sdev->type;\n        info.addr[num_pd_disks].connect_port_bitmap = 0x1;\n        info.addr[num_pd_disks].sas_addr[0] =\n            cpu_to_le64(megasas_get_sata_addr(pd_id));\n        num_pd_disks++;\n        offset += sizeof(struct mfi_pd_address);\n    }\n    trace_megasas_dcmd_pd_get_list(cmd->index, num_pd_disks,\n                                   max_pd_disks, offset);\n\n    info.size = cpu_to_le32(offset);\n    info.count = cpu_to_le32(num_pd_disks);\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, offset, &cmd->qsg);\n    return MFI_STAT_OK;\n}\n",
        "linevul": 0.0339256189763546
    },
    {
        "code": "static int ne2000_post_load(void* opaque, int version_id)\n{\n    NE2000State* s = opaque;\n\n    if (version_id < 2) {\n        s->rxcr = 0x0c;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static int ne2000_post_load(void* opaque, int version_id)\n{\n    NE2000State* s = opaque;\n\n    if (version_id < 2) {\n        s->rxcr = 0x0c;\n    }\n    return 0;\n}\n",
        "linevul": 5.493635035236366e-05
    },
    {
        "code": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (blit_is_unsafe(s))\n        return 0;\n\n    cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->vga.start_addr,\n            s->cirrus_blt_srcaddr - s->vga.start_addr,\n            s->cirrus_blt_width, s->cirrus_blt_height);\n\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (blit_is_unsafe(s))\n        return 0;\n\n    cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->vga.start_addr,\n            s->cirrus_blt_srcaddr - s->vga.start_addr,\n            s->cirrus_blt_width, s->cirrus_blt_height);\n\n    return 1;\n}\n",
        "linevul": 4.637461097445339e-05
    },
    {
        "code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n\n    assert(bs->read_only);\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n \n     /* Allocate and read in the snapshot's L1 table */\n     new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n        return ret;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n\n    assert(bs->read_only);\n\n    /* Search the snapshot */\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n \n     /* Allocate and read in the snapshot's L1 table */\n//fix_flaw_line_below:\n//    if (sn->l1_size > QCOW_MAX_L1_SIZE) {\n//fix_flaw_line_below:\n//        error_setg(errp, \"Snapshot L1 table too large\");\n//fix_flaw_line_below:\n//        return -EFBIG;\n//fix_flaw_line_below:\n//    }\n     new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n        return ret;\n    }\n",
        "linevul": 0.00010562539682723582
    },
    {
        "code": "static bool virtio_extra_state_needed(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    return k->has_extra_state &&\n        k->has_extra_state(qbus->parent);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static bool virtio_extra_state_needed(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    return k->has_extra_state &&\n        k->has_extra_state(qbus->parent);\n}\n",
        "linevul": 4.9182577640749514e-05
    },
    {
        "code": "static inline void eth_pulse_irq(struct xlx_ethlite *s)\n{\n    /* Only the first gie reg is active.  */\n    if (s->regs[R_TX_GIE0] & GIE_GIE) {\n        qemu_irq_pulse(s->irq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a0d1cbdacff5df4ded16b753b38fdd9da6092968",
        "vul_func_with_fix": "static inline void eth_pulse_irq(struct xlx_ethlite *s)\n{\n    /* Only the first gie reg is active.  */\n    if (s->regs[R_TX_GIE0] & GIE_GIE) {\n        qemu_irq_pulse(s->irq);\n    }\n}\n",
        "linevul": 4.596672079060227e-05
    },
    {
        "code": "static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t sect,\n                          uint8_t last_sect, uint8_t num_sides)\n{\n    return (((track * num_sides) + head) * last_sect) + sect - 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t sect,\n                          uint8_t last_sect, uint8_t num_sides)\n{\n    return (((track * num_sides) + head) * last_sect) + sect - 1;\n}\n",
        "linevul": 6.056834899936803e-05
    },
    {
        "code": "static uint32_t fdctrl_read_data(FDCtrl *fdctrl)\n {\n     FDrive *cur_drv;\n     uint32_t retval = 0;\n    int pos;\n \n     cur_drv = get_cur_drv(fdctrl);\n     fdctrl->dsr &= ~FD_DSR_PWRDOWN;\n    if (!(fdctrl->msr & FD_MSR_RQM) || !(fdctrl->msr & FD_MSR_DIO)) {\n        FLOPPY_DPRINTF(\"error: controller not ready for reading\\n\");\n         return 0;\n     }\n     pos = fdctrl->data_pos;\n     if (fdctrl->msr & FD_MSR_NONDMA) {\n        pos %= FD_SECTOR_LEN;\n         if (pos == 0) {\n             if (fdctrl->data_pos != 0)\n                 if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n                    FLOPPY_DPRINTF(\"error seeking to next sector %d\\n\",\n                                   fd_sector(cur_drv));\n                    return 0;\n                }\n            if (blk_read(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n                < 0) {\n                FLOPPY_DPRINTF(\"error getting sector %d\\n\",\n                               fd_sector(cur_drv));\n                /* Sure, image size is too small... */\n                memset(fdctrl->fifo, 0, FD_SECTOR_LEN);\n            }\n        }\n    }\n    retval = fdctrl->fifo[pos];\n    if (++fdctrl->data_pos == fdctrl->data_len) {\n        fdctrl->data_pos = 0;\n        /* Switch from transfer mode to status mode\n         * then from status mode to command mode\n         */\n        if (fdctrl->msr & FD_MSR_NONDMA) {\n            fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n        } else {\n            fdctrl_reset_fifo(fdctrl);\n            fdctrl_reset_irq(fdctrl);\n        }\n    }\n    FLOPPY_DPRINTF(\"data register: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static uint32_t fdctrl_read_data(FDCtrl *fdctrl)\n {\n     FDrive *cur_drv;\n     uint32_t retval = 0;\n//flaw_line_below:\n    int pos;\n//fix_flaw_line_below:\n//    uint32_t pos;\n \n     cur_drv = get_cur_drv(fdctrl);\n     fdctrl->dsr &= ~FD_DSR_PWRDOWN;\n    if (!(fdctrl->msr & FD_MSR_RQM) || !(fdctrl->msr & FD_MSR_DIO)) {\n        FLOPPY_DPRINTF(\"error: controller not ready for reading\\n\");\n         return 0;\n     }\n     pos = fdctrl->data_pos;\n//fix_flaw_line_below:\n//    pos %= FD_SECTOR_LEN;\n     if (fdctrl->msr & FD_MSR_NONDMA) {\n//flaw_line_below:\n        pos %= FD_SECTOR_LEN;\n         if (pos == 0) {\n             if (fdctrl->data_pos != 0)\n                 if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n                    FLOPPY_DPRINTF(\"error seeking to next sector %d\\n\",\n                                   fd_sector(cur_drv));\n                    return 0;\n                }\n            if (blk_read(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n                < 0) {\n                FLOPPY_DPRINTF(\"error getting sector %d\\n\",\n                               fd_sector(cur_drv));\n                /* Sure, image size is too small... */\n                memset(fdctrl->fifo, 0, FD_SECTOR_LEN);\n            }\n        }\n    }\n    retval = fdctrl->fifo[pos];\n    if (++fdctrl->data_pos == fdctrl->data_len) {\n        fdctrl->data_pos = 0;\n        /* Switch from transfer mode to status mode\n         * then from status mode to command mode\n         */\n        if (fdctrl->msr & FD_MSR_NONDMA) {\n            fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n        } else {\n            fdctrl_reset_fifo(fdctrl);\n            fdctrl_reset_irq(fdctrl);\n        }\n    }\n    FLOPPY_DPRINTF(\"data register: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "linevul": 0.9993301630020142
    },
    {
        "code": "static int local_unlinkat_common(FsContext *ctx, int dirfd, const char *name,\n                                 int flags)\n{\n    int ret = -1;\n\n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n        int map_dirfd;\n\n        if (flags == AT_REMOVEDIR) {\n            int fd;\n\n            fd = openat_dir(dirfd, name);\n            if (fd == -1) {\n                goto err_out;\n            }\n            /*\n             * If directory remove .virtfs_metadata contained in the\n             * directory\n             */\n            ret = unlinkat(fd, VIRTFS_META_DIR, AT_REMOVEDIR);\n            close_preserve_errno(fd);\n            if (ret < 0 && errno != ENOENT) {\n                /*\n                 * We didn't had the .virtfs_metadata file. May be file created\n                 * in non-mapped mode ?. Ignore ENOENT.\n                 */\n                goto err_out;\n            }\n        }\n        /*\n         * Now remove the name from parent directory\n         * .virtfs_metadata directory.\n         */\n        map_dirfd = openat_dir(dirfd, VIRTFS_META_DIR);\n        ret = unlinkat(map_dirfd, name, 0);\n        close_preserve_errno(map_dirfd);\n        if (ret < 0 && errno != ENOENT) {\n            /*\n             * We didn't had the .virtfs_metadata file. May be file created\n             * in non-mapped mode ?. Ignore ENOENT.\n             */\n            goto err_out;\n        }\n    }\n\n    ret = unlinkat(dirfd, name, flags);\nerr_out:\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_unlinkat_common(FsContext *ctx, int dirfd, const char *name,\n                                 int flags)\n{\n    int ret = -1;\n\n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n        int map_dirfd;\n\n        if (flags == AT_REMOVEDIR) {\n            int fd;\n\n            fd = openat_dir(dirfd, name);\n            if (fd == -1) {\n                goto err_out;\n            }\n            /*\n             * If directory remove .virtfs_metadata contained in the\n             * directory\n             */\n            ret = unlinkat(fd, VIRTFS_META_DIR, AT_REMOVEDIR);\n            close_preserve_errno(fd);\n            if (ret < 0 && errno != ENOENT) {\n                /*\n                 * We didn't had the .virtfs_metadata file. May be file created\n                 * in non-mapped mode ?. Ignore ENOENT.\n                 */\n                goto err_out;\n            }\n        }\n        /*\n         * Now remove the name from parent directory\n         * .virtfs_metadata directory.\n         */\n        map_dirfd = openat_dir(dirfd, VIRTFS_META_DIR);\n        ret = unlinkat(map_dirfd, name, 0);\n        close_preserve_errno(map_dirfd);\n        if (ret < 0 && errno != ENOENT) {\n            /*\n             * We didn't had the .virtfs_metadata file. May be file created\n             * in non-mapped mode ?. Ignore ENOENT.\n             */\n            goto err_out;\n        }\n    }\n\n    ret = unlinkat(dirfd, name, flags);\nerr_out:\n    return ret;\n}\n",
        "linevul": 6.46819535177201e-05
    },
    {
        "code": "static coroutine_fn int qcow2_co_write_zeroes(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors, BdrvRequestFlags flags)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    /* Emulate misaligned zero writes */\n    if (sector_num % s->cluster_sectors || nb_sectors % s->cluster_sectors) {\n        return -ENOTSUP;\n    }\n\n    /* Whatever is left can use real zero clusters */\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_zero_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors);\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9",
        "vul_func_with_fix": "static coroutine_fn int qcow2_co_write_zeroes(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors, BdrvRequestFlags flags)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    /* Emulate misaligned zero writes */\n    if (sector_num % s->cluster_sectors || nb_sectors % s->cluster_sectors) {\n        return -ENOTSUP;\n    }\n\n    /* Whatever is left can use real zero clusters */\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_zero_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors);\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n}\n",
        "linevul": 4.9856349505716935e-05
    },
    {
        "code": "static void ncq_cb(void *opaque, int ret)\n{\n    NCQTransferState *ncq_tfs = (NCQTransferState *)opaque;\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n\n    /* Clear bit for this tag in SActive */\n    ncq_tfs->drive->port_regs.scr_act &= ~(1 << ncq_tfs->tag);\n\n    if (ret < 0) {\n        /* error */\n        ide_state->error = ABRT_ERR;\n        ide_state->status = READY_STAT | ERR_STAT;\n        ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    } else {\n        ide_state->status = READY_STAT | SEEK_STAT;\n    }\n\n    ahci_write_fis_sdb(ncq_tfs->drive->hba, ncq_tfs->drive->port_no,\n                       (1 << ncq_tfs->tag));\n\n    DPRINTF(ncq_tfs->drive->port_no, \"NCQ transfer tag %d finished\\n\",\n            ncq_tfs->tag);\n\n    bdrv_acct_done(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct);\n    qemu_sglist_destroy(&ncq_tfs->sglist);\n    ncq_tfs->used = 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static void ncq_cb(void *opaque, int ret)\n{\n    NCQTransferState *ncq_tfs = (NCQTransferState *)opaque;\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n\n    /* Clear bit for this tag in SActive */\n    ncq_tfs->drive->port_regs.scr_act &= ~(1 << ncq_tfs->tag);\n\n    if (ret < 0) {\n        /* error */\n        ide_state->error = ABRT_ERR;\n        ide_state->status = READY_STAT | ERR_STAT;\n        ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    } else {\n        ide_state->status = READY_STAT | SEEK_STAT;\n    }\n\n    ahci_write_fis_sdb(ncq_tfs->drive->hba, ncq_tfs->drive->port_no,\n                       (1 << ncq_tfs->tag));\n\n    DPRINTF(ncq_tfs->drive->port_no, \"NCQ transfer tag %d finished\\n\",\n            ncq_tfs->tag);\n\n    bdrv_acct_done(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct);\n    qemu_sglist_destroy(&ncq_tfs->sglist);\n    ncq_tfs->used = 0;\n}\n",
        "linevul": 6.860777648398653e-05
    },
    {
        "code": "static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n{\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n    int i, j, pwlen;\n    unsigned char key[8];\n    time_t now = time(NULL);\n\n    if (!vs->vd->password) {\n        VNC_DEBUG(\"No password configured on server\");\n        goto reject;\n    }\n    if (vs->vd->expires < now) {\n        VNC_DEBUG(\"Password is expired\");\n        goto reject;\n    }\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n    /* Calculate the expected challenge response */\n    pwlen = strlen(vs->vd->password);\n    for (i=0; i<sizeof(key); i++)\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n    deskey(key, EN0);\n    for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n        des(response+j, response+j);\n\n    /* Compare expected vs actual challenge response */\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n        goto reject;\n    } else {\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n        vnc_write_u32(vs, 0); /* Accept auth */\n        vnc_flush(vs);\n\n        start_client_init(vs);\n    }\n    return 0;\n\nreject:\n    vnc_write_u32(vs, 1); /* Reject auth */\n    if (vs->minor >= 8) {\n        static const char err[] = \"Authentication failed\";\n        vnc_write_u32(vs, sizeof(err));\n        vnc_write(vs, err, sizeof(err));\n    }\n    vnc_flush(vs);\n    vnc_client_error(vs);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n{\n    unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n    int i, j, pwlen;\n    unsigned char key[8];\n    time_t now = time(NULL);\n\n    if (!vs->vd->password) {\n        VNC_DEBUG(\"No password configured on server\");\n        goto reject;\n    }\n    if (vs->vd->expires < now) {\n        VNC_DEBUG(\"Password is expired\");\n        goto reject;\n    }\n\n    memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n\n    /* Calculate the expected challenge response */\n    pwlen = strlen(vs->vd->password);\n    for (i=0; i<sizeof(key); i++)\n        key[i] = i<pwlen ? vs->vd->password[i] : 0;\n    deskey(key, EN0);\n    for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n        des(response+j, response+j);\n\n    /* Compare expected vs actual challenge response */\n    if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n        VNC_DEBUG(\"Client challenge response did not match\\n\");\n        goto reject;\n    } else {\n        VNC_DEBUG(\"Accepting VNC challenge response\\n\");\n        vnc_write_u32(vs, 0); /* Accept auth */\n        vnc_flush(vs);\n\n        start_client_init(vs);\n    }\n    return 0;\n\nreject:\n    vnc_write_u32(vs, 1); /* Reject auth */\n    if (vs->minor >= 8) {\n        static const char err[] = \"Authentication failed\";\n        vnc_write_u32(vs, sizeof(err));\n        vnc_write(vs, err, sizeof(err));\n    }\n    vnc_flush(vs);\n    vnc_client_error(vs);\n    return 0;\n}\n",
        "linevul": 0.00012382313434500247
    },
    {
        "code": "static void vnc_queue_clear(VncJobQueue *q)\n{\n    qemu_cond_destroy(&queue->cond);\n    qemu_mutex_destroy(&queue->mutex);\n    buffer_free(&queue->buffer);\n    g_free(q);\n    queue = NULL; /* Unset global queue */\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static void vnc_queue_clear(VncJobQueue *q)\n{\n    qemu_cond_destroy(&queue->cond);\n    qemu_mutex_destroy(&queue->mutex);\n    buffer_free(&queue->buffer);\n    g_free(q);\n    queue = NULL; /* Unset global queue */\n}\n",
        "linevul": 6.0832768213003874e-05
    },
    {
        "code": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n         return;\n     }\n \n    n = r->iov.iov_len / 512;\n     if (n) {\n         if (s->tray_open) {\n             scsi_write_complete(r, -ENOMEDIUM);\n         }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n         bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n         r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n         if (r->req.aiocb == NULL) {\n             scsi_write_complete(r, -ENOMEM);\n         }\n     } else {\n        /* Invoke completion routine to fetch data from host.  */\n         scsi_write_complete(r, 0);\n     }\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n         return;\n     }\n \n//flaw_line_below:\n    n = r->iov.iov_len / 512;\n//fix_flaw_line_below:\n//    n = r->qiov.size / 512;\n     if (n) {\n         if (s->tray_open) {\n             scsi_write_complete(r, -ENOMEDIUM);\n         }\n//flaw_line_below:\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n//flaw_line_below:\n\n         bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n         r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n//flaw_line_below:\n                                   scsi_write_complete, r);\n//fix_flaw_line_below:\n//                                       scsi_write_complete, r);\n         if (r->req.aiocb == NULL) {\n             scsi_write_complete(r, -ENOMEM);\n         }\n     } else {\n//flaw_line_below:\n        /* Invoke completion routine to fetch data from host.  */\n//fix_flaw_line_below:\n//        /* Called for the first time.  Ask the driver to send us more data.  */\n         scsi_write_complete(r, 0);\n     }\n }\n",
        "linevul": 0.9970735311508179
    },
    {
        "code": "pvscsi_on_command(PVSCSIState *s, uint64_t cmd_id)\n{\n    if ((cmd_id > PVSCSI_CMD_FIRST) && (cmd_id < PVSCSI_CMD_LAST)) {\n        s->curr_cmd = cmd_id;\n    } else {\n        s->curr_cmd = PVSCSI_CMD_FIRST;\n        trace_pvscsi_on_cmd_unknown(cmd_id);\n    }\n\n    s->curr_cmd_data_cntr = 0;\n    s->reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;\n\n    pvscsi_do_command_processing(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": "pvscsi_on_command(PVSCSIState *s, uint64_t cmd_id)\n{\n    if ((cmd_id > PVSCSI_CMD_FIRST) && (cmd_id < PVSCSI_CMD_LAST)) {\n        s->curr_cmd = cmd_id;\n    } else {\n        s->curr_cmd = PVSCSI_CMD_FIRST;\n        trace_pvscsi_on_cmd_unknown(cmd_id);\n    }\n\n    s->curr_cmd_data_cntr = 0;\n    s->reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;\n\n    pvscsi_do_command_processing(s);\n}\n",
        "linevul": 4.6721292164875194e-05
    },
    {
        "code": "iscsi_getlength(BlockDriverState *bs)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    int64_t len;\n\n    len  = iscsilun->num_blocks;\n    len *= iscsilun->block_size;\n\n    return len;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_getlength(BlockDriverState *bs)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    int64_t len;\n\n    len  = iscsilun->num_blocks;\n    len *= iscsilun->block_size;\n\n    return len;\n}\n",
        "linevul": 6.148116517579183e-05
    },
    {
        "code": "static uint64_t pxa2xx_clkcfg_read(CPUARMState *env, const ARMCPRegInfo *ri)\n{\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n    return s->clkcfg;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=caa881abe0e01f9931125a0977ec33c5343e4aa7",
        "vul_func_with_fix": "static uint64_t pxa2xx_clkcfg_read(CPUARMState *env, const ARMCPRegInfo *ri)\n{\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n    return s->clkcfg;\n}\n",
        "linevul": 4.8879406676860526e-05
    },
    {
        "code": "static void pmac_ide_writel (void *opaque,\n                             hwaddr addr, uint32_t val)\n{\n    MACIOIDEState *d = opaque;\n\n    addr = (addr & 0xFFF) >> 4;\n    val = bswap32(val);\n    if (addr == 0) {\n        ide_data_writel(&d->bus, 0, val);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void pmac_ide_writel (void *opaque,\n                             hwaddr addr, uint32_t val)\n{\n    MACIOIDEState *d = opaque;\n\n    addr = (addr & 0xFFF) >> 4;\n    val = bswap32(val);\n    if (addr == 0) {\n        ide_data_writel(&d->bus, 0, val);\n    }\n}\n",
        "linevul": 4.847744639846496e-05
    },
    {
        "code": "static USBEndpoint *xhci_epid_to_usbep(XHCIEPContext *epctx)\n{\n    USBPort *uport;\n    uint32_t token;\n\n    if (!epctx) {\n        return NULL;\n    }\n    uport = epctx->xhci->slots[epctx->slotid - 1].uport;\n    token = (epctx->epid & 1) ? USB_TOKEN_IN : USB_TOKEN_OUT;\n    if (!uport) {\n        return NULL;\n    }\n    return usb_ep_get(uport->dev, token, epctx->epid >> 1);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static USBEndpoint *xhci_epid_to_usbep(XHCIEPContext *epctx)\n{\n    USBPort *uport;\n    uint32_t token;\n\n    if (!epctx) {\n        return NULL;\n    }\n    uport = epctx->xhci->slots[epctx->slotid - 1].uport;\n    token = (epctx->epid & 1) ? USB_TOKEN_IN : USB_TOKEN_OUT;\n    if (!uport) {\n        return NULL;\n    }\n    return usb_ep_get(uport->dev, token, epctx->epid >> 1);\n}\n",
        "linevul": 4.943914609611966e-05
    },
    {
        "code": "static void vmxnet_tx_pkt_calculate_hdr_len(struct VmxnetTxPkt *pkt)\n{\n    pkt->hdr_len = pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len +\n        pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=93060258ae748573ca7197204125a2670047896d",
        "vul_func_with_fix": "static void vmxnet_tx_pkt_calculate_hdr_len(struct VmxnetTxPkt *pkt)\n{\n    pkt->hdr_len = pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG].iov_len +\n        pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG].iov_len;\n}\n",
        "linevul": 6.47491033305414e-05
    },
    {
        "code": "e1000e_process_tx_desc(E1000ECore *core,\n                       struct e1000e_tx *tx,\n                       struct e1000_tx_desc *dp,\n                       int queue_index)\n{\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n    unsigned int split_size = txd_lower & 0xffff;\n    uint64_t addr;\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n    bool eop = txd_lower & E1000_TXD_CMD_EOP;\n\n    if (dtype == E1000_TXD_CMD_DEXT) { /* context descriptor */\n        e1000x_read_tx_ctx_descr(xp, &tx->props);\n        e1000e_process_snap_option(core, le32_to_cpu(xp->cmd_and_length));\n        return;\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n        /* data descriptor */\n        tx->props.sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n        tx->props.cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;\n        e1000e_process_ts_option(core, dp);\n    } else {\n        /* legacy descriptor */\n        e1000e_process_ts_option(core, dp);\n        tx->props.cptse = 0;\n    }\n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (!tx->skip_cp) {\n        if (!net_tx_pkt_add_raw_fragment(tx->tx_pkt, addr, split_size)) {\n            tx->skip_cp = true;\n        }\n    }\n\n    if (eop) {\n        if (!tx->skip_cp && net_tx_pkt_parse(tx->tx_pkt)) {\n            if (e1000x_vlan_enabled(core->mac) &&\n                e1000x_is_vlan_txd(txd_lower)) {\n                net_tx_pkt_setup_vlan_header_ex(tx->tx_pkt,\n                    le16_to_cpu(dp->upper.fields.special), core->vet);\n            }\n            if (e1000e_tx_pkt_send(core, tx, queue_index)) {\n                e1000e_on_tx_done_update_stats(core, tx->tx_pkt);\n            }\n        }\n\n        tx->skip_cp = false;\n        net_tx_pkt_reset(tx->tx_pkt);\n\n        tx->props.sum_needed = 0;\n        tx->props.cptse = 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_process_tx_desc(E1000ECore *core,\n                       struct e1000e_tx *tx,\n                       struct e1000_tx_desc *dp,\n                       int queue_index)\n{\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n    unsigned int split_size = txd_lower & 0xffff;\n    uint64_t addr;\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n    bool eop = txd_lower & E1000_TXD_CMD_EOP;\n\n    if (dtype == E1000_TXD_CMD_DEXT) { /* context descriptor */\n        e1000x_read_tx_ctx_descr(xp, &tx->props);\n        e1000e_process_snap_option(core, le32_to_cpu(xp->cmd_and_length));\n        return;\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n        /* data descriptor */\n        tx->props.sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n        tx->props.cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;\n        e1000e_process_ts_option(core, dp);\n    } else {\n        /* legacy descriptor */\n        e1000e_process_ts_option(core, dp);\n        tx->props.cptse = 0;\n    }\n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (!tx->skip_cp) {\n        if (!net_tx_pkt_add_raw_fragment(tx->tx_pkt, addr, split_size)) {\n            tx->skip_cp = true;\n        }\n    }\n\n    if (eop) {\n        if (!tx->skip_cp && net_tx_pkt_parse(tx->tx_pkt)) {\n            if (e1000x_vlan_enabled(core->mac) &&\n                e1000x_is_vlan_txd(txd_lower)) {\n                net_tx_pkt_setup_vlan_header_ex(tx->tx_pkt,\n                    le16_to_cpu(dp->upper.fields.special), core->vet);\n            }\n            if (e1000e_tx_pkt_send(core, tx, queue_index)) {\n                e1000e_on_tx_done_update_stats(core, tx->tx_pkt);\n            }\n        }\n\n        tx->skip_cp = false;\n        net_tx_pkt_reset(tx->tx_pkt);\n\n        tx->props.sum_needed = 0;\n        tx->props.cptse = 0;\n    }\n}\n",
        "linevul": 0.00020939556998200715
    },
    {
        "code": "void virtio_notify_config(VirtIODevice *vdev)\n{\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))\n        return;\n\n    vdev->isr |= 0x03;\n    virtio_notify_vector(vdev, vdev->config_vector);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "void virtio_notify_config(VirtIODevice *vdev)\n{\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))\n        return;\n\n    vdev->isr |= 0x03;\n    virtio_notify_vector(vdev, vdev->config_vector);\n}\n",
        "linevul": 4.516089757089503e-05
    },
    {
        "code": "static void virtio_net_save(QEMUFile *f, void *opaque)\n{\n    int i;\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    /* At this point, backend must be stopped, otherwise\n     * it might keep writing to memory. */\n    assert(!n->vhost_started);\n    virtio_save(vdev, f);\n\n    qemu_put_buffer(f, n->mac, ETH_ALEN);\n    qemu_put_be32(f, n->vqs[0].tx_waiting);\n    qemu_put_be32(f, n->mergeable_rx_bufs);\n    qemu_put_be16(f, n->status);\n    qemu_put_byte(f, n->promisc);\n    qemu_put_byte(f, n->allmulti);\n    qemu_put_be32(f, n->mac_table.in_use);\n    qemu_put_buffer(f, n->mac_table.macs, n->mac_table.in_use * ETH_ALEN);\n    qemu_put_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n    qemu_put_be32(f, n->has_vnet_hdr);\n    qemu_put_byte(f, n->mac_table.multi_overflow);\n    qemu_put_byte(f, n->mac_table.uni_overflow);\n    qemu_put_byte(f, n->alluni);\n    qemu_put_byte(f, n->nomulti);\n    qemu_put_byte(f, n->nouni);\n    qemu_put_byte(f, n->nobcast);\n    qemu_put_byte(f, n->has_ufo);\n    if (n->max_queues > 1) {\n        qemu_put_be16(f, n->max_queues);\n        qemu_put_be16(f, n->curr_queues);\n        for (i = 1; i < n->curr_queues; i++) {\n            qemu_put_be32(f, n->vqs[i].tx_waiting);\n        }\n    }\n\n    if ((1 << VIRTIO_NET_F_CTRL_GUEST_OFFLOADS) & vdev->guest_features) {\n        qemu_put_be64(f, n->curr_guest_offloads);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_save(QEMUFile *f, void *opaque)\n{\n    int i;\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    /* At this point, backend must be stopped, otherwise\n     * it might keep writing to memory. */\n    assert(!n->vhost_started);\n    virtio_save(vdev, f);\n\n    qemu_put_buffer(f, n->mac, ETH_ALEN);\n    qemu_put_be32(f, n->vqs[0].tx_waiting);\n    qemu_put_be32(f, n->mergeable_rx_bufs);\n    qemu_put_be16(f, n->status);\n    qemu_put_byte(f, n->promisc);\n    qemu_put_byte(f, n->allmulti);\n    qemu_put_be32(f, n->mac_table.in_use);\n    qemu_put_buffer(f, n->mac_table.macs, n->mac_table.in_use * ETH_ALEN);\n    qemu_put_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n    qemu_put_be32(f, n->has_vnet_hdr);\n    qemu_put_byte(f, n->mac_table.multi_overflow);\n    qemu_put_byte(f, n->mac_table.uni_overflow);\n    qemu_put_byte(f, n->alluni);\n    qemu_put_byte(f, n->nomulti);\n    qemu_put_byte(f, n->nouni);\n    qemu_put_byte(f, n->nobcast);\n    qemu_put_byte(f, n->has_ufo);\n    if (n->max_queues > 1) {\n        qemu_put_be16(f, n->max_queues);\n        qemu_put_be16(f, n->curr_queues);\n        for (i = 1; i < n->curr_queues; i++) {\n            qemu_put_be32(f, n->vqs[i].tx_waiting);\n        }\n    }\n\n    if ((1 << VIRTIO_NET_F_CTRL_GUEST_OFFLOADS) & vdev->guest_features) {\n        qemu_put_be64(f, n->curr_guest_offloads);\n    }\n}\n",
        "linevul": 5.023547782911919e-05
    },
    {
        "code": "e1000e_mac_eitr_read(E1000ECore *core, int index)\n{\n    return core->eitr_guest_value[index - EITR];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_mac_eitr_read(E1000ECore *core, int index)\n{\n    return core->eitr_guest_value[index - EITR];\n}\n",
        "linevul": 5.861557292519137e-05
    },
    {
        "code": "static size_t mptsas_config_pack_ext(uint8_t **data, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vpack(data, fmt, ap);\n    va_end(ap);\n\n    if (data) {\n        assert(ret < 65536 && (ret % 4) == 0);\n        stw_le_p(*data + 4, ret / 4);\n    }\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "static size_t mptsas_config_pack_ext(uint8_t **data, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vpack(data, fmt, ap);\n    va_end(ap);\n\n    if (data) {\n        assert(ret < 65536 && (ret % 4) == 0);\n        stw_le_p(*data + 4, ret / 4);\n    }\n    return ret;\n}\n",
        "linevul": 4.817554508917965e-05
    },
    {
        "code": "static int send_solid_rect(VncState *vs)\n{\n    size_t bytes;\n         tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);\n         bytes = 3;\n     } else {\n        bytes = vs->clientds.pf.bytes_per_pixel;\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static int send_solid_rect(VncState *vs)\n{\n    size_t bytes;\n         tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);\n         bytes = 3;\n     } else {\n//flaw_line_below:\n        bytes = vs->clientds.pf.bytes_per_pixel;\n//fix_flaw_line_below:\n//        bytes = vs->client_pf.bytes_per_pixel;\n     }\n",
        "linevul": 5.133073136676103e-05
    },
    {
        "code": "e1000e_set_tdt(E1000ECore *core, int index, uint32_t val)\n{\n    E1000E_TxRing txr;\n    int qidx = e1000e_mq_queue_idx(TDT, index);\n    uint32_t tarc_reg = (qidx == 0) ? TARC0 : TARC1;\n\n    core->mac[index] = val & 0xffff;\n\n    if (core->mac[tarc_reg] & E1000_TARC_ENABLE) {\n        e1000e_tx_ring_init(core, &txr, qidx);\n        e1000e_start_xmit(core, &txr);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_set_tdt(E1000ECore *core, int index, uint32_t val)\n{\n    E1000E_TxRing txr;\n    int qidx = e1000e_mq_queue_idx(TDT, index);\n    uint32_t tarc_reg = (qidx == 0) ? TARC0 : TARC1;\n\n    core->mac[index] = val & 0xffff;\n\n    if (core->mac[tarc_reg] & E1000_TARC_ENABLE) {\n        e1000e_tx_ring_init(core, &txr, qidx);\n        e1000e_start_xmit(core, &txr);\n    }\n}\n",
        "linevul": 4.671362694352865e-05
    },
    {
        "code": "static void ide_cd_change_cb(void *opaque, bool load)\n{\n    IDEState *s = opaque;\n    uint64_t nb_sectors;\n\n    s->tray_open = !load;\n    blk_get_geometry(s->blk, &nb_sectors);\n    s->nb_sectors = nb_sectors;\n\n    /*\n     * First indicate to the guest that a CD has been removed.  That's\n     * done on the next command the guest sends us.\n     *\n     * Then we set UNIT_ATTENTION, by which the guest will\n     * detect a new CD in the drive.  See ide_atapi_cmd() for details.\n     */\n    s->cdrom_changed = 1;\n    s->events.new_media = true;\n    s->events.eject_request = false;\n    ide_set_irq(s->bus);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_cd_change_cb(void *opaque, bool load)\n{\n    IDEState *s = opaque;\n    uint64_t nb_sectors;\n\n    s->tray_open = !load;\n    blk_get_geometry(s->blk, &nb_sectors);\n    s->nb_sectors = nb_sectors;\n\n    /*\n     * First indicate to the guest that a CD has been removed.  That's\n     * done on the next command the guest sends us.\n     *\n     * Then we set UNIT_ATTENTION, by which the guest will\n     * detect a new CD in the drive.  See ide_atapi_cmd() for details.\n     */\n    s->cdrom_changed = 1;\n    s->events.new_media = true;\n    s->events.eject_request = false;\n    ide_set_irq(s->bus);\n}\n",
        "linevul": 6.671938172075897e-05
    },
    {
        "code": "void rng_backend_request_entropy(RngBackend *s, size_t size,\n                                 EntropyReceiveFunc *receive_entropy,\n                                  void *opaque)\n {\n     RngBackendClass *k = RNG_BACKEND_GET_CLASS(s);\n \n     if (k->request_entropy) {\n        k->request_entropy(s, size, receive_entropy, opaque);\n     }\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=60253ed1e6ec6d8e5ef2efe7bf755f475dce9956",
        "vul_func_with_fix": "void rng_backend_request_entropy(RngBackend *s, size_t size,\n                                 EntropyReceiveFunc *receive_entropy,\n                                  void *opaque)\n {\n     RngBackendClass *k = RNG_BACKEND_GET_CLASS(s);\n//fix_flaw_line_below:\n//    RngRequest *req;\n \n     if (k->request_entropy) {\n//flaw_line_below:\n        k->request_entropy(s, size, receive_entropy, opaque);\n//fix_flaw_line_below:\n//        req = g_malloc(sizeof(*req));\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//        req->offset = 0;\n//fix_flaw_line_below:\n//        req->size = size;\n//fix_flaw_line_below:\n//        req->receive_entropy = receive_entropy;\n//fix_flaw_line_below:\n//        req->opaque = opaque;\n//fix_flaw_line_below:\n//        req->data = g_malloc(req->size);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//        k->request_entropy(s, req);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//        s->requests = g_slist_append(s->requests, req);\n     }\n }\n",
        "linevul": 0.9995189905166626
    },
    {
        "code": "static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n                                       GIOCondition condition,\n                                       void *opaque)\n{\n    qemu_coroutine_enter(opaque);\n    return TRUE;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=2b0bbc4f8809c972bad134bc1a2570dbb01dea0b",
        "vul_func_with_fix": "static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n//flaw_line_below:\n                                       GIOCondition condition,\n//flaw_line_below:\n                                       void *opaque)\n//flaw_line_below:\n{\n//flaw_line_below:\n    qemu_coroutine_enter(opaque);\n//flaw_line_below:\n    return TRUE;\n//flaw_line_below:\n}\n",
        "linevul": 4.584589260048233e-05
    },
    {
        "code": "static int get_unused_buffer(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t buf[1024];\n    int block_len;\n\n    while (size > 0) {\n        block_len = MIN(sizeof(buf), size);\n        size -= block_len;\n        qemu_get_buffer(f, buf, block_len);\n    }\n   return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "static int get_unused_buffer(QEMUFile *f, void *pv, size_t size)\n{\n    uint8_t buf[1024];\n    int block_len;\n\n    while (size > 0) {\n        block_len = MIN(sizeof(buf), size);\n        size -= block_len;\n        qemu_get_buffer(f, buf, block_len);\n    }\n   return 0;\n}\n",
        "linevul": 6.709211447741836e-05
    },
    {
        "code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n\n    pause_all_vcpus();\n\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n\n    switch (opcode[0]) {\n    case 0x89: /* mov r32 to r/m32 */\n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */\n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: /* mov r/m32 to r32 */\n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: /* mov abs to eax */\n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: /* mov eax to abs */\n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: /* mov imm32, r/m32 (c7/0) */\n        patch_byte(cpu, ip, 0x68);  /* push imm32 */\n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: /* push r/m32 */\n        patch_byte(cpu, ip, 0x50); /* push eax */\n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n\n    resume_all_vcpus();\n\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n//flaw_line_below:\n    uint32_t imm32;\n//fix_flaw_line_below:\n//    uint32_t imm32 = 0;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n\n    pause_all_vcpus();\n\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n\n    switch (opcode[0]) {\n    case 0x89: /* mov r32 to r/m32 */\n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  /* push reg */\n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: /* mov r/m32 to r32 */\n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: /* mov abs to eax */\n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: /* mov eax to abs */\n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: /* mov imm32, r/m32 (c7/0) */\n        patch_byte(cpu, ip, 0x68);  /* push imm32 */\n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: /* push r/m32 */\n        patch_byte(cpu, ip, 0x50); /* push eax */\n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n\n    resume_all_vcpus();\n\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}\n",
        "linevul": 0.00015172296843957156
    },
    {
        "code": "static void bdrv_qcow2_init(void)\n{\n    bdrv_register(&bdrv_qcow2);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9",
        "vul_func_with_fix": "static void bdrv_qcow2_init(void)\n{\n    bdrv_register(&bdrv_qcow2);\n}\n",
        "linevul": 5.015429269406013e-05
    },
    {
        "code": "static void ehci_frame_timer(void *opaque)\n{\n    EHCIState *ehci = opaque;\n    int need_timer = 0;\n    int64_t expire_time, t_now;\n    uint64_t ns_elapsed;\n    int uframes, skipped_uframes;\n    int i;\n\n    t_now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    ns_elapsed = t_now - ehci->last_run_ns;\n    uframes = ns_elapsed / UFRAME_TIMER_NS;\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n        need_timer++;\n\n        if (uframes > (ehci->maxframes * 8)) {\n            skipped_uframes = uframes - (ehci->maxframes * 8);\n            ehci_update_frindex(ehci, skipped_uframes);\n            ehci->last_run_ns += UFRAME_TIMER_NS * skipped_uframes;\n            uframes -= skipped_uframes;\n            DPRINTF(\"WARNING - EHCI skipped %d uframes\\n\", skipped_uframes);\n        }\n\n        for (i = 0; i < uframes; i++) {\n            /*\n             * If we're running behind schedule, we should not catch up\n             * too fast, as that will make some guests unhappy:\n             * 1) We must process a minimum of MIN_UFR_PER_TICK frames,\n             *    otherwise we will never catch up\n             * 2) Process frames until the guest has requested an irq (IOC)\n             */\n            if (i >= MIN_UFR_PER_TICK) {\n                ehci_commit_irq(ehci);\n                if ((ehci->usbsts & USBINTR_MASK) & ehci->usbintr) {\n                    break;\n                }\n            }\n            if (ehci->periodic_sched_active) {\n                ehci->periodic_sched_active--;\n            }\n            ehci_update_frindex(ehci, 1);\n            if ((ehci->frindex & 7) == 0) {\n                ehci_advance_periodic_state(ehci);\n            }\n            ehci->last_run_ns += UFRAME_TIMER_NS;\n        }\n    } else {\n        ehci->periodic_sched_active = 0;\n        ehci_update_frindex(ehci, uframes);\n        ehci->last_run_ns += UFRAME_TIMER_NS * uframes;\n    }\n\n    if (ehci->periodic_sched_active) {\n        ehci->async_stepdown = 0;\n    } else if (ehci->async_stepdown < ehci->maxframes / 2) {\n        ehci->async_stepdown++;\n    }\n\n    /*  Async is not inside loop since it executes everything it can once\n     *  called\n     */\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n        need_timer++;\n        ehci_advance_async_state(ehci);\n    }\n\n    ehci_commit_irq(ehci);\n    if (ehci->usbsts_pending) {\n        need_timer++;\n        ehci->async_stepdown = 0;\n    }\n\n    if (ehci_enabled(ehci) && (ehci->usbintr & USBSTS_FLR)) {\n        need_timer++;\n    }\n\n    if (need_timer) {\n        /* If we've raised int, we speed up the timer, so that we quickly\n         * notice any new packets queued up in response */\n        if (ehci->int_req_by_async && (ehci->usbsts & USBSTS_INT)) {\n            expire_time = t_now + get_ticks_per_sec() / (FRAME_TIMER_FREQ * 4);\n            ehci->int_req_by_async = false;\n        } else {\n            expire_time = t_now + (get_ticks_per_sec()\n                               * (ehci->async_stepdown+1) / FRAME_TIMER_FREQ);\n        }\n        timer_mod(ehci->frame_timer, expire_time);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=156a2e4dbffa85997636a7a39ef12da6f1b40254",
        "vul_func_with_fix": "static void ehci_frame_timer(void *opaque)\n{\n    EHCIState *ehci = opaque;\n    int need_timer = 0;\n    int64_t expire_time, t_now;\n    uint64_t ns_elapsed;\n    int uframes, skipped_uframes;\n    int i;\n\n    t_now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    ns_elapsed = t_now - ehci->last_run_ns;\n    uframes = ns_elapsed / UFRAME_TIMER_NS;\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n        need_timer++;\n\n        if (uframes > (ehci->maxframes * 8)) {\n            skipped_uframes = uframes - (ehci->maxframes * 8);\n            ehci_update_frindex(ehci, skipped_uframes);\n            ehci->last_run_ns += UFRAME_TIMER_NS * skipped_uframes;\n            uframes -= skipped_uframes;\n            DPRINTF(\"WARNING - EHCI skipped %d uframes\\n\", skipped_uframes);\n        }\n\n        for (i = 0; i < uframes; i++) {\n            /*\n             * If we're running behind schedule, we should not catch up\n             * too fast, as that will make some guests unhappy:\n             * 1) We must process a minimum of MIN_UFR_PER_TICK frames,\n             *    otherwise we will never catch up\n             * 2) Process frames until the guest has requested an irq (IOC)\n             */\n            if (i >= MIN_UFR_PER_TICK) {\n                ehci_commit_irq(ehci);\n                if ((ehci->usbsts & USBINTR_MASK) & ehci->usbintr) {\n                    break;\n                }\n            }\n            if (ehci->periodic_sched_active) {\n                ehci->periodic_sched_active--;\n            }\n            ehci_update_frindex(ehci, 1);\n            if ((ehci->frindex & 7) == 0) {\n                ehci_advance_periodic_state(ehci);\n            }\n            ehci->last_run_ns += UFRAME_TIMER_NS;\n        }\n    } else {\n        ehci->periodic_sched_active = 0;\n        ehci_update_frindex(ehci, uframes);\n        ehci->last_run_ns += UFRAME_TIMER_NS * uframes;\n    }\n\n    if (ehci->periodic_sched_active) {\n        ehci->async_stepdown = 0;\n    } else if (ehci->async_stepdown < ehci->maxframes / 2) {\n        ehci->async_stepdown++;\n    }\n\n    /*  Async is not inside loop since it executes everything it can once\n     *  called\n     */\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n        need_timer++;\n        ehci_advance_async_state(ehci);\n    }\n\n    ehci_commit_irq(ehci);\n    if (ehci->usbsts_pending) {\n        need_timer++;\n        ehci->async_stepdown = 0;\n    }\n\n    if (ehci_enabled(ehci) && (ehci->usbintr & USBSTS_FLR)) {\n        need_timer++;\n    }\n\n    if (need_timer) {\n        /* If we've raised int, we speed up the timer, so that we quickly\n         * notice any new packets queued up in response */\n        if (ehci->int_req_by_async && (ehci->usbsts & USBSTS_INT)) {\n            expire_time = t_now + get_ticks_per_sec() / (FRAME_TIMER_FREQ * 4);\n            ehci->int_req_by_async = false;\n        } else {\n            expire_time = t_now + (get_ticks_per_sec()\n                               * (ehci->async_stepdown+1) / FRAME_TIMER_FREQ);\n        }\n        timer_mod(ehci->frame_timer, expire_time);\n    }\n}\n",
        "linevul": 6.541652692249045e-05
    },
    {
        "code": "size_t mptsas_config_phy_0(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n    SCSIDevice *dev;\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n        return i;\n    }\n\n    dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n\n    return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"w*wqwb*blbb*b*b*l\",\n                                  dev_handle, s->sas_addr, dev_handle, i,\n                                  (dev\n                                   ? MPI_SAS_DEVICE_INFO_END_DEVICE /* | MPI_SAS_DEVICE_INFO_SSP_TARGET?? */\n                                   : MPI_SAS_DEVICE_INFO_NO_DEVICE),\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_phy_0(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n    SCSIDevice *dev;\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n        return i;\n    }\n\n    dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n\n    return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"w*wqwb*blbb*b*b*l\",\n                                  dev_handle, s->sas_addr, dev_handle, i,\n                                  (dev\n                                   ? MPI_SAS_DEVICE_INFO_END_DEVICE /* | MPI_SAS_DEVICE_INFO_SSP_TARGET?? */\n                                   : MPI_SAS_DEVICE_INFO_NO_DEVICE),\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5);\n}\n",
        "linevul": 4.843129136133939e-05
    },
    {
        "code": "static int handle_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK | O_WRONLY);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = ftruncate(fd, size);\n    close(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_NONBLOCK | O_WRONLY);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = ftruncate(fd, size);\n    close(fd);\n    return ret;\n}\n",
        "linevul": 5.8125016948906705e-05
    },
    {
        "code": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n{\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->dma_left = 0;\n        s->dma_counter = 0;\n        if (datalen > 0) {\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n        }\n        scsi_req_continue(s->current_req);\n    }\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n    esp_raise_irq(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=926cde5f3e4d2504ed161ed0cb771ac7cad6fd11",
        "vul_func_with_fix": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n{\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->dma_left = 0;\n        s->dma_counter = 0;\n        if (datalen > 0) {\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n        }\n        scsi_req_continue(s->current_req);\n    }\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n    esp_raise_irq(s);\n}\n",
        "linevul": 4.765491758007556e-05
    },
    {
        "code": "static void scoop_register_types(void)\n{\n    type_register_static(&scoop_sysbus_info);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=52f91c3723932f8340fe36c8ec8b18a757c37b2b",
        "vul_func_with_fix": "static void scoop_register_types(void)\n{\n    type_register_static(&scoop_sysbus_info);\n}\n",
        "linevul": 0.00017817443585954607
    },
    {
        "code": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n{\n    BlockDriverInfo bdi;\n    int ret;\n\n    ret = bdrv_get_info(bs, &bdi);\n    if (ret < 0 || bdi.cluster_size == 0) {\n        return bs->request_alignment;\n    } else {\n        return bdi.cluster_size;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static int bdrv_get_cluster_size(BlockDriverState *bs)\n{\n    BlockDriverInfo bdi;\n    int ret;\n\n    ret = bdrv_get_info(bs, &bdi);\n    if (ret < 0 || bdi.cluster_size == 0) {\n        return bs->request_alignment;\n    } else {\n        return bdi.cluster_size;\n    }\n}\n",
        "linevul": 5.6696226238273084e-05
    },
    {
        "code": "static void v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n    offset = 7;\n    err = pdu_marshal(pdu, offset, \"d\", total);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n    offset = 7;\n    err = pdu_marshal(pdu, offset, \"d\", total);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.00036018030368722975
    },
    {
        "code": "static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n{\n     int i;\n     VncDisplay *vd = ds->opaque;\n     struct VncSurface *s = &vd->guest;\n \n     h += y;\n \n       two 16-pixel blocks but we only mark the first as dirty\n    */\n    w += (x % 16);\n    x -= (x % 16);\n     w += (x % 16);\n     x -= (x % 16);\n \n    x = MIN(x, s->ds->width);\n    y = MIN(y, s->ds->height);\n    w = MIN(x + w, s->ds->width) - x;\n    h = MIN(h, s->ds->height);\n \n     for (; y < h; y++)\n         for (i = 0; i < w; i += 16)\n\nvoid vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n\nvoid buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n\nint buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n\nuint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n\nvoid buffer_reset(Buffer *buffer)\n{\n        buffer->offset = 0;\n}\n\nvoid buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n\nvoid buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n\nstatic void vnc_desktop_resize(VncState *vs)\n{\n    DisplayState *ds = vs->ds;\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == ds_get_width(ds) &&\n        vs->client_height == ds_get_height(ds)) {\n        return;\n    }\n    vs->client_width = ds_get_width(ds);\n    vs->client_height = ds_get_height(ds);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n{\n     int i;\n     VncDisplay *vd = ds->opaque;\n     struct VncSurface *s = &vd->guest;\n//fix_flaw_line_below:\n//    int width = ds_get_width(ds);\n//fix_flaw_line_below:\n//    int height = ds_get_height(ds);\n \n     h += y;\n \n       two 16-pixel blocks but we only mark the first as dirty\n    */\n    w += (x % 16);\n    x -= (x % 16);\n     w += (x % 16);\n     x -= (x % 16);\n \n//flaw_line_below:\n    x = MIN(x, s->ds->width);\n//flaw_line_below:\n    y = MIN(y, s->ds->height);\n//flaw_line_below:\n    w = MIN(x + w, s->ds->width) - x;\n//flaw_line_below:\n    h = MIN(h, s->ds->height);\n//fix_flaw_line_below:\n//    x = MIN(x, width);\n//fix_flaw_line_below:\n//    y = MIN(y, height);\n//fix_flaw_line_below:\n//    w = MIN(x + w, width) - x;\n//fix_flaw_line_below:\n//    h = MIN(h, height);\n \n     for (; y < h; y++)\n         for (i = 0; i < w; i += 16)\n\nvoid vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n\nvoid buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n\nint buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n\nuint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n\nvoid buffer_reset(Buffer *buffer)\n{\n        buffer->offset = 0;\n}\n\nvoid buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n\nvoid buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n\nstatic void vnc_desktop_resize(VncState *vs)\n{\n    DisplayState *ds = vs->ds;\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == ds_get_width(ds) &&\n        vs->client_height == ds_get_height(ds)) {\n        return;\n    }\n    vs->client_width = ds_get_width(ds);\n    vs->client_height = ds_get_height(ds);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n     }\n",
        "linevul": 0.9993447661399841
    },
    {
        "code": "static void mptsas_update_interrupt(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    uint32_t state = s->intr_status & ~(s->intr_mask | MPI_HIS_IOP_DOORBELL_STATUS);\n\n    if (msi_enabled(pci)) {\n        if (state) {\n            trace_mptsas_irq_msi(s);\n            msi_notify(pci, 0);\n        }\n    }\n\n    trace_mptsas_irq_intx(s, !!state);\n    pci_set_irq(pci, !!state);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static void mptsas_update_interrupt(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    uint32_t state = s->intr_status & ~(s->intr_mask | MPI_HIS_IOP_DOORBELL_STATUS);\n\n    if (msi_enabled(pci)) {\n        if (state) {\n            trace_mptsas_irq_msi(s);\n            msi_notify(pci, 0);\n        }\n    }\n\n    trace_mptsas_irq_intx(s, !!state);\n    pci_set_irq(pci, !!state);\n}\n",
        "linevul": 4.631114279618487e-05
    },
    {
        "code": "static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        l3_hdr->iov_base = g_malloc(ETH_MAX_IP4_HDR_LEN);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n         }\n \n         l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n         pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n \n         /* copy optional IPv4 header data */\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n        break;\n\n    case ETH_P_IPV6:\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                               &pkt->l4proto, &full_ip6hdr_len)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_base = g_malloc(full_ip6hdr_len);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=93060258ae748573ca7197204125a2670047896d",
        "vul_func_with_fix": "static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        l3_hdr->iov_base = g_malloc(ETH_MAX_IP4_HDR_LEN);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n         }\n \n         l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n//fix_flaw_line_below:\n//        if(l3_hdr->iov_len < sizeof(struct ip_header))\n//fix_flaw_line_below:\n//        {\n//fix_flaw_line_below:\n//            l3_hdr->iov_len = 0;\n//fix_flaw_line_below:\n//            return false;\n//fix_flaw_line_below:\n//        }\n         pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n \n         /* copy optional IPv4 header data */\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n        break;\n\n    case ETH_P_IPV6:\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                               &pkt->l4proto, &full_ip6hdr_len)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_base = g_malloc(full_ip6hdr_len);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n",
        "linevul": 9.168063843389973e-05
    },
    {
        "code": "tight_detect_smooth_image(VncState *vs, int w, int h)\n{\n    unsigned int errors;\n    int compression = vs->tight.compression;\n    int quality = vs->tight.quality;\n\n    if (!vs->vd->lossy) {\n        return 0;\n     }\n \n     if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n        vs->clientds.pf.bytes_per_pixel == 1 ||\n         w < VNC_TIGHT_DETECT_MIN_WIDTH || h < VNC_TIGHT_DETECT_MIN_HEIGHT) {\n         return 0;\n     }\n\n    if (vs->tight.quality != (uint8_t)-1) {\n        if (w * h < VNC_TIGHT_JPEG_MIN_RECT_SIZE) {\n            return 0;\n        }\n    } else {\n        if (w * h < tight_conf[compression].gradient_min_rect_size) {\n            return 0;\n         }\n     }\n \n    if (vs->clientds.pf.bytes_per_pixel == 4) {\n         if (vs->tight.pixel24) {\n             errors = tight_detect_smooth_image24(vs, w, h);\n             if (vs->tight.quality != (uint8_t)-1) {\n                return (errors < tight_conf[quality].jpeg_threshold24);\n            }\n            return (errors < tight_conf[compression].gradient_threshold24);\n        } else {\n            errors = tight_detect_smooth_image32(vs, w, h);\n        }\n    } else {\n        errors = tight_detect_smooth_image16(vs, w, h);\n    }\n    if (quality != -1) {\n        return (errors < tight_conf[quality].jpeg_threshold);\n    }\n    return (errors < tight_conf[compression].gradient_threshold);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "tight_detect_smooth_image(VncState *vs, int w, int h)\n{\n    unsigned int errors;\n    int compression = vs->tight.compression;\n    int quality = vs->tight.quality;\n\n    if (!vs->vd->lossy) {\n        return 0;\n     }\n \n     if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n//flaw_line_below:\n        vs->clientds.pf.bytes_per_pixel == 1 ||\n//fix_flaw_line_below:\n//        vs->client_pf.bytes_per_pixel == 1 ||\n         w < VNC_TIGHT_DETECT_MIN_WIDTH || h < VNC_TIGHT_DETECT_MIN_HEIGHT) {\n         return 0;\n     }\n\n    if (vs->tight.quality != (uint8_t)-1) {\n        if (w * h < VNC_TIGHT_JPEG_MIN_RECT_SIZE) {\n            return 0;\n        }\n    } else {\n        if (w * h < tight_conf[compression].gradient_min_rect_size) {\n            return 0;\n         }\n     }\n \n//flaw_line_below:\n    if (vs->clientds.pf.bytes_per_pixel == 4) {\n//fix_flaw_line_below:\n//    if (vs->client_pf.bytes_per_pixel == 4) {\n         if (vs->tight.pixel24) {\n             errors = tight_detect_smooth_image24(vs, w, h);\n             if (vs->tight.quality != (uint8_t)-1) {\n                return (errors < tight_conf[quality].jpeg_threshold24);\n            }\n            return (errors < tight_conf[compression].gradient_threshold24);\n        } else {\n            errors = tight_detect_smooth_image32(vs, w, h);\n        }\n    } else {\n        errors = tight_detect_smooth_image16(vs, w, h);\n    }\n    if (quality != -1) {\n        return (errors < tight_conf[quality].jpeg_threshold);\n    }\n    return (errors < tight_conf[compression].gradient_threshold);\n}\n",
        "linevul": 0.9978833794593811
    },
    {
        "code": "static void scsi_cancel_io(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n    if (r->req.aiocb) {\n        bdrv_aio_cancel(r->req.aiocb);\n    }\n     r->req.aiocb = NULL;\n }\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": "static void scsi_cancel_io(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n    if (r->req.aiocb) {\n        bdrv_aio_cancel(r->req.aiocb);\n    }\n     r->req.aiocb = NULL;\n }\n",
        "linevul": 5.2449715440161526e-05
    },
    {
        "code": "static void vmxnet3_put_ring_to_file(QEMUFile *f, Vmxnet3Ring *r)\n{\n    qemu_put_be64(f, r->pa);\n    qemu_put_be32(f, r->size);\n    qemu_put_be32(f, r->cell_size);\n    qemu_put_be32(f, r->next);\n    qemu_put_byte(f, r->gen);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_put_ring_to_file(QEMUFile *f, Vmxnet3Ring *r)\n{\n    qemu_put_be64(f, r->pa);\n    qemu_put_be32(f, r->size);\n    qemu_put_be32(f, r->cell_size);\n    qemu_put_be32(f, r->next);\n    qemu_put_byte(f, r->gen);\n}\n",
        "linevul": 6.151917477836832e-05
    },
    {
        "code": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = pixman_image_get_width(vs->vd->server);\n    int height = pixman_image_get_height(vs->vd->server);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = pixman_image_get_width(vs->vd->server);\n    int height = pixman_image_get_height(vs->vd->server);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}\n",
        "linevul": 5.5479249567724764e-05
    },
    {
        "code": "static BlockAIOCB *iscsi_aio_ioctl(BlockDriverState *bs,\n        unsigned long int req, void *buf,\n        BlockCompletionFunc *cb, void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n    struct iscsi_data data;\n    IscsiAIOCB *acb;\n\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n\n    acb->iscsilun = iscsilun;\n    acb->bh          = NULL;\n    acb->status      = -EINPROGRESS;\n    acb->buf         = NULL;\n    acb->ioh         = buf;\n\n    if (req != SG_IO) {\n        iscsi_ioctl_handle_emulated(acb, req, buf);\n         return &acb->common;\n     }\n \n     acb->task = malloc(sizeof(struct scsi_task));\n     if (acb->task == NULL) {\n         error_report(\"iSCSI: Failed to allocate task for scsi command. %s\",\n    case SG_DXFER_TO_DEV:\n        acb->task->xfer_dir = SCSI_XFER_WRITE;\n        break;\n    case SG_DXFER_FROM_DEV:\n        acb->task->xfer_dir = SCSI_XFER_READ;\n        break;\n    default:\n        acb->task->xfer_dir = SCSI_XFER_NONE;\n        break;\n    }\n\n    acb->task->cdb_size = acb->ioh->cmd_len;\n    memcpy(&acb->task->cdb[0], acb->ioh->cmdp, acb->ioh->cmd_len);\n    acb->task->expxferlen = acb->ioh->dxfer_len;\n\n    data.size = 0;\n    if (acb->task->xfer_dir == SCSI_XFER_WRITE) {\n        if (acb->ioh->iovec_count == 0) {\n            data.data = acb->ioh->dxferp;\n            data.size = acb->ioh->dxfer_len;\n        } else {\n            scsi_task_set_iov_out(acb->task,\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n                                 acb->ioh->iovec_count);\n        }\n    }\n\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n                                 iscsi_aio_ioctl_cb,\n                                 (data.size > 0) ? &data : NULL,\n                                 acb) != 0) {\n        scsi_free_scsi_task(acb->task);\n        qemu_aio_unref(acb);\n        return NULL;\n    }\n\n    /* tell libiscsi to read straight into the buffer we got from ioctl */\n    if (acb->task->xfer_dir == SCSI_XFER_READ) {\n        if (acb->ioh->iovec_count == 0) {\n            scsi_task_add_data_in_buffer(acb->task,\n                                         acb->ioh->dxfer_len,\n                                         acb->ioh->dxferp);\n        } else {\n            scsi_task_set_iov_in(acb->task,\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n                                 acb->ioh->iovec_count);\n        }\n    }\n\n    iscsi_set_events(iscsilun);\n\n    return &acb->common;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static BlockAIOCB *iscsi_aio_ioctl(BlockDriverState *bs,\n        unsigned long int req, void *buf,\n        BlockCompletionFunc *cb, void *opaque)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n    struct iscsi_data data;\n    IscsiAIOCB *acb;\n\n    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n\n    acb->iscsilun = iscsilun;\n    acb->bh          = NULL;\n    acb->status      = -EINPROGRESS;\n    acb->buf         = NULL;\n    acb->ioh         = buf;\n\n    if (req != SG_IO) {\n        iscsi_ioctl_handle_emulated(acb, req, buf);\n         return &acb->common;\n     }\n \n//fix_flaw_line_below:\n//    if (acb->ioh->cmd_len > SCSI_CDB_MAX_SIZE) {\n//fix_flaw_line_below:\n//        error_report(\"iSCSI: ioctl error CDB exceeds max size (%d > %d)\",\n//fix_flaw_line_below:\n//                     acb->ioh->cmd_len, SCSI_CDB_MAX_SIZE);\n//fix_flaw_line_below:\n//        qemu_aio_unref(acb);\n//fix_flaw_line_below:\n//        return NULL;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     acb->task = malloc(sizeof(struct scsi_task));\n     if (acb->task == NULL) {\n         error_report(\"iSCSI: Failed to allocate task for scsi command. %s\",\n    case SG_DXFER_TO_DEV:\n        acb->task->xfer_dir = SCSI_XFER_WRITE;\n        break;\n    case SG_DXFER_FROM_DEV:\n        acb->task->xfer_dir = SCSI_XFER_READ;\n        break;\n    default:\n        acb->task->xfer_dir = SCSI_XFER_NONE;\n        break;\n    }\n\n    acb->task->cdb_size = acb->ioh->cmd_len;\n    memcpy(&acb->task->cdb[0], acb->ioh->cmdp, acb->ioh->cmd_len);\n    acb->task->expxferlen = acb->ioh->dxfer_len;\n\n    data.size = 0;\n    if (acb->task->xfer_dir == SCSI_XFER_WRITE) {\n        if (acb->ioh->iovec_count == 0) {\n            data.data = acb->ioh->dxferp;\n            data.size = acb->ioh->dxfer_len;\n        } else {\n            scsi_task_set_iov_out(acb->task,\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n                                 acb->ioh->iovec_count);\n        }\n    }\n\n    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,\n                                 iscsi_aio_ioctl_cb,\n                                 (data.size > 0) ? &data : NULL,\n                                 acb) != 0) {\n        scsi_free_scsi_task(acb->task);\n        qemu_aio_unref(acb);\n        return NULL;\n    }\n\n    /* tell libiscsi to read straight into the buffer we got from ioctl */\n    if (acb->task->xfer_dir == SCSI_XFER_READ) {\n        if (acb->ioh->iovec_count == 0) {\n            scsi_task_add_data_in_buffer(acb->task,\n                                         acb->ioh->dxfer_len,\n                                         acb->ioh->dxferp);\n        } else {\n            scsi_task_set_iov_in(acb->task,\n                                 (struct scsi_iovec *) acb->ioh->dxferp,\n                                 acb->ioh->iovec_count);\n        }\n    }\n\n    iscsi_set_events(iscsilun);\n\n    return &acb->common;\n}\n",
        "linevul": 0.00013491993013303727
    },
    {
        "code": "static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    dma_addr_t iov_pa, iov_size;\n\n    cmd->flags = le16_to_cpu(cmd->frame->header.flags);\n    if (!cmd->frame->header.sge_count) {\n        trace_megasas_dcmd_zero_sge(cmd->index);\n        cmd->iov_size = 0;\n        return 0;\n    } else if (cmd->frame->header.sge_count > 1) {\n        trace_megasas_dcmd_invalid_sge(cmd->index,\n                                       cmd->frame->header.sge_count);\n        cmd->iov_size = 0;\n        return -1;\n    }\n    iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);\n    iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);\n    pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);\n    qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);\n    cmd->iov_size = iov_size;\n    return cmd->iov_size;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    dma_addr_t iov_pa, iov_size;\n\n    cmd->flags = le16_to_cpu(cmd->frame->header.flags);\n    if (!cmd->frame->header.sge_count) {\n        trace_megasas_dcmd_zero_sge(cmd->index);\n        cmd->iov_size = 0;\n        return 0;\n    } else if (cmd->frame->header.sge_count > 1) {\n        trace_megasas_dcmd_invalid_sge(cmd->index,\n                                       cmd->frame->header.sge_count);\n        cmd->iov_size = 0;\n        return -1;\n    }\n    iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);\n    iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);\n    pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);\n    qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);\n    cmd->iov_size = iov_size;\n    return cmd->iov_size;\n}\n",
        "linevul": 7.126695709303021e-05
    },
    {
        "code": "static inline void pcnet_tmd_load(PCNetState *s, struct pcnet_TMD *tmd,\n                                  hwaddr addr)\n{\n    if (!BCR_SSIZE32(s)) {\n        struct {\n            uint32_t tbadr;\n            int16_t length;\n            int16_t status;\n\t} xda;\n        s->phys_mem_read(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);\n        tmd->tbadr = le32_to_cpu(xda.tbadr) & 0xffffff;\n        tmd->length = le16_to_cpu(xda.length);\n        tmd->status = (le32_to_cpu(xda.tbadr) >> 16) & 0xff00;\n        tmd->misc = le16_to_cpu(xda.status) << 16;\n        tmd->res = 0;\n    } else {\n        s->phys_mem_read(s->dma_opaque, addr, (void *)tmd, sizeof(*tmd), 0);\n        le32_to_cpus(&tmd->tbadr);\n        le16_to_cpus((uint16_t *)&tmd->length);\n        le16_to_cpus((uint16_t *)&tmd->status);\n        le32_to_cpus(&tmd->misc);\n        le32_to_cpus(&tmd->res);\n        if (BCR_SWSTYLE(s) == 3) {\n            uint32_t tmp = tmd->tbadr;\n            tmd->tbadr = tmd->misc;\n            tmd->misc = tmp;\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8b98a2f07175d46c3f7217639bd5e03f",
        "vul_func_with_fix": "static inline void pcnet_tmd_load(PCNetState *s, struct pcnet_TMD *tmd,\n                                  hwaddr addr)\n{\n    if (!BCR_SSIZE32(s)) {\n        struct {\n            uint32_t tbadr;\n            int16_t length;\n            int16_t status;\n\t} xda;\n        s->phys_mem_read(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);\n        tmd->tbadr = le32_to_cpu(xda.tbadr) & 0xffffff;\n        tmd->length = le16_to_cpu(xda.length);\n        tmd->status = (le32_to_cpu(xda.tbadr) >> 16) & 0xff00;\n        tmd->misc = le16_to_cpu(xda.status) << 16;\n        tmd->res = 0;\n    } else {\n        s->phys_mem_read(s->dma_opaque, addr, (void *)tmd, sizeof(*tmd), 0);\n        le32_to_cpus(&tmd->tbadr);\n        le16_to_cpus((uint16_t *)&tmd->length);\n        le16_to_cpus((uint16_t *)&tmd->status);\n        le32_to_cpus(&tmd->misc);\n        le32_to_cpus(&tmd->res);\n        if (BCR_SWSTYLE(s) == 3) {\n            uint32_t tmp = tmd->tbadr;\n            tmd->tbadr = tmd->misc;\n            tmd->misc = tmp;\n        }\n    }\n}\n",
        "linevul": 0.00027367626898922026
    },
    {
        "code": "static void serial_update_parameters(SerialState *s)\n{\n     int speed, parity, data_bits, stop_bits, frame_size;\n     QEMUSerialSetParams ssp;\n \n    if (s->divider == 0)\n         return;\n \n     /* Start bit. */\n     frame_size = 1;\n        /* Parity bit. */\n        frame_size++;\n        if (s->lcr & 0x10)\n            parity = 'E';\n        else\n            parity = 'O';\n    } else {\n            parity = 'N';\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3592fe0c919cf27a81d8e9f9b4f269553418bb01",
        "vul_func_with_fix": "static void serial_update_parameters(SerialState *s)\n{\n     int speed, parity, data_bits, stop_bits, frame_size;\n     QEMUSerialSetParams ssp;\n \n//flaw_line_below:\n    if (s->divider == 0)\n//fix_flaw_line_below:\n//    if (s->divider == 0 || s->divider > s->baudbase) {\n         return;\n//fix_flaw_line_below:\n//    }\n \n     /* Start bit. */\n     frame_size = 1;\n        /* Parity bit. */\n        frame_size++;\n        if (s->lcr & 0x10)\n            parity = 'E';\n        else\n            parity = 'O';\n    } else {\n            parity = 'N';\n    }\n",
        "linevul": 0.9987252354621887
    },
    {
        "code": "static void xhci_msix_update(XHCIState *xhci, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    bool enabled;\n\n    if (!msix_enabled(pci_dev)) {\n        return;\n    }\n\n    enabled = xhci->intr[v].iman & IMAN_IE;\n    if (enabled == xhci->intr[v].msix_used) {\n        return;\n    }\n\n    if (enabled) {\n        trace_usb_xhci_irq_msix_use(v);\n        msix_vector_use(pci_dev, v);\n        xhci->intr[v].msix_used = true;\n    } else {\n        trace_usb_xhci_irq_msix_unuse(v);\n        msix_vector_unuse(pci_dev, v);\n        xhci->intr[v].msix_used = false;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_msix_update(XHCIState *xhci, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    bool enabled;\n\n    if (!msix_enabled(pci_dev)) {\n        return;\n    }\n\n    enabled = xhci->intr[v].iman & IMAN_IE;\n    if (enabled == xhci->intr[v].msix_used) {\n        return;\n    }\n\n    if (enabled) {\n        trace_usb_xhci_irq_msix_use(v);\n        msix_vector_use(pci_dev, v);\n        xhci->intr[v].msix_used = true;\n    } else {\n        trace_usb_xhci_irq_msix_unuse(v);\n        msix_vector_unuse(pci_dev, v);\n        xhci->intr[v].msix_used = false;\n    }\n}\n",
        "linevul": 4.649904803954996e-05
    },
    {
        "code": "static int find_image_format(BlockDriverState *bs, const char *filename,\n                             BlockDriver **pdrv, Error **errp)\n{\n    int score, score_max;\n    BlockDriver *drv1, *drv;\n    uint8_t buf[2048];\n    int ret = 0;\n\n    /* Return the raw BlockDriver * to scsi-generic devices or empty drives */\n    if (bs->sg || !bdrv_is_inserted(bs) || bdrv_getlength(bs) == 0) {\n        drv = bdrv_find_format(\"raw\");\n        if (!drv) {\n            error_setg(errp, \"Could not find raw image format\");\n            ret = -ENOENT;\n        }\n        *pdrv = drv;\n        return ret;\n    }\n\n    ret = bdrv_pread(bs, 0, buf, sizeof(buf));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read image for determining its \"\n                         \"format\");\n        *pdrv = NULL;\n        return ret;\n    }\n\n    score_max = 0;\n    drv = NULL;\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n        if (drv1->bdrv_probe) {\n            score = drv1->bdrv_probe(buf, ret, filename);\n            if (score > score_max) {\n                score_max = score;\n                drv = drv1;\n            }\n        }\n    }\n    if (!drv) {\n        error_setg(errp, \"Could not determine image format: No compatible \"\n                   \"driver found\");\n        ret = -ENOENT;\n    }\n    *pdrv = drv;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static int find_image_format(BlockDriverState *bs, const char *filename,\n                             BlockDriver **pdrv, Error **errp)\n{\n    int score, score_max;\n    BlockDriver *drv1, *drv;\n    uint8_t buf[2048];\n    int ret = 0;\n\n    /* Return the raw BlockDriver * to scsi-generic devices or empty drives */\n    if (bs->sg || !bdrv_is_inserted(bs) || bdrv_getlength(bs) == 0) {\n        drv = bdrv_find_format(\"raw\");\n        if (!drv) {\n            error_setg(errp, \"Could not find raw image format\");\n            ret = -ENOENT;\n        }\n        *pdrv = drv;\n        return ret;\n    }\n\n    ret = bdrv_pread(bs, 0, buf, sizeof(buf));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read image for determining its \"\n                         \"format\");\n        *pdrv = NULL;\n        return ret;\n    }\n\n    score_max = 0;\n    drv = NULL;\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n        if (drv1->bdrv_probe) {\n            score = drv1->bdrv_probe(buf, ret, filename);\n            if (score > score_max) {\n                score_max = score;\n                drv = drv1;\n            }\n        }\n    }\n    if (!drv) {\n        error_setg(errp, \"Could not determine image format: No compatible \"\n                   \"driver found\");\n        ret = -ENOENT;\n    }\n    *pdrv = drv;\n    return ret;\n}\n",
        "linevul": 6.418303382815793e-05
    },
    {
        "code": "static void ne2000_register_types(void)\n{\n    type_register_static(&ne2000_info);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static void ne2000_register_types(void)\n{\n    type_register_static(&ne2000_info);\n}\n",
        "linevul": 0.00010398184531368315
    },
    {
        "code": "static int find_snapshot_by_id_or_name(BlockDriverState *bs,\n                                       const char *id_or_name)\n{\n    int ret;\n\n    ret = find_snapshot_by_id_and_name(bs, id_or_name, NULL);\n    if (ret >= 0) {\n        return ret;\n    }\n    return find_snapshot_by_id_and_name(bs, NULL, id_or_name);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c05e4667be91b46ab42b5a11babf8e84d476cc6b",
        "vul_func_with_fix": "static int find_snapshot_by_id_or_name(BlockDriverState *bs,\n                                       const char *id_or_name)\n{\n    int ret;\n\n    ret = find_snapshot_by_id_and_name(bs, id_or_name, NULL);\n    if (ret >= 0) {\n        return ret;\n    }\n    return find_snapshot_by_id_and_name(bs, NULL, id_or_name);\n}\n",
        "linevul": 5.423032780527137e-05
    },
    {
        "code": "static int get_dotl_openflags(V9fsState *s, int oflags)\n{\n    int flags;\n    /*\n     * Filter the client open flags\n     */\n    flags = dotl_to_open_flags(oflags);\n    flags &= ~(O_NOCTTY | O_ASYNC | O_CREAT);\n    /*\n     * Ignore direct disk access hint until the server supports it.\n     */\n    flags &= ~O_DIRECT;\n    return flags;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int get_dotl_openflags(V9fsState *s, int oflags)\n{\n    int flags;\n    /*\n     * Filter the client open flags\n     */\n    flags = dotl_to_open_flags(oflags);\n    flags &= ~(O_NOCTTY | O_ASYNC | O_CREAT);\n    /*\n     * Ignore direct disk access hint until the server supports it.\n     */\n    flags &= ~O_DIRECT;\n    return flags;\n}\n",
        "linevul": 7.742926391074434e-05
    },
    {
        "code": "static void put_extra_state(QEMUFile *f, void *pv, size_t size)\n{\n    VirtIODevice *vdev = pv;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    k->save_extra_state(qbus->parent, f);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void put_extra_state(QEMUFile *f, void *pv, size_t size)\n{\n    VirtIODevice *vdev = pv;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    k->save_extra_state(qbus->parent, f);\n}\n",
        "linevul": 4.9902821046998724e-05
    },
    {
        "code": "static ssize_t pdu_marshal(V9fsPDU *pdu, size_t offset, const char *fmt, ...)\n{\n    ssize_t ret;\n    va_list ap;\n\n    va_start(ap, fmt);\n    ret = pdu->s->transport->pdu_vmarshal(pdu, offset, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static ssize_t pdu_marshal(V9fsPDU *pdu, size_t offset, const char *fmt, ...)\n{\n    ssize_t ret;\n    va_list ap;\n\n    va_start(ap, fmt);\n    ret = pdu->s->transport->pdu_vmarshal(pdu, offset, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n",
        "linevul": 7.589549204567447e-05
    },
    {
        "code": "static int coroutine_fn v9fs_complete_renameat(V9fsPDU *pdu, int32_t olddirfid,\n                                               V9fsString *old_name,\n                                               int32_t newdirfid,\n                                               V9fsString *new_name)\n{\n    int err = 0;\n    V9fsState *s = pdu->s;\n    V9fsFidState *newdirfidp = NULL, *olddirfidp = NULL;\n\n    olddirfidp = get_fid(pdu, olddirfid);\n    if (olddirfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    if (newdirfid != -1) {\n        newdirfidp = get_fid(pdu, newdirfid);\n        if (newdirfidp == NULL) {\n            err = -ENOENT;\n            goto out;\n        }\n    } else {\n        newdirfidp = get_fid(pdu, olddirfid);\n    }\n\n    err = v9fs_co_renameat(pdu, &olddirfidp->path, old_name,\n                           &newdirfidp->path, new_name);\n    if (err < 0) {\n        goto out;\n    }\n    if (s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT) {\n        /* Only for path based fid  we need to do the below fixup */\n        err = v9fs_fix_fid_paths(pdu, &olddirfidp->path, old_name,\n                                 &newdirfidp->path, new_name);\n    }\nout:\n    if (olddirfidp) {\n        put_fid(pdu, olddirfidp);\n    }\n    if (newdirfidp) {\n        put_fid(pdu, newdirfidp);\n    }\n    return err;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn v9fs_complete_renameat(V9fsPDU *pdu, int32_t olddirfid,\n                                               V9fsString *old_name,\n                                               int32_t newdirfid,\n                                               V9fsString *new_name)\n{\n    int err = 0;\n    V9fsState *s = pdu->s;\n    V9fsFidState *newdirfidp = NULL, *olddirfidp = NULL;\n\n    olddirfidp = get_fid(pdu, olddirfid);\n    if (olddirfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    if (newdirfid != -1) {\n        newdirfidp = get_fid(pdu, newdirfid);\n        if (newdirfidp == NULL) {\n            err = -ENOENT;\n            goto out;\n        }\n    } else {\n        newdirfidp = get_fid(pdu, olddirfid);\n    }\n\n    err = v9fs_co_renameat(pdu, &olddirfidp->path, old_name,\n                           &newdirfidp->path, new_name);\n    if (err < 0) {\n        goto out;\n    }\n    if (s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT) {\n        /* Only for path based fid  we need to do the below fixup */\n        err = v9fs_fix_fid_paths(pdu, &olddirfidp->path, old_name,\n                                 &newdirfidp->path, new_name);\n    }\nout:\n    if (olddirfidp) {\n        put_fid(pdu, olddirfidp);\n    }\n    if (newdirfidp) {\n        put_fid(pdu, newdirfidp);\n    }\n    return err;\n}\n",
        "linevul": 0.00010597567597869784
    },
    {
        "code": "static int send_full_color_rect(VncState *vs, int x, int y, int w, int h)\n{\n    int stream = 0;\n    ssize_t bytes;\n\n#ifdef CONFIG_VNC_PNG\n    if (tight_can_send_png_rect(vs, w, h)) {\n        return send_png_rect(vs, x, y, w, h, NULL);\n    }\n#endif\n         tight_pack24(vs, vs->tight.tight.buffer, w * h, &vs->tight.tight.offset);\n         bytes = 3;\n     } else {\n        bytes = vs->clientds.pf.bytes_per_pixel;\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static int send_full_color_rect(VncState *vs, int x, int y, int w, int h)\n{\n    int stream = 0;\n    ssize_t bytes;\n\n#ifdef CONFIG_VNC_PNG\n    if (tight_can_send_png_rect(vs, w, h)) {\n        return send_png_rect(vs, x, y, w, h, NULL);\n    }\n#endif\n         tight_pack24(vs, vs->tight.tight.buffer, w * h, &vs->tight.tight.offset);\n         bytes = 3;\n     } else {\n//flaw_line_below:\n        bytes = vs->clientds.pf.bytes_per_pixel;\n//fix_flaw_line_below:\n//        bytes = vs->client_pf.bytes_per_pixel;\n     }\n",
        "linevul": 0.001466836896724999
    },
    {
        "code": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n     /* First allocate space in qemu for device tree */\n     fdt = g_malloc0(dt_size);\n \n    dt_file_load_size = load_image(filename_path, fdt);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=da885fe1ee8b4589047484bd7fa05a4905b52b17",
        "vul_func_with_fix": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n     /* First allocate space in qemu for device tree */\n     fdt = g_malloc0(dt_size);\n \n//flaw_line_below:\n    dt_file_load_size = load_image(filename_path, fdt);\n//fix_flaw_line_below:\n//    dt_file_load_size = load_image_size(filename_path, fdt, dt_size);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n",
        "linevul": 0.0031403943430632353
    },
    {
        "code": "static int vapic_prepare(VAPICROMState *s)\n{\n    if (vapic_map_rom_writable(s) < 0) {\n        return -1;\n    }\n\n    if (patch_hypercalls(s) < 0) {\n        return -1;\n    }\n\n    vapic_enable_tpr_reporting(true);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static int vapic_prepare(VAPICROMState *s)\n{\n    if (vapic_map_rom_writable(s) < 0) {\n        return -1;\n    }\n\n    if (patch_hypercalls(s) < 0) {\n        return -1;\n    }\n\n    vapic_enable_tpr_reporting(true);\n\n    return 0;\n}\n",
        "linevul": 5.328351107891649e-05
    },
    {
        "code": "static int parallels_read(BlockDriverState *bs, int64_t sector_num,\n                    uint8_t *buf, int nb_sectors)\n{\n    while (nb_sectors > 0) {\n        int64_t position = seek_to_sector(bs, sector_num);\n        if (position >= 0) {\n            if (bdrv_pread(bs->file, position, buf, 512) != 512)\n                return -1;\n        } else {\n            memset(buf, 0, 512);\n        }\n        nb_sectors--;\n        sector_num++;\n        buf += 512;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=afbcc40bee4ef51731102d7d4b499ee12fc182e1",
        "vul_func_with_fix": "static int parallels_read(BlockDriverState *bs, int64_t sector_num,\n                    uint8_t *buf, int nb_sectors)\n{\n    while (nb_sectors > 0) {\n        int64_t position = seek_to_sector(bs, sector_num);\n        if (position >= 0) {\n            if (bdrv_pread(bs->file, position, buf, 512) != 512)\n                return -1;\n        } else {\n            memset(buf, 0, 512);\n        }\n        nb_sectors--;\n        sector_num++;\n        buf += 512;\n    }\n    return 0;\n}\n",
        "linevul": 0.0003251306770835072
    },
    {
        "code": "uint64_t ram_bytes_remaining(void)\n{\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "uint64_t ram_bytes_remaining(void)\n{\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n}\n",
        "linevul": 0.00018369346798863262
    },
    {
        "code": "static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)\n{\n    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);\n     info->num_memslots = NUM_MEMSLOTS;\n     info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;\n     info->internal_groupslot_id = 0;\n    info->qxl_ram_size = ssd->bufsize;\n     info->n_surfaces = ssd->num_surfaces;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)\n{\n    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);\n     info->num_memslots = NUM_MEMSLOTS;\n     info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;\n     info->internal_groupslot_id = 0;\n//flaw_line_below:\n    info->qxl_ram_size = ssd->bufsize;\n//fix_flaw_line_below:\n//    info->qxl_ram_size = 16 * 1024 * 1024;\n     info->n_surfaces = ssd->num_surfaces;\n }\n",
        "linevul": 0.002524701878428459
    },
    {
        "code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "linevul": 0.00017687090439721942
    },
    {
        "code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n    trace_esp_mem_readb(saddr, s->rregs[saddr]);\n    switch (saddr) {\n    case ESP_FIFO:\n        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n            /* Data out.  */\n            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n            s->rregs[ESP_FIFO] = 0;\n            esp_raise_irq(s);\n        } else if (s->ti_rptr < s->ti_wptr) {\n            s->ti_size--;\n            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            esp_raise_irq(s);\n        }\n        if (s->ti_rptr == s->ti_wptr) {\n            s->ti_rptr = 0;\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n    return s->rregs[saddr];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n    trace_esp_mem_readb(saddr, s->rregs[saddr]);\n    switch (saddr) {\n    case ESP_FIFO:\n        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n            /* Data out.  */\n            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n            s->rregs[ESP_FIFO] = 0;\n            esp_raise_irq(s);\n        } else if (s->ti_rptr < s->ti_wptr) {\n            s->ti_size--;\n            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            esp_raise_irq(s);\n        }\n        if (s->ti_rptr == s->ti_wptr) {\n            s->ti_rptr = 0;\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n    return s->rregs[saddr];\n}\n",
        "linevul": 5.30669822182972e-05
    },
    {
        "code": "static bool cmd_data_set_management(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case DSM_TRIM:\n        if (s->blk) {\n            ide_sector_start_dma(s, IDE_DMA_TRIM);\n            return false;\n        }\n        break;\n    }\n\n    ide_abort_command(s);\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_data_set_management(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case DSM_TRIM:\n        if (s->blk) {\n            ide_sector_start_dma(s, IDE_DMA_TRIM);\n            return false;\n        }\n        break;\n    }\n\n    ide_abort_command(s);\n    return true;\n}\n",
        "linevul": 4.6138171455822885e-05
    },
    {
        "code": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n                                          hwaddr addr,\n                                          unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    /* XXX handle bitblt */\n    (void)s;\n    ret = 0xff;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n                                          hwaddr addr,\n                                          unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    /* XXX handle bitblt */\n    (void)s;\n    ret = 0xff;\n    return ret;\n}\n",
        "linevul": 4.506087861955166e-05
    },
    {
        "code": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n     if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n         trace_usb_ohci_iso_td_read_failed(addr);\n         ohci_die(ohci);\n        return 0;\n     }\n \n     starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n     if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n         trace_usb_ohci_iso_td_read_failed(addr);\n         ohci_die(ohci);\n//flaw_line_below:\n        return 0;\n//fix_flaw_line_below:\n//        return 1;\n     }\n \n     starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}\n",
        "linevul": 0.014845466241240501
    },
    {
        "code": "static inline int xhci_running(XHCIState *xhci)\n{\n    return !(xhci->usbsts & USBSTS_HCH) && !xhci->intr[0].er_full;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static inline int xhci_running(XHCIState *xhci)\n{\n    return !(xhci->usbsts & USBSTS_HCH) && !xhci->intr[0].er_full;\n}\n",
        "linevul": 5.302995123201981e-05
    },
    {
        "code": "size_t mptsas_config_manufacturing_10(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(10, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_manufacturing_10(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(10, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n",
        "linevul": 5.1793969760183245e-05
    },
    {
        "code": "static int ram_save_complete(QEMUFile *f, void *opaque)\n{\n    qemu_mutex_lock_ramlist();\n    migration_bitmap_sync();\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n    /* try transferring iterative blocks of memory */\n\n    /* flush all remaining blocks regardless of rate limiting */\n    while (true) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, true);\n        /* no more blocks to sent */\n        if (bytes_sent == 0) {\n            break;\n        }\n        bytes_transferred += bytes_sent;\n    }\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n    migration_end();\n\n    qemu_mutex_unlock_ramlist();\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static int ram_save_complete(QEMUFile *f, void *opaque)\n{\n    qemu_mutex_lock_ramlist();\n    migration_bitmap_sync();\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n    /* try transferring iterative blocks of memory */\n\n    /* flush all remaining blocks regardless of rate limiting */\n    while (true) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, true);\n        /* no more blocks to sent */\n        if (bytes_sent == 0) {\n            break;\n        }\n        bytes_transferred += bytes_sent;\n    }\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n    migration_end();\n\n    qemu_mutex_unlock_ramlist();\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n    return 0;\n}\n",
        "linevul": 5.163187233847566e-05
    },
    {
        "code": "uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)\n{\n    VGACommonState *s = opaque;\n    uint32_t val;\n\n    if (s->vbe_index < VBE_DISPI_INDEX_NB) {\n        if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_GETCAPS) {\n            switch(s->vbe_index) {\n                /* XXX: do not hardcode ? */\n            case VBE_DISPI_INDEX_XRES:\n                val = VBE_DISPI_MAX_XRES;\n                break;\n            case VBE_DISPI_INDEX_YRES:\n                val = VBE_DISPI_MAX_YRES;\n                break;\n            case VBE_DISPI_INDEX_BPP:\n                val = VBE_DISPI_MAX_BPP;\n                break;\n            default:\n                val = s->vbe_regs[s->vbe_index];\n                break;\n            }\n        } else {\n            val = s->vbe_regs[s->vbe_index];\n        }\n    } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {\n        val = s->vbe_size / (64 * 1024);\n    } else {\n        val = 0;\n    }\n    trace_vga_vbe_read(s->vbe_index, val);\n    return val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)\n{\n    VGACommonState *s = opaque;\n    uint32_t val;\n\n    if (s->vbe_index < VBE_DISPI_INDEX_NB) {\n        if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_GETCAPS) {\n            switch(s->vbe_index) {\n                /* XXX: do not hardcode ? */\n            case VBE_DISPI_INDEX_XRES:\n                val = VBE_DISPI_MAX_XRES;\n                break;\n            case VBE_DISPI_INDEX_YRES:\n                val = VBE_DISPI_MAX_YRES;\n                break;\n            case VBE_DISPI_INDEX_BPP:\n                val = VBE_DISPI_MAX_BPP;\n                break;\n            default:\n                val = s->vbe_regs[s->vbe_index];\n                break;\n            }\n        } else {\n            val = s->vbe_regs[s->vbe_index];\n        }\n    } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {\n        val = s->vbe_size / (64 * 1024);\n    } else {\n        val = 0;\n    }\n    trace_vga_vbe_read(s->vbe_index, val);\n    return val;\n}\n",
        "linevul": 5.961220813333057e-05
    },
    {
        "code": "static void mptsas_process_ioc_init(MPTSASState *s, MPIMsgIOCInit *req)\n{\n    MPIMsgIOCInitReply reply;\n\n    mptsas_fix_ioc_init_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    s->who_init               = req->WhoInit;\n    s->reply_frame_size       = req->ReplyFrameSize;\n    s->max_buses              = req->MaxBuses;\n    s->max_devices            = req->MaxDevices ? req->MaxDevices : 256;\n    s->host_mfa_high_addr     = (hwaddr)req->HostMfaHighAddr << 32;\n    s->sense_buffer_high_addr = (hwaddr)req->SenseBufferHighAddr << 32;\n\n    if (s->state == MPI_IOC_STATE_READY) {\n        s->state = MPI_IOC_STATE_OPERATIONAL;\n    }\n\n    memset(&reply, 0, sizeof(reply));\n    reply.WhoInit    = s->who_init;\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.MaxDevices = s->max_devices;\n    reply.MaxBuses   = s->max_buses;\n    reply.MsgContext = req->MsgContext;\n\n    mptsas_fix_ioc_init_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static void mptsas_process_ioc_init(MPTSASState *s, MPIMsgIOCInit *req)\n{\n    MPIMsgIOCInitReply reply;\n\n    mptsas_fix_ioc_init_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    s->who_init               = req->WhoInit;\n    s->reply_frame_size       = req->ReplyFrameSize;\n    s->max_buses              = req->MaxBuses;\n    s->max_devices            = req->MaxDevices ? req->MaxDevices : 256;\n    s->host_mfa_high_addr     = (hwaddr)req->HostMfaHighAddr << 32;\n    s->sense_buffer_high_addr = (hwaddr)req->SenseBufferHighAddr << 32;\n\n    if (s->state == MPI_IOC_STATE_READY) {\n        s->state = MPI_IOC_STATE_OPERATIONAL;\n    }\n\n    memset(&reply, 0, sizeof(reply));\n    reply.WhoInit    = s->who_init;\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.MaxDevices = s->max_devices;\n    reply.MaxBuses   = s->max_buses;\n    reply.MsgContext = req->MsgContext;\n\n    mptsas_fix_ioc_init_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n",
        "linevul": 4.970529334968887e-05
    },
    {
        "code": "static bool net_tx_pkt_parse_headers(struct NetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[NET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        l3_hdr->iov_len = 0;\n        pkt->packet_type = ETH_PKT_UCAST;\n        return false;\n    } else {\n        l2_hdr->iov_len = ETH_MAX_L2_HDR_LEN;\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n        pkt->packet_type = get_eth_packet_type(l2_hdr->iov_base);\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr, 1, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n\n        if (l3_hdr->iov_len < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        if (IP_HDR_GET_LEN(l3_hdr->iov_base) != sizeof(struct ip_header)) {\n            /* copy optional IPv4 header data if any*/\n            bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                    l2_hdr->iov_len + sizeof(struct ip_header),\n                                    l3_hdr->iov_base + sizeof(struct ip_header),\n                                    l3_hdr->iov_len - sizeof(struct ip_header));\n            if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n                l3_hdr->iov_len = 0;\n                return false;\n            }\n        }\n\n        break;\n\n    case ETH_P_IPV6:\n    {\n        eth_ip6_hdr_info hdrinfo;\n\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                &hdrinfo)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = hdrinfo.l4proto;\n        full_ip6hdr_len = hdrinfo.full_hdr_len;\n\n        if (full_ip6hdr_len > ETH_MAX_IP_DGRAM_LEN) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n    }\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n\n    net_tx_pkt_calculate_hdr_len(pkt);\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "static bool net_tx_pkt_parse_headers(struct NetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[NET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        l3_hdr->iov_len = 0;\n        pkt->packet_type = ETH_PKT_UCAST;\n        return false;\n    } else {\n        l2_hdr->iov_len = ETH_MAX_L2_HDR_LEN;\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n        pkt->packet_type = get_eth_packet_type(l2_hdr->iov_base);\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr, 1, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n\n        if (l3_hdr->iov_len < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        if (IP_HDR_GET_LEN(l3_hdr->iov_base) != sizeof(struct ip_header)) {\n            /* copy optional IPv4 header data if any*/\n            bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                    l2_hdr->iov_len + sizeof(struct ip_header),\n                                    l3_hdr->iov_base + sizeof(struct ip_header),\n                                    l3_hdr->iov_len - sizeof(struct ip_header));\n            if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n                l3_hdr->iov_len = 0;\n                return false;\n            }\n        }\n\n        break;\n\n    case ETH_P_IPV6:\n    {\n        eth_ip6_hdr_info hdrinfo;\n\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                &hdrinfo)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = hdrinfo.l4proto;\n        full_ip6hdr_len = hdrinfo.full_hdr_len;\n\n        if (full_ip6hdr_len > ETH_MAX_IP_DGRAM_LEN) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n    }\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n\n    net_tx_pkt_calculate_hdr_len(pkt);\n    return true;\n}\n",
        "linevul": 0.0002931550261564553
    },
    {
        "code": "static void gen_cmovcc1(CPUX86State *env, DisasContext *s, TCGMemOp ot, int b,\n                        int modrm, int reg)\n{\n    CCPrepare cc;\n\n    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n    cc = gen_prepare_cc(s, b, cpu_T1);\n    if (cc.mask != -1) {\n        TCGv t0 = tcg_temp_new();\n        tcg_gen_andi_tl(t0, cc.reg, cc.mask);\n        cc.reg = t0;\n    }\n    if (!cc.use_reg2) {\n        cc.reg2 = tcg_const_tl(cc.imm);\n    }\n\n    tcg_gen_movcond_tl(cc.cond, cpu_T0, cc.reg, cc.reg2,\n                       cpu_T0, cpu_regs[reg]);\n    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n    if (cc.mask != -1) {\n        tcg_temp_free(cc.reg);\n    }\n    if (!cc.use_reg2) {\n        tcg_temp_free(cc.reg2);\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_cmovcc1(CPUX86State *env, DisasContext *s, TCGMemOp ot, int b,\n                        int modrm, int reg)\n{\n    CCPrepare cc;\n\n    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n    cc = gen_prepare_cc(s, b, cpu_T1);\n    if (cc.mask != -1) {\n        TCGv t0 = tcg_temp_new();\n        tcg_gen_andi_tl(t0, cc.reg, cc.mask);\n        cc.reg = t0;\n    }\n    if (!cc.use_reg2) {\n        cc.reg2 = tcg_const_tl(cc.imm);\n    }\n\n    tcg_gen_movcond_tl(cc.cond, cpu_T0, cc.reg, cc.reg2,\n                       cpu_T0, cpu_regs[reg]);\n    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n    if (cc.mask != -1) {\n        tcg_temp_free(cc.reg);\n    }\n    if (!cc.use_reg2) {\n        tcg_temp_free(cc.reg2);\n    }\n}\n",
        "linevul": 5.082053394289687e-05
    },
    {
        "code": "static void ehci_free_queue(EHCIQueue *q, const char *warn)\n{\n    EHCIQueueHead *head = q->async ? &q->ehci->aqueues : &q->ehci->pqueues;\n    int cancelled;\n\n    trace_usb_ehci_queue_action(q, \"free\");\n    cancelled = ehci_cancel_queue(q);\n    if (warn && cancelled > 0) {\n        ehci_trace_guest_bug(q->ehci, warn);\n    }\n    QTAILQ_REMOVE(head, q, next);\n    g_free(q);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_free_queue(EHCIQueue *q, const char *warn)\n{\n    EHCIQueueHead *head = q->async ? &q->ehci->aqueues : &q->ehci->pqueues;\n    int cancelled;\n\n    trace_usb_ehci_queue_action(q, \"free\");\n    cancelled = ehci_cancel_queue(q);\n    if (warn && cancelled > 0) {\n        ehci_trace_guest_bug(q->ehci, warn);\n    }\n    QTAILQ_REMOVE(head, q, next);\n    g_free(q);\n}\n",
        "linevul": 4.667840039473958e-05
    },
    {
        "code": "void e1000e_core_pre_save(E1000ECore *core)\n{\n    int i;\n    NetClientState *nc = qemu_get_queue(core->owner_nic);\n\n    /*\n    * If link is down and auto-negotiation is supported and ongoing,\n    * complete auto-negotiation immediately. This allows us to look\n    * at MII_SR_AUTONEG_COMPLETE to infer link status on load.\n    */\n    if (nc->link_down && e1000e_have_autoneg(core)) {\n        core->phy[0][PHY_STATUS] |= MII_SR_AUTONEG_COMPLETE;\n        e1000e_update_flowctl_status(core);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(core->tx); i++) {\n        if (net_tx_pkt_has_fragments(core->tx[i].tx_pkt)) {\n            core->tx[i].skip_cp = true;\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "void e1000e_core_pre_save(E1000ECore *core)\n{\n    int i;\n    NetClientState *nc = qemu_get_queue(core->owner_nic);\n\n    /*\n    * If link is down and auto-negotiation is supported and ongoing,\n    * complete auto-negotiation immediately. This allows us to look\n    * at MII_SR_AUTONEG_COMPLETE to infer link status on load.\n    */\n    if (nc->link_down && e1000e_have_autoneg(core)) {\n        core->phy[0][PHY_STATUS] |= MII_SR_AUTONEG_COMPLETE;\n        e1000e_update_flowctl_status(core);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(core->tx); i++) {\n        if (net_tx_pkt_has_fragments(core->tx[i].tx_pkt)) {\n            core->tx[i].skip_cp = true;\n        }\n    }\n}\n",
        "linevul": 5.682223491021432e-05
    },
    {
        "code": "size_t net_tx_pkt_get_total_len(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n\n    return pkt->hdr_len + pkt->payload_len;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "size_t net_tx_pkt_get_total_len(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n\n    return pkt->hdr_len + pkt->payload_len;\n}\n",
        "linevul": 6.25452448730357e-05
    },
    {
        "code": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=7f61f4690dd153be98900a2a508b88989e692753",
        "vul_func_with_fix": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n//flaw_line_below:\n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n//flaw_line_below:\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n//flaw_line_below:\n        return -1;\n//flaw_line_below:\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n",
        "linevul": 0.9993973970413208
    },
    {
        "code": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n {\n     AHCICmdHdr *cmd = ad->cur_cmd;\n     uint32_t opts = le32_to_cpu(cmd->opts);\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n     uint8_t *prdt;\n     int i;\n     int r = 0;\n    int sum = 0;\n     int off_idx = -1;\n    int off_pos = -1;\n     int tbl_entry_size;\n     IDEBus *bus = &ad->port;\n     BusState *qbus = BUS(bus);\n \n     if (!sglist_alloc_hint) {\n         DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n         return -1;\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (sglist_alloc_hint > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < sglist_alloc_hint; i++) {\n            /* flags_size is zero-based */\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset <= (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n         }\n         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n             DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                             __func__, off_idx, off_pos);\n             r = -1;\n             goto out;\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            prdt_tbl_entry_size(&tbl[i]));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n             /* flags_size is zero-based */\n             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                             prdt_tbl_entry_size(&tbl[i]));\n         }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n//fix_flaw_line_below:\n//static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n//fix_flaw_line_below:\n//                                int32_t offset)\n {\n     AHCICmdHdr *cmd = ad->cur_cmd;\n     uint32_t opts = le32_to_cpu(cmd->opts);\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n     uint8_t *prdt;\n     int i;\n     int r = 0;\n//flaw_line_below:\n    int sum = 0;\n//fix_flaw_line_below:\n//    uint64_t sum = 0;\n     int off_idx = -1;\n//flaw_line_below:\n    int off_pos = -1;\n//fix_flaw_line_below:\n//    int64_t off_pos = -1;\n     int tbl_entry_size;\n     IDEBus *bus = &ad->port;\n     BusState *qbus = BUS(bus);\n \n//fix_flaw_line_below:\n//    /*\n//fix_flaw_line_below:\n//     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n//fix_flaw_line_below:\n//     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n//fix_flaw_line_below:\n//     * 512 byte sector size. We limit the PRDT in this implementation to\n//fix_flaw_line_below:\n//     * a reasonably large 2GiB, which can accommodate the maximum transfer\n//fix_flaw_line_below:\n//     * request for sector sizes up to 32K.\n//fix_flaw_line_below:\n//     */\n//fix_flaw_line_below:\n//\n     if (!sglist_alloc_hint) {\n         DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n         return -1;\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (sglist_alloc_hint > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < sglist_alloc_hint; i++) {\n            /* flags_size is zero-based */\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset <= (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n         }\n         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n             DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n//flaw_line_below:\n                            \"off_idx: %d, off_pos: %d\\n\",\n//fix_flaw_line_below:\n//                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                             __func__, off_idx, off_pos);\n             r = -1;\n             goto out;\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            prdt_tbl_entry_size(&tbl[i]));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n             /* flags_size is zero-based */\n             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                             prdt_tbl_entry_size(&tbl[i]));\n//fix_flaw_line_below:\n//            if (sglist->size > INT32_MAX) {\n//fix_flaw_line_below:\n//                error_report(\"AHCI Physical Region Descriptor Table describes \"\n//fix_flaw_line_below:\n//                             \"more than 2 GiB.\\n\");\n//fix_flaw_line_below:\n//                qemu_sglist_destroy(sglist);\n//fix_flaw_line_below:\n//                r = -1;\n//fix_flaw_line_below:\n//                goto out;\n//fix_flaw_line_below:\n//            }\n         }\n",
        "linevul": 0.9443146586418152
    },
    {
        "code": "static void iscsi_block_init(void)\n{\n    bdrv_register(&bdrv_iscsi);\n    qemu_add_opts(&qemu_iscsi_opts);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_block_init(void)\n{\n    bdrv_register(&bdrv_iscsi);\n    qemu_add_opts(&qemu_iscsi_opts);\n}\n",
        "linevul": 5.992785736452788e-05
    },
    {
        "code": " static void scsi_read_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n         }\n     }\n \n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n \n    n = r->iov.iov_len / 512;\n     r->sector += n;\n     r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": " static void scsi_read_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n         }\n     }\n \n//flaw_line_below:\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n//fix_flaw_line_below:\n//    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n \n//flaw_line_below:\n    n = r->iov.iov_len / 512;\n//fix_flaw_line_below:\n//    n = r->qiov.size / 512;\n     r->sector += n;\n     r->sector_count -= n;\n//flaw_line_below:\n    scsi_req_data(&r->req, r->iov.iov_len);\n//fix_flaw_line_below:\n//    scsi_req_data(&r->req, r->qiov.size);\n }\n",
        "linevul": 0.9969455599784851
    },
    {
        "code": "static void fdctrl_write (void *opaque, uint32_t reg, uint32_t value)\n{\n    FDCtrl *fdctrl = opaque;\n\n    FLOPPY_DPRINTF(\"write reg%d: 0x%02x\\n\", reg & 7, value);\n\n    reg &= 7;\n    switch (reg) {\n    case FD_REG_DOR:\n        fdctrl_write_dor(fdctrl, value);\n        break;\n    case FD_REG_TDR:\n        fdctrl_write_tape(fdctrl, value);\n        break;\n    case FD_REG_DSR:\n        fdctrl_write_rate(fdctrl, value);\n        break;\n    case FD_REG_FIFO:\n        fdctrl_write_data(fdctrl, value);\n        break;\n    case FD_REG_CCR:\n        fdctrl_write_ccr(fdctrl, value);\n        break;\n    default:\n        break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static void fdctrl_write (void *opaque, uint32_t reg, uint32_t value)\n{\n    FDCtrl *fdctrl = opaque;\n\n    FLOPPY_DPRINTF(\"write reg%d: 0x%02x\\n\", reg & 7, value);\n\n    reg &= 7;\n    switch (reg) {\n    case FD_REG_DOR:\n        fdctrl_write_dor(fdctrl, value);\n        break;\n    case FD_REG_TDR:\n        fdctrl_write_tape(fdctrl, value);\n        break;\n    case FD_REG_DSR:\n        fdctrl_write_rate(fdctrl, value);\n        break;\n    case FD_REG_FIFO:\n        fdctrl_write_data(fdctrl, value);\n        break;\n    case FD_REG_CCR:\n        fdctrl_write_ccr(fdctrl, value);\n        break;\n    default:\n        break;\n    }\n}\n",
        "linevul": 6.801044219173491e-05
    },
    {
        "code": "static void write_response(ESPState *s)\n{\n    trace_esp_write_response(s->status);\n    s->ti_buf[0] = s->status;\n    s->ti_buf[1] = 0;\n    if (s->dma) {\n        s->dma_memory_write(s->dma_opaque, s->ti_buf, 2);\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n    } else {\n        s->ti_size = 2;\n        s->ti_rptr = 0;\n        s->ti_wptr = 0;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
        "vul_func_with_fix": "static void write_response(ESPState *s)\n{\n    trace_esp_write_response(s->status);\n    s->ti_buf[0] = s->status;\n    s->ti_buf[1] = 0;\n    if (s->dma) {\n        s->dma_memory_write(s->dma_opaque, s->ti_buf, 2);\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n    } else {\n        s->ti_size = 2;\n        s->ti_rptr = 0;\n        s->ti_wptr = 0;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}\n",
        "linevul": 0.00015951598470564932
    },
    {
        "code": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(ctx, fs_path->data, O_WRONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = ftruncate(fd, size);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(ctx, fs_path->data, O_WRONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = ftruncate(fd, size);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "linevul": 5.737041647080332e-05
    },
    {
        "code": "static void iscsi_attach_aio_context(BlockDriverState *bs,\n                                     AioContext *new_context)\n{\n    IscsiLun *iscsilun = bs->opaque;\n\n    iscsilun->aio_context = new_context;\n    iscsi_set_events(iscsilun);\n\n    /* Set up a timer for sending out iSCSI NOPs */\n    iscsilun->nop_timer = aio_timer_new(iscsilun->aio_context,\n                                        QEMU_CLOCK_REALTIME, SCALE_MS,\n                                        iscsi_nop_timed_event, iscsilun);\n    timer_mod(iscsilun->nop_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    /* Set up a timer for periodic calls to iscsi_set_events and to\n     * scan for command timeout */\n    iscsilun->event_timer = aio_timer_new(iscsilun->aio_context,\n                                          QEMU_CLOCK_REALTIME, SCALE_MS,\n                                          iscsi_timed_check_events, iscsilun);\n    timer_mod(iscsilun->event_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_attach_aio_context(BlockDriverState *bs,\n                                     AioContext *new_context)\n{\n    IscsiLun *iscsilun = bs->opaque;\n\n    iscsilun->aio_context = new_context;\n    iscsi_set_events(iscsilun);\n\n    /* Set up a timer for sending out iSCSI NOPs */\n    iscsilun->nop_timer = aio_timer_new(iscsilun->aio_context,\n                                        QEMU_CLOCK_REALTIME, SCALE_MS,\n                                        iscsi_nop_timed_event, iscsilun);\n    timer_mod(iscsilun->nop_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    /* Set up a timer for periodic calls to iscsi_set_events and to\n     * scan for command timeout */\n    iscsilun->event_timer = aio_timer_new(iscsilun->aio_context,\n                                          QEMU_CLOCK_REALTIME, SCALE_MS,\n                                          iscsi_timed_check_events, iscsilun);\n    timer_mod(iscsilun->event_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n}\n",
        "linevul": 5.892190529266372e-05
    },
    {
        "code": "static void ahci_reset_port(AHCIState *s, int port)\n{\n    AHCIDevice *d = &s->dev[port];\n    AHCIPortRegs *pr = &d->port_regs;\n    IDEState *ide_state = &d->port.ifs[0];\n    int i;\n\n    DPRINTF(port, \"reset port\\n\");\n\n    ide_bus_reset(&d->port);\n    ide_state->ncq_queues = AHCI_MAX_CMDS;\n\n    pr->scr_stat = 0;\n    pr->scr_err = 0;\n    pr->scr_act = 0;\n    d->busy_slot = -1;\n    d->init_d2h_sent = false;\n\n    ide_state = &s->dev[port].port.ifs[0];\n    if (!ide_state->bs) {\n        return;\n    }\n\n    /* reset ncq queue */\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[i];\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        if (ncq_tfs->aiocb) {\n            bdrv_aio_cancel(ncq_tfs->aiocb);\n            ncq_tfs->aiocb = NULL;\n        }\n\n        /* Maybe we just finished the request thanks to bdrv_aio_cancel() */\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        qemu_sglist_destroy(&ncq_tfs->sglist);\n        ncq_tfs->used = 0;\n    }\n\n    s->dev[port].port_state = STATE_RUN;\n    if (!ide_state->bs) {\n        s->dev[port].port_regs.sig = 0;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    } else if (ide_state->drive_kind == IDE_CD) {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_CDROM;\n        ide_state->lcyl = 0x14;\n        ide_state->hcyl = 0xeb;\n        DPRINTF(port, \"set lcyl = %d\\n\", ide_state->lcyl);\n        ide_state->status = SEEK_STAT | WRERR_STAT | READY_STAT;\n    } else {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_DISK;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    }\n\n    ide_state->error = 1;\n    ahci_init_d2h(d);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static void ahci_reset_port(AHCIState *s, int port)\n{\n    AHCIDevice *d = &s->dev[port];\n    AHCIPortRegs *pr = &d->port_regs;\n    IDEState *ide_state = &d->port.ifs[0];\n    int i;\n\n    DPRINTF(port, \"reset port\\n\");\n\n    ide_bus_reset(&d->port);\n    ide_state->ncq_queues = AHCI_MAX_CMDS;\n\n    pr->scr_stat = 0;\n    pr->scr_err = 0;\n    pr->scr_act = 0;\n    d->busy_slot = -1;\n    d->init_d2h_sent = false;\n\n    ide_state = &s->dev[port].port.ifs[0];\n    if (!ide_state->bs) {\n        return;\n    }\n\n    /* reset ncq queue */\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[i];\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        if (ncq_tfs->aiocb) {\n            bdrv_aio_cancel(ncq_tfs->aiocb);\n            ncq_tfs->aiocb = NULL;\n        }\n\n        /* Maybe we just finished the request thanks to bdrv_aio_cancel() */\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        qemu_sglist_destroy(&ncq_tfs->sglist);\n        ncq_tfs->used = 0;\n    }\n\n    s->dev[port].port_state = STATE_RUN;\n    if (!ide_state->bs) {\n        s->dev[port].port_regs.sig = 0;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    } else if (ide_state->drive_kind == IDE_CD) {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_CDROM;\n        ide_state->lcyl = 0x14;\n        ide_state->hcyl = 0xeb;\n        DPRINTF(port, \"set lcyl = %d\\n\", ide_state->lcyl);\n        ide_state->status = SEEK_STAT | WRERR_STAT | READY_STAT;\n    } else {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_DISK;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    }\n\n    ide_state->error = 1;\n    ahci_init_d2h(d);\n}\n",
        "linevul": 4.456137685338035e-05
    },
    {
        "code": "void virtio_queue_set_notification(VirtQueue *vq, int enable)\n{\n    vq->notification = enable;\n    if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vring_avail_idx(vq));\n    } else if (enable) {\n        vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);\n    } else {\n        vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);\n    }\n    if (enable) {\n        /* Expose avail event/used flags before caller checks the avail idx. */\n        smp_mb();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=973e7170dddefb491a48df5cba33b2ae151013a0",
        "vul_func_with_fix": "void virtio_queue_set_notification(VirtQueue *vq, int enable)\n{\n    vq->notification = enable;\n    if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vring_avail_idx(vq));\n    } else if (enable) {\n        vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);\n    } else {\n        vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);\n    }\n    if (enable) {\n        /* Expose avail event/used flags before caller checks the avail idx. */\n        smp_mb();\n    }\n}\n",
        "linevul": 5.9057812904939055e-05
    },
    {
        "code": "static int ndis_query(USBNetState *s, uint32_t oid,\n                      uint8_t *inbuf, unsigned int inlen, uint8_t *outbuf,\n                      size_t outlen)\n{\n    unsigned int i;\n\n    switch (oid) {\n    /* general oids (table 4-1) */\n    /* mandatory */\n    case OID_GEN_SUPPORTED_LIST:\n        for (i = 0; i < ARRAY_SIZE(oid_supported_list); i++)\n            ((le32 *) outbuf)[i] = cpu_to_le32(oid_supported_list[i]);\n        return sizeof(oid_supported_list);\n\n    /* mandatory */\n    case OID_GEN_HARDWARE_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_SUPPORTED:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_IN_USE:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_FRAME_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_LINK_SPEED:\n        *((le32 *) outbuf) = cpu_to_le32(s->speed);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_TRANSMIT_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RECEIVE_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_ID:\n        *((le32 *) outbuf) = cpu_to_le32(s->vendorid);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_DESCRIPTION:\n        pstrcpy((char *)outbuf, outlen, \"QEMU USB RNDIS Net\");\n        return strlen((char *)outbuf) + 1;\n\n    case OID_GEN_VENDOR_DRIVER_VERSION:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_CURRENT_PACKET_FILTER:\n        *((le32 *) outbuf) = cpu_to_le32(s->filter);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_TOTAL_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(RNDIS_MAX_TOTAL_SIZE);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_CONNECT_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(s->media_state);\n        return sizeof(le32);\n\n    case OID_GEN_PHYSICAL_MEDIUM:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    case OID_GEN_MAC_OPTIONS:\n        *((le32 *) outbuf) = cpu_to_le32(\n                        NDIS_MAC_OPTION_RECEIVE_SERIALIZED |\n                        NDIS_MAC_OPTION_FULL_DUPLEX);\n        return sizeof(le32);\n\n    /* statistics OIDs (table 4-2) */\n    /* mandatory */\n    case OID_GEN_XMIT_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_XMIT_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_NO_BUFFER:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* ieee802.3 OIDs (table 4-3) */\n    /* mandatory */\n    case OID_802_3_PERMANENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_CURRENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_MULTICAST_LIST:\n        *((le32 *) outbuf) = cpu_to_le32(0xe0000000);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_MAXIMUM_LIST_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    case OID_802_3_MAC_OPTIONS:\n        return 0;\n\n    /* ieee802.3 statistics OIDs (table 4-4) */\n    /* mandatory */\n    case OID_802_3_RCV_ERROR_ALIGNMENT:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_ONE_COLLISION:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_MORE_COLLISIONS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    default:\n        fprintf(stderr, \"usbnet: unknown OID 0x%08x\\n\", oid);\n        return 0;\n    }\n    return -1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "vul_func_with_fix": "static int ndis_query(USBNetState *s, uint32_t oid,\n                      uint8_t *inbuf, unsigned int inlen, uint8_t *outbuf,\n                      size_t outlen)\n{\n    unsigned int i;\n\n    switch (oid) {\n    /* general oids (table 4-1) */\n    /* mandatory */\n    case OID_GEN_SUPPORTED_LIST:\n        for (i = 0; i < ARRAY_SIZE(oid_supported_list); i++)\n            ((le32 *) outbuf)[i] = cpu_to_le32(oid_supported_list[i]);\n        return sizeof(oid_supported_list);\n\n    /* mandatory */\n    case OID_GEN_HARDWARE_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_SUPPORTED:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_IN_USE:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_FRAME_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_LINK_SPEED:\n        *((le32 *) outbuf) = cpu_to_le32(s->speed);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_TRANSMIT_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RECEIVE_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_ID:\n        *((le32 *) outbuf) = cpu_to_le32(s->vendorid);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_DESCRIPTION:\n        pstrcpy((char *)outbuf, outlen, \"QEMU USB RNDIS Net\");\n        return strlen((char *)outbuf) + 1;\n\n    case OID_GEN_VENDOR_DRIVER_VERSION:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_CURRENT_PACKET_FILTER:\n        *((le32 *) outbuf) = cpu_to_le32(s->filter);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_TOTAL_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(RNDIS_MAX_TOTAL_SIZE);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_CONNECT_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(s->media_state);\n        return sizeof(le32);\n\n    case OID_GEN_PHYSICAL_MEDIUM:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    case OID_GEN_MAC_OPTIONS:\n        *((le32 *) outbuf) = cpu_to_le32(\n                        NDIS_MAC_OPTION_RECEIVE_SERIALIZED |\n                        NDIS_MAC_OPTION_FULL_DUPLEX);\n        return sizeof(le32);\n\n    /* statistics OIDs (table 4-2) */\n    /* mandatory */\n    case OID_GEN_XMIT_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_XMIT_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_NO_BUFFER:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* ieee802.3 OIDs (table 4-3) */\n    /* mandatory */\n    case OID_802_3_PERMANENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_CURRENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_MULTICAST_LIST:\n        *((le32 *) outbuf) = cpu_to_le32(0xe0000000);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_MAXIMUM_LIST_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    case OID_802_3_MAC_OPTIONS:\n        return 0;\n\n    /* ieee802.3 statistics OIDs (table 4-4) */\n    /* mandatory */\n    case OID_802_3_RCV_ERROR_ALIGNMENT:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_ONE_COLLISION:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_MORE_COLLISIONS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    default:\n        fprintf(stderr, \"usbnet: unknown OID 0x%08x\\n\", oid);\n        return 0;\n    }\n    return -1;\n}\n",
        "linevul": 0.0030339558143168688
    },
    {
        "code": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n                                AHCICmdHdr *cmd, int64_t limit, uint64_t offset)\n{\n    uint16_t opts = le16_to_cpu(cmd->opts);\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n    uint64_t prdt_addr = cfis_addr + 0x80;\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n    int i;\n    int r = 0;\n    uint64_t sum = 0;\n    int off_idx = -1;\n    int64_t off_pos = -1;\n    int tbl_entry_size;\n    IDEBus *bus = &ad->port;\n    BusState *qbus = BUS(bus);\n\n    if (!prdtl) {\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n        return -1;\n    }\n\n    /* map PRDT */\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n                                DMA_DIRECTION_TO_DEVICE))){\n        DPRINTF(ad->port_no, \"map failed\\n\");\n        return -1;\n    }\n\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (prdtl > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < prdtl; i++) {\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset < (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n                         ad->hba->as);\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n                            limit));\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n                                limit - sglist->size));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n    return r;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n                                AHCICmdHdr *cmd, int64_t limit, uint64_t offset)\n{\n    uint16_t opts = le16_to_cpu(cmd->opts);\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n    uint64_t prdt_addr = cfis_addr + 0x80;\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n    int i;\n    int r = 0;\n    uint64_t sum = 0;\n    int off_idx = -1;\n    int64_t off_pos = -1;\n    int tbl_entry_size;\n    IDEBus *bus = &ad->port;\n    BusState *qbus = BUS(bus);\n\n    if (!prdtl) {\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n        return -1;\n    }\n\n    /* map PRDT */\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n                                DMA_DIRECTION_TO_DEVICE))){\n        DPRINTF(ad->port_no, \"map failed\\n\");\n        return -1;\n    }\n\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (prdtl > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < prdtl; i++) {\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset < (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n                         ad->hba->as);\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n                            limit));\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n                                limit - sglist->size));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n    return r;\n}\n",
        "linevul": 4.8125402827281505e-05
    },
    {
        "code": "static EHCIPacket *ehci_alloc_packet(EHCIQueue *q)\n{\n    EHCIPacket *p;\n\n    p = g_new0(EHCIPacket, 1);\n    p->queue = q;\n    usb_packet_init(&p->packet);\n    QTAILQ_INSERT_TAIL(&q->packets, p, next);\n    trace_usb_ehci_packet_action(p->queue, p, \"alloc\");\n    return p;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static EHCIPacket *ehci_alloc_packet(EHCIQueue *q)\n{\n    EHCIPacket *p;\n\n    p = g_new0(EHCIPacket, 1);\n    p->queue = q;\n    usb_packet_init(&p->packet);\n    QTAILQ_INSERT_TAIL(&q->packets, p, next);\n    trace_usb_ehci_packet_action(p->queue, p, \"alloc\");\n    return p;\n}\n",
        "linevul": 4.7578272642567754e-05
    },
    {
        "code": "static inline void gen_string_movl_A0_EDI(DisasContext *s)\n{\n    gen_lea_v_seg(s, s->aflag, cpu_regs[R_EDI], R_ES, -1);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline void gen_string_movl_A0_EDI(DisasContext *s)\n{\n    gen_lea_v_seg(s, s->aflag, cpu_regs[R_EDI], R_ES, -1);\n}\n",
        "linevul": 4.8694335418986157e-05
    },
    {
        "code": "void net_checksum_calculate(uint8_t *data, int length)\n{\n     int hlen, plen, proto, csum_offset;\n     uint16_t csum;\n \n     if ((data[14] & 0xf0) != 0x40)\n        return; /* not IPv4 */\n     hlen  = (data[14] & 0x0f) * 4;\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=362786f14a753d8a5256ef97d7c10ed576d6572b",
        "vul_func_with_fix": "void net_checksum_calculate(uint8_t *data, int length)\n{\n     int hlen, plen, proto, csum_offset;\n     uint16_t csum;\n \n//fix_flaw_line_below:\n//    /* Ensure data has complete L2 & L3 headers. */\n//fix_flaw_line_below:\n//    if (length < 14 + 20) {\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     if ((data[14] & 0xf0) != 0x40)\n        return; /* not IPv4 */\n     hlen  = (data[14] & 0x0f) * 4;\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n",
        "linevul": 0.9987840056419373
    },
    {
        "code": "static int proxy_lremovexattr(FsContext *ctx, V9fsPath *fs_path,\n                              const char *name)\n{\n    int retval;\n    V9fsString xname;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n    retval = v9fs_request(ctx->private, T_LREMOVEXATTR, NULL, fs_path, &xname);\n    v9fs_string_free(&xname);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_lremovexattr(FsContext *ctx, V9fsPath *fs_path,\n                              const char *name)\n{\n    int retval;\n    V9fsString xname;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n    retval = v9fs_request(ctx->private, T_LREMOVEXATTR, NULL, fs_path, &xname);\n    v9fs_string_free(&xname);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n",
        "linevul": 4.796499706571922e-05
    },
    {
        "code": "static void zrle_write_u32(VncState *vs, uint32_t value)\n{\n    vnc_write(vs, (uint8_t *)&value, 4);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static void zrle_write_u32(VncState *vs, uint32_t value)\n{\n    vnc_write(vs, (uint8_t *)&value, 4);\n}\n",
        "linevul": 4.925937173538841e-05
    },
    {
        "code": "static int handle_cmd(AHCIState *s, int port, int slot)\n{\n    IDEState *ide_state;\n    uint32_t opts;\n    uint64_t tbl_addr;\n    AHCICmdHdr *cmd;\n    uint8_t *cmd_fis;\n    dma_addr_t cmd_len;\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* Engine currently busy, try again later */\n        DPRINTF(port, \"engine busy\\n\");\n        return -1;\n    }\n\n    cmd = &((AHCICmdHdr *)s->dev[port].lst)[slot];\n\n    if (!s->dev[port].lst) {\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n        return -1;\n    }\n\n    /* remember current slot handle for later */\n    s->dev[port].cur_cmd = cmd;\n\n    opts = le32_to_cpu(cmd->opts);\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n\n    cmd_len = 0x80;\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n                             DMA_DIRECTION_FROM_DEVICE);\n\n    if (!cmd_fis) {\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n        return -1;\n    }\n\n    /* The device we are working for */\n    ide_state = &s->dev[port].port.ifs[0];\n\n    if (!ide_state->bs) {\n        DPRINTF(port, \"error: guest accessed unused port\");\n        goto out;\n    }\n\n    debug_print_fis(cmd_fis, 0x90);\n\n    switch (cmd_fis[0]) {\n        case SATA_FIS_TYPE_REGISTER_H2D:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (cmd_fis[1]) {\n        case SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER:\n            break;\n        case 0:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (s->dev[port].port_state) {\n        case STATE_RUN:\n            if (cmd_fis[15] & ATA_SRST) {\n                s->dev[port].port_state = STATE_RESET;\n            }\n            break;\n        case STATE_RESET:\n            if (!(cmd_fis[15] & ATA_SRST)) {\n                ahci_reset_port(s, port);\n            }\n            break;\n    }\n\n    if (cmd_fis[1] == SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER) {\n\n        /* Check for NCQ command */\n        if ((cmd_fis[2] == READ_FPDMA_QUEUED) ||\n            (cmd_fis[2] == WRITE_FPDMA_QUEUED)) {\n            process_ncq_command(s, port, cmd_fis, slot);\n            goto out;\n        }\n\n        /* Decompose the FIS  */\n        ide_state->nsector = (int64_t)((cmd_fis[13] << 8) | cmd_fis[12]);\n        ide_state->feature = cmd_fis[3];\n        if (!ide_state->nsector) {\n            ide_state->nsector = 256;\n        }\n\n        if (ide_state->drive_kind != IDE_CD) {\n            /*\n             * We set the sector depending on the sector defined in the FIS.\n             * Unfortunately, the spec isn't exactly obvious on this one.\n             *\n             * Apparently LBA48 commands set fis bytes 10,9,8,6,5,4 to the\n             * 48 bit sector number. ATA_CMD_READ_DMA_EXT is an example for\n             * such a command.\n             *\n             * Non-LBA48 commands however use 7[lower 4 bits],6,5,4 to define a\n             * 28-bit sector number. ATA_CMD_READ_DMA is an example for such\n             * a command.\n             *\n             * Since the spec doesn't explicitly state what each field should\n             * do, I simply assume non-used fields as reserved and OR everything\n             * together, independent of the command.\n             */\n            ide_set_sector(ide_state, ((uint64_t)cmd_fis[10] << 40)\n                                    | ((uint64_t)cmd_fis[9] << 32)\n                                    /* This is used for LBA48 commands */\n                                    | ((uint64_t)cmd_fis[8] << 24)\n                                    /* This is used for non-LBA48 commands */\n                                    | ((uint64_t)(cmd_fis[7] & 0xf) << 24)\n                                    | ((uint64_t)cmd_fis[6] << 16)\n                                    | ((uint64_t)cmd_fis[5] << 8)\n                                    | cmd_fis[4]);\n        }\n\n        /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command\n         * table to ide_state->io_buffer\n         */\n        if (opts & AHCI_CMD_ATAPI) {\n            memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n            ide_state->lcyl = 0x14;\n            ide_state->hcyl = 0xeb;\n            debug_print_fis(ide_state->io_buffer, 0x10);\n            ide_state->feature = IDE_FEATURE_DMA;\n            s->dev[port].done_atapi_packet = false;\n            /* XXX send PIO setup FIS */\n        }\n\n        ide_state->error = 0;\n\n        /* Reset transferred byte counter */\n        cmd->status = 0;\n\n        /* We're ready to process the command in FIS byte 2. */\n        ide_exec_cmd(&s->dev[port].port, cmd_fis[2]);\n\n        if ((s->dev[port].port.ifs[0].status & (READY_STAT|DRQ_STAT|BUSY_STAT)) ==\n            READY_STAT) {\n            ahci_write_fis_d2h(&s->dev[port], cmd_fis);\n        }\n    }\n\nout:\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n                     cmd_len);\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* async command, complete later */\n        s->dev[port].busy_slot = slot;\n        return -1;\n    }\n\n    /* done handling the command */\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static int handle_cmd(AHCIState *s, int port, int slot)\n{\n    IDEState *ide_state;\n    uint32_t opts;\n    uint64_t tbl_addr;\n    AHCICmdHdr *cmd;\n    uint8_t *cmd_fis;\n    dma_addr_t cmd_len;\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* Engine currently busy, try again later */\n        DPRINTF(port, \"engine busy\\n\");\n        return -1;\n    }\n\n    cmd = &((AHCICmdHdr *)s->dev[port].lst)[slot];\n\n    if (!s->dev[port].lst) {\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n        return -1;\n    }\n\n    /* remember current slot handle for later */\n    s->dev[port].cur_cmd = cmd;\n\n    opts = le32_to_cpu(cmd->opts);\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n\n    cmd_len = 0x80;\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n                             DMA_DIRECTION_FROM_DEVICE);\n\n    if (!cmd_fis) {\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n        return -1;\n    }\n\n    /* The device we are working for */\n    ide_state = &s->dev[port].port.ifs[0];\n\n    if (!ide_state->bs) {\n        DPRINTF(port, \"error: guest accessed unused port\");\n        goto out;\n    }\n\n    debug_print_fis(cmd_fis, 0x90);\n    //debug_print_fis(cmd_fis, (opts & AHCI_CMD_HDR_CMD_FIS_LEN) * 4);\n\n    switch (cmd_fis[0]) {\n        case SATA_FIS_TYPE_REGISTER_H2D:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (cmd_fis[1]) {\n        case SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER:\n            break;\n        case 0:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (s->dev[port].port_state) {\n        case STATE_RUN:\n            if (cmd_fis[15] & ATA_SRST) {\n                s->dev[port].port_state = STATE_RESET;\n            }\n            break;\n        case STATE_RESET:\n            if (!(cmd_fis[15] & ATA_SRST)) {\n                ahci_reset_port(s, port);\n            }\n            break;\n    }\n\n    if (cmd_fis[1] == SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER) {\n\n        /* Check for NCQ command */\n        if ((cmd_fis[2] == READ_FPDMA_QUEUED) ||\n            (cmd_fis[2] == WRITE_FPDMA_QUEUED)) {\n            process_ncq_command(s, port, cmd_fis, slot);\n            goto out;\n        }\n\n        /* Decompose the FIS  */\n        ide_state->nsector = (int64_t)((cmd_fis[13] << 8) | cmd_fis[12]);\n        ide_state->feature = cmd_fis[3];\n        if (!ide_state->nsector) {\n            ide_state->nsector = 256;\n        }\n\n        if (ide_state->drive_kind != IDE_CD) {\n            /*\n             * We set the sector depending on the sector defined in the FIS.\n             * Unfortunately, the spec isn't exactly obvious on this one.\n             *\n             * Apparently LBA48 commands set fis bytes 10,9,8,6,5,4 to the\n             * 48 bit sector number. ATA_CMD_READ_DMA_EXT is an example for\n             * such a command.\n             *\n             * Non-LBA48 commands however use 7[lower 4 bits],6,5,4 to define a\n             * 28-bit sector number. ATA_CMD_READ_DMA is an example for such\n             * a command.\n             *\n             * Since the spec doesn't explicitly state what each field should\n             * do, I simply assume non-used fields as reserved and OR everything\n             * together, independent of the command.\n             */\n            ide_set_sector(ide_state, ((uint64_t)cmd_fis[10] << 40)\n                                    | ((uint64_t)cmd_fis[9] << 32)\n                                    /* This is used for LBA48 commands */\n                                    | ((uint64_t)cmd_fis[8] << 24)\n                                    /* This is used for non-LBA48 commands */\n                                    | ((uint64_t)(cmd_fis[7] & 0xf) << 24)\n                                    | ((uint64_t)cmd_fis[6] << 16)\n                                    | ((uint64_t)cmd_fis[5] << 8)\n                                    | cmd_fis[4]);\n        }\n\n        /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command\n         * table to ide_state->io_buffer\n         */\n        if (opts & AHCI_CMD_ATAPI) {\n            memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n            ide_state->lcyl = 0x14;\n            ide_state->hcyl = 0xeb;\n            debug_print_fis(ide_state->io_buffer, 0x10);\n            ide_state->feature = IDE_FEATURE_DMA;\n            s->dev[port].done_atapi_packet = false;\n            /* XXX send PIO setup FIS */\n        }\n\n        ide_state->error = 0;\n\n        /* Reset transferred byte counter */\n        cmd->status = 0;\n\n        /* We're ready to process the command in FIS byte 2. */\n        ide_exec_cmd(&s->dev[port].port, cmd_fis[2]);\n\n        if ((s->dev[port].port.ifs[0].status & (READY_STAT|DRQ_STAT|BUSY_STAT)) ==\n            READY_STAT) {\n            ahci_write_fis_d2h(&s->dev[port], cmd_fis);\n        }\n    }\n\nout:\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n                     cmd_len);\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* async command, complete later */\n        s->dev[port].busy_slot = slot;\n        return -1;\n    }\n\n    /* done handling the command */\n    return 0;\n}\n",
        "linevul": 5.9411704569356516e-05
    },
    {
        "code": "v9fs_path_sprintf(V9fsPath *path, const char *fmt, ...)\n{\n    va_list ap;\n\n    v9fs_path_free(path);\n\n    va_start(ap, fmt);\n    /* Bump the size for including terminating NULL */\n    path->size = g_vasprintf(&path->data, fmt, ap) + 1;\n    va_end(ap);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "v9fs_path_sprintf(V9fsPath *path, const char *fmt, ...)\n{\n    va_list ap;\n\n    v9fs_path_free(path);\n\n    va_start(ap, fmt);\n    /* Bump the size for including terminating NULL */\n    path->size = g_vasprintf(&path->data, fmt, ap) + 1;\n    va_end(ap);\n}\n",
        "linevul": 6.096134166000411e-05
    },
    {
        "code": "static int virtio_validate_features(VirtIODevice *vdev)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    if (k->validate_features) {\n        return k->validate_features(vdev);\n    } else {\n        return 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static int virtio_validate_features(VirtIODevice *vdev)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    if (k->validate_features) {\n        return k->validate_features(vdev);\n    } else {\n        return 0;\n    }\n}\n",
        "linevul": 4.5843360567232594e-05
    },
    {
        "code": "static FILE *local_fopenat(int dirfd, const char *name, const char *mode)\n{\n    int fd, o_mode = 0;\n    FILE *fp;\n    int flags;\n    /*\n     * only supports two modes\n     */\n    if (mode[0] == 'r') {\n        flags = O_RDONLY;\n    } else if (mode[0] == 'w') {\n        flags = O_WRONLY | O_TRUNC | O_CREAT;\n        o_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n    } else {\n        return NULL;\n    }\n    fd = openat_file(dirfd, name, flags, o_mode);\n    if (fd == -1) {\n        return NULL;\n    }\n    fp = fdopen(fd, mode);\n    if (!fp) {\n        close(fd);\n    }\n    return fp;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static FILE *local_fopenat(int dirfd, const char *name, const char *mode)\n{\n    int fd, o_mode = 0;\n    FILE *fp;\n    int flags;\n    /*\n     * only supports two modes\n     */\n    if (mode[0] == 'r') {\n        flags = O_RDONLY;\n    } else if (mode[0] == 'w') {\n        flags = O_WRONLY | O_TRUNC | O_CREAT;\n        o_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n    } else {\n        return NULL;\n    }\n    fd = openat_file(dirfd, name, flags, o_mode);\n    if (fd == -1) {\n        return NULL;\n    }\n    fp = fdopen(fd, mode);\n    if (!fp) {\n        close(fd);\n    }\n    return fp;\n}\n",
        "linevul": 8.367785630980507e-05
    },
    {
        "code": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n",
        "linevul": 0.00019968952983617783
    },
    {
        "code": "static void xhci_complete(USBPort *port, USBPacket *packet)\n{\n    XHCITransfer *xfer = container_of(packet, XHCITransfer, packet);\n\n    if (packet->status == USB_RET_REMOVE_FROM_QUEUE) {\n        xhci_ep_nuke_one_xfer(xfer, 0);\n        return;\n    }\n    xhci_try_complete_packet(xfer);\n    xhci_kick_epctx(xfer->epctx, xfer->streamid);\n    if (xfer->complete) {\n        xhci_ep_free_xfer(xfer);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_complete(USBPort *port, USBPacket *packet)\n{\n    XHCITransfer *xfer = container_of(packet, XHCITransfer, packet);\n\n    if (packet->status == USB_RET_REMOVE_FROM_QUEUE) {\n        xhci_ep_nuke_one_xfer(xfer, 0);\n        return;\n    }\n    xhci_try_complete_packet(xfer);\n    xhci_kick_epctx(xfer->epctx, xfer->streamid);\n    if (xfer->complete) {\n        xhci_ep_free_xfer(xfer);\n    }\n}\n",
        "linevul": 7.369366358034313e-05
    },
    {
        "code": "void bdrv_disable_copy_on_read(BlockDriverState *bs)\n{\n    assert(bs->copy_on_read > 0);\n    bs->copy_on_read--;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "void bdrv_disable_copy_on_read(BlockDriverState *bs)\n{\n    assert(bs->copy_on_read > 0);\n    bs->copy_on_read--;\n}\n",
        "linevul": 7.849774556234479e-05
    },
    {
        "code": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n     g_free(name);\n     close_preserve_errno(dirfd);\n     if (xattr_len < 0) {\n         return -1;\n     }\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n     g_free(name);\n     close_preserve_errno(dirfd);\n     if (xattr_len < 0) {\n//fix_flaw_line_below:\n//        g_free(orig_value);\n         return -1;\n     }\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}\n",
        "linevul": 0.2418675273656845
    },
    {
        "code": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n{\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n        s->redraw_fifo_first = s->redraw_fifo_last;\n        return;\n    }\n    /* Overlapping region updates can be optimised out here - if someone\n     * knows a smart algorithm to do that, please share.  */\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n        rect = &s->redraw_fifo[s->redraw_fifo_first++];\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n{\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n        s->redraw_fifo_first = s->redraw_fifo_last;\n        return;\n    }\n    /* Overlapping region updates can be optimised out here - if someone\n     * knows a smart algorithm to do that, please share.  */\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n        rect = &s->redraw_fifo[s->redraw_fifo_first++];\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n    }\n}\n",
        "linevul": 4.694978997576982e-05
    },
    {
        "code": "static size_t fill(uint8_t *data, size_t size, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vfill(data, size, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "static size_t fill(uint8_t *data, size_t size, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vfill(data, size, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n",
        "linevul": 6.158114410936832e-05
    },
    {
        "code": "static void ahci_idp_write(void *opaque, hwaddr addr,\n                           uint64_t val, unsigned size)\n{\n    AHCIState *s = opaque;\n\n    if (addr == s->idp_offset) {\n        /* index register - mask off reserved bits */\n        s->idp_index = (uint32_t)val & ((AHCI_MEM_BAR_SIZE - 1) & ~3);\n    } else if (addr == s->idp_offset + 4) {\n        /* data register - do memory write at location selected by index */\n        ahci_mem_write(opaque, s->idp_index, val, size);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_idp_write(void *opaque, hwaddr addr,\n                           uint64_t val, unsigned size)\n{\n    AHCIState *s = opaque;\n\n    if (addr == s->idp_offset) {\n        /* index register - mask off reserved bits */\n        s->idp_index = (uint32_t)val & ((AHCI_MEM_BAR_SIZE - 1) & ~3);\n    } else if (addr == s->idp_offset + 4) {\n        /* data register - do memory write at location selected by index */\n        ahci_mem_write(opaque, s->idp_index, val, size);\n    }\n}\n",
        "linevul": 4.675766103900969e-05
    },
    {
        "code": "static void virtio_queue_host_notifier_aio_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_aio_vq(vq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtio_queue_host_notifier_aio_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_aio_vq(vq);\n    }\n}\n",
        "linevul": 5.359303759178147e-05
    },
    {
        "code": " pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n \n    if (ready_ptr != mgr->consumed_ptr) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": " pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n//fix_flaw_line_below:\n//    uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING\n//fix_flaw_line_below:\n//                            * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n \n//flaw_line_below:\n    if (ready_ptr != mgr->consumed_ptr) {\n//fix_flaw_line_below:\n//    if (ready_ptr != mgr->consumed_ptr\n//fix_flaw_line_below:\n//        && ready_ptr - mgr->consumed_ptr < ring_size) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n",
        "linevul": 0.9994491934776306
    },
    {
        "code": "static void vga_draw_cursor_line(uint8_t *d1,\n                                 const uint8_t *src1,\n                                 int poffset, int w,\n                                 unsigned int color0,\n                                 unsigned int color1,\n                                 unsigned int color_xor)\n{\n    const uint8_t *plane0, *plane1;\n    int x, b0, b1;\n    uint8_t *d;\n\n    d = d1;\n    plane0 = src1;\n    plane1 = src1 + poffset;\n    for (x = 0; x < w; x++) {\n        b0 = (plane0[x >> 3] >> (7 - (x & 7))) & 1;\n        b1 = (plane1[x >> 3] >> (7 - (x & 7))) & 1;\n        switch (b0 | (b1 << 1)) {\n        case 0:\n            break;\n        case 1:\n            ((uint32_t *)d)[0] ^= color_xor;\n            break;\n        case 2:\n            ((uint32_t *)d)[0] = color0;\n            break;\n        case 3:\n            ((uint32_t *)d)[0] = color1;\n            break;\n        }\n        d += 4;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static void vga_draw_cursor_line(uint8_t *d1,\n                                 const uint8_t *src1,\n                                 int poffset, int w,\n                                 unsigned int color0,\n                                 unsigned int color1,\n                                 unsigned int color_xor)\n{\n    const uint8_t *plane0, *plane1;\n    int x, b0, b1;\n    uint8_t *d;\n\n    d = d1;\n    plane0 = src1;\n    plane1 = src1 + poffset;\n    for (x = 0; x < w; x++) {\n        b0 = (plane0[x >> 3] >> (7 - (x & 7))) & 1;\n        b1 = (plane1[x >> 3] >> (7 - (x & 7))) & 1;\n        switch (b0 | (b1 << 1)) {\n        case 0:\n            break;\n        case 1:\n            ((uint32_t *)d)[0] ^= color_xor;\n            break;\n        case 2:\n            ((uint32_t *)d)[0] = color0;\n            break;\n        case 3:\n            ((uint32_t *)d)[0] = color1;\n            break;\n        }\n        d += 4;\n    }\n}\n",
        "linevul": 5.486106965690851e-05
    },
    {
        "code": "static void ehci_advance_async_state(EHCIState *ehci)\n{\n    const int async = 1;\n\n    switch(ehci_get_state(ehci, async)) {\n    case EST_INACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            break;\n        }\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n    case EST_ACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            ehci_queues_rip_all(ehci, async);\n            ehci_set_state(ehci, async, EST_INACTIVE);\n            break;\n        }\n\n        /* make sure guest has acknowledged the doorbell interrupt */\n        /* TO-DO: is this really needed? */\n        if (ehci->usbsts & USBSTS_IAA) {\n            DPRINTF(\"IAA status bit still set.\\n\");\n            break;\n        }\n\n        /* check that address register has been set */\n        if (ehci->asynclistaddr == 0) {\n            break;\n        }\n\n        ehci_set_state(ehci, async, EST_WAITLISTHEAD);\n        ehci_advance_state(ehci, async);\n\n        /* If the doorbell is set, the guest wants to make a change to the\n         * schedule. The host controller needs to release cached data.\n         * (section 4.8.2)\n         */\n        if (ehci->usbcmd & USBCMD_IAAD) {\n            /* Remove all unseen qhs from the async qhs queue */\n            ehci_queues_rip_unseen(ehci, async);\n            trace_usb_ehci_doorbell_ack();\n            ehci->usbcmd &= ~USBCMD_IAAD;\n            ehci_raise_irq(ehci, USBSTS_IAA);\n        }\n        break;\n\n    default:\n        /* this should only be due to a developer mistake */\n        fprintf(stderr, \"ehci: Bad asynchronous state %d. \"\n                \"Resetting to active\\n\", ehci->astate);\n        g_assert_not_reached();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_advance_async_state(EHCIState *ehci)\n{\n    const int async = 1;\n\n    switch(ehci_get_state(ehci, async)) {\n    case EST_INACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            break;\n        }\n        ehci_set_state(ehci, async, EST_ACTIVE);\n        // No break, fall through to ACTIVE\n\n    case EST_ACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            ehci_queues_rip_all(ehci, async);\n            ehci_set_state(ehci, async, EST_INACTIVE);\n            break;\n        }\n\n        /* make sure guest has acknowledged the doorbell interrupt */\n        /* TO-DO: is this really needed? */\n        if (ehci->usbsts & USBSTS_IAA) {\n            DPRINTF(\"IAA status bit still set.\\n\");\n            break;\n        }\n\n        /* check that address register has been set */\n        if (ehci->asynclistaddr == 0) {\n            break;\n        }\n\n        ehci_set_state(ehci, async, EST_WAITLISTHEAD);\n        ehci_advance_state(ehci, async);\n\n        /* If the doorbell is set, the guest wants to make a change to the\n         * schedule. The host controller needs to release cached data.\n         * (section 4.8.2)\n         */\n        if (ehci->usbcmd & USBCMD_IAAD) {\n            /* Remove all unseen qhs from the async qhs queue */\n            ehci_queues_rip_unseen(ehci, async);\n            trace_usb_ehci_doorbell_ack();\n            ehci->usbcmd &= ~USBCMD_IAAD;\n            ehci_raise_irq(ehci, USBSTS_IAA);\n        }\n        break;\n\n    default:\n        /* this should only be due to a developer mistake */\n        fprintf(stderr, \"ehci: Bad asynchronous state %d. \"\n                \"Resetting to active\\n\", ehci->astate);\n        g_assert_not_reached();\n    }\n}\n",
        "linevul": 4.609753523254767e-05
    },
    {
        "code": "iscsi_abort_task_cb(struct iscsi_context *iscsi, int status, void *command_data,\n                    void *private_data)\n{\n    IscsiAIOCB *acb = private_data;\n\n    acb->status = -ECANCELED;\n    iscsi_schedule_bh(acb);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_abort_task_cb(struct iscsi_context *iscsi, int status, void *command_data,\n                    void *private_data)\n{\n    IscsiAIOCB *acb = private_data;\n\n    acb->status = -ECANCELED;\n    iscsi_schedule_bh(acb);\n}\n",
        "linevul": 4.660105696530081e-05
    },
    {
        "code": "pvscsi_pre_save(void *opaque)\n{\n    PVSCSIState *s = (PVSCSIState *) opaque;\n\n    trace_pvscsi_state(\"presave\");\n\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    assert(QTAILQ_EMPTY(&s->completion_queue));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": "pvscsi_pre_save(void *opaque)\n{\n    PVSCSIState *s = (PVSCSIState *) opaque;\n\n    trace_pvscsi_state(\"presave\");\n\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    assert(QTAILQ_EMPTY(&s->completion_queue));\n}\n",
        "linevul": 4.639942926587537e-05
    },
    {
        "code": "static void ide_cfata_identify_size(IDEState *s)\n{\n    uint16_t *p = (uint16_t *)s->identify_data;\n    put_le16(p + 7, s->nb_sectors >> 16);  /* Sectors per card */\n    put_le16(p + 8, s->nb_sectors);        /* Sectors per card */\n    put_le16(p + 60, s->nb_sectors);       /* Total LBA sectors */\n    put_le16(p + 61, s->nb_sectors >> 16); /* Total LBA sectors */\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_cfata_identify_size(IDEState *s)\n{\n    uint16_t *p = (uint16_t *)s->identify_data;\n    put_le16(p + 7, s->nb_sectors >> 16);  /* Sectors per card */\n    put_le16(p + 8, s->nb_sectors);        /* Sectors per card */\n    put_le16(p + 60, s->nb_sectors);       /* Total LBA sectors */\n    put_le16(p + 61, s->nb_sectors >> 16); /* Total LBA sectors */\n}\n",
        "linevul": 4.748268111143261e-05
    },
    {
        "code": "static void v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    /*\n     * Currently we only support BASIC fields in stat, so there is no\n     * need to look at request_mask.\n     */\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n    /*  fill st_gen if requested and supported by underlying fs */\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            /* we have valid st_gen: update result mask */\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            /* request cancelled, e.g. by Tflush */\n            goto out;\n        default:\n            /* failed to get st_gen: not fatal, ignore */\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    /*\n     * Currently we only support BASIC fields in stat, so there is no\n     * need to look at request_mask.\n     */\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n    /*  fill st_gen if requested and supported by underlying fs */\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            /* we have valid st_gen: update result mask */\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            /* request cancelled, e.g. by Tflush */\n            goto out;\n        default:\n            /* failed to get st_gen: not fatal, ignore */\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n",
        "linevul": 9.192575816996396e-05
    },
    {
        "code": "static void vga_update_memory_access(VGACommonState *s)\n{\n    hwaddr base, offset, size;\n\n    if (s->legacy_address_space == NULL) {\n        return;\n    }\n\n    if (s->has_chain4_alias) {\n        memory_region_del_subregion(s->legacy_address_space, &s->chain4_alias);\n        object_unparent(OBJECT(&s->chain4_alias));\n        s->has_chain4_alias = false;\n        s->plane_updated = 0xf;\n    }\n    if ((s->sr[VGA_SEQ_PLANE_WRITE] & VGA_SR02_ALL_PLANES) ==\n        VGA_SR02_ALL_PLANES && s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n        offset = 0;\n        switch ((s->gr[VGA_GFX_MISC] >> 2) & 3) {\n        case 0:\n            base = 0xa0000;\n            size = 0x20000;\n            break;\n        case 1:\n            base = 0xa0000;\n            size = 0x10000;\n            offset = s->bank_offset;\n            break;\n        case 2:\n            base = 0xb0000;\n            size = 0x8000;\n            break;\n        case 3:\n        default:\n            base = 0xb8000;\n            size = 0x8000;\n            break;\n        }\n        base += isa_mem_base;\n        memory_region_init_alias(&s->chain4_alias, memory_region_owner(&s->vram),\n                                 \"vga.chain4\", &s->vram, offset, size);\n        memory_region_add_subregion_overlap(s->legacy_address_space, base,\n                                            &s->chain4_alias, 2);\n        s->has_chain4_alias = true;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=c1b886c45dc70f247300f549dce9833f3fa2def5",
        "vul_func_with_fix": "static void vga_update_memory_access(VGACommonState *s)\n{\n    hwaddr base, offset, size;\n\n    if (s->legacy_address_space == NULL) {\n        return;\n    }\n\n    if (s->has_chain4_alias) {\n        memory_region_del_subregion(s->legacy_address_space, &s->chain4_alias);\n        object_unparent(OBJECT(&s->chain4_alias));\n        s->has_chain4_alias = false;\n        s->plane_updated = 0xf;\n    }\n    if ((s->sr[VGA_SEQ_PLANE_WRITE] & VGA_SR02_ALL_PLANES) ==\n        VGA_SR02_ALL_PLANES && s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n        offset = 0;\n        switch ((s->gr[VGA_GFX_MISC] >> 2) & 3) {\n        case 0:\n            base = 0xa0000;\n            size = 0x20000;\n            break;\n        case 1:\n            base = 0xa0000;\n            size = 0x10000;\n            offset = s->bank_offset;\n            break;\n        case 2:\n            base = 0xb0000;\n            size = 0x8000;\n            break;\n        case 3:\n        default:\n            base = 0xb8000;\n            size = 0x8000;\n            break;\n        }\n        base += isa_mem_base;\n        memory_region_init_alias(&s->chain4_alias, memory_region_owner(&s->vram),\n                                 \"vga.chain4\", &s->vram, offset, size);\n        memory_region_add_subregion_overlap(s->legacy_address_space, base,\n                                            &s->chain4_alias, 2);\n        s->has_chain4_alias = true;\n    }\n}\n",
        "linevul": 5.052045889897272e-05
    },
    {
        "code": "static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (qemu_has_vnet_hdr(nc->peer)) {\n        return true;\n    }\n\n    VMW_WRPRN(\"Peer has no virtio extension. Task offloads will be emulated.\");\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484",
        "vul_func_with_fix": "static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (qemu_has_vnet_hdr(nc->peer)) {\n        return true;\n    }\n\n    VMW_WRPRN(\"Peer has no virtio extension. Task offloads will be emulated.\");\n    return false;\n}\n",
        "linevul": 4.880851702182554e-05
    },
    {
        "code": "iscsi_co_writev_flags(BlockDriverState *bs, int64_t sector_num, int nb_sectors,\n                      QEMUIOVector *iov, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct IscsiTask iTask;\n    uint64_t lba;\n    uint32_t num_sectors;\n    bool fua = flags & BDRV_REQ_FUA;\n\n    if (fua) {\n        assert(iscsilun->dpofua);\n    }\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n        return -EINVAL;\n    }\n\n    if (bs->bl.max_transfer_length && nb_sectors > bs->bl.max_transfer_length) {\n        error_report(\"iSCSI Error: Write of %d sectors exceeds max_xfer_len \"\n                     \"of %d sectors\", nb_sectors, bs->bl.max_transfer_length);\n        return -EINVAL;\n    }\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n    num_sectors = sector_qemu2lun(nb_sectors, iscsilun);\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\nretry:\n    if (iscsilun->use_16_for_rw) {\n        iTask.task = iscsi_write16_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    } else {\n        iTask.task = iscsi_write10_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    }\n    if (iTask.task == NULL) {\n        return -ENOMEM;\n    }\n    scsi_task_set_iov_out(iTask.task, (struct scsi_iovec *) iov->iov,\n                          iov->niov);\n    while (!iTask.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_coroutine_yield();\n    }\n\n    if (iTask.task != NULL) {\n        scsi_free_scsi_task(iTask.task);\n        iTask.task = NULL;\n    }\n\n    if (iTask.do_retry) {\n        iTask.complete = 0;\n        goto retry;\n    }\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n        return iTask.err_code;\n    }\n\n    iscsi_allocationmap_set(iscsilun, sector_num, nb_sectors);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_co_writev_flags(BlockDriverState *bs, int64_t sector_num, int nb_sectors,\n                      QEMUIOVector *iov, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct IscsiTask iTask;\n    uint64_t lba;\n    uint32_t num_sectors;\n    bool fua = flags & BDRV_REQ_FUA;\n\n    if (fua) {\n        assert(iscsilun->dpofua);\n    }\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n        return -EINVAL;\n    }\n\n    if (bs->bl.max_transfer_length && nb_sectors > bs->bl.max_transfer_length) {\n        error_report(\"iSCSI Error: Write of %d sectors exceeds max_xfer_len \"\n                     \"of %d sectors\", nb_sectors, bs->bl.max_transfer_length);\n        return -EINVAL;\n    }\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n    num_sectors = sector_qemu2lun(nb_sectors, iscsilun);\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\nretry:\n    if (iscsilun->use_16_for_rw) {\n        iTask.task = iscsi_write16_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    } else {\n        iTask.task = iscsi_write10_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    }\n    if (iTask.task == NULL) {\n        return -ENOMEM;\n    }\n    scsi_task_set_iov_out(iTask.task, (struct scsi_iovec *) iov->iov,\n                          iov->niov);\n    while (!iTask.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_coroutine_yield();\n    }\n\n    if (iTask.task != NULL) {\n        scsi_free_scsi_task(iTask.task);\n        iTask.task = NULL;\n    }\n\n    if (iTask.do_retry) {\n        iTask.complete = 0;\n        goto retry;\n    }\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n        return iTask.err_code;\n    }\n\n    iscsi_allocationmap_set(iscsilun, sector_num, nb_sectors);\n\n    return 0;\n}\n",
        "linevul": 0.0007140474626794457
    },
    {
        "code": "static void net_tx_pkt_rebuild_payload(struct NetTxPkt *pkt)\n{\n    pkt->payload_len = iov_size(pkt->raw, pkt->raw_frags) - pkt->hdr_len;\n    pkt->payload_frags = iov_copy(&pkt->vec[NET_TX_PKT_PL_START_FRAG],\n                                pkt->max_payload_frags,\n                                pkt->raw, pkt->raw_frags,\n                                pkt->hdr_len, pkt->payload_len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "static void net_tx_pkt_rebuild_payload(struct NetTxPkt *pkt)\n{\n    pkt->payload_len = iov_size(pkt->raw, pkt->raw_frags) - pkt->hdr_len;\n    pkt->payload_frags = iov_copy(&pkt->vec[NET_TX_PKT_PL_START_FRAG],\n                                pkt->max_payload_frags,\n                                pkt->raw, pkt->raw_frags,\n                                pkt->hdr_len, pkt->payload_len);\n}\n",
        "linevul": 5.7543446018826216e-05
    },
    {
        "code": "static void iscsi_allocationmap_clear(IscsiLun *iscsilun, int64_t sector_num,\n                                      int nb_sectors)\n{\n    int64_t cluster_num, nb_clusters;\n    if (iscsilun->allocationmap == NULL) {\n        return;\n    }\n    cluster_num = DIV_ROUND_UP(sector_num, iscsilun->cluster_sectors);\n    nb_clusters = (sector_num + nb_sectors) / iscsilun->cluster_sectors\n                  - cluster_num;\n    if (nb_clusters > 0) {\n        bitmap_clear(iscsilun->allocationmap, cluster_num, nb_clusters);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_allocationmap_clear(IscsiLun *iscsilun, int64_t sector_num,\n                                      int nb_sectors)\n{\n    int64_t cluster_num, nb_clusters;\n    if (iscsilun->allocationmap == NULL) {\n        return;\n    }\n    cluster_num = DIV_ROUND_UP(sector_num, iscsilun->cluster_sectors);\n    nb_clusters = (sector_num + nb_sectors) / iscsilun->cluster_sectors\n                  - cluster_num;\n    if (nb_clusters > 0) {\n        bitmap_clear(iscsilun->allocationmap, cluster_num, nb_clusters);\n    }\n}\n",
        "linevul": 5.611166125163436e-05
    },
    {
        "code": "e1000e_set_ics(E1000ECore *core, int index, uint32_t val)\n{\n    trace_e1000e_irq_write_ics(val);\n    e1000e_set_interrupt_cause(core, val);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_set_ics(E1000ECore *core, int index, uint32_t val)\n{\n    trace_e1000e_irq_write_ics(val);\n    e1000e_set_interrupt_cause(core, val);\n}\n",
        "linevul": 5.535162199521437e-05
    },
    {
        "code": "static int handle_opendir(FsContext *ctx,\n                          V9fsPath *fs_path, V9fsFidOpenState *fs)\n{\n    int ret;\n    ret = handle_open(ctx, fs_path, O_DIRECTORY, fs);\n    if (ret < 0) {\n        return -1;\n    }\n    fs->dir.stream = fdopendir(ret);\n    if (!fs->dir.stream) {\n        return -1;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_opendir(FsContext *ctx,\n                          V9fsPath *fs_path, V9fsFidOpenState *fs)\n{\n    int ret;\n    ret = handle_open(ctx, fs_path, O_DIRECTORY, fs);\n    if (ret < 0) {\n        return -1;\n    }\n    fs->dir.stream = fdopendir(ret);\n    if (!fs->dir.stream) {\n        return -1;\n    }\n    return 0;\n}\n",
        "linevul": 5.34731698280666e-05
    },
    {
        "code": "static int coroutine_fn v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)\n{\n    int err = 1;\n    if (f->fid_type == P9_FID_FILE) {\n        if (f->fs.fd == -1) {\n            do {\n                err = v9fs_co_open(pdu, f, f->open_flags);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    } else if (f->fid_type == P9_FID_DIR) {\n        if (f->fs.dir.stream == NULL) {\n            do {\n                err = v9fs_co_opendir(pdu, f);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    }\n    return err;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)\n{\n    int err = 1;\n    if (f->fid_type == P9_FID_FILE) {\n        if (f->fs.fd == -1) {\n            do {\n                err = v9fs_co_open(pdu, f, f->open_flags);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    } else if (f->fid_type == P9_FID_DIR) {\n        if (f->fs.dir.stream == NULL) {\n            do {\n                err = v9fs_co_opendir(pdu, f);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    }\n    return err;\n}\n",
        "linevul": 0.00011803462984971702
    },
    {
        "code": "size_t mptsas_config_io_unit_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x01,\n                              \"*b*b*w*l\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_io_unit_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x01,\n                              \"*b*b*w*l\");\n}\n",
        "linevul": 5.106411117594689e-05
    },
    {
        "code": "static void gen_lea_modrm(CPUX86State *env, DisasContext *s, int modrm)\n{\n    AddressParts a = gen_lea_modrm_0(env, s, modrm);\n    TCGv ea = gen_lea_modrm_1(a);\n    gen_lea_v_seg(s, s->aflag, ea, a.def_seg, s->override);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_lea_modrm(CPUX86State *env, DisasContext *s, int modrm)\n{\n    AddressParts a = gen_lea_modrm_0(env, s, modrm);\n    TCGv ea = gen_lea_modrm_1(a);\n    gen_lea_v_seg(s, s->aflag, ea, a.def_seg, s->override);\n}\n",
        "linevul": 7.279474812094122e-05
    },
    {
        "code": "static uint64_t vmxnet3_get_mac_high(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[4]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[5]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static uint64_t vmxnet3_get_mac_high(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[4]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[5]);\n}\n",
        "linevul": 5.1787552365567535e-05
    },
    {
        "code": "static int coroutine_fn stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                                       const struct stat *stbuf,\n                                       V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=702dbcc274e2ca43be20ba64c758c0ca57dab91d",
        "vul_func_with_fix": "static int coroutine_fn stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                                       const struct stat *stbuf,\n                                       V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n",
        "linevul": 0.00010399038001196459
    },
    {
        "code": "static inline void gen_ins(DisasContext *s, TCGMemOp ot)\n{\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_start();\n    }\n    gen_string_movl_A0_EDI(s);\n    /* Note: we must do this dummy write first to be restartable in\n       case of page fault. */\n    tcg_gen_movi_tl(cpu_T0, 0);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n    gen_helper_in_func(ot, cpu_T0, cpu_tmp2_i32);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    gen_op_movl_T0_Dshift(ot);\n    gen_op_add_reg_T0(s->aflag, R_EDI);\n    gen_bpt_io(s, cpu_tmp2_i32, ot);\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_end();\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline void gen_ins(DisasContext *s, TCGMemOp ot)\n{\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_start();\n    }\n    gen_string_movl_A0_EDI(s);\n    /* Note: we must do this dummy write first to be restartable in\n       case of page fault. */\n    tcg_gen_movi_tl(cpu_T0, 0);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n    gen_helper_in_func(ot, cpu_T0, cpu_tmp2_i32);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    gen_op_movl_T0_Dshift(ot);\n    gen_op_add_reg_T0(s->aflag, R_EDI);\n    gen_bpt_io(s, cpu_tmp2_i32, ot);\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_end();\n    }\n}\n",
        "linevul": 6.282309186644852e-05
    },
    {
        "code": "vmxnet3_on_rx_done_update_stats(VMXNET3State *s,\n                                int qidx,\n                                Vmxnet3PktStatus status)\n{\n    struct UPT1_RxStats *stats = &s->rxq_descr[qidx].rxq_stats;\n    size_t tot_len = net_rx_pkt_get_total_len(s->rx_pkt);\n\n    switch (status) {\n    case VMXNET3_PKT_STATUS_OUT_OF_BUF:\n        stats->pktsRxOutOfBuf++;\n        break;\n\n    case VMXNET3_PKT_STATUS_ERROR:\n        stats->pktsRxError++;\n        break;\n    case VMXNET3_PKT_STATUS_OK:\n        switch (net_rx_pkt_get_packet_type(s->rx_pkt)) {\n        case ETH_PKT_BCAST:\n            stats->bcastPktsRxOK++;\n            stats->bcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_MCAST:\n            stats->mcastPktsRxOK++;\n            stats->mcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_UCAST:\n            stats->ucastPktsRxOK++;\n            stats->ucastBytesRxOK += tot_len;\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (tot_len > s->mtu) {\n            stats->LROPktsRxOK++;\n            stats->LROBytesRxOK += tot_len;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_on_rx_done_update_stats(VMXNET3State *s,\n                                int qidx,\n                                Vmxnet3PktStatus status)\n{\n    struct UPT1_RxStats *stats = &s->rxq_descr[qidx].rxq_stats;\n    size_t tot_len = net_rx_pkt_get_total_len(s->rx_pkt);\n\n    switch (status) {\n    case VMXNET3_PKT_STATUS_OUT_OF_BUF:\n        stats->pktsRxOutOfBuf++;\n        break;\n\n    case VMXNET3_PKT_STATUS_ERROR:\n        stats->pktsRxError++;\n        break;\n    case VMXNET3_PKT_STATUS_OK:\n        switch (net_rx_pkt_get_packet_type(s->rx_pkt)) {\n        case ETH_PKT_BCAST:\n            stats->bcastPktsRxOK++;\n            stats->bcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_MCAST:\n            stats->mcastPktsRxOK++;\n            stats->mcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_UCAST:\n            stats->ucastPktsRxOK++;\n            stats->ucastBytesRxOK += tot_len;\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (tot_len > s->mtu) {\n            stats->LROPktsRxOK++;\n            stats->LROBytesRxOK += tot_len;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n}\n",
        "linevul": 5.211512325331569e-05
    },
    {
        "code": "static int megasas_cluster_reset_ld(MegasasState *s, MegasasCmd *cmd)\n{\n    uint16_t target_id;\n    int i;\n\n    /* mbox0 contains the device index */\n    target_id = le16_to_cpu(cmd->frame->dcmd.mbox[0]);\n    trace_megasas_dcmd_reset_ld(cmd->index, target_id);\n    for (i = 0; i < s->fw_cmds; i++) {\n        MegasasCmd *tmp_cmd = &s->frames[i];\n        if (tmp_cmd->req && tmp_cmd->req->dev->id == target_id) {\n            SCSIDevice *d = tmp_cmd->req->dev;\n            qdev_reset_all(&d->qdev);\n        }\n    }\n    return MFI_STAT_OK;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_cluster_reset_ld(MegasasState *s, MegasasCmd *cmd)\n{\n    uint16_t target_id;\n    int i;\n\n    /* mbox0 contains the device index */\n    target_id = le16_to_cpu(cmd->frame->dcmd.mbox[0]);\n    trace_megasas_dcmd_reset_ld(cmd->index, target_id);\n    for (i = 0; i < s->fw_cmds; i++) {\n        MegasasCmd *tmp_cmd = &s->frames[i];\n        if (tmp_cmd->req && tmp_cmd->req->dev->id == target_id) {\n            SCSIDevice *d = tmp_cmd->req->dev;\n            qdev_reset_all(&d->qdev);\n        }\n    }\n    return MFI_STAT_OK;\n}\n",
        "linevul": 5.313655856298283e-05
    },
    {
        "code": "static void gen_shiftd_rm_T1(DisasContext *s, TCGMemOp ot, int op1,\n                             bool is_right, TCGv count_in)\n{\n    target_ulong mask = (ot == MO_64 ? 63 : 31);\n    TCGv count;\n\n    /* load */\n    if (op1 == OR_TMP0) {\n        gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n    } else {\n        gen_op_mov_v_reg(ot, cpu_T0, op1);\n    }\n\n    count = tcg_temp_new();\n    tcg_gen_andi_tl(count, count_in, mask);\n\n    switch (ot) {\n    case MO_16:\n        /* Note: we implement the Intel behaviour for shift count > 16.\n           This means \"shrdw C, B, A\" shifts A:B:A >> C.  Build the B:A\n           portion by constructing it as a 32-bit value.  */\n        if (is_right) {\n            tcg_gen_deposit_tl(cpu_tmp0, cpu_T0, cpu_T1, 16, 16);\n            tcg_gen_mov_tl(cpu_T1, cpu_T0);\n            tcg_gen_mov_tl(cpu_T0, cpu_tmp0);\n        } else {\n            tcg_gen_deposit_tl(cpu_T1, cpu_T0, cpu_T1, 16, 16);\n        }\n        /* FALLTHRU */\n#ifdef TARGET_X86_64\n    case MO_32:\n        /* Concatenate the two 32-bit values and use a 64-bit shift.  */\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_shr_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shr_i64(cpu_T0, cpu_T0, count);\n        } else {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T1, cpu_T0);\n            tcg_gen_shl_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shl_i64(cpu_T0, cpu_T0, count);\n            tcg_gen_shri_i64(cpu_tmp0, cpu_tmp0, 32);\n            tcg_gen_shri_i64(cpu_T0, cpu_T0, 32);\n        }\n        break;\n#endif\n    default:\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_shr_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shr_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        } else {\n            tcg_gen_shl_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n            if (ot == MO_16) {\n                /* Only needed if count > 16, for Intel behaviour.  */\n                tcg_gen_subfi_tl(cpu_tmp4, 33, count);\n                tcg_gen_shr_tl(cpu_tmp4, cpu_T1, cpu_tmp4);\n                tcg_gen_or_tl(cpu_tmp0, cpu_tmp0, cpu_tmp4);\n            }\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shl_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shr_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        }\n        tcg_gen_movi_tl(cpu_tmp4, 0);\n        tcg_gen_movcond_tl(TCG_COND_EQ, cpu_T1, count, cpu_tmp4,\n                           cpu_tmp4, cpu_T1);\n        tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_T1);\n        break;\n    }\n\n    /* store */\n    gen_op_st_rm_T0_A0(s, ot, op1);\n\n    gen_shift_flags(s, ot, cpu_T0, cpu_tmp0, count, is_right);\n    tcg_temp_free(count);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_shiftd_rm_T1(DisasContext *s, TCGMemOp ot, int op1,\n                             bool is_right, TCGv count_in)\n{\n    target_ulong mask = (ot == MO_64 ? 63 : 31);\n    TCGv count;\n\n    /* load */\n    if (op1 == OR_TMP0) {\n        gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n    } else {\n        gen_op_mov_v_reg(ot, cpu_T0, op1);\n    }\n\n    count = tcg_temp_new();\n    tcg_gen_andi_tl(count, count_in, mask);\n\n    switch (ot) {\n    case MO_16:\n        /* Note: we implement the Intel behaviour for shift count > 16.\n           This means \"shrdw C, B, A\" shifts A:B:A >> C.  Build the B:A\n           portion by constructing it as a 32-bit value.  */\n        if (is_right) {\n            tcg_gen_deposit_tl(cpu_tmp0, cpu_T0, cpu_T1, 16, 16);\n            tcg_gen_mov_tl(cpu_T1, cpu_T0);\n            tcg_gen_mov_tl(cpu_T0, cpu_tmp0);\n        } else {\n            tcg_gen_deposit_tl(cpu_T1, cpu_T0, cpu_T1, 16, 16);\n        }\n        /* FALLTHRU */\n#ifdef TARGET_X86_64\n    case MO_32:\n        /* Concatenate the two 32-bit values and use a 64-bit shift.  */\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_shr_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shr_i64(cpu_T0, cpu_T0, count);\n        } else {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T1, cpu_T0);\n            tcg_gen_shl_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shl_i64(cpu_T0, cpu_T0, count);\n            tcg_gen_shri_i64(cpu_tmp0, cpu_tmp0, 32);\n            tcg_gen_shri_i64(cpu_T0, cpu_T0, 32);\n        }\n        break;\n#endif\n    default:\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_shr_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shr_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        } else {\n            tcg_gen_shl_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n            if (ot == MO_16) {\n                /* Only needed if count > 16, for Intel behaviour.  */\n                tcg_gen_subfi_tl(cpu_tmp4, 33, count);\n                tcg_gen_shr_tl(cpu_tmp4, cpu_T1, cpu_tmp4);\n                tcg_gen_or_tl(cpu_tmp0, cpu_tmp0, cpu_tmp4);\n            }\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shl_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shr_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        }\n        tcg_gen_movi_tl(cpu_tmp4, 0);\n        tcg_gen_movcond_tl(TCG_COND_EQ, cpu_T1, count, cpu_tmp4,\n                           cpu_tmp4, cpu_T1);\n        tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_T1);\n        break;\n    }\n\n    /* store */\n    gen_op_st_rm_T0_A0(s, ot, op1);\n\n    gen_shift_flags(s, ot, cpu_T0, cpu_tmp0, count, is_right);\n    tcg_temp_free(count);\n}\n",
        "linevul": 4.67812133138068e-05
    },
    {
        "code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n \n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n    if (blit_is_unsafe(s, false))\n        return 0;\n\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=f153b563f8cf121aebf5a2fff5f0110faf58ccb3",
        "vul_func_with_fix": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n \n//fix_flaw_line_below:\n//    if (off_pitch < 0) {\n//fix_flaw_line_below:\n//        off_begin -= bytesperline - 1;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n//fix_flaw_line_below:\n//        assert(off_cur_end >= off_cur);\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n    if (blit_is_unsafe(s, false))\n        return 0;\n\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}\n",
        "linevul": 0.9975045323371887
    },
    {
        "code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n     unsigned num_sg = *p_num_sg;\n     assert(num_sg <= max_num_sg);\n \n     while (sz) {\n         hwaddr len = sz;\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n     unsigned num_sg = *p_num_sg;\n     assert(num_sg <= max_num_sg);\n \n//fix_flaw_line_below:\n//    if (!sz) {\n//fix_flaw_line_below:\n//        error_report(\"virtio: zero sized buffers are not allowed\");\n//fix_flaw_line_below:\n//        exit(1);\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     while (sz) {\n         hwaddr len = sz;\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}\n",
        "linevul": 0.9966753721237183
    },
    {
        "code": "static bool vring_notify(VirtIODevice *vdev, VirtQueue *vq)\n{\n    uint16_t old, new;\n    bool v;\n    /* We need to expose used array entries before checking used event. */\n    smp_mb();\n    /* Always notify when queue is empty (when feature acknowledge) */\n    if (((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n         !vq->inuse && vring_avail_idx(vq) == vq->last_avail_idx)) {\n        return true;\n    }\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n        return !(vring_avail_flags(vq) & VRING_AVAIL_F_NO_INTERRUPT);\n    }\n\n    v = vq->signalled_used_valid;\n    vq->signalled_used_valid = true;\n    old = vq->signalled_used;\n    new = vq->signalled_used = vring_used_idx(vq);\n    return !v || vring_need_event(vring_used_event(vq), new, old);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "static bool vring_notify(VirtIODevice *vdev, VirtQueue *vq)\n{\n    uint16_t old, new;\n    bool v;\n    /* We need to expose used array entries before checking used event. */\n    smp_mb();\n    /* Always notify when queue is empty (when feature acknowledge) */\n    if (((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n         !vq->inuse && vring_avail_idx(vq) == vq->last_avail_idx)) {\n        return true;\n    }\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n        return !(vring_avail_flags(vq) & VRING_AVAIL_F_NO_INTERRUPT);\n    }\n\n    v = vq->signalled_used_valid;\n    vq->signalled_used_valid = true;\n    old = vq->signalled_used;\n    new = vq->signalled_used = vring_used_idx(vq);\n    return !v || vring_need_event(vring_used_event(vq), new, old);\n}\n",
        "linevul": 5.990957288304344e-05
    },
    {
        "code": "vmxnet3_dump_conf_descr(const char *name,\n                        struct Vmxnet3_VariableLenConfDesc *pm_descr)\n{\n    VMW_CFPRN(\"%s descriptor dump: Version %u, Length %u\",\n              name, pm_descr->confVer, pm_descr->confLen);\n\n};\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_dump_conf_descr(const char *name,\n                        struct Vmxnet3_VariableLenConfDesc *pm_descr)\n{\n    VMW_CFPRN(\"%s descriptor dump: Version %u, Length %u\",\n              name, pm_descr->confVer, pm_descr->confLen);\n\n};\n",
        "linevul": 4.925194662064314e-05
    },
    {
        "code": "static int put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static int put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "linevul": 0.00016637856606394053
    },
    {
        "code": "static void GCC_FMT_ATTR(3, 4) report_unsupported(BlockDriverState *bs,\n    Error **errp, const char *fmt, ...)\n{\n    char msg[64];\n    va_list ap;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE, bs->device_name, \"qcow2\",\n              msg);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static void GCC_FMT_ATTR(3, 4) report_unsupported(BlockDriverState *bs,\n    Error **errp, const char *fmt, ...)\n{\n    char msg[64];\n    va_list ap;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE, bs->device_name, \"qcow2\",\n              msg);\n}\n",
        "linevul": 4.8361136578023434e-05
    },
    {
        "code": "static inline bool stellaris_tx_thr_reached(stellaris_enet_state *s)\n{\n    return (s->thr < 0x3f &&\n            (s->tx_fifo_len >= 4 * (s->thr * 8 + 1)));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3a15cc0e1ee7168db0782133d2607a6bfa422d66",
        "vul_func_with_fix": "static inline bool stellaris_tx_thr_reached(stellaris_enet_state *s)\n{\n    return (s->thr < 0x3f &&\n            (s->tx_fifo_len >= 4 * (s->thr * 8 + 1)));\n}\n",
        "linevul": 5.7401932281209156e-05
    },
    {
        "code": "e1000e_ring_head_descr(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return e1000e_ring_base(core, r) + E1000_RING_DESC_LEN * core->mac[r->dh];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_ring_head_descr(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return e1000e_ring_base(core, r) + E1000_RING_DESC_LEN * core->mac[r->dh];\n}\n",
        "linevul": 4.9950478569371626e-05
    },
    {
        "code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n//fix_flaw_line_below:\n//    if (s->stop <= s->start) {\n//fix_flaw_line_below:\n//        return 1;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
        "linevul": 0.999388575553894
    },
    {
        "code": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n                        void *opaque)\n{\n    VMStateField *field = vmsd->fields;\n\n    if (vmsd->pre_save) {\n        vmsd->pre_save(opaque);\n    }\n    while (field->name) {\n        if (!field->field_exists ||\n            field->field_exists(opaque, vmsd->version_id)) {\n            void *base_addr = vmstate_base_addr(opaque, field);\n            int i, n_elems = vmstate_n_elems(opaque, field);\n            int size = vmstate_size(opaque, field);\n\n            for (i = 0; i < n_elems; i++) {\n                void *addr = base_addr + size * i;\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n                    addr = *(void **)addr;\n                }\n                if (field->flags & VMS_STRUCT) {\n                    vmstate_save_state(f, field->vmsd, addr);\n                } else {\n                    field->info->put(f, addr, size);\n                }\n            }\n        } else {\n            if (field->flags & VMS_MUST_EXIST) {\n                fprintf(stderr, \"Output state validation failed: %s/%s\\n\",\n                        vmsd->name, field->name);\n                assert(!(field->flags & VMS_MUST_EXIST));\n            }\n        }\n        field++;\n    }\n    vmstate_subsection_save(f, vmsd, opaque);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n                        void *opaque)\n{\n    VMStateField *field = vmsd->fields;\n\n    if (vmsd->pre_save) {\n        vmsd->pre_save(opaque);\n    }\n    while (field->name) {\n        if (!field->field_exists ||\n            field->field_exists(opaque, vmsd->version_id)) {\n            void *base_addr = vmstate_base_addr(opaque, field);\n            int i, n_elems = vmstate_n_elems(opaque, field);\n            int size = vmstate_size(opaque, field);\n\n            for (i = 0; i < n_elems; i++) {\n                void *addr = base_addr + size * i;\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n                    addr = *(void **)addr;\n                }\n                if (field->flags & VMS_STRUCT) {\n                    vmstate_save_state(f, field->vmsd, addr);\n                } else {\n                    field->info->put(f, addr, size);\n                }\n            }\n        } else {\n            if (field->flags & VMS_MUST_EXIST) {\n                fprintf(stderr, \"Output state validation failed: %s/%s\\n\",\n                        vmsd->name, field->name);\n                assert(!(field->flags & VMS_MUST_EXIST));\n            }\n        }\n        field++;\n    }\n    vmstate_subsection_save(f, vmsd, opaque);\n}\n",
        "linevul": 7.30837564333342e-05
    },
    {
        "code": " static int get_int32_le(QEMUFile *f, void *pv, size_t size)\n {\n    int32_t loaded;\n     int32_t loaded;\n     qemu_get_sbe32s(f, &loaded);\n \n    if (loaded <= *cur) {\n         *cur = loaded;\n         return 0;\n     }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": " static int get_int32_le(QEMUFile *f, void *pv, size_t size)\n {\n    int32_t loaded;\n     int32_t loaded;\n     qemu_get_sbe32s(f, &loaded);\n \n//flaw_line_below:\n    if (loaded <= *cur) {\n//fix_flaw_line_below:\n//    if (loaded >= 0 && loaded <= *cur) {\n         *cur = loaded;\n         return 0;\n     }\n}\n",
        "linevul": 0.9992620348930359
    },
    {
        "code": "e1000e_process_snap_option(E1000ECore *core, uint32_t cmd_and_length)\n{\n    if (cmd_and_length & E1000_TXD_CMD_SNAP) {\n        trace_e1000e_wrn_no_snap_support();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_process_snap_option(E1000ECore *core, uint32_t cmd_and_length)\n{\n    if (cmd_and_length & E1000_TXD_CMD_SNAP) {\n        trace_e1000e_wrn_no_snap_support();\n    }\n}\n",
        "linevul": 5.3890591516392305e-05
    },
    {
        "code": "static ssize_t fremovexattrat_nofollow(int dirfd, const char *filename,\n                                       const char *name)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = lremovexattr(proc_path, name);\n    g_free(proc_path);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "static ssize_t fremovexattrat_nofollow(int dirfd, const char *filename,\n                                       const char *name)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = lremovexattr(proc_path, name);\n    g_free(proc_path);\n    return ret;\n}\n",
        "linevul": 5.283158316160552e-05
    },
    {
        "code": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n{\n    printf(\"%s: what are we supposed to return?\\n\", __func__);\n    return 0xcafe;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n{\n    printf(\"%s: what are we supposed to return?\\n\", __func__);\n    return 0xcafe;\n}\n",
        "linevul": 5.044622957939282e-05
    },
    {
        "code": "static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "linevul": 6.743663834640756e-05
    },
    {
        "code": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n \n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n \n//fix_flaw_line_below:\n//    switch (bits_per_pixel) {\n//fix_flaw_line_below:\n//    case 8:\n//fix_flaw_line_below:\n//    case 16:\n//fix_flaw_line_below:\n//    case 32:\n//fix_flaw_line_below:\n//        break;\n//fix_flaw_line_below:\n//    default:\n//fix_flaw_line_below:\n//        vnc_client_error(vs);\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n",
        "linevul": 0.9960359930992126
    },
    {
        "code": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n \n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n        return;\n    }\n     /* Read the message header from the guest first. */\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=06630554ccbdd25780aa03c3548aaff1eb56dffd",
        "vul_func_with_fix": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n \n//flaw_line_below:\n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n//flaw_line_below:\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n//flaw_line_below:\n        return;\n//flaw_line_below:\n    }\n//flaw_line_below:\n\n     /* Read the message header from the guest first. */\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }\n",
        "linevul": 0.9969598054885864
    },
    {
        "code": "static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)\n{\n    hwaddr pa;\n    pa = vq->vring.avail + offsetof(VRingAvail, ring[i]);\n    return lduw_phys(&address_space_memory, pa);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)\n{\n    hwaddr pa;\n    pa = vq->vring.avail + offsetof(VRingAvail, ring[i]);\n    return lduw_phys(&address_space_memory, pa);\n}\n",
        "linevul": 4.971420639776625e-05
    },
    {
        "code": "static uint32_t vmxnet3_get_interrupt_config(VMXNET3State *s)\n{\n    uint32_t interrupt_mode = VMXNET3_IT_AUTO | (VMXNET3_IMM_AUTO << 2);\n    VMW_CFPRN(\"Interrupt config is 0x%X\", interrupt_mode);\n    return interrupt_mode;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static uint32_t vmxnet3_get_interrupt_config(VMXNET3State *s)\n{\n    uint32_t interrupt_mode = VMXNET3_IT_AUTO | (VMXNET3_IMM_AUTO << 2);\n    VMW_CFPRN(\"Interrupt config is 0x%X\", interrupt_mode);\n    return interrupt_mode;\n}\n",
        "linevul": 5.0134160119341686e-05
    },
    {
        "code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n     assert(s->cirrus_blt_width > 0);\n     assert(s->cirrus_blt_height > 0);\n \n     if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                               s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n         return true;\n    }\n\n    return false;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n     assert(s->cirrus_blt_width > 0);\n     assert(s->cirrus_blt_height > 0);\n \n//fix_flaw_line_below:\n//    if (s->cirrus_blt_width > CIRRUS_BLTBUFSIZE) {\n//fix_flaw_line_below:\n//        return true;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                               s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n         return true;\n    }\n\n    return false;\n}\n",
        "linevul": 0.9970898628234863
    },
    {
        "code": "static int virtio_net_handle_vlan_table(VirtIONet *n, uint8_t cmd,\n                                        struct iovec *iov, unsigned int iov_cnt)\n{\n    uint16_t vid;\n    size_t s;\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    s = iov_to_buf(iov, iov_cnt, 0, &vid, sizeof(vid));\n    vid = lduw_p(&vid);\n    if (s != sizeof(vid)) {\n        return VIRTIO_NET_ERR;\n    }\n\n    if (vid >= MAX_VLAN)\n        return VIRTIO_NET_ERR;\n\n    if (cmd == VIRTIO_NET_CTRL_VLAN_ADD)\n        n->vlans[vid >> 5] |= (1U << (vid & 0x1f));\n    else if (cmd == VIRTIO_NET_CTRL_VLAN_DEL)\n        n->vlans[vid >> 5] &= ~(1U << (vid & 0x1f));\n    else\n        return VIRTIO_NET_ERR;\n\n    rxfilter_notify(nc);\n\n    return VIRTIO_NET_OK;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static int virtio_net_handle_vlan_table(VirtIONet *n, uint8_t cmd,\n                                        struct iovec *iov, unsigned int iov_cnt)\n{\n    uint16_t vid;\n    size_t s;\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    s = iov_to_buf(iov, iov_cnt, 0, &vid, sizeof(vid));\n    vid = lduw_p(&vid);\n    if (s != sizeof(vid)) {\n        return VIRTIO_NET_ERR;\n    }\n\n    if (vid >= MAX_VLAN)\n        return VIRTIO_NET_ERR;\n\n    if (cmd == VIRTIO_NET_CTRL_VLAN_ADD)\n        n->vlans[vid >> 5] |= (1U << (vid & 0x1f));\n    else if (cmd == VIRTIO_NET_CTRL_VLAN_DEL)\n        n->vlans[vid >> 5] &= ~(1U << (vid & 0x1f));\n    else\n        return VIRTIO_NET_ERR;\n\n    rxfilter_notify(nc);\n\n    return VIRTIO_NET_OK;\n}\n",
        "linevul": 4.65977682324592e-05
    },
    {
        "code": "vmxnet3_msix_save(QEMUFile *f, void *opaque)\n{\n    PCIDevice *d = PCI_DEVICE(opaque);\n    msix_save(d, f);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_msix_save(QEMUFile *f, void *opaque)\n{\n    PCIDevice *d = PCI_DEVICE(opaque);\n    msix_save(d, f);\n}\n",
        "linevul": 6.40894504613243e-05
    },
    {
        "code": "void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    unsigned int offset;\n    int i;\n\n    trace_virtqueue_fill(vq, elem, len, idx);\n\n    offset = 0;\n    for (i = 0; i < elem->in_num; i++) {\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n                                  elem->in_sg[i].iov_len,\n                                  1, size);\n\n        offset += size;\n    }\n\n    for (i = 0; i < elem->out_num; i++)\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n                                  elem->out_sg[i].iov_len,\n                                  0, elem->out_sg[i].iov_len);\n\n    idx = (idx + vring_used_idx(vq)) % vq->vring.num;\n\n    /* Get a pointer to the next entry in the used ring. */\n    vring_used_ring_id(vq, idx, elem->index);\n    vring_used_ring_len(vq, idx, len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    unsigned int offset;\n    int i;\n\n    trace_virtqueue_fill(vq, elem, len, idx);\n\n    offset = 0;\n    for (i = 0; i < elem->in_num; i++) {\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n                                  elem->in_sg[i].iov_len,\n                                  1, size);\n\n        offset += size;\n    }\n\n    for (i = 0; i < elem->out_num; i++)\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n                                  elem->out_sg[i].iov_len,\n                                  0, elem->out_sg[i].iov_len);\n\n    idx = (idx + vring_used_idx(vq)) % vq->vring.num;\n\n    /* Get a pointer to the next entry in the used ring. */\n    vring_used_ring_id(vq, idx, elem->index);\n    vring_used_ring_len(vq, idx, len);\n}\n",
        "linevul": 5.4456588259199634e-05
    },
    {
        "code": "static void ne2000_asic_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    NE2000State *s = opaque;\n\n#ifdef DEBUG_NE2000\n    printf(\"NE2000: asic write val=0x%04x\\n\", val);\n#endif\n    if (s->rcnt == 0)\n        return;\n    if (s->dcfg & 0x01) {\n        /* 16 bit access */\n        ne2000_mem_writew(s, s->rsar, val);\n        ne2000_dma_update(s, 2);\n    } else {\n        /* 8 bit access */\n        ne2000_mem_writeb(s, s->rsar, val);\n        ne2000_dma_update(s, 1);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static void ne2000_asic_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    NE2000State *s = opaque;\n\n#ifdef DEBUG_NE2000\n    printf(\"NE2000: asic write val=0x%04x\\n\", val);\n#endif\n    if (s->rcnt == 0)\n        return;\n    if (s->dcfg & 0x01) {\n        /* 16 bit access */\n        ne2000_mem_writew(s, s->rsar, val);\n        ne2000_dma_update(s, 2);\n    } else {\n        /* 8 bit access */\n        ne2000_mem_writeb(s, s->rsar, val);\n        ne2000_dma_update(s, 1);\n    }\n}\n",
        "linevul": 5.8526929933577776e-05
    },
    {
        "code": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n             cursor.bpp = vmsvga_fifo_read(s);\n \n             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n            if (cursor.width > 256 ||\n                cursor.height > 256 ||\n                cursor.bpp > 32 ||\n                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n                     goto badcmd;\n             }\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n             cursor.bpp = vmsvga_fifo_read(s);\n \n             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n//flaw_line_below:\n            if (cursor.width > 256 ||\n//flaw_line_below:\n                cursor.height > 256 ||\n//flaw_line_below:\n                cursor.bpp > 32 ||\n//flaw_line_below:\n                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n//flaw_line_below:\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n//fix_flaw_line_below:\n//            if (cursor.width > 256\n//fix_flaw_line_below:\n//                || cursor.height > 256\n//fix_flaw_line_below:\n//                || cursor.bpp > 32\n//fix_flaw_line_below:\n//                || SVGA_BITMAP_SIZE(x, y)\n//fix_flaw_line_below:\n//                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])\n//fix_flaw_line_below:\n//                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)\n//fix_flaw_line_below:\n//                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {\n                     goto badcmd;\n             }\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n",
        "linevul": 0.00021398261014837772
    },
    {
        "code": "static void ohci_roothub_reset(OHCIState *ohci)\n{\n    OHCIPort *port;\n    int i;\n\n    ohci_bus_stop(ohci);\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n    ohci->rhstatus = 0;\n\n    for (i = 0; i < ohci->num_ports; i++) {\n        port = &ohci->rhport[i];\n        port->ctrl = 0;\n        if (port->port.dev && port->port.dev->attached) {\n            usb_port_reset(&port->port);\n        }\n    }\n    if (ohci->async_td) {\n        usb_cancel_packet(&ohci->usb_packet);\n        ohci->async_td = 0;\n    }\n    ohci_stop_endpoints(ohci);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void ohci_roothub_reset(OHCIState *ohci)\n{\n    OHCIPort *port;\n    int i;\n\n    ohci_bus_stop(ohci);\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n    ohci->rhstatus = 0;\n\n    for (i = 0; i < ohci->num_ports; i++) {\n        port = &ohci->rhport[i];\n        port->ctrl = 0;\n        if (port->port.dev && port->port.dev->attached) {\n            usb_port_reset(&port->port);\n        }\n    }\n    if (ohci->async_td) {\n        usb_cancel_packet(&ohci->usb_packet);\n        ohci->async_td = 0;\n    }\n    ohci_stop_endpoints(ohci);\n}\n",
        "linevul": 4.6566492528654635e-05
    },
    {
        "code": "static void ssd0323_cd(void *opaque, int n, int level)\n{\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    DPRINTF(\"%s mode\\n\", level ? \"Data\" : \"Command\");\n    s->mode = level ? SSD0323_DATA : SSD0323_CMD;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ead7a57df37d2187813a121308213f41591bd811",
        "vul_func_with_fix": "static void ssd0323_cd(void *opaque, int n, int level)\n{\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    DPRINTF(\"%s mode\\n\", level ? \"Data\" : \"Command\");\n    s->mode = level ? SSD0323_DATA : SSD0323_CMD;\n}\n",
        "linevul": 4.821488982997835e-05
    },
    {
        "code": "int bdrv_create_file(const char* filename, QEMUOptionParameter *options,\n                     Error **errp)\n{\n    BlockDriver *drv;\n    Error *local_err = NULL;\n    int ret;\n\n    drv = bdrv_find_protocol(filename, true);\n    if (drv == NULL) {\n        error_setg(errp, \"Could not find protocol for file '%s'\", filename);\n        return -ENOENT;\n    }\n\n    ret = bdrv_create(drv, filename, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    }\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "int bdrv_create_file(const char* filename, QEMUOptionParameter *options,\n                     Error **errp)\n{\n    BlockDriver *drv;\n    Error *local_err = NULL;\n    int ret;\n\n    drv = bdrv_find_protocol(filename, true);\n    if (drv == NULL) {\n        error_setg(errp, \"Could not find protocol for file '%s'\", filename);\n        return -ENOENT;\n    }\n\n    ret = bdrv_create(drv, filename, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    }\n    return ret;\n}\n",
        "linevul": 4.9335249059367925e-05
    },
    {
        "code": "void ide_transfer_stop(IDEState *s)\n{\n    s->end_transfer_func = ide_transfer_stop;\n    s->data_ptr = s->io_buffer;\n    s->data_end = s->io_buffer;\n    s->status &= ~DRQ_STAT;\n    ide_cmd_done(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "void ide_transfer_stop(IDEState *s)\n{\n    s->end_transfer_func = ide_transfer_stop;\n    s->data_ptr = s->io_buffer;\n    s->data_end = s->io_buffer;\n    s->status &= ~DRQ_STAT;\n    ide_cmd_done(s);\n}\n",
        "linevul": 5.595494440058246e-05
    },
    {
        "code": "int pt_removexattr(FsContext *ctx, const char *path, const char *name)\n{\n    return local_removexattr_nofollow(ctx, path, name);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "int pt_removexattr(FsContext *ctx, const char *path, const char *name)\n{\n    return local_removexattr_nofollow(ctx, path, name);\n}\n",
        "linevul": 5.384210089687258e-05
    },
    {
        "code": "static int ehci_state_fetchsitd(EHCIState *ehci, int async)\n{\n    uint32_t entry;\n    EHCIsitd sitd;\n\n    assert(!async);\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    if (get_dwords(ehci, NLPTR_GET(entry), (uint32_t *)&sitd,\n                   sizeof(EHCIsitd) >> 2) < 0) {\n        return 0;\n    }\n    ehci_trace_sitd(ehci, entry, &sitd);\n\n    if (!(sitd.results & SITD_RESULTS_ACTIVE)) {\n        /* siTD is not active, nothing to do */;\n    } else {\n        /* TODO: split transfers are not implemented */\n        fprintf(stderr, \"WARNING: Skipping active siTD\\n\");\n    }\n\n    ehci_set_fetch_addr(ehci, async, sitd.next);\n    ehci_set_state(ehci, async, EST_FETCHENTRY);\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_state_fetchsitd(EHCIState *ehci, int async)\n{\n    uint32_t entry;\n    EHCIsitd sitd;\n\n    assert(!async);\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    if (get_dwords(ehci, NLPTR_GET(entry), (uint32_t *)&sitd,\n                   sizeof(EHCIsitd) >> 2) < 0) {\n        return 0;\n    }\n    ehci_trace_sitd(ehci, entry, &sitd);\n\n    if (!(sitd.results & SITD_RESULTS_ACTIVE)) {\n        /* siTD is not active, nothing to do */;\n    } else {\n        /* TODO: split transfers are not implemented */\n        fprintf(stderr, \"WARNING: Skipping active siTD\\n\");\n    }\n\n    ehci_set_fetch_addr(ehci, async, sitd.next);\n    ehci_set_state(ehci, async, EST_FETCHENTRY);\n    return 1;\n}\n",
        "linevul": 4.684701707446948e-05
    },
    {
        "code": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n    return core->mac[r->dh] == core->mac[r->dt];\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n//flaw_line_below:\n    return core->mac[r->dh] == core->mac[r->dt];\n//fix_flaw_line_below:\n//    return core->mac[r->dh] == core->mac[r->dt] ||\n//fix_flaw_line_below:\n//                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;\n }\n",
        "linevul": 9.258696081815287e-05
    },
    {
        "code": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n        uint32_t size;\n    } prd;\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n//fix_flaw_line_below:\n///**\n//fix_flaw_line_below:\n// * Return the number of bytes successfully prepared.\n//fix_flaw_line_below:\n// * -1 on error.\n//fix_flaw_line_below:\n// */\n//fix_flaw_line_below:\n//static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n        uint32_t size;\n    } prd;\n",
        "linevul": 0.02598501741886139
    },
    {
        "code": " static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n {\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n     qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     return r->qiov.size / 512;\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": " static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n {\n//flaw_line_below:\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n//fix_flaw_line_below:\n//    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    if (!r->iov.iov_base) {\n//fix_flaw_line_below:\n//        r->buflen = SCSI_DMA_BUF_SIZE;\n//fix_flaw_line_below:\n//        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n     qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     return r->qiov.size / 512;\n }\n",
        "linevul": 0.0013680682750418782
    },
    {
        "code": "static void ide_cfata_metadata_read(IDEState *s)\n{\n    uint16_t *p;\n\n    if (((s->hcyl << 16) | s->lcyl) << 9 > s->mdata_size + 2) {\n        s->status = ERR_STAT;\n        s->error = ABRT_ERR;\n        return;\n    }\n\n    p = (uint16_t *) s->io_buffer;\n    memset(p, 0, 0x200);\n\n    put_le16(p + 0, s->media_changed);\t\t/* Media status */\n    memcpy(p + 1, s->mdata_storage + (((s->hcyl << 16) | s->lcyl) << 9),\n                    MIN(MIN(s->mdata_size - (((s->hcyl << 16) | s->lcyl) << 9),\n                                    s->nsector << 9), 0x200 - 2));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_cfata_metadata_read(IDEState *s)\n{\n    uint16_t *p;\n\n    if (((s->hcyl << 16) | s->lcyl) << 9 > s->mdata_size + 2) {\n        s->status = ERR_STAT;\n        s->error = ABRT_ERR;\n        return;\n    }\n\n    p = (uint16_t *) s->io_buffer;\n    memset(p, 0, 0x200);\n\n    put_le16(p + 0, s->media_changed);\t\t/* Media status */\n    memcpy(p + 1, s->mdata_storage + (((s->hcyl << 16) | s->lcyl) << 9),\n                    MIN(MIN(s->mdata_size - (((s->hcyl << 16) | s->lcyl) << 9),\n                                    s->nsector << 9), 0x200 - 2));\n}\n",
        "linevul": 5.361061994335614e-05
    },
    {
        "code": "static uint8_t vga_dumb_retrace(VGACommonState *s)\n{\n    return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "static uint8_t vga_dumb_retrace(VGACommonState *s)\n{\n    return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);\n}\n",
        "linevul": 4.8708170652389526e-05
    },
    {
        "code": "static int xhci_submit(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    uint64_t mfindex;\n\n    DPRINTF(\"xhci_submit(slotid=%d,epid=%d)\\n\", xfer->slotid, xfer->epid);\n\n    xfer->in_xfer = epctx->type>>2;\n\n    switch(epctx->type) {\n    case ET_INTR_OUT:\n    case ET_INTR_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_intr_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    case ET_BULK_OUT:\n    case ET_BULK_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = false;\n        break;\n    case ET_ISO_OUT:\n    case ET_ISO_IN:\n        xfer->pkts = 1;\n        xfer->iso_xfer = true;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_iso_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"endpoint type\", epctx->type);\n        return -1;\n    }\n\n    if (xhci_setup_packet(xfer) < 0) {\n        return -1;\n    }\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n    xhci_try_complete_packet(xfer);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static int xhci_submit(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    uint64_t mfindex;\n\n    DPRINTF(\"xhci_submit(slotid=%d,epid=%d)\\n\", xfer->slotid, xfer->epid);\n\n    xfer->in_xfer = epctx->type>>2;\n\n    switch(epctx->type) {\n    case ET_INTR_OUT:\n    case ET_INTR_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_intr_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    case ET_BULK_OUT:\n    case ET_BULK_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = false;\n        break;\n    case ET_ISO_OUT:\n    case ET_ISO_IN:\n        xfer->pkts = 1;\n        xfer->iso_xfer = true;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_iso_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"endpoint type\", epctx->type);\n        return -1;\n    }\n\n    if (xhci_setup_packet(xfer) < 0) {\n        return -1;\n    }\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n    xhci_try_complete_packet(xfer);\n    return 0;\n}\n",
        "linevul": 4.7620938858017325e-05
    },
    {
        "code": "static bool megasas_use_queue64(MegasasState *s)\n{\n    return s->flags & MEGASAS_MASK_USE_QUEUE64;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static bool megasas_use_queue64(MegasasState *s)\n{\n    return s->flags & MEGASAS_MASK_USE_QUEUE64;\n}\n",
        "linevul": 5.86838141316548e-05
    },
    {
        "code": "static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    /* hdr_len refers to the header we supply to the guest */\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement elem;\n        int len, total;\n        const struct iovec *sg = elem.in_sg;\n\n        total = 0;\n\n        if (virtqueue_pop(q->rx_vq, &elem) == 0) {\n            if (i == 0)\n                return -1;\n            error_report(\"virtio-net unexpected empty queue: \"\n                    \"i %zd mergeable %d offset %zd, size %zd, \"\n                    \"guest hdr len %zd, host hdr len %zd guest features 0x%x\",\n                    i, n->mergeable_rx_bufs, offset, size,\n                    n->guest_hdr_len, n->host_hdr_len, vdev->guest_features);\n            exit(1);\n        }\n\n        if (elem.in_num < 1) {\n            error_report(\"virtio-net receive queue contains no in buffers\");\n            exit(1);\n        }\n\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem.in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem.in_num, buf, size);\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        /* copy in packet.  ugh */\n        len = iov_from_buf(sg, elem.in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        /* If buffers can't be merged, at this point we\n         * must have consumed the complete packet.\n         * Otherwise, drop it. */\n        if (!n->mergeable_rx_bufs && offset < size) {\n#if 0\n            error_report(\"virtio-net truncated non-mergeable packet: \"\n                         \"i %zd mergeable %d offset %zd, size %zd, \"\n                         \"guest hdr len %zd, host hdr len %zd\",\n                         i, n->mergeable_rx_bufs,\n                         offset, size, n->guest_hdr_len, n->host_hdr_len);\n#endif\n            return size;\n        }\n\n        /* signal other side */\n        virtqueue_fill(q->rx_vq, &elem, total, i++);\n    }\n\n    if (mhdr_cnt) {\n        stw_p(&mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    /* hdr_len refers to the header we supply to the guest */\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement elem;\n        int len, total;\n        const struct iovec *sg = elem.in_sg;\n\n        total = 0;\n\n        if (virtqueue_pop(q->rx_vq, &elem) == 0) {\n            if (i == 0)\n                return -1;\n            error_report(\"virtio-net unexpected empty queue: \"\n                    \"i %zd mergeable %d offset %zd, size %zd, \"\n                    \"guest hdr len %zd, host hdr len %zd guest features 0x%x\",\n                    i, n->mergeable_rx_bufs, offset, size,\n                    n->guest_hdr_len, n->host_hdr_len, vdev->guest_features);\n            exit(1);\n        }\n\n        if (elem.in_num < 1) {\n            error_report(\"virtio-net receive queue contains no in buffers\");\n            exit(1);\n        }\n\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem.in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem.in_num, buf, size);\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        /* copy in packet.  ugh */\n        len = iov_from_buf(sg, elem.in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        /* If buffers can't be merged, at this point we\n         * must have consumed the complete packet.\n         * Otherwise, drop it. */\n        if (!n->mergeable_rx_bufs && offset < size) {\n#if 0\n            error_report(\"virtio-net truncated non-mergeable packet: \"\n                         \"i %zd mergeable %d offset %zd, size %zd, \"\n                         \"guest hdr len %zd, host hdr len %zd\",\n                         i, n->mergeable_rx_bufs,\n                         offset, size, n->guest_hdr_len, n->host_hdr_len);\n#endif\n            return size;\n        }\n\n        /* signal other side */\n        virtqueue_fill(q->rx_vq, &elem, total, i++);\n    }\n\n    if (mhdr_cnt) {\n        stw_p(&mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n}\n",
        "linevul": 9.264552500098944e-05
    },
    {
        "code": "static void v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.0001377365697408095
    },
    {
        "code": "static ssize_t flistxattrat_nofollow(int dirfd, const char *filename,\n                                     char *list, size_t size)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = llistxattr(proc_path, list, size);\n    g_free(proc_path);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "static ssize_t flistxattrat_nofollow(int dirfd, const char *filename,\n                                     char *list, size_t size)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = llistxattr(proc_path, list, size);\n    g_free(proc_path);\n    return ret;\n}\n",
        "linevul": 5.1360158977331594e-05
    },
    {
        "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd;\n    EHCIqh qh;\n    int state;\n\n    /* Verify the qh + qtd, like we do when going through fetchqh & fetchqtd */\n    get_dwords(q->ehci, NLPTR_GET(q->qhaddr),\n               (uint32_t *) &qh, sizeof(EHCIqh) >> 2);\n    get_dwords(q->ehci, NLPTR_GET(q->qtdaddr),\n               (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2);\n    if (!ehci_verify_qh(q, &qh) || !ehci_verify_qtd(p, &qtd)) {\n        p->async = EHCI_ASYNC_INITIALIZED;\n        ehci_free_packet(p);\n        return;\n    }\n\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    }\n    ehci_set_state(q->ehci, q->async, state);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd;\n    EHCIqh qh;\n    int state;\n\n    /* Verify the qh + qtd, like we do when going through fetchqh & fetchqtd */\n    get_dwords(q->ehci, NLPTR_GET(q->qhaddr),\n               (uint32_t *) &qh, sizeof(EHCIqh) >> 2);\n    get_dwords(q->ehci, NLPTR_GET(q->qtdaddr),\n               (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2);\n    if (!ehci_verify_qh(q, &qh) || !ehci_verify_qtd(p, &qtd)) {\n        p->async = EHCI_ASYNC_INITIALIZED;\n        ehci_free_packet(p);\n        return;\n    }\n\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    }\n    ehci_set_state(q->ehci, q->async, state);\n}\n",
        "linevul": 5.006722858524881e-05
    },
    {
        "code": "static void vmxnet3_trigger_interrupt(VMXNET3State *s, int lidx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    s->interrupt_states[lidx].is_pending = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n\n    if (s->msix_used && msix_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    if (msi_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    return;\n\ndo_automask:\n    s->interrupt_states[lidx].is_masked = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_trigger_interrupt(VMXNET3State *s, int lidx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    s->interrupt_states[lidx].is_pending = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n\n    if (s->msix_used && msix_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    if (msi_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    return;\n\ndo_automask:\n    s->interrupt_states[lidx].is_masked = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n",
        "linevul": 4.610764517565258e-05
    },
    {
        "code": "static void v9fs_read(void *opaque)\n{\n    int32_t fid;\n    uint64_t off;\n    ssize_t err = 0;\n    int32_t count = 0;\n    size_t offset = 7;\n    uint32_t max_count;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_DIR) {\n\n        if (off == 0) {\n            v9fs_co_rewinddir(pdu, fidp);\n        }\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n        if (count < 0) {\n            err = count;\n            goto out;\n        }\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n    } else if (fidp->fid_type == P9_FID_FILE) {\n        QEMUIOVector qiov_full;\n        QEMUIOVector qiov;\n        int32_t len;\n\n        v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\n        qemu_iovec_init(&qiov, qiov_full.niov);\n        do {\n            qemu_iovec_reset(&qiov);\n            qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\n            if (0) {\n                print_sg(qiov.iov, qiov.niov);\n            }\n            /* Loop in case of EINTR */\n            do {\n                len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\n                if (len >= 0) {\n                    off   += len;\n                    count += len;\n                }\n            } while (len == -EINTR && !pdu->cancelled);\n             if (len < 0) {\n                 /* IO error return the error */\n                 err = len;\n                goto out;\n             }\n         } while (count < max_count && len > 0);\n         err = pdu_marshal(pdu, offset, \"d\", count);\n         if (err < 0) {\n            goto out;\n         }\n         err += offset + count;\n         qemu_iovec_destroy(&qiov);\n         qemu_iovec_destroy(&qiov_full);\n     } else if (fidp->fid_type == P9_FID_XATTR) {\n    } else {\n        err = -EINVAL;\n    }\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_read(void *opaque)\n{\n    int32_t fid;\n    uint64_t off;\n    ssize_t err = 0;\n    int32_t count = 0;\n    size_t offset = 7;\n    uint32_t max_count;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_DIR) {\n\n        if (off == 0) {\n            v9fs_co_rewinddir(pdu, fidp);\n        }\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n        if (count < 0) {\n            err = count;\n            goto out;\n        }\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n    } else if (fidp->fid_type == P9_FID_FILE) {\n        QEMUIOVector qiov_full;\n        QEMUIOVector qiov;\n        int32_t len;\n\n        v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\n        qemu_iovec_init(&qiov, qiov_full.niov);\n        do {\n            qemu_iovec_reset(&qiov);\n            qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\n            if (0) {\n                print_sg(qiov.iov, qiov.niov);\n            }\n            /* Loop in case of EINTR */\n            do {\n                len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\n                if (len >= 0) {\n                    off   += len;\n                    count += len;\n                }\n            } while (len == -EINTR && !pdu->cancelled);\n             if (len < 0) {\n                 /* IO error return the error */\n                 err = len;\n//flaw_line_below:\n                goto out;\n//fix_flaw_line_below:\n//                goto out_free_iovec;\n             }\n         } while (count < max_count && len > 0);\n         err = pdu_marshal(pdu, offset, \"d\", count);\n         if (err < 0) {\n//flaw_line_below:\n            goto out;\n//fix_flaw_line_below:\n//            goto out_free_iovec;\n         }\n         err += offset + count;\n//fix_flaw_line_below:\n//out_free_iovec:\n         qemu_iovec_destroy(&qiov);\n         qemu_iovec_destroy(&qiov_full);\n     } else if (fidp->fid_type == P9_FID_XATTR) {\n    } else {\n        err = -EINVAL;\n    }\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.00014208948414307088
    },
    {
        "code": "static void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n",
        "linevul": 4.5638735173270106e-05
    },
    {
        "code": "static int megasas_handle_scsi(MegasasState *s, MegasasCmd *cmd,\n                               bool is_logical)\n{\n    uint8_t *cdb;\n    bool is_write;\n    struct SCSIDevice *sdev = NULL;\n\n    cdb = cmd->frame->pass.cdb;\n\n    if (is_logical) {\n        if (cmd->frame->header.target_id >= MFI_MAX_LD ||\n            cmd->frame->header.lun_id != 0) {\n            trace_megasas_scsi_target_not_present(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n            return MFI_STAT_DEVICE_NOT_FOUND;\n        }\n    }\n    sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id);\n\n    cmd->iov_size = le32_to_cpu(cmd->frame->header.data_len);\n    trace_megasas_handle_scsi(mfi_frame_desc[cmd->frame->header.frame_cmd],\n                              is_logical, cmd->frame->header.target_id,\n                              cmd->frame->header.lun_id, sdev, cmd->iov_size);\n\n    if (!sdev || (megasas_is_jbod(s) && is_logical)) {\n        trace_megasas_scsi_target_not_present(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id,\n                cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    if (megasas_map_sgl(s, cmd, &cmd->frame->pass.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n                mfi_frame_desc[cmd->frame->header.frame_cmd],\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    is_write = (cmd->req->cmd.mode == SCSI_XFER_TO_DEV);\n    if (cmd->iov_size) {\n        if (is_write) {\n            trace_megasas_scsi_write_start(cmd->index, cmd->iov_size);\n        } else {\n            trace_megasas_scsi_read_start(cmd->index, cmd->iov_size);\n        }\n    } else {\n        trace_megasas_scsi_nodata(cmd->index);\n    }\n    megasas_enqueue_req(cmd, is_write);\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_handle_scsi(MegasasState *s, MegasasCmd *cmd,\n                               bool is_logical)\n{\n    uint8_t *cdb;\n    bool is_write;\n    struct SCSIDevice *sdev = NULL;\n\n    cdb = cmd->frame->pass.cdb;\n\n    if (is_logical) {\n        if (cmd->frame->header.target_id >= MFI_MAX_LD ||\n            cmd->frame->header.lun_id != 0) {\n            trace_megasas_scsi_target_not_present(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n            return MFI_STAT_DEVICE_NOT_FOUND;\n        }\n    }\n    sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id);\n\n    cmd->iov_size = le32_to_cpu(cmd->frame->header.data_len);\n    trace_megasas_handle_scsi(mfi_frame_desc[cmd->frame->header.frame_cmd],\n                              is_logical, cmd->frame->header.target_id,\n                              cmd->frame->header.lun_id, sdev, cmd->iov_size);\n\n    if (!sdev || (megasas_is_jbod(s) && is_logical)) {\n        trace_megasas_scsi_target_not_present(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id,\n                cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    if (megasas_map_sgl(s, cmd, &cmd->frame->pass.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n                mfi_frame_desc[cmd->frame->header.frame_cmd],\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    is_write = (cmd->req->cmd.mode == SCSI_XFER_TO_DEV);\n    if (cmd->iov_size) {\n        if (is_write) {\n            trace_megasas_scsi_write_start(cmd->index, cmd->iov_size);\n        } else {\n            trace_megasas_scsi_read_start(cmd->index, cmd->iov_size);\n        }\n    } else {\n        trace_megasas_scsi_nodata(cmd->index);\n    }\n    megasas_enqueue_req(cmd, is_write);\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "linevul": 5.757237886427902e-05
    },
    {
        "code": "static void ide_issue_trim_cb(void *opaque, int ret)\n{\n    TrimAIOCB *iocb = opaque;\n    if (ret >= 0) {\n        while (iocb->j < iocb->qiov->niov) {\n            int j = iocb->j;\n            while (++iocb->i < iocb->qiov->iov[j].iov_len / 8) {\n                int i = iocb->i;\n                uint64_t *buffer = iocb->qiov->iov[j].iov_base;\n\n                /* 6-byte LBA + 2-byte range per entry */\n                uint64_t entry = le64_to_cpu(buffer[i]);\n                uint64_t sector = entry & 0x0000ffffffffffffULL;\n                uint16_t count = entry >> 48;\n\n                if (count == 0) {\n                    continue;\n                }\n\n                /* Got an entry! Submit and exit.  */\n                iocb->aiocb = blk_aio_discard(iocb->blk, sector, count,\n                                              ide_issue_trim_cb, opaque);\n                return;\n            }\n\n            iocb->j++;\n            iocb->i = -1;\n        }\n    } else {\n        iocb->ret = ret;\n    }\n\n    iocb->aiocb = NULL;\n    if (iocb->bh) {\n        qemu_bh_schedule(iocb->bh);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_issue_trim_cb(void *opaque, int ret)\n{\n    TrimAIOCB *iocb = opaque;\n    if (ret >= 0) {\n        while (iocb->j < iocb->qiov->niov) {\n            int j = iocb->j;\n            while (++iocb->i < iocb->qiov->iov[j].iov_len / 8) {\n                int i = iocb->i;\n                uint64_t *buffer = iocb->qiov->iov[j].iov_base;\n\n                /* 6-byte LBA + 2-byte range per entry */\n                uint64_t entry = le64_to_cpu(buffer[i]);\n                uint64_t sector = entry & 0x0000ffffffffffffULL;\n                uint16_t count = entry >> 48;\n\n                if (count == 0) {\n                    continue;\n                }\n\n                /* Got an entry! Submit and exit.  */\n                iocb->aiocb = blk_aio_discard(iocb->blk, sector, count,\n                                              ide_issue_trim_cb, opaque);\n                return;\n            }\n\n            iocb->j++;\n            iocb->i = -1;\n        }\n    } else {\n        iocb->ret = ret;\n    }\n\n    iocb->aiocb = NULL;\n    if (iocb->bh) {\n        qemu_bh_schedule(iocb->bh);\n    }\n}\n",
        "linevul": 5.1975850510643795e-05
    },
    {
        "code": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    bool start = req->cmd.buf[4] & 1;\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n        if (!start && !s->tray_open && s->tray_locked) {\n            scsi_check_condition(r,\n                                 bdrv_is_inserted(s->bs)\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n            return -1;\n        }\n        bdrv_eject(s->bs, !start);\n        s->tray_open = !start;\n    }\n     return 0;\n }\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    bool start = req->cmd.buf[4] & 1;\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n        if (!start && !s->tray_open && s->tray_locked) {\n            scsi_check_condition(r,\n                                 bdrv_is_inserted(s->bs)\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n            return -1;\n        }\n        bdrv_eject(s->bs, !start);\n        s->tray_open = !start;\n    }\n     return 0;\n }\n",
        "linevul": 4.698911652667448e-05
    },
    {
        "code": "static int32_t coroutine_fn get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int32_t coroutine_fn get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "linevul": 6.724969716742635e-05
    },
    {
        "code": "pvscsi_send_msg(PVSCSIState *s, SCSIDevice *dev, uint32_t msg_type)\n{\n    if (s->msg_ring_info_valid && pvscsi_ring_msg_has_room(&s->rings)) {\n        PVSCSIMsgDescDevStatusChanged msg = {0};\n\n        msg.type = msg_type;\n        msg.bus = dev->channel;\n        msg.target = dev->id;\n        msg.lun[1] = dev->lun;\n\n        pvscsi_msg_ring_put(s, (PVSCSIRingMsgDesc *)&msg);\n        pvscsi_ring_flush_msg(&s->rings);\n        pvscsi_raise_message_interrupt(s);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": "pvscsi_send_msg(PVSCSIState *s, SCSIDevice *dev, uint32_t msg_type)\n{\n    if (s->msg_ring_info_valid && pvscsi_ring_msg_has_room(&s->rings)) {\n        PVSCSIMsgDescDevStatusChanged msg = {0};\n\n        msg.type = msg_type;\n        msg.bus = dev->channel;\n        msg.target = dev->id;\n        msg.lun[1] = dev->lun;\n\n        pvscsi_msg_ring_put(s, (PVSCSIRingMsgDesc *)&msg);\n        pvscsi_ring_flush_msg(&s->rings);\n        pvscsi_raise_message_interrupt(s);\n    }\n}\n",
        "linevul": 4.721271398011595e-05
    },
    {
        "code": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(s, fs_path->data, O_RDONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = fstatfs(fd, stbuf);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(s, fs_path->data, O_RDONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = fstatfs(fd, stbuf);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "linevul": 5.154248356120661e-05
    },
    {
        "code": "static uint64_t ehci_port_read(void *ptr, hwaddr addr,\n                               unsigned size)\n{\n    EHCIState *s = ptr;\n    uint32_t val;\n\n    val = s->portsc[addr >> 2];\n    trace_usb_ehci_portsc_read(addr + s->portscbase, addr >> 2, val);\n    return val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static uint64_t ehci_port_read(void *ptr, hwaddr addr,\n                               unsigned size)\n{\n    EHCIState *s = ptr;\n    uint32_t val;\n\n    val = s->portsc[addr >> 2];\n    trace_usb_ehci_portsc_read(addr + s->portscbase, addr >> 2, val);\n    return val;\n}\n",
        "linevul": 5.220097227720544e-05
    },
    {
        "code": "static int proxy_fsync(FsContext *ctx, int fid_type,\n                       V9fsFidOpenState *fs, int datasync)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n\n    if (datasync) {\n        return qemu_fdatasync(fd);\n    } else {\n        return fsync(fd);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_fsync(FsContext *ctx, int fid_type,\n                       V9fsFidOpenState *fs, int datasync)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n\n    if (datasync) {\n        return qemu_fdatasync(fd);\n    } else {\n        return fsync(fd);\n    }\n}\n",
        "linevul": 4.85314303659834e-05
    },
    {
        "code": "static void cirrus_vga_write_palette(CirrusVGAState * s, int reg_value)\n{\n    s->vga.dac_cache[s->vga.dac_sub_index] = reg_value;\n    if (++s->vga.dac_sub_index == 3) {\n        if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {\n            memcpy(&s->cirrus_hidden_palette[(s->vga.dac_write_index & 0x0f) * 3],\n                   s->vga.dac_cache, 3);\n        } else {\n            memcpy(&s->vga.palette[s->vga.dac_write_index * 3], s->vga.dac_cache, 3);\n        }\n        /* XXX update cursor */\n\ts->vga.dac_sub_index = 0;\n\ts->vga.dac_write_index++;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static void cirrus_vga_write_palette(CirrusVGAState * s, int reg_value)\n{\n    s->vga.dac_cache[s->vga.dac_sub_index] = reg_value;\n    if (++s->vga.dac_sub_index == 3) {\n        if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {\n            memcpy(&s->cirrus_hidden_palette[(s->vga.dac_write_index & 0x0f) * 3],\n                   s->vga.dac_cache, 3);\n        } else {\n            memcpy(&s->vga.palette[s->vga.dac_write_index * 3], s->vga.dac_cache, 3);\n        }\n        /* XXX update cursor */\n\ts->vga.dac_sub_index = 0;\n\ts->vga.dac_write_index++;\n    }\n}\n",
        "linevul": 4.657155659515411e-05
    },
    {
        "code": "int64_t xbzrle_cache_resize(int64_t new_size)\n{\n    PageCache *new_cache;\n    int64_t ret;\n\n    if (new_size < TARGET_PAGE_SIZE) {\n        return -1;\n    }\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache != NULL) {\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n            goto out_new_size;\n        }\n        new_cache = cache_init(new_size / TARGET_PAGE_SIZE,\n                                        TARGET_PAGE_SIZE);\n        if (!new_cache) {\n            error_report(\"Error creating cache\");\n            ret = -1;\n            goto out;\n        }\n\n        cache_fini(XBZRLE.cache);\n        XBZRLE.cache = new_cache;\n    }\n\nout_new_size:\n    ret = pow2floor(new_size);\nout:\n    XBZRLE_cache_unlock();\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "int64_t xbzrle_cache_resize(int64_t new_size)\n{\n    PageCache *new_cache;\n    int64_t ret;\n\n    if (new_size < TARGET_PAGE_SIZE) {\n        return -1;\n    }\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache != NULL) {\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n            goto out_new_size;\n        }\n        new_cache = cache_init(new_size / TARGET_PAGE_SIZE,\n                                        TARGET_PAGE_SIZE);\n        if (!new_cache) {\n            error_report(\"Error creating cache\");\n            ret = -1;\n            goto out;\n        }\n\n        cache_fini(XBZRLE.cache);\n        XBZRLE.cache = new_cache;\n    }\n\nout_new_size:\n    ret = pow2floor(new_size);\nout:\n    XBZRLE_cache_unlock();\n    return ret;\n}\n",
        "linevul": 0.0002333522425033152
    },
    {
        "code": " static void v9fs_walk(void *opaque)\n {\n     int name_idx;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n     V9fsFidState *newfidp = NULL;\n     V9fsPDU *pdu = opaque;\n     V9fsState *s = pdu->s;\n \n     err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n     if (err < 0) {\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n         err = -ENOENT;\n         goto out_nofid;\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=56f101ecce0eafd09e2daf1c4eeb1377d6959261",
        "vul_func_with_fix": " static void v9fs_walk(void *opaque)\n {\n     int name_idx;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n     V9fsFidState *newfidp = NULL;\n     V9fsPDU *pdu = opaque;\n     V9fsState *s = pdu->s;\n//fix_flaw_line_below:\n//    V9fsQID qid;\n \n     err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n     if (err < 0) {\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n         err = -ENOENT;\n         goto out_nofid;\n     }\n",
        "linevul": 0.9984464049339294
    },
    {
        "code": "static void vapic_reset(DeviceState *dev)\n{\n    VAPICROMState *s = VAPIC(dev);\n\n    s->state = VAPIC_INACTIVE;\n    s->rom_state_paddr = 0;\n    vapic_enable_tpr_reporting(false);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static void vapic_reset(DeviceState *dev)\n{\n    VAPICROMState *s = VAPIC(dev);\n\n    s->state = VAPIC_INACTIVE;\n    s->rom_state_paddr = 0;\n    vapic_enable_tpr_reporting(false);\n}\n",
        "linevul": 4.810227619600482e-05
    },
    {
        "code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n {\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n     SCSIRequest *req;\n    SCSIDiskReq *r;\n \n     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n     return req;\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n {\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n     SCSIRequest *req;\n//flaw_line_below:\n    SCSIDiskReq *r;\n \n     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n//flaw_line_below:\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n//flaw_line_below:\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n     return req;\n }\n",
        "linevul": 0.99899822473526
    },
    {
        "code": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n    to_device = (s->ti_size < 0);\n    len = s->dma_left;\n    if (s->do_cmd) {\n        trace_esp_do_dma(s->cmdlen, len);\n        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n        s->ti_size = 0;\n        s->cmdlen = 0;\n        s->do_cmd = 0;\n        do_cmd(s, s->cmdbuf);\n        return;\n    }\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n    if (len > s->async_len) {\n        len = s->async_len;\n    }\n    if (to_device) {\n        s->dma_memory_read(s->dma_opaque, s->async_buf, len);\n    } else {\n        s->dma_memory_write(s->dma_opaque, s->async_buf, len);\n    }\n    s->dma_left -= len;\n    s->async_buf += len;\n    s->async_len -= len;\n    if (to_device)\n        s->ti_size += len;\n    else\n        s->ti_size -= len;\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        /* If there is still data to be read from the device then\n           complete the DMA operation immediately.  Otherwise defer\n           until the scsi layer has completed.  */\n        if (to_device || s->dma_left != 0 || s->ti_size == 0) {\n            return;\n        }\n    }\n\n    /* Partially filled a scsi buffer. Complete immediately.  */\n    esp_dma_done(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
        "vul_func_with_fix": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n    to_device = (s->ti_size < 0);\n    len = s->dma_left;\n    if (s->do_cmd) {\n        trace_esp_do_dma(s->cmdlen, len);\n        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n        s->ti_size = 0;\n        s->cmdlen = 0;\n        s->do_cmd = 0;\n        do_cmd(s, s->cmdbuf);\n        return;\n    }\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n    if (len > s->async_len) {\n        len = s->async_len;\n    }\n    if (to_device) {\n        s->dma_memory_read(s->dma_opaque, s->async_buf, len);\n    } else {\n        s->dma_memory_write(s->dma_opaque, s->async_buf, len);\n    }\n    s->dma_left -= len;\n    s->async_buf += len;\n    s->async_len -= len;\n    if (to_device)\n        s->ti_size += len;\n    else\n        s->ti_size -= len;\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        /* If there is still data to be read from the device then\n           complete the DMA operation immediately.  Otherwise defer\n           until the scsi layer has completed.  */\n        if (to_device || s->dma_left != 0 || s->ti_size == 0) {\n            return;\n        }\n    }\n\n    /* Partially filled a scsi buffer. Complete immediately.  */\n    esp_dma_done(s);\n}\n",
        "linevul": 0.09847528487443924
    },
    {
        "code": "static void esp_soft_reset(ESPState *s)\n{\n    qemu_irq_lower(s->irq);\n    esp_hard_reset(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "static void esp_soft_reset(ESPState *s)\n{\n    qemu_irq_lower(s->irq);\n    esp_hard_reset(s);\n}\n",
        "linevul": 4.842634734814055e-05
    },
    {
        "code": "static uint64_t xhci_doorbell_read(void *ptr, hwaddr reg,\n                                   unsigned size)\n{\n    /* doorbells always read as 0 */\n    trace_usb_xhci_doorbell_read(reg, 0);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static uint64_t xhci_doorbell_read(void *ptr, hwaddr reg,\n                                   unsigned size)\n{\n    /* doorbells always read as 0 */\n    trace_usb_xhci_doorbell_read(reg, 0);\n    return 0;\n}\n",
        "linevul": 5.2839546697214246e-05
    },
    {
        "code": "static void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n",
        "linevul": 4.5371467422228307e-05
    },
    {
        "code": "int nbd_client(int fd)\n{\n    int ret;\n    int serrno;\n\n    TRACE(\"Doing NBD loop\");\n\n    ret = ioctl(fd, NBD_DO_IT);\n    if (ret < 0 && errno == EPIPE) {\n        /* NBD_DO_IT normally returns EPIPE when someone has disconnected\n         * the socket via NBD_DISCONNECT.  We do not want to return 1 in\n         * that case.\n         */\n        ret = 0;\n    }\n    serrno = errno;\n\n    TRACE(\"NBD loop returned %d: %s\", ret, strerror(serrno));\n\n    TRACE(\"Clearing NBD queue\");\n    ioctl(fd, NBD_CLEAR_QUE);\n\n    TRACE(\"Clearing NBD socket\");\n    ioctl(fd, NBD_CLEAR_SOCK);\n\n    errno = serrno;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "int nbd_client(int fd)\n{\n    int ret;\n    int serrno;\n\n    TRACE(\"Doing NBD loop\");\n\n    ret = ioctl(fd, NBD_DO_IT);\n    if (ret < 0 && errno == EPIPE) {\n        /* NBD_DO_IT normally returns EPIPE when someone has disconnected\n         * the socket via NBD_DISCONNECT.  We do not want to return 1 in\n         * that case.\n         */\n        ret = 0;\n    }\n    serrno = errno;\n\n    TRACE(\"NBD loop returned %d: %s\", ret, strerror(serrno));\n\n    TRACE(\"Clearing NBD queue\");\n    ioctl(fd, NBD_CLEAR_QUE);\n\n    TRACE(\"Clearing NBD socket\");\n    ioctl(fd, NBD_CLEAR_SOCK);\n\n    errno = serrno;\n    return ret;\n}\n",
        "linevul": 5.282120400806889e-05
    },
    {
        "code": "static bool esp_mem_accepts(void *opaque, hwaddr addr,\n                            unsigned size, bool is_write)\n{\n    return (size == 1) || (is_write && size == 4);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "static bool esp_mem_accepts(void *opaque, hwaddr addr,\n                            unsigned size, bool is_write)\n{\n    return (size == 1) || (is_write && size == 4);\n}\n",
        "linevul": 4.991409878130071e-05
    },
    {
        "code": "static void gen_op_update2_cc(void)\n{\n    tcg_gen_mov_tl(cpu_cc_src, cpu_T1);\n    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_op_update2_cc(void)\n{\n    tcg_gen_mov_tl(cpu_cc_src, cpu_T1);\n    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n}\n",
        "linevul": 6.33067247690633e-05
    },
    {
        "code": "static void ahci_write_fis_sdb(AHCIState *s, int port, uint32_t finished)\n{\n    AHCIDevice *ad = &s->dev[port];\n    AHCIPortRegs *pr = &ad->port_regs;\n    IDEState *ide_state;\n    SDBFIS *sdb_fis;\n\n    if (!s->dev[port].res_fis ||\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n\n    sdb_fis = (SDBFIS *)&ad->res_fis[RES_FIS_SDBFIS];\n    ide_state = &ad->port.ifs[0];\n\n    sdb_fis->type = 0xA1;\n    /* Interrupt pending & Notification bit */\n    sdb_fis->flags = (ad->hba->control_regs.irqstatus ? (1 << 6) : 0);\n    sdb_fis->status = ide_state->status & 0x77;\n    sdb_fis->error = ide_state->error;\n    /* update SAct field in SDB_FIS */\n    s->dev[port].finished |= finished;\n    sdb_fis->payload = cpu_to_le32(ad->finished);\n\n    /* Update shadow registers (except BSY 0x80 and DRQ 0x08) */\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        (ad->port.ifs[0].status & 0x77) |\n        (pr->tfdata & 0x88);\n\n    ahci_trigger_irq(s, ad, PORT_IRQ_SDB_FIS);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ahci_write_fis_sdb(AHCIState *s, int port, uint32_t finished)\n{\n    AHCIDevice *ad = &s->dev[port];\n    AHCIPortRegs *pr = &ad->port_regs;\n    IDEState *ide_state;\n    SDBFIS *sdb_fis;\n\n    if (!s->dev[port].res_fis ||\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n\n    sdb_fis = (SDBFIS *)&ad->res_fis[RES_FIS_SDBFIS];\n    ide_state = &ad->port.ifs[0];\n\n    sdb_fis->type = 0xA1;\n    /* Interrupt pending & Notification bit */\n    sdb_fis->flags = (ad->hba->control_regs.irqstatus ? (1 << 6) : 0);\n    sdb_fis->status = ide_state->status & 0x77;\n    sdb_fis->error = ide_state->error;\n    /* update SAct field in SDB_FIS */\n    s->dev[port].finished |= finished;\n    sdb_fis->payload = cpu_to_le32(ad->finished);\n\n    /* Update shadow registers (except BSY 0x80 and DRQ 0x08) */\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        (ad->port.ifs[0].status & 0x77) |\n        (pr->tfdata & 0x88);\n\n    ahci_trigger_irq(s, ad, PORT_IRQ_SDB_FIS);\n}\n",
        "linevul": 5.850176603416912e-05
    },
    {
        "code": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_vq(vq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_vq(vq);\n    }\n}\n",
        "linevul": 5.146821786183864e-05
    },
    {
        "code": "static void lsi_request_cancelled(SCSIRequest *req)\n{\n    LSIState *s = LSI53C895A(req->bus->qbus.parent);\n    lsi_request *p = req->hba_private;\n\n    req->hba_private = NULL;\n    lsi_request_free(s, p);\n    scsi_req_unref(req);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08",
        "vul_func_with_fix": "static void lsi_request_cancelled(SCSIRequest *req)\n{\n    LSIState *s = LSI53C895A(req->bus->qbus.parent);\n    lsi_request *p = req->hba_private;\n\n    req->hba_private = NULL;\n    lsi_request_free(s, p);\n    scsi_req_unref(req);\n}\n",
        "linevul": 4.77922658319585e-05
    },
    {
        "code": "static void usb_net_handle_data(USBDevice *dev, USBPacket *p)\n{\n    USBNetState *s = (USBNetState *) dev;\n\n    switch(p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->ep->nr) {\n        case 1:\n            usb_net_handle_statusin(s, p);\n            break;\n\n        case 2:\n            usb_net_handle_datain(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    case USB_TOKEN_OUT:\n        switch (p->ep->nr) {\n        case 2:\n            usb_net_handle_dataout(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    default:\n    fail:\n        p->status = USB_RET_STALL;\n        break;\n    }\n\n    if (p->status == USB_RET_STALL) {\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n                        p->pid, p->ep->nr, p->iov.size);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=80eecda8e5d09c442c24307f340840a5b70ea3b9",
        "vul_func_with_fix": "static void usb_net_handle_data(USBDevice *dev, USBPacket *p)\n{\n    USBNetState *s = (USBNetState *) dev;\n\n    switch(p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->ep->nr) {\n        case 1:\n            usb_net_handle_statusin(s, p);\n            break;\n\n        case 2:\n            usb_net_handle_datain(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    case USB_TOKEN_OUT:\n        switch (p->ep->nr) {\n        case 2:\n            usb_net_handle_dataout(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    default:\n    fail:\n        p->status = USB_RET_STALL;\n        break;\n    }\n\n    if (p->status == USB_RET_STALL) {\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n                        p->pid, p->ep->nr, p->iov.size);\n    }\n}\n",
        "linevul": 8.648396760690957e-05
    },
    {
        "code": "void virtio_queue_invalidate_signalled_used(VirtIODevice *vdev, int n)\n{\n    vdev->vq[n].signalled_used_valid = false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "void virtio_queue_invalidate_signalled_used(VirtIODevice *vdev, int n)\n{\n    vdev->vq[n].signalled_used_valid = false;\n}\n",
        "linevul": 4.733249079436064e-05
    },
    {
        "code": "static coroutine_fn int qcow2_co_discard(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_discard_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors, QCOW2_DISCARD_REQUEST);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9",
        "vul_func_with_fix": "static coroutine_fn int qcow2_co_discard(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_discard_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors, QCOW2_DISCARD_REQUEST);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n",
        "linevul": 5.0040493078995496e-05
    },
    {
        "code": "static void pmac_ide_writew (void *opaque,\n                             hwaddr addr, uint32_t val)\n{\n    MACIOIDEState *d = opaque;\n\n    addr = (addr & 0xFFF) >> 4;\n    val = bswap16(val);\n    if (addr == 0) {\n        ide_data_writew(&d->bus, 0, val);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void pmac_ide_writew (void *opaque,\n                             hwaddr addr, uint32_t val)\n{\n    MACIOIDEState *d = opaque;\n\n    addr = (addr & 0xFFF) >> 4;\n    val = bswap16(val);\n    if (addr == 0) {\n        ide_data_writew(&d->bus, 0, val);\n    }\n}\n",
        "linevul": 4.964825711795129e-05
    },
    {
        "code": "e1000e_intrmgr_pause(E1000ECore *core)\n{\n    int i;\n\n    e1000e_intmgr_timer_pause(&core->radv);\n    e1000e_intmgr_timer_pause(&core->rdtr);\n    e1000e_intmgr_timer_pause(&core->raid);\n    e1000e_intmgr_timer_pause(&core->tidv);\n    e1000e_intmgr_timer_pause(&core->tadv);\n\n    e1000e_intmgr_timer_pause(&core->itr);\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        e1000e_intmgr_timer_pause(&core->eitr[i]);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_intrmgr_pause(E1000ECore *core)\n{\n    int i;\n\n    e1000e_intmgr_timer_pause(&core->radv);\n    e1000e_intmgr_timer_pause(&core->rdtr);\n    e1000e_intmgr_timer_pause(&core->raid);\n    e1000e_intmgr_timer_pause(&core->tidv);\n    e1000e_intmgr_timer_pause(&core->tadv);\n\n    e1000e_intmgr_timer_pause(&core->itr);\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        e1000e_intmgr_timer_pause(&core->eitr[i]);\n    }\n}\n",
        "linevul": 4.613949204212986e-05
    },
    {
        "code": "static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)\n{\n    BusChild *kid, *next;\n    int slot = ffs(slots) - 1;\n    PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);\n\n    if (!bus) {\n        return;\n    }\n\n    /* Mark request as complete */\n    s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);\n    s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);\n\n    QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {\n        DeviceState *qdev = kid->child;\n        PCIDevice *dev = PCI_DEVICE(qdev);\n        if (PCI_SLOT(dev->devfn) == slot) {\n            if (!acpi_pcihp_pc_no_hotplug(s, dev)) {\n                object_unparent(OBJECT(qdev));\n            }\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fa365d7cd11185237471823a5a33d36765454e16",
        "vul_func_with_fix": "static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)\n{\n    BusChild *kid, *next;\n    int slot = ffs(slots) - 1;\n    PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);\n\n    if (!bus) {\n        return;\n    }\n\n    /* Mark request as complete */\n    s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);\n    s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);\n\n    QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {\n        DeviceState *qdev = kid->child;\n        PCIDevice *dev = PCI_DEVICE(qdev);\n        if (PCI_SLOT(dev->devfn) == slot) {\n            if (!acpi_pcihp_pc_no_hotplug(s, dev)) {\n                object_unparent(OBJECT(qdev));\n            }\n        }\n    }\n}\n",
        "linevul": 4.9339203542331234e-05
    },
    {
        "code": "static uint64_t pxa2xx_cppmnc_read(CPUARMState *env, const ARMCPRegInfo *ri)\n{\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n    return s->pmnc;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=caa881abe0e01f9931125a0977ec33c5343e4aa7",
        "vul_func_with_fix": "static uint64_t pxa2xx_cppmnc_read(CPUARMState *env, const ARMCPRegInfo *ri)\n{\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n    return s->pmnc;\n}\n",
        "linevul": 5.397298446041532e-05
    },
    {
        "code": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n    /* destroy msix memory region */\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        msix_uninit(dev, &xhci->mem, &xhci->mem);\n    }\n\n    usb_bus_release(&xhci->bus);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n    /* destroy msix memory region */\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        msix_uninit(dev, &xhci->mem, &xhci->mem);\n    }\n\n    usb_bus_release(&xhci->bus);\n}\n",
        "linevul": 5.195845733396709e-05
    },
    {
        "code": "static int ehci_qh_do_overlay(EHCIQueue *q)\n{\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n    int i;\n    int dtoggle;\n    int ping;\n    int eps;\n    int reload;\n\n    assert(p != NULL);\n    assert(p->qtdaddr == q->qtdaddr);\n\n\n    dtoggle = q->qh.token & QTD_TOKEN_DTOGGLE;\n    ping    = q->qh.token & QTD_TOKEN_PING;\n\n    q->qh.current_qtd = p->qtdaddr;\n    q->qh.next_qtd    = p->qtd.next;\n    q->qh.altnext_qtd = p->qtd.altnext;\n    q->qh.token       = p->qtd.token;\n\n\n    eps = get_field(q->qh.epchar, QH_EPCHAR_EPS);\n    if (eps == EHCI_QH_EPS_HIGH) {\n        q->qh.token &= ~QTD_TOKEN_PING;\n        q->qh.token |= ping;\n    }\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n    set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    for (i = 0; i < 5; i++) {\n        q->qh.bufptr[i] = p->qtd.bufptr[i];\n    }\n\n    if (!(q->qh.epchar & QH_EPCHAR_DTC)) {\n        q->qh.token &= ~QTD_TOKEN_DTOGGLE;\n        q->qh.token |= dtoggle;\n    }\n\n    q->qh.bufptr[1] &= ~BUFPTR_CPROGMASK_MASK;\n    q->qh.bufptr[2] &= ~BUFPTR_FRAMETAG_MASK;\n\n    ehci_flush_qh(q);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_qh_do_overlay(EHCIQueue *q)\n{\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n    int i;\n    int dtoggle;\n    int ping;\n    int eps;\n    int reload;\n\n    assert(p != NULL);\n    assert(p->qtdaddr == q->qtdaddr);\n\n    // remember values in fields to preserve in qh after overlay\n\n    dtoggle = q->qh.token & QTD_TOKEN_DTOGGLE;\n    ping    = q->qh.token & QTD_TOKEN_PING;\n\n    q->qh.current_qtd = p->qtdaddr;\n    q->qh.next_qtd    = p->qtd.next;\n    q->qh.altnext_qtd = p->qtd.altnext;\n    q->qh.token       = p->qtd.token;\n\n\n    eps = get_field(q->qh.epchar, QH_EPCHAR_EPS);\n    if (eps == EHCI_QH_EPS_HIGH) {\n        q->qh.token &= ~QTD_TOKEN_PING;\n        q->qh.token |= ping;\n    }\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n    set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    for (i = 0; i < 5; i++) {\n        q->qh.bufptr[i] = p->qtd.bufptr[i];\n    }\n\n    if (!(q->qh.epchar & QH_EPCHAR_DTC)) {\n        // preserve QH DT bit\n        q->qh.token &= ~QTD_TOKEN_DTOGGLE;\n        q->qh.token |= dtoggle;\n    }\n\n    q->qh.bufptr[1] &= ~BUFPTR_CPROGMASK_MASK;\n    q->qh.bufptr[2] &= ~BUFPTR_FRAMETAG_MASK;\n\n    ehci_flush_qh(q);\n\n    return 0;\n}\n",
        "linevul": 8.517022797605023e-05
    },
    {
        "code": "vmxnet3_is_allowed_mcast_group(VMXNET3State *s, const uint8_t *group_mac)\n{\n    int i;\n    for (i = 0; i < s->mcast_list_len; i++) {\n        if (!memcmp(group_mac, s->mcast_list[i].a, sizeof(s->mcast_list[i]))) {\n            return true;\n        }\n    }\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_is_allowed_mcast_group(VMXNET3State *s, const uint8_t *group_mac)\n{\n    int i;\n    for (i = 0; i < s->mcast_list_len; i++) {\n        if (!memcmp(group_mac, s->mcast_list[i].a, sizeof(s->mcast_list[i]))) {\n            return true;\n        }\n    }\n    return false;\n}\n",
        "linevul": 4.935990727972239e-05
    },
    {
        "code": "static int megasas_handle_io(MegasasState *s, MegasasCmd *cmd)\n{\n    uint32_t lba_count, lba_start_hi, lba_start_lo;\n    uint64_t lba_start;\n    bool is_write = (cmd->frame->header.frame_cmd == MFI_CMD_LD_WRITE);\n    uint8_t cdb[16];\n    int len;\n    struct SCSIDevice *sdev = NULL;\n\n    lba_count = le32_to_cpu(cmd->frame->io.header.data_len);\n    lba_start_lo = le32_to_cpu(cmd->frame->io.lba_lo);\n    lba_start_hi = le32_to_cpu(cmd->frame->io.lba_hi);\n    lba_start = ((uint64_t)lba_start_hi << 32) | lba_start_lo;\n\n    if (cmd->frame->header.target_id < MFI_MAX_LD &&\n        cmd->frame->header.lun_id == 0) {\n        sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                                cmd->frame->header.lun_id);\n    }\n\n    trace_megasas_handle_io(cmd->index,\n                            mfi_frame_desc[cmd->frame->header.frame_cmd],\n                            cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id,\n                            (unsigned long)lba_start, (unsigned long)lba_count);\n    if (!sdev) {\n        trace_megasas_io_target_not_present(cmd->index,\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], 1,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id,\n            cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->iov_size = lba_count * sdev->blocksize;\n    if (megasas_map_sgl(s, cmd, &cmd->frame->io.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    megasas_encode_lba(cdb, lba_start, lba_count, is_write);\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n    len = megasas_enqueue_req(cmd, is_write);\n    if (len > 0) {\n        if (is_write) {\n            trace_megasas_io_write_start(cmd->index, lba_start, lba_count, len);\n        } else {\n            trace_megasas_io_read_start(cmd->index, lba_start, lba_count, len);\n        }\n    }\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_handle_io(MegasasState *s, MegasasCmd *cmd)\n{\n    uint32_t lba_count, lba_start_hi, lba_start_lo;\n    uint64_t lba_start;\n    bool is_write = (cmd->frame->header.frame_cmd == MFI_CMD_LD_WRITE);\n    uint8_t cdb[16];\n    int len;\n    struct SCSIDevice *sdev = NULL;\n\n    lba_count = le32_to_cpu(cmd->frame->io.header.data_len);\n    lba_start_lo = le32_to_cpu(cmd->frame->io.lba_lo);\n    lba_start_hi = le32_to_cpu(cmd->frame->io.lba_hi);\n    lba_start = ((uint64_t)lba_start_hi << 32) | lba_start_lo;\n\n    if (cmd->frame->header.target_id < MFI_MAX_LD &&\n        cmd->frame->header.lun_id == 0) {\n        sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                                cmd->frame->header.lun_id);\n    }\n\n    trace_megasas_handle_io(cmd->index,\n                            mfi_frame_desc[cmd->frame->header.frame_cmd],\n                            cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id,\n                            (unsigned long)lba_start, (unsigned long)lba_count);\n    if (!sdev) {\n        trace_megasas_io_target_not_present(cmd->index,\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], 1,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id,\n            cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->iov_size = lba_count * sdev->blocksize;\n    if (megasas_map_sgl(s, cmd, &cmd->frame->io.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    megasas_encode_lba(cdb, lba_start, lba_count, is_write);\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n    len = megasas_enqueue_req(cmd, is_write);\n    if (len > 0) {\n        if (is_write) {\n            trace_megasas_io_write_start(cmd->index, lba_start, lba_count, len);\n        } else {\n            trace_megasas_io_read_start(cmd->index, lba_start, lba_count, len);\n        }\n    }\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "linevul": 7.441069465130568e-05
    },
    {
        "code": "static void receive_header(VirtIONet *n, const struct iovec *iov, int iov_cnt,\n                           const void *buf, size_t size)\n{\n    if (n->has_vnet_hdr) {\n        /* FIXME this cast is evil */\n        void *wbuf = (void *)buf;\n        work_around_broken_dhclient(wbuf, wbuf + n->host_hdr_len,\n                                    size - n->host_hdr_len);\n        iov_from_buf(iov, iov_cnt, 0, buf, sizeof(struct virtio_net_hdr));\n    } else {\n        struct virtio_net_hdr hdr = {\n            .flags = 0,\n            .gso_type = VIRTIO_NET_HDR_GSO_NONE\n        };\n        iov_from_buf(iov, iov_cnt, 0, &hdr, sizeof hdr);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void receive_header(VirtIONet *n, const struct iovec *iov, int iov_cnt,\n                           const void *buf, size_t size)\n{\n    if (n->has_vnet_hdr) {\n        /* FIXME this cast is evil */\n        void *wbuf = (void *)buf;\n        work_around_broken_dhclient(wbuf, wbuf + n->host_hdr_len,\n                                    size - n->host_hdr_len);\n        iov_from_buf(iov, iov_cnt, 0, buf, sizeof(struct virtio_net_hdr));\n    } else {\n        struct virtio_net_hdr hdr = {\n            .flags = 0,\n            .gso_type = VIRTIO_NET_HDR_GSO_NONE\n        };\n        iov_from_buf(iov, iov_cnt, 0, &hdr, sizeof hdr);\n    }\n}\n",
        "linevul": 9.654468885855749e-05
    },
    {
        "code": "static bool cmd_read_dma(IDEState *s, uint8_t cmd)\n{\n    bool lba48 = (cmd == WIN_READDMA_EXT);\n\n    if (!s->blk) {\n        ide_abort_command(s);\n        return true;\n    }\n\n    ide_cmd_lba48_transform(s, lba48);\n    ide_sector_start_dma(s, IDE_DMA_READ);\n\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_read_dma(IDEState *s, uint8_t cmd)\n{\n    bool lba48 = (cmd == WIN_READDMA_EXT);\n\n    if (!s->blk) {\n        ide_abort_command(s);\n        return true;\n    }\n\n    ide_cmd_lba48_transform(s, lba48);\n    ide_sector_start_dma(s, IDE_DMA_READ);\n\n    return false;\n}\n",
        "linevul": 4.994419214199297e-05
    },
    {
        "code": "static void virtio_net_set_status(struct VirtIODevice *vdev, uint8_t status)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q;\n    int i;\n    uint8_t queue_status;\n\n    virtio_net_vhost_status(n, status);\n\n    for (i = 0; i < n->max_queues; i++) {\n        q = &n->vqs[i];\n\n        if ((!n->multiqueue && i != 0) || i >= n->curr_queues) {\n            queue_status = 0;\n        } else {\n            queue_status = status;\n        }\n\n        if (!q->tx_waiting) {\n            continue;\n        }\n\n        if (virtio_net_started(n, queue_status) && !n->vhost_started) {\n            if (q->tx_timer) {\n                timer_mod(q->tx_timer,\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n            } else {\n                qemu_bh_schedule(q->tx_bh);\n            }\n        } else {\n            if (q->tx_timer) {\n                timer_del(q->tx_timer);\n            } else {\n                qemu_bh_cancel(q->tx_bh);\n            }\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_set_status(struct VirtIODevice *vdev, uint8_t status)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q;\n    int i;\n    uint8_t queue_status;\n\n    virtio_net_vhost_status(n, status);\n\n    for (i = 0; i < n->max_queues; i++) {\n        q = &n->vqs[i];\n\n        if ((!n->multiqueue && i != 0) || i >= n->curr_queues) {\n            queue_status = 0;\n        } else {\n            queue_status = status;\n        }\n\n        if (!q->tx_waiting) {\n            continue;\n        }\n\n        if (virtio_net_started(n, queue_status) && !n->vhost_started) {\n            if (q->tx_timer) {\n                timer_mod(q->tx_timer,\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n            } else {\n                qemu_bh_schedule(q->tx_bh);\n            }\n        } else {\n            if (q->tx_timer) {\n                timer_del(q->tx_timer);\n            } else {\n                qemu_bh_cancel(q->tx_bh);\n            }\n        }\n    }\n}\n",
        "linevul": 4.594954225467518e-05
    },
    {
        "code": "static void gen_set_hflag(DisasContext *s, uint32_t mask)\n{\n    if ((s->flags & mask) == 0) {\n        TCGv_i32 t = tcg_temp_new_i32();\n        tcg_gen_ld_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_gen_ori_i32(t, t, mask);\n        tcg_gen_st_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_temp_free_i32(t);\n        s->flags |= mask;\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_set_hflag(DisasContext *s, uint32_t mask)\n{\n    if ((s->flags & mask) == 0) {\n        TCGv_i32 t = tcg_temp_new_i32();\n        tcg_gen_ld_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_gen_ori_i32(t, t, mask);\n        tcg_gen_st_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_temp_free_i32(t);\n        s->flags |= mask;\n    }\n}\n",
        "linevul": 5.7135643146466464e-05
    },
    {
        "code": "static void vmxnet3_ack_events(VMXNET3State *s, uint32_t val)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t events;\n\n    VMW_CBPRN(\"Clearing events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, ecr) & ~val;\n    VMXNET3_WRITE_DRV_SHARED32(d, s->drv_shmem, ecr, events);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_ack_events(VMXNET3State *s, uint32_t val)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t events;\n\n    VMW_CBPRN(\"Clearing events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, ecr) & ~val;\n    VMXNET3_WRITE_DRV_SHARED32(d, s->drv_shmem, ecr, events);\n}\n",
        "linevul": 4.5501627027988434e-05
    },
    {
        "code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n    if (!nc->peer) {\n        return;\n    }\n    if (nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {\n        return;\n    }\n\n    if (!tap_get_vhost_net(nc->peer)) {\n        return;\n    }\n\n    if (!!n->vhost_started ==\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r;\n        if (!vhost_net_query(tap_get_vhost_net(nc->peer), vdev)) {\n            return;\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n        n->vhost_started = 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n    if (!nc->peer) {\n        return;\n    }\n    if (nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {\n        return;\n    }\n\n    if (!tap_get_vhost_net(nc->peer)) {\n        return;\n    }\n\n    if (!!n->vhost_started ==\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r;\n        if (!vhost_net_query(tap_get_vhost_net(nc->peer), vdev)) {\n            return;\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n        n->vhost_started = 0;\n    }\n}\n",
        "linevul": 5.288370084599592e-05
    },
    {
        "code": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n{\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n    PCIDevice *pci_dev =\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n    DPRINTF(0, \"raise irq\\n\");\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n        msi_notify(pci_dev, 0);\n    } else {\n        qemu_irq_raise(s->irq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n{\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n    PCIDevice *pci_dev =\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n    DPRINTF(0, \"raise irq\\n\");\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n        msi_notify(pci_dev, 0);\n    } else {\n        qemu_irq_raise(s->irq);\n    }\n}\n",
        "linevul": 4.533682295004837e-05
    },
    {
        "code": "static void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n",
        "linevul": 4.936979530612007e-05
    },
    {
        "code": "static uint32_t fdctrl_read_statusA(FDCtrl *fdctrl)\n{\n    uint32_t retval = fdctrl->sra;\n\n    FLOPPY_DPRINTF(\"status register A: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static uint32_t fdctrl_read_statusA(FDCtrl *fdctrl)\n{\n    uint32_t retval = fdctrl->sra;\n\n    FLOPPY_DPRINTF(\"status register A: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "linevul": 4.7729368816362694e-05
    },
    {
        "code": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n     uint8_t len;\n \n     if (flags & RAM_SAVE_FLAG_CONTINUE) {\n        if (!block) {\n             error_report(\"Ack, bad migration stream!\");\n             return NULL;\n         }\n\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n     id[len] = 0;\n \n     QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        if (!strncmp(id, block->idstr, sizeof(id)))\n             return memory_region_get_ram_ptr(block->mr) + offset;\n     }\n \n     error_report(\"Can't find block %s!\", id);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n     uint8_t len;\n \n     if (flags & RAM_SAVE_FLAG_CONTINUE) {\n//flaw_line_below:\n        if (!block) {\n//fix_flaw_line_below:\n//        if (!block || block->length <= offset) {\n             error_report(\"Ack, bad migration stream!\");\n             return NULL;\n         }\n\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n     id[len] = 0;\n \n     QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n//flaw_line_below:\n        if (!strncmp(id, block->idstr, sizeof(id)))\n//fix_flaw_line_below:\n//        if (!strncmp(id, block->idstr, sizeof(id)) && block->length > offset) {\n             return memory_region_get_ram_ptr(block->mr) + offset;\n//fix_flaw_line_below:\n//        }\n     }\n \n     error_report(\"Can't find block %s!\", id);\n}\n",
        "linevul": 0.9967419505119324
    },
    {
        "code": "static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    PCIDevice *dev = opaque;\n    if (dev->msix_vector_poll_notifier) {\n        unsigned vector_start = addr * 8;\n        unsigned vector_end = MIN(addr + size * 8, dev->msix_entries_nr);\n        dev->msix_vector_poll_notifier(dev, vector_start, vector_end);\n    }\n\n     return pci_get_long(dev->msix_pba + addr);\n }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285",
        "vul_func_with_fix": "static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    PCIDevice *dev = opaque;\n    if (dev->msix_vector_poll_notifier) {\n        unsigned vector_start = addr * 8;\n        unsigned vector_end = MIN(addr + size * 8, dev->msix_entries_nr);\n        dev->msix_vector_poll_notifier(dev, vector_start, vector_end);\n    }\n\n     return pci_get_long(dev->msix_pba + addr);\n }\n",
        "linevul": 0.0009350088657811284
    },
    {
        "code": "static void stellaris_enet_send(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n\n    /* Ethernet header is in the FIFO but not in the datacount.\n     * We don't implement explicit CRC, so just ignore any\n     * CRC value in the FIFO.\n     */\n    framelen += 14;\n    if ((s->tctl & SE_TCTL_PADEN) && framelen < 60) {\n        memset(&s->tx_fifo[framelen + 2], 0, 60 - framelen);\n        framelen = 60;\n    }\n    /* This MIN will have no effect unless the FIFO data is corrupt\n     * (eg bad data from an incoming migration); otherwise the check\n     * on the datalen at the start of writing the data into the FIFO\n     * will have caught this. Silently write a corrupt half-packet,\n     * which is what the hardware does in FIFO underrun situations.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo) - 2);\n    qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo + 2, framelen);\n    s->tx_fifo_len = 0;\n    s->ris |= SE_INT_TXEMP;\n    stellaris_enet_update(s);\n    DPRINTF(\"Done TX\\n\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3a15cc0e1ee7168db0782133d2607a6bfa422d66",
        "vul_func_with_fix": "static void stellaris_enet_send(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n\n    /* Ethernet header is in the FIFO but not in the datacount.\n     * We don't implement explicit CRC, so just ignore any\n     * CRC value in the FIFO.\n     */\n    framelen += 14;\n    if ((s->tctl & SE_TCTL_PADEN) && framelen < 60) {\n        memset(&s->tx_fifo[framelen + 2], 0, 60 - framelen);\n        framelen = 60;\n    }\n    /* This MIN will have no effect unless the FIFO data is corrupt\n     * (eg bad data from an incoming migration); otherwise the check\n     * on the datalen at the start of writing the data into the FIFO\n     * will have caught this. Silently write a corrupt half-packet,\n     * which is what the hardware does in FIFO underrun situations.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo) - 2);\n    qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo + 2, framelen);\n    s->tx_fifo_len = 0;\n    s->ris |= SE_INT_TXEMP;\n    stellaris_enet_update(s);\n    DPRINTF(\"Done TX\\n\");\n}\n",
        "linevul": 7.294985698536038e-05
    },
    {
        "code": "bool net_tx_pkt_send_loopback(struct NetTxPkt *pkt, NetClientState *nc)\n{\n    bool res;\n\n    pkt->is_loopback = true;\n    res = net_tx_pkt_send(pkt, nc);\n    pkt->is_loopback = false;\n\n    return res;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "bool net_tx_pkt_send_loopback(struct NetTxPkt *pkt, NetClientState *nc)\n{\n    bool res;\n\n    pkt->is_loopback = true;\n    res = net_tx_pkt_send(pkt, nc);\n    pkt->is_loopback = false;\n\n    return res;\n}\n",
        "linevul": 4.7323235776275396e-05
    },
    {
        "code": "static void bdrv_io_limits_intercept(BlockDriverState *bs,\n                                     unsigned int bytes,\n                                     bool is_write)\n{\n    /* does this io must wait */\n    bool must_wait = throttle_schedule_timer(&bs->throttle_state, is_write);\n\n    /* if must wait or any request of this type throttled queue the IO */\n    if (must_wait ||\n        !qemu_co_queue_empty(&bs->throttled_reqs[is_write])) {\n        qemu_co_queue_wait(&bs->throttled_reqs[is_write]);\n    }\n\n    /* the IO will be executed, do the accounting */\n    throttle_account(&bs->throttle_state, is_write, bytes);\n\n\n    /* if the next request must wait -> do nothing */\n    if (throttle_schedule_timer(&bs->throttle_state, is_write)) {\n        return;\n    }\n\n    /* else queue next request for execution */\n    qemu_co_queue_next(&bs->throttled_reqs[is_write]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static void bdrv_io_limits_intercept(BlockDriverState *bs,\n                                     unsigned int bytes,\n                                     bool is_write)\n{\n    /* does this io must wait */\n    bool must_wait = throttle_schedule_timer(&bs->throttle_state, is_write);\n\n    /* if must wait or any request of this type throttled queue the IO */\n    if (must_wait ||\n        !qemu_co_queue_empty(&bs->throttled_reqs[is_write])) {\n        qemu_co_queue_wait(&bs->throttled_reqs[is_write]);\n    }\n\n    /* the IO will be executed, do the accounting */\n    throttle_account(&bs->throttle_state, is_write, bytes);\n\n\n    /* if the next request must wait -> do nothing */\n    if (throttle_schedule_timer(&bs->throttle_state, is_write)) {\n        return;\n    }\n\n    /* else queue next request for execution */\n    qemu_co_queue_next(&bs->throttled_reqs[is_write]);\n}\n",
        "linevul": 5.910885738558136e-05
    },
    {
        "code": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n    int refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return refcount;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n//flaw_line_below:\n    int refcount_table_index, block_index;\n//fix_flaw_line_below:\n//    uint64_t refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return refcount;\n}\n",
        "linevul": 7.816132711013779e-05
    },
    {
        "code": "static long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n",
        "linevul": 6.935292185517028e-05
    },
    {
        "code": "void sl_bootparam_write(hwaddr ptr)\n{\n    cpu_physical_memory_write(ptr, &zaurus_bootparam,\n                              sizeof(struct sl_param_info));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=52f91c3723932f8340fe36c8ec8b18a757c37b2b",
        "vul_func_with_fix": "void sl_bootparam_write(hwaddr ptr)\n{\n    cpu_physical_memory_write(ptr, &zaurus_bootparam,\n                              sizeof(struct sl_param_info));\n}\n",
        "linevul": 8.748648542677984e-05
    },
    {
        "code": "void v9fs_path_free(V9fsPath *path)\n{\n    g_free(path->data);\n    path->data = NULL;\n    path->size = 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "void v9fs_path_free(V9fsPath *path)\n{\n    g_free(path->data);\n    path->data = NULL;\n    path->size = 0;\n}\n",
        "linevul": 0.00010528470738790929
    },
    {
        "code": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n{\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n     CirrusVGAState *s = &d->cirrus_vga;\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n     int16_t device_id = pc->device_id;\n\n     /* follow real hardware, cirrus card emulated has 4 MB video memory.\n       Also accept 8 MB/16 MB for backward compatibility. */\n     if (s->vga.vram_size_mb != 4 && s->vga.vram_size_mb != 8 &&\n         s->vga.vram_size_mb != 16) {\n         error_report(\"Invalid cirrus_vga ram size '%u'\",\n                      s->vga.vram_size_mb);\n         return -1;\n     }\n     /* setup VGA */\n     vga_common_init(&s->vga, OBJECT(dev), true);\n     cirrus_init_common(s, OBJECT(dev), device_id, 1, pci_address_space(dev),\n                        pci_address_space_io(dev));\n     s->vga.con = graphic_console_init(DEVICE(dev), 0, s->vga.hw_ops, &s->vga);\n\n     /* setup PCI */\n\n    memory_region_init(&s->pci_bar, OBJECT(dev), \"cirrus-pci-bar0\", 0x2000000);\n\n    /* XXX: add byte swapping apertures */\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n                                &s->cirrus_linear_bitblt_io);\n\n     /* setup memory space */\n     /* memory #0 LFB */\n     /* memory #1 memory-mapped I/O */\n     /* XXX: s->vga.vram_size must be a power of two */\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n     if (device_id == CIRRUS_ID_CLGD5446) {\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n     }\n     return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n{\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n     CirrusVGAState *s = &d->cirrus_vga;\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n     int16_t device_id = pc->device_id;\n\n     /* follow real hardware, cirrus card emulated has 4 MB video memory.\n       Also accept 8 MB/16 MB for backward compatibility. */\n     if (s->vga.vram_size_mb != 4 && s->vga.vram_size_mb != 8 &&\n         s->vga.vram_size_mb != 16) {\n         error_report(\"Invalid cirrus_vga ram size '%u'\",\n                      s->vga.vram_size_mb);\n         return -1;\n     }\n     /* setup VGA */\n     vga_common_init(&s->vga, OBJECT(dev), true);\n     cirrus_init_common(s, OBJECT(dev), device_id, 1, pci_address_space(dev),\n                        pci_address_space_io(dev));\n     s->vga.con = graphic_console_init(DEVICE(dev), 0, s->vga.hw_ops, &s->vga);\n\n     /* setup PCI */\n\n    memory_region_init(&s->pci_bar, OBJECT(dev), \"cirrus-pci-bar0\", 0x2000000);\n\n    /* XXX: add byte swapping apertures */\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n                                &s->cirrus_linear_bitblt_io);\n\n     /* setup memory space */\n     /* memory #0 LFB */\n     /* memory #1 memory-mapped I/O */\n     /* XXX: s->vga.vram_size must be a power of two */\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n     if (device_id == CIRRUS_ID_CLGD5446) {\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n     }\n     return 0;\n}\n",
        "linevul": 0.01349408645182848
    },
    {
        "code": "static void gen_sse(CPUX86State *env, DisasContext *s, int b,\n                    target_ulong pc_start, int rex_r)\n{\n    int b1, op1_offset, op2_offset, is_xmm, val;\n    int modrm, mod, rm, reg;\n    SSEFunc_0_epp sse_fn_epp;\n    SSEFunc_0_eppi sse_fn_eppi;\n    SSEFunc_0_ppi sse_fn_ppi;\n    SSEFunc_0_eppt sse_fn_eppt;\n    TCGMemOp ot;\n\n    b &= 0xff;\n    if (s->prefix & PREFIX_DATA)\n        b1 = 1;\n    else if (s->prefix & PREFIX_REPZ)\n        b1 = 2;\n    else if (s->prefix & PREFIX_REPNZ)\n        b1 = 3;\n    else\n        b1 = 0;\n    sse_fn_epp = sse_op_table1[b][b1];\n    if (!sse_fn_epp) {\n        goto unknown_op;\n    }\n    if ((b <= 0x5f && b >= 0x10) || b == 0xc6 || b == 0xc2) {\n        is_xmm = 1;\n    } else {\n        if (b1 == 0) {\n            /* MMX case */\n            is_xmm = 0;\n        } else {\n            is_xmm = 1;\n        }\n    }\n    /* simple MMX/SSE operation */\n    if (s->flags & HF_TS_MASK) {\n        gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        return;\n    }\n    if (s->flags & HF_EM_MASK) {\n    illegal_op:\n        gen_illegal_opcode(s);\n        return;\n    }\n    if (is_xmm\n        && !(s->flags & HF_OSFXSR_MASK)\n        && ((b != 0x38 && b != 0x3a) || (s->prefix & PREFIX_DATA))) {\n        goto unknown_op;\n    }\n    if (b == 0x0e) {\n        if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n            /* If we were fully decoding this we might use illegal_op.  */\n            goto unknown_op;\n        }\n        /* femms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    if (b == 0x77) {\n        /* emms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    /* prepare MMX state (XXX: optimize by storing fptt and fptags in\n       the static cpu state) */\n    if (!is_xmm) {\n        gen_helper_enter_mmx(cpu_env);\n    }\n\n    modrm = cpu_ldub_code(env, s->pc++);\n    reg = ((modrm >> 3) & 7);\n    if (is_xmm)\n        reg |= rex_r;\n    mod = (modrm >> 6) & 3;\n    if (sse_fn_epp == SSE_SPECIAL) {\n        b |= (b1 << 8);\n        switch(b) {\n        case 0x0e7: /* movntq */\n            if (mod == 3) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            break;\n        case 0x1e7: /* movntdq */\n        case 0x02b: /* movntps */\n        case 0x12b: /* movntps */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x3f0: /* lddqu */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x22b: /* movntss */\n        case 0x32b: /* movntsd */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if (b1 & 1) {\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                    xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            }\n            break;\n        case 0x6e: /* movd mm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State,fpregs[reg].mmx));\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,fpregs[reg].mmx));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_mmx(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x16e: /* movd xmm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                gen_helper_movq_mm_T0_xmm(cpu_ptr0, cpu_T0);\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_xmm(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x6f: /* movq mm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[rm].mmx));\n                tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x010: /* movups */\n        case 0x110: /* movupd */\n        case 0x028: /* movaps */\n        case 0x128: /* movapd */\n        case 0x16f: /* movdqa xmm, ea */\n        case 0x26f: /* movdqu xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[reg]),\n                            offsetof(CPUX86State,xmm_regs[rm]));\n            }\n            break;\n        case 0x210: /* movss xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n            }\n            break;\n        case 0x310: /* movsd xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x012: /* movlps */\n        case 0x112: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                /* movhlps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x212: /* movsldup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(2)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n            break;\n        case 0x312: /* movddup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            break;\n        case 0x016: /* movhps */\n        case 0x116: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                /* movlhps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x216: /* movshdup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(1)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(3)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            break;\n        case 0x178:\n        case 0x378:\n            {\n                int bit_index, field_length;\n\n                if (b1 == 1 && reg != 0)\n                    goto illegal_op;\n                field_length = cpu_ldub_code(env, s->pc++) & 0x3F;\n                bit_index = cpu_ldub_code(env, s->pc++) & 0x3F;\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env,\n                    offsetof(CPUX86State,xmm_regs[reg]));\n                if (b1 == 1)\n                    gen_helper_extrq_i(cpu_env, cpu_ptr0,\n                                       tcg_const_i32(bit_index),\n                                       tcg_const_i32(field_length));\n                else\n                    gen_helper_insertq_i(cpu_env, cpu_ptr0,\n                                         tcg_const_i32(bit_index),\n                                         tcg_const_i32(field_length));\n            }\n            break;\n        case 0x7e: /* movd ea, mm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,fpregs[reg].mmx.MMX_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x17e: /* movd ea, xmm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x27e: /* movq xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x7f: /* movq ea, mm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                gen_op_movq(offsetof(CPUX86State,fpregs[rm].mmx),\n                            offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x011: /* movups */\n        case 0x111: /* movupd */\n        case 0x029: /* movaps */\n        case 0x129: /* movapd */\n        case 0x17f: /* movdqa ea, xmm */\n        case 0x27f: /* movdqu ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[rm]),\n                            offsetof(CPUX86State,xmm_regs[reg]));\n            }\n            break;\n        case 0x211: /* movss ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            }\n            break;\n        case 0x311: /* movsd ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            }\n            break;\n        case 0x013: /* movlps */\n        case 0x113: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x017: /* movhps */\n        case 0x117: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x71: /* shift mm, im */\n        case 0x72:\n        case 0x73:\n        case 0x171: /* shift xmm, im */\n        case 0x172:\n        case 0x173:\n            if (b1 >= 2) {\n\t        goto unknown_op;\n            }\n            val = cpu_ldub_code(env, s->pc++);\n            if (is_xmm) {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(1)));\n                op1_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(1)));\n                op1_offset = offsetof(CPUX86State,mmx_t0);\n            }\n            sse_fn_epp = sse_op_table2[((b - 1) & 3) * 8 +\n                                       (((modrm >> 3)) & 7)][b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (is_xmm) {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op1_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x050: /* movmskps */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskps(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x150: /* movmskpd */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskpd(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x02a: /* cvtpi2ps */\n        case 0x12a: /* cvtpi2pd */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b >> 8) {\n            case 0x0:\n                gen_helper_cvtpi2ps(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            default:\n            case 0x1:\n                gen_helper_cvtpi2pd(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22a: /* cvtsi2ss */\n        case 0x32a: /* cvtsi2sd */\n            ot = mo_64_32(s->dflag);\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            if (ot == MO_32) {\n                SSEFunc_0_epi sse_fn_epi = sse_op_table3ai[(b >> 8) & 1];\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                sse_fn_epi(cpu_env, cpu_ptr0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_0_epl sse_fn_epl = sse_op_table3aq[(b >> 8) & 1];\n                sse_fn_epl(cpu_env, cpu_ptr0, cpu_T0);\n#else\n                goto illegal_op;\n#endif\n            }\n            break;\n        case 0x02c: /* cvttps2pi */\n        case 0x12c: /* cvttpd2pi */\n        case 0x02d: /* cvtps2pi */\n        case 0x12d: /* cvtpd2pi */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n                gen_ldo_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            op1_offset = offsetof(CPUX86State,fpregs[reg & 7].mmx);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b) {\n            case 0x02c:\n                gen_helper_cvttps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12c:\n                gen_helper_cvttpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x02d:\n                gen_helper_cvtps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12d:\n                gen_helper_cvtpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22c: /* cvttss2si */\n        case 0x32c: /* cvttsd2si */\n        case 0x22d: /* cvtss2si */\n        case 0x32d: /* cvtsd2si */\n            ot = mo_64_32(s->dflag);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                if ((b >> 8) & 1) {\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_Q(0)));\n                } else {\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                }\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            if (ot == MO_32) {\n                SSEFunc_i_ep sse_fn_i_ep =\n                    sse_op_table3bi[((b >> 7) & 2) | (b & 1)];\n                sse_fn_i_ep(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n                tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_l_ep sse_fn_l_ep =\n                    sse_op_table3bq[((b >> 7) & 2) | (b & 1)];\n                sse_fn_l_ep(cpu_T0, cpu_env, cpu_ptr0);\n#else\n                goto illegal_op;\n#endif\n            }\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0xc4: /* pinsrw */\n        case 0x1c4:\n            s->rip_offset = 1;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,xmm_regs[reg].ZMM_W(val)));\n            } else {\n                val &= 3;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[reg].mmx.MMX_W(val)));\n            }\n            break;\n        case 0xc5: /* pextrw */\n        case 0x1c5:\n            if (mod != 3)\n                goto illegal_op;\n            ot = mo_64_32(s->dflag);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[rm].ZMM_W(val)));\n            } else {\n                val &= 3;\n                rm = (modrm & 7);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[rm].mmx.MMX_W(val)));\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0x1d6: /* movq ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x2d6: /* movq2dq */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7);\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                        offsetof(CPUX86State,fpregs[rm].mmx));\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x3d6: /* movdq2q */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_movq(offsetof(CPUX86State,fpregs[reg & 7].mmx),\n                        offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            break;\n        case 0xd7: /* pmovmskb */\n        case 0x1d7:\n            if (mod != 3)\n                goto illegal_op;\n            if (b1) {\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,xmm_regs[rm]));\n                gen_helper_pmovmskb_xmm(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,fpregs[rm].mmx));\n                gen_helper_pmovmskb_mmx(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n\n        case 0x138:\n        case 0x038:\n            b = modrm;\n            if ((b & 0xf0) == 0xf0) {\n                goto do_0f_38_fx;\n            }\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_epp = sse_op_table6[b].op[b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table6[b].ext_mask))\n                goto illegal_op;\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    switch (b) {\n                    case 0x20: case 0x30: /* pmovsxbw, pmovzxbw */\n                    case 0x23: case 0x33: /* pmovsxwd, pmovzxwd */\n                    case 0x25: case 0x35: /* pmovsxdq, pmovzxdq */\n                        gen_ldq_env_A0(s, op2_offset +\n                                        offsetof(ZMMReg, ZMM_Q(0)));\n                        break;\n                    case 0x21: case 0x31: /* pmovsxbd, pmovzxbd */\n                    case 0x24: case 0x34: /* pmovsxwq, pmovzxwq */\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_L(0)));\n                        break;\n                    case 0x22: case 0x32: /* pmovsxbq, pmovzxbq */\n                        tcg_gen_qemu_ld_tl(cpu_tmp0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                        tcg_gen_st16_tl(cpu_tmp0, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_W(0)));\n                        break;\n                    case 0x2a:            /* movntqda */\n                        gen_ldo_env_A0(s, op1_offset);\n                        return;\n                    default:\n                        gen_ldo_env_A0(s, op2_offset);\n                    }\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            if (sse_fn_epp == SSE_SPECIAL) {\n                goto unknown_op;\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            if (b == 0x17) {\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n            break;\n\n        case 0x238:\n        case 0x338:\n        do_0f_38_fx:\n            /* Various integer extensions at 0f 38 f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* crc32 Gd,Eb */\n            case 0x3f1: /* crc32 Gd,Ey */\n            do_crc32:\n                if (!(s->cpuid_ext_features & CPUID_EXT_SSE42)) {\n                    goto illegal_op;\n                }\n                if ((b & 0xff) == 0xf0) {\n                    ot = MO_8;\n                } else if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[reg]);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                gen_helper_crc32(cpu_T0, cpu_tmp2_i32,\n                                 cpu_T0, tcg_const_i32(8 << ot));\n\n                ot = mo_64_32(s->dflag);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x1f0: /* crc32 or movbe */\n            case 0x1f1:\n                /* For these insns, the f3 prefix is supposed to have priority\n                   over the 66 prefix, but that's not what we implement above\n                   setting b1.  */\n                if (s->prefix & PREFIX_REPNZ) {\n                    goto do_crc32;\n                }\n                /* FALLTHRU */\n            case 0x0f0: /* movbe Gy,My */\n            case 0x0f1: /* movbe My,Gy */\n                if (!(s->cpuid_ext_features & CPUID_EXT_MOVBE)) {\n                    goto illegal_op;\n                }\n                if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                gen_lea_modrm(env, s, modrm);\n                if ((b & 1) == 0) {\n                    tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                } else {\n                    tcg_gen_qemu_st_tl(cpu_regs[reg], cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                }\n                break;\n\n            case 0x0f2: /* andn Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_andc_tl(cpu_T0, cpu_regs[s->vex_v], cpu_T0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_LOGICB + ot);\n                break;\n\n            case 0x0f7: /* bextr Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                {\n                    TCGv bound, zero;\n\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                    /* Extract START, and shift the operand.\n                       Shifts larger than operand size get zeros.  */\n                    tcg_gen_ext8u_tl(cpu_A0, cpu_regs[s->vex_v]);\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_A0);\n\n                    bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    zero = tcg_const_tl(0);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_T0, cpu_A0, bound,\n                                       cpu_T0, zero);\n                    tcg_temp_free(zero);\n\n                    /* Extract the LEN into a mask.  Lengths larger than\n                       operand size get all ones.  */\n                    tcg_gen_extract_tl(cpu_A0, cpu_regs[s->vex_v], 8, 8);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_A0, cpu_A0, bound,\n                                       cpu_A0, bound);\n                    tcg_temp_free(bound);\n                    tcg_gen_movi_tl(cpu_T1, 1);\n                    tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_A0);\n                    tcg_gen_subi_tl(cpu_T1, cpu_T1, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                    gen_op_update1_cc();\n                    set_cc_op(s, CC_OP_LOGICB + ot);\n                }\n                break;\n\n            case 0x0f5: /* bzhi Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                {\n                    TCGv bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    /* Note that since we're using BMILG (in order to get O\n                       cleared) we need to store the inverse into C.  */\n                    tcg_gen_setcond_tl(TCG_COND_LT, cpu_cc_src,\n                                       cpu_T1, bound);\n                    tcg_gen_movcond_tl(TCG_COND_GT, cpu_T1, cpu_T1,\n                                       bound, bound, cpu_T1);\n                    tcg_temp_free(bound);\n                }\n                tcg_gen_movi_tl(cpu_A0, -1);\n                tcg_gen_shl_tl(cpu_A0, cpu_A0, cpu_T1);\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_BMILGB + ot);\n                break;\n\n            case 0x3f6: /* mulx By, Gy, rdx, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                switch (ot) {\n                default:\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EDX]);\n                    tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                      cpu_tmp2_i32, cpu_tmp3_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[s->vex_v], cpu_tmp2_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp3_i32);\n                    break;\n#ifdef TARGET_X86_64\n                case MO_64:\n                    tcg_gen_mulu2_i64(cpu_T0, cpu_T1,\n                                      cpu_T0, cpu_regs[R_EDX]);\n                    tcg_gen_mov_i64(cpu_regs[s->vex_v], cpu_T0);\n                    tcg_gen_mov_i64(cpu_regs[reg], cpu_T1);\n                    break;\n#endif\n                }\n                break;\n\n            case 0x3f5: /* pdep Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pdep(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x2f5: /* pext Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pext(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x1f6: /* adcx Gy, Ey */\n            case 0x2f6: /* adox Gy, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_ADX)) {\n                    goto illegal_op;\n                } else {\n                    TCGv carry_in, carry_out, zero;\n                    int end_op;\n\n                    ot = mo_64_32(s->dflag);\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                    /* Re-use the carry-out from a previous round.  */\n                    TCGV_UNUSED(carry_in);\n                    carry_out = (b == 0x1f6 ? cpu_cc_dst : cpu_cc_src2);\n                    switch (s->cc_op) {\n                    case CC_OP_ADCX:\n                        if (b == 0x1f6) {\n                            carry_in = cpu_cc_dst;\n                            end_op = CC_OP_ADCX;\n                        } else {\n                            end_op = CC_OP_ADCOX;\n                        }\n                        break;\n                    case CC_OP_ADOX:\n                        if (b == 0x1f6) {\n                            end_op = CC_OP_ADCOX;\n                        } else {\n                            carry_in = cpu_cc_src2;\n                            end_op = CC_OP_ADOX;\n                        }\n                        break;\n                    case CC_OP_ADCOX:\n                        end_op = CC_OP_ADCOX;\n                        carry_in = carry_out;\n                        break;\n                    default:\n                        end_op = (b == 0x1f6 ? CC_OP_ADCX : CC_OP_ADOX);\n                        break;\n                    }\n                    /* If we can't reuse carry-out, get it out of EFLAGS.  */\n                    if (TCGV_IS_UNUSED(carry_in)) {\n                        if (s->cc_op != CC_OP_ADCX && s->cc_op != CC_OP_ADOX) {\n                            gen_compute_eflags(s);\n                        }\n                        carry_in = cpu_tmp0;\n                        tcg_gen_extract_tl(carry_in, cpu_cc_src,\n                                           ctz32(b == 0x1f6 ? CC_C : CC_O), 1);\n                    }\n\n                    switch (ot) {\n#ifdef TARGET_X86_64\n                    case MO_32:\n                        /* If we know TL is 64-bit, and we want a 32-bit\n                           result, just do everything in 64-bit arithmetic.  */\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_regs[reg]);\n                        tcg_gen_ext32u_i64(cpu_T0, cpu_T0);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, cpu_regs[reg]);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, carry_in);\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_T0);\n                        tcg_gen_shri_i64(carry_out, cpu_T0, 32);\n                        break;\n#endif\n                    default:\n                        /* Otherwise compute the carry-out in two steps.  */\n                        zero = tcg_const_tl(0);\n                        tcg_gen_add2_tl(cpu_T0, carry_out,\n                                        cpu_T0, zero,\n                                        carry_in, zero);\n                        tcg_gen_add2_tl(cpu_regs[reg], carry_out,\n                                        cpu_regs[reg], carry_out,\n                                        cpu_T0, zero);\n                        tcg_temp_free(zero);\n                        break;\n                    }\n                    set_cc_op(s, end_op);\n                }\n                break;\n\n            case 0x1f7: /* shlx Gy, Ey, By */\n            case 0x2f7: /* sarx Gy, Ey, By */\n            case 0x3f7: /* shrx Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                if (ot == MO_64) {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 63);\n                } else {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 31);\n                }\n                if (b == 0x1f7) {\n                    tcg_gen_shl_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else if (b == 0x2f7) {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_sar_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_T1);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x0f3:\n            case 0x1f3:\n            case 0x2f3:\n            case 0x3f3: /* Group 17 */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                switch (reg & 7) {\n                case 1: /* blsr By,Ey */\n                    tcg_gen_neg_tl(cpu_T1, cpu_T0);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n                    gen_op_mov_reg_v(ot, s->vex_v, cpu_T0);\n                    gen_op_update2_cc();\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 2: /* blsmsk By,Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 3: /* blsi By, Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                default:\n                    goto unknown_op;\n                }\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        case 0x03a:\n        case 0x13a:\n            b = modrm;\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_eppi = sse_op_table7[b].op[b1];\n            if (!sse_fn_eppi) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table7[b].ext_mask))\n                goto illegal_op;\n\n            if (sse_fn_eppi == SSE_SPECIAL) {\n                ot = mo_64_32(s->dflag);\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3)\n                    gen_lea_modrm(env, s, modrm);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                val = cpu_ldub_code(env, s->pc++);\n                switch (b) {\n                case 0x14: /* pextrb */\n                    tcg_gen_ld8u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    break;\n                case 0x15: /* pextrw */\n                    tcg_gen_ld16u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_W(val & 7)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                    }\n                    break;\n                case 0x16:\n                    if (ot == MO_32) { /* pextrd */\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                        if (mod == 3) {\n                            tcg_gen_extu_i32_tl(cpu_regs[rm], cpu_tmp2_i32);\n                        } else {\n                            tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                    } else { /* pextrq */\n#ifdef TARGET_X86_64\n                        tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n                        if (mod == 3) {\n                            tcg_gen_mov_i64(cpu_regs[rm], cpu_tmp1_i64);\n                        } else {\n                            tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                case 0x17: /* extractps */\n                    tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_L(val & 3)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUL);\n                    }\n                    break;\n                case 0x20: /* pinsrb */\n                    if (mod == 3) {\n                        gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n                    } else {\n                        tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    tcg_gen_st8_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    break;\n                case 0x21: /* insertps */\n                    if (mod == 3) {\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,xmm_regs[rm]\n                                                .ZMM_L((val >> 6) & 3)));\n                    } else {\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                    tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                    offsetof(CPUX86State,xmm_regs[reg]\n                                            .ZMM_L((val >> 4) & 3)));\n                    if ((val >> 0) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(0)));\n                    if ((val >> 1) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(1)));\n                    if ((val >> 2) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(2)));\n                    if ((val >> 3) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(3)));\n                    break;\n                case 0x22:\n                    if (ot == MO_32) { /* pinsrd */\n                        if (mod == 3) {\n                            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[rm]);\n                        } else {\n                            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                    } else { /* pinsrq */\n#ifdef TARGET_X86_64\n                        if (mod == 3) {\n                            gen_op_mov_v_reg(ot, cpu_tmp1_i64, rm);\n                        } else {\n                            tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n                        tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                }\n                return;\n            }\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldo_env_A0(s, op2_offset);\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            val = cpu_ldub_code(env, s->pc++);\n\n            if ((b & 0xfc) == 0x60) { /* pcmpXstrX */\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                if (s->dflag == MO_64) {\n                    /* The helper must use entire 64-bit gp registers */\n                    val |= 1 << 8;\n                }\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_eppi(cpu_env, cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n\n        case 0x33a:\n            /* Various integer extensions at 0f 3a f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* rorx Gy,Ey, Ib */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                b = cpu_ldub_code(env, s->pc++);\n                if (ot == MO_64) {\n                    tcg_gen_rotri_tl(cpu_T0, cpu_T0, b & 63);\n                } else {\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_rotri_i32(cpu_tmp2_i32, cpu_tmp2_i32, b & 31);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        default:\n        unknown_op:\n            gen_unknown_opcode(env, s);\n            return;\n        }\n    } else {\n        /* generic MMX or SSE operation */\n        switch(b) {\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n        case 0xc2: /* compare insns */\n            s->rip_offset = 1;\n            break;\n        default:\n            break;\n        }\n        if (is_xmm) {\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            if (mod != 3) {\n                int sz = 4;\n\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                switch (b) {\n                case 0x50 ... 0x5a:\n                case 0x5c ... 0x5f:\n                case 0xc2:\n                    /* Most sse scalar operations.  */\n                    if (b1 == 2) {\n                        sz = 2;\n                    } else if (b1 == 3) {\n                        sz = 3;\n                    }\n                    break;\n\n                case 0x2e:  /* ucomis[sd] */\n                case 0x2f:  /* comis[sd] */\n                    if (b1 == 0) {\n                        sz = 2;\n                    } else {\n                        sz = 3;\n                    }\n                    break;\n                }\n\n                switch (sz) {\n                case 2:\n                    /* 32 bit access */\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env,\n                                    offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                    break;\n                case 3:\n                    /* 64 bit access */\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_D(0)));\n                    break;\n                default:\n                    /* 128 bit access */\n                    gen_ldo_env_A0(s, op2_offset);\n                    break;\n                }\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n        } else {\n            op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n        }\n        switch(b) {\n        case 0x0f: /* 3DNow! data insns */\n            val = cpu_ldub_code(env, s->pc++);\n            sse_fn_epp = sse_op_table5[val];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n                goto illegal_op;\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n            val = cpu_ldub_code(env, s->pc++);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_ppi = (SSEFunc_0_ppi)sse_fn_epp;\n            sse_fn_ppi(cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n        case 0xc2:\n            /* compare insns */\n            val = cpu_ldub_code(env, s->pc++);\n            if (val >= 8)\n                goto unknown_op;\n            sse_fn_epp = sse_op_table4[val][b1];\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0xf7:\n            /* maskmov : we must prepare A0 */\n            if (mod != 3)\n                goto illegal_op;\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EDI]);\n            gen_extu(s->aflag, cpu_A0);\n            gen_add_A0_ds_seg(s);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_eppt = (SSEFunc_0_eppt)sse_fn_epp;\n            sse_fn_eppt(cpu_env, cpu_ptr0, cpu_ptr1, cpu_A0);\n            break;\n        default:\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        }\n        if (b == 0x2e || b == 0x2f) {\n            set_cc_op(s, CC_OP_EFLAGS);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_sse(CPUX86State *env, DisasContext *s, int b,\n                    target_ulong pc_start, int rex_r)\n{\n    int b1, op1_offset, op2_offset, is_xmm, val;\n    int modrm, mod, rm, reg;\n    SSEFunc_0_epp sse_fn_epp;\n    SSEFunc_0_eppi sse_fn_eppi;\n    SSEFunc_0_ppi sse_fn_ppi;\n    SSEFunc_0_eppt sse_fn_eppt;\n    TCGMemOp ot;\n\n    b &= 0xff;\n    if (s->prefix & PREFIX_DATA)\n        b1 = 1;\n    else if (s->prefix & PREFIX_REPZ)\n        b1 = 2;\n    else if (s->prefix & PREFIX_REPNZ)\n        b1 = 3;\n    else\n        b1 = 0;\n    sse_fn_epp = sse_op_table1[b][b1];\n    if (!sse_fn_epp) {\n        goto unknown_op;\n    }\n    if ((b <= 0x5f && b >= 0x10) || b == 0xc6 || b == 0xc2) {\n        is_xmm = 1;\n    } else {\n        if (b1 == 0) {\n            /* MMX case */\n            is_xmm = 0;\n        } else {\n            is_xmm = 1;\n        }\n    }\n    /* simple MMX/SSE operation */\n    if (s->flags & HF_TS_MASK) {\n        gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        return;\n    }\n    if (s->flags & HF_EM_MASK) {\n    illegal_op:\n        gen_illegal_opcode(s);\n        return;\n    }\n    if (is_xmm\n        && !(s->flags & HF_OSFXSR_MASK)\n        && ((b != 0x38 && b != 0x3a) || (s->prefix & PREFIX_DATA))) {\n        goto unknown_op;\n    }\n    if (b == 0x0e) {\n        if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n            /* If we were fully decoding this we might use illegal_op.  */\n            goto unknown_op;\n        }\n        /* femms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    if (b == 0x77) {\n        /* emms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    /* prepare MMX state (XXX: optimize by storing fptt and fptags in\n       the static cpu state) */\n    if (!is_xmm) {\n        gen_helper_enter_mmx(cpu_env);\n    }\n\n    modrm = cpu_ldub_code(env, s->pc++);\n    reg = ((modrm >> 3) & 7);\n    if (is_xmm)\n        reg |= rex_r;\n    mod = (modrm >> 6) & 3;\n    if (sse_fn_epp == SSE_SPECIAL) {\n        b |= (b1 << 8);\n        switch(b) {\n        case 0x0e7: /* movntq */\n            if (mod == 3) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            break;\n        case 0x1e7: /* movntdq */\n        case 0x02b: /* movntps */\n        case 0x12b: /* movntps */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x3f0: /* lddqu */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x22b: /* movntss */\n        case 0x32b: /* movntsd */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if (b1 & 1) {\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                    xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            }\n            break;\n        case 0x6e: /* movd mm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State,fpregs[reg].mmx));\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,fpregs[reg].mmx));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_mmx(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x16e: /* movd xmm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                gen_helper_movq_mm_T0_xmm(cpu_ptr0, cpu_T0);\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_xmm(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x6f: /* movq mm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[rm].mmx));\n                tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x010: /* movups */\n        case 0x110: /* movupd */\n        case 0x028: /* movaps */\n        case 0x128: /* movapd */\n        case 0x16f: /* movdqa xmm, ea */\n        case 0x26f: /* movdqu xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[reg]),\n                            offsetof(CPUX86State,xmm_regs[rm]));\n            }\n            break;\n        case 0x210: /* movss xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n            }\n            break;\n        case 0x310: /* movsd xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x012: /* movlps */\n        case 0x112: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                /* movhlps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x212: /* movsldup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(2)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n            break;\n        case 0x312: /* movddup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            break;\n        case 0x016: /* movhps */\n        case 0x116: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                /* movlhps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x216: /* movshdup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(1)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(3)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            break;\n        case 0x178:\n        case 0x378:\n            {\n                int bit_index, field_length;\n\n                if (b1 == 1 && reg != 0)\n                    goto illegal_op;\n                field_length = cpu_ldub_code(env, s->pc++) & 0x3F;\n                bit_index = cpu_ldub_code(env, s->pc++) & 0x3F;\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env,\n                    offsetof(CPUX86State,xmm_regs[reg]));\n                if (b1 == 1)\n                    gen_helper_extrq_i(cpu_env, cpu_ptr0,\n                                       tcg_const_i32(bit_index),\n                                       tcg_const_i32(field_length));\n                else\n                    gen_helper_insertq_i(cpu_env, cpu_ptr0,\n                                         tcg_const_i32(bit_index),\n                                         tcg_const_i32(field_length));\n            }\n            break;\n        case 0x7e: /* movd ea, mm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,fpregs[reg].mmx.MMX_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x17e: /* movd ea, xmm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x27e: /* movq xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x7f: /* movq ea, mm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                gen_op_movq(offsetof(CPUX86State,fpregs[rm].mmx),\n                            offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x011: /* movups */\n        case 0x111: /* movupd */\n        case 0x029: /* movaps */\n        case 0x129: /* movapd */\n        case 0x17f: /* movdqa ea, xmm */\n        case 0x27f: /* movdqu ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[rm]),\n                            offsetof(CPUX86State,xmm_regs[reg]));\n            }\n            break;\n        case 0x211: /* movss ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            }\n            break;\n        case 0x311: /* movsd ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            }\n            break;\n        case 0x013: /* movlps */\n        case 0x113: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x017: /* movhps */\n        case 0x117: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x71: /* shift mm, im */\n        case 0x72:\n        case 0x73:\n        case 0x171: /* shift xmm, im */\n        case 0x172:\n        case 0x173:\n            if (b1 >= 2) {\n\t        goto unknown_op;\n            }\n            val = cpu_ldub_code(env, s->pc++);\n            if (is_xmm) {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(1)));\n                op1_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(1)));\n                op1_offset = offsetof(CPUX86State,mmx_t0);\n            }\n            sse_fn_epp = sse_op_table2[((b - 1) & 3) * 8 +\n                                       (((modrm >> 3)) & 7)][b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (is_xmm) {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op1_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x050: /* movmskps */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskps(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x150: /* movmskpd */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskpd(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x02a: /* cvtpi2ps */\n        case 0x12a: /* cvtpi2pd */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b >> 8) {\n            case 0x0:\n                gen_helper_cvtpi2ps(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            default:\n            case 0x1:\n                gen_helper_cvtpi2pd(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22a: /* cvtsi2ss */\n        case 0x32a: /* cvtsi2sd */\n            ot = mo_64_32(s->dflag);\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            if (ot == MO_32) {\n                SSEFunc_0_epi sse_fn_epi = sse_op_table3ai[(b >> 8) & 1];\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                sse_fn_epi(cpu_env, cpu_ptr0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_0_epl sse_fn_epl = sse_op_table3aq[(b >> 8) & 1];\n                sse_fn_epl(cpu_env, cpu_ptr0, cpu_T0);\n#else\n                goto illegal_op;\n#endif\n            }\n            break;\n        case 0x02c: /* cvttps2pi */\n        case 0x12c: /* cvttpd2pi */\n        case 0x02d: /* cvtps2pi */\n        case 0x12d: /* cvtpd2pi */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n                gen_ldo_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            op1_offset = offsetof(CPUX86State,fpregs[reg & 7].mmx);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b) {\n            case 0x02c:\n                gen_helper_cvttps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12c:\n                gen_helper_cvttpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x02d:\n                gen_helper_cvtps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12d:\n                gen_helper_cvtpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22c: /* cvttss2si */\n        case 0x32c: /* cvttsd2si */\n        case 0x22d: /* cvtss2si */\n        case 0x32d: /* cvtsd2si */\n            ot = mo_64_32(s->dflag);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                if ((b >> 8) & 1) {\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_Q(0)));\n                } else {\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                }\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            if (ot == MO_32) {\n                SSEFunc_i_ep sse_fn_i_ep =\n                    sse_op_table3bi[((b >> 7) & 2) | (b & 1)];\n                sse_fn_i_ep(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n                tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_l_ep sse_fn_l_ep =\n                    sse_op_table3bq[((b >> 7) & 2) | (b & 1)];\n                sse_fn_l_ep(cpu_T0, cpu_env, cpu_ptr0);\n#else\n                goto illegal_op;\n#endif\n            }\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0xc4: /* pinsrw */\n        case 0x1c4:\n            s->rip_offset = 1;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,xmm_regs[reg].ZMM_W(val)));\n            } else {\n                val &= 3;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[reg].mmx.MMX_W(val)));\n            }\n            break;\n        case 0xc5: /* pextrw */\n        case 0x1c5:\n            if (mod != 3)\n                goto illegal_op;\n            ot = mo_64_32(s->dflag);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[rm].ZMM_W(val)));\n            } else {\n                val &= 3;\n                rm = (modrm & 7);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[rm].mmx.MMX_W(val)));\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0x1d6: /* movq ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x2d6: /* movq2dq */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7);\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                        offsetof(CPUX86State,fpregs[rm].mmx));\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x3d6: /* movdq2q */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_movq(offsetof(CPUX86State,fpregs[reg & 7].mmx),\n                        offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            break;\n        case 0xd7: /* pmovmskb */\n        case 0x1d7:\n            if (mod != 3)\n                goto illegal_op;\n            if (b1) {\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,xmm_regs[rm]));\n                gen_helper_pmovmskb_xmm(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,fpregs[rm].mmx));\n                gen_helper_pmovmskb_mmx(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n\n        case 0x138:\n        case 0x038:\n            b = modrm;\n            if ((b & 0xf0) == 0xf0) {\n                goto do_0f_38_fx;\n            }\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_epp = sse_op_table6[b].op[b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table6[b].ext_mask))\n                goto illegal_op;\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    switch (b) {\n                    case 0x20: case 0x30: /* pmovsxbw, pmovzxbw */\n                    case 0x23: case 0x33: /* pmovsxwd, pmovzxwd */\n                    case 0x25: case 0x35: /* pmovsxdq, pmovzxdq */\n                        gen_ldq_env_A0(s, op2_offset +\n                                        offsetof(ZMMReg, ZMM_Q(0)));\n                        break;\n                    case 0x21: case 0x31: /* pmovsxbd, pmovzxbd */\n                    case 0x24: case 0x34: /* pmovsxwq, pmovzxwq */\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_L(0)));\n                        break;\n                    case 0x22: case 0x32: /* pmovsxbq, pmovzxbq */\n                        tcg_gen_qemu_ld_tl(cpu_tmp0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                        tcg_gen_st16_tl(cpu_tmp0, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_W(0)));\n                        break;\n                    case 0x2a:            /* movntqda */\n                        gen_ldo_env_A0(s, op1_offset);\n                        return;\n                    default:\n                        gen_ldo_env_A0(s, op2_offset);\n                    }\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            if (sse_fn_epp == SSE_SPECIAL) {\n                goto unknown_op;\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            if (b == 0x17) {\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n            break;\n\n        case 0x238:\n        case 0x338:\n        do_0f_38_fx:\n            /* Various integer extensions at 0f 38 f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* crc32 Gd,Eb */\n            case 0x3f1: /* crc32 Gd,Ey */\n            do_crc32:\n                if (!(s->cpuid_ext_features & CPUID_EXT_SSE42)) {\n                    goto illegal_op;\n                }\n                if ((b & 0xff) == 0xf0) {\n                    ot = MO_8;\n                } else if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[reg]);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                gen_helper_crc32(cpu_T0, cpu_tmp2_i32,\n                                 cpu_T0, tcg_const_i32(8 << ot));\n\n                ot = mo_64_32(s->dflag);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x1f0: /* crc32 or movbe */\n            case 0x1f1:\n                /* For these insns, the f3 prefix is supposed to have priority\n                   over the 66 prefix, but that's not what we implement above\n                   setting b1.  */\n                if (s->prefix & PREFIX_REPNZ) {\n                    goto do_crc32;\n                }\n                /* FALLTHRU */\n            case 0x0f0: /* movbe Gy,My */\n            case 0x0f1: /* movbe My,Gy */\n                if (!(s->cpuid_ext_features & CPUID_EXT_MOVBE)) {\n                    goto illegal_op;\n                }\n                if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                gen_lea_modrm(env, s, modrm);\n                if ((b & 1) == 0) {\n                    tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                } else {\n                    tcg_gen_qemu_st_tl(cpu_regs[reg], cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                }\n                break;\n\n            case 0x0f2: /* andn Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_andc_tl(cpu_T0, cpu_regs[s->vex_v], cpu_T0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_LOGICB + ot);\n                break;\n\n            case 0x0f7: /* bextr Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                {\n                    TCGv bound, zero;\n\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                    /* Extract START, and shift the operand.\n                       Shifts larger than operand size get zeros.  */\n                    tcg_gen_ext8u_tl(cpu_A0, cpu_regs[s->vex_v]);\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_A0);\n\n                    bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    zero = tcg_const_tl(0);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_T0, cpu_A0, bound,\n                                       cpu_T0, zero);\n                    tcg_temp_free(zero);\n\n                    /* Extract the LEN into a mask.  Lengths larger than\n                       operand size get all ones.  */\n                    tcg_gen_extract_tl(cpu_A0, cpu_regs[s->vex_v], 8, 8);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_A0, cpu_A0, bound,\n                                       cpu_A0, bound);\n                    tcg_temp_free(bound);\n                    tcg_gen_movi_tl(cpu_T1, 1);\n                    tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_A0);\n                    tcg_gen_subi_tl(cpu_T1, cpu_T1, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                    gen_op_update1_cc();\n                    set_cc_op(s, CC_OP_LOGICB + ot);\n                }\n                break;\n\n            case 0x0f5: /* bzhi Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                {\n                    TCGv bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    /* Note that since we're using BMILG (in order to get O\n                       cleared) we need to store the inverse into C.  */\n                    tcg_gen_setcond_tl(TCG_COND_LT, cpu_cc_src,\n                                       cpu_T1, bound);\n                    tcg_gen_movcond_tl(TCG_COND_GT, cpu_T1, cpu_T1,\n                                       bound, bound, cpu_T1);\n                    tcg_temp_free(bound);\n                }\n                tcg_gen_movi_tl(cpu_A0, -1);\n                tcg_gen_shl_tl(cpu_A0, cpu_A0, cpu_T1);\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_BMILGB + ot);\n                break;\n\n            case 0x3f6: /* mulx By, Gy, rdx, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                switch (ot) {\n                default:\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EDX]);\n                    tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                      cpu_tmp2_i32, cpu_tmp3_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[s->vex_v], cpu_tmp2_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp3_i32);\n                    break;\n#ifdef TARGET_X86_64\n                case MO_64:\n                    tcg_gen_mulu2_i64(cpu_T0, cpu_T1,\n                                      cpu_T0, cpu_regs[R_EDX]);\n                    tcg_gen_mov_i64(cpu_regs[s->vex_v], cpu_T0);\n                    tcg_gen_mov_i64(cpu_regs[reg], cpu_T1);\n                    break;\n#endif\n                }\n                break;\n\n            case 0x3f5: /* pdep Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pdep(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x2f5: /* pext Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pext(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x1f6: /* adcx Gy, Ey */\n            case 0x2f6: /* adox Gy, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_ADX)) {\n                    goto illegal_op;\n                } else {\n                    TCGv carry_in, carry_out, zero;\n                    int end_op;\n\n                    ot = mo_64_32(s->dflag);\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                    /* Re-use the carry-out from a previous round.  */\n                    TCGV_UNUSED(carry_in);\n                    carry_out = (b == 0x1f6 ? cpu_cc_dst : cpu_cc_src2);\n                    switch (s->cc_op) {\n                    case CC_OP_ADCX:\n                        if (b == 0x1f6) {\n                            carry_in = cpu_cc_dst;\n                            end_op = CC_OP_ADCX;\n                        } else {\n                            end_op = CC_OP_ADCOX;\n                        }\n                        break;\n                    case CC_OP_ADOX:\n                        if (b == 0x1f6) {\n                            end_op = CC_OP_ADCOX;\n                        } else {\n                            carry_in = cpu_cc_src2;\n                            end_op = CC_OP_ADOX;\n                        }\n                        break;\n                    case CC_OP_ADCOX:\n                        end_op = CC_OP_ADCOX;\n                        carry_in = carry_out;\n                        break;\n                    default:\n                        end_op = (b == 0x1f6 ? CC_OP_ADCX : CC_OP_ADOX);\n                        break;\n                    }\n                    /* If we can't reuse carry-out, get it out of EFLAGS.  */\n                    if (TCGV_IS_UNUSED(carry_in)) {\n                        if (s->cc_op != CC_OP_ADCX && s->cc_op != CC_OP_ADOX) {\n                            gen_compute_eflags(s);\n                        }\n                        carry_in = cpu_tmp0;\n                        tcg_gen_extract_tl(carry_in, cpu_cc_src,\n                                           ctz32(b == 0x1f6 ? CC_C : CC_O), 1);\n                    }\n\n                    switch (ot) {\n#ifdef TARGET_X86_64\n                    case MO_32:\n                        /* If we know TL is 64-bit, and we want a 32-bit\n                           result, just do everything in 64-bit arithmetic.  */\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_regs[reg]);\n                        tcg_gen_ext32u_i64(cpu_T0, cpu_T0);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, cpu_regs[reg]);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, carry_in);\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_T0);\n                        tcg_gen_shri_i64(carry_out, cpu_T0, 32);\n                        break;\n#endif\n                    default:\n                        /* Otherwise compute the carry-out in two steps.  */\n                        zero = tcg_const_tl(0);\n                        tcg_gen_add2_tl(cpu_T0, carry_out,\n                                        cpu_T0, zero,\n                                        carry_in, zero);\n                        tcg_gen_add2_tl(cpu_regs[reg], carry_out,\n                                        cpu_regs[reg], carry_out,\n                                        cpu_T0, zero);\n                        tcg_temp_free(zero);\n                        break;\n                    }\n                    set_cc_op(s, end_op);\n                }\n                break;\n\n            case 0x1f7: /* shlx Gy, Ey, By */\n            case 0x2f7: /* sarx Gy, Ey, By */\n            case 0x3f7: /* shrx Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                if (ot == MO_64) {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 63);\n                } else {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 31);\n                }\n                if (b == 0x1f7) {\n                    tcg_gen_shl_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else if (b == 0x2f7) {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_sar_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_T1);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x0f3:\n            case 0x1f3:\n            case 0x2f3:\n            case 0x3f3: /* Group 17 */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                switch (reg & 7) {\n                case 1: /* blsr By,Ey */\n                    tcg_gen_neg_tl(cpu_T1, cpu_T0);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n                    gen_op_mov_reg_v(ot, s->vex_v, cpu_T0);\n                    gen_op_update2_cc();\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 2: /* blsmsk By,Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 3: /* blsi By, Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                default:\n                    goto unknown_op;\n                }\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        case 0x03a:\n        case 0x13a:\n            b = modrm;\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_eppi = sse_op_table7[b].op[b1];\n            if (!sse_fn_eppi) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table7[b].ext_mask))\n                goto illegal_op;\n\n            if (sse_fn_eppi == SSE_SPECIAL) {\n                ot = mo_64_32(s->dflag);\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3)\n                    gen_lea_modrm(env, s, modrm);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                val = cpu_ldub_code(env, s->pc++);\n                switch (b) {\n                case 0x14: /* pextrb */\n                    tcg_gen_ld8u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    break;\n                case 0x15: /* pextrw */\n                    tcg_gen_ld16u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_W(val & 7)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                    }\n                    break;\n                case 0x16:\n                    if (ot == MO_32) { /* pextrd */\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                        if (mod == 3) {\n                            tcg_gen_extu_i32_tl(cpu_regs[rm], cpu_tmp2_i32);\n                        } else {\n                            tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                    } else { /* pextrq */\n#ifdef TARGET_X86_64\n                        tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n                        if (mod == 3) {\n                            tcg_gen_mov_i64(cpu_regs[rm], cpu_tmp1_i64);\n                        } else {\n                            tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                case 0x17: /* extractps */\n                    tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_L(val & 3)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUL);\n                    }\n                    break;\n                case 0x20: /* pinsrb */\n                    if (mod == 3) {\n                        gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n                    } else {\n                        tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    tcg_gen_st8_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    break;\n                case 0x21: /* insertps */\n                    if (mod == 3) {\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,xmm_regs[rm]\n                                                .ZMM_L((val >> 6) & 3)));\n                    } else {\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                    tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                    offsetof(CPUX86State,xmm_regs[reg]\n                                            .ZMM_L((val >> 4) & 3)));\n                    if ((val >> 0) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(0)));\n                    if ((val >> 1) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(1)));\n                    if ((val >> 2) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(2)));\n                    if ((val >> 3) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(3)));\n                    break;\n                case 0x22:\n                    if (ot == MO_32) { /* pinsrd */\n                        if (mod == 3) {\n                            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[rm]);\n                        } else {\n                            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                    } else { /* pinsrq */\n#ifdef TARGET_X86_64\n                        if (mod == 3) {\n                            gen_op_mov_v_reg(ot, cpu_tmp1_i64, rm);\n                        } else {\n                            tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n                        tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                }\n                return;\n            }\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldo_env_A0(s, op2_offset);\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            val = cpu_ldub_code(env, s->pc++);\n\n            if ((b & 0xfc) == 0x60) { /* pcmpXstrX */\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                if (s->dflag == MO_64) {\n                    /* The helper must use entire 64-bit gp registers */\n                    val |= 1 << 8;\n                }\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_eppi(cpu_env, cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n\n        case 0x33a:\n            /* Various integer extensions at 0f 3a f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* rorx Gy,Ey, Ib */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                b = cpu_ldub_code(env, s->pc++);\n                if (ot == MO_64) {\n                    tcg_gen_rotri_tl(cpu_T0, cpu_T0, b & 63);\n                } else {\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_rotri_i32(cpu_tmp2_i32, cpu_tmp2_i32, b & 31);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        default:\n        unknown_op:\n            gen_unknown_opcode(env, s);\n            return;\n        }\n    } else {\n        /* generic MMX or SSE operation */\n        switch(b) {\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n        case 0xc2: /* compare insns */\n            s->rip_offset = 1;\n            break;\n        default:\n            break;\n        }\n        if (is_xmm) {\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            if (mod != 3) {\n                int sz = 4;\n\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                switch (b) {\n                case 0x50 ... 0x5a:\n                case 0x5c ... 0x5f:\n                case 0xc2:\n                    /* Most sse scalar operations.  */\n                    if (b1 == 2) {\n                        sz = 2;\n                    } else if (b1 == 3) {\n                        sz = 3;\n                    }\n                    break;\n\n                case 0x2e:  /* ucomis[sd] */\n                case 0x2f:  /* comis[sd] */\n                    if (b1 == 0) {\n                        sz = 2;\n                    } else {\n                        sz = 3;\n                    }\n                    break;\n                }\n\n                switch (sz) {\n                case 2:\n                    /* 32 bit access */\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env,\n                                    offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                    break;\n                case 3:\n                    /* 64 bit access */\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_D(0)));\n                    break;\n                default:\n                    /* 128 bit access */\n                    gen_ldo_env_A0(s, op2_offset);\n                    break;\n                }\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n        } else {\n            op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n        }\n        switch(b) {\n        case 0x0f: /* 3DNow! data insns */\n            val = cpu_ldub_code(env, s->pc++);\n            sse_fn_epp = sse_op_table5[val];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n                goto illegal_op;\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n            val = cpu_ldub_code(env, s->pc++);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_ppi = (SSEFunc_0_ppi)sse_fn_epp;\n            sse_fn_ppi(cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n        case 0xc2:\n            /* compare insns */\n            val = cpu_ldub_code(env, s->pc++);\n            if (val >= 8)\n                goto unknown_op;\n            sse_fn_epp = sse_op_table4[val][b1];\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0xf7:\n            /* maskmov : we must prepare A0 */\n            if (mod != 3)\n                goto illegal_op;\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EDI]);\n            gen_extu(s->aflag, cpu_A0);\n            gen_add_A0_ds_seg(s);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_eppt = (SSEFunc_0_eppt)sse_fn_epp;\n            sse_fn_eppt(cpu_env, cpu_ptr0, cpu_ptr1, cpu_A0);\n            break;\n        default:\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        }\n        if (b == 0x2e || b == 0x2f) {\n            set_cc_op(s, CC_OP_EFLAGS);\n        }\n    }\n}\n",
        "linevul": 0.0003404050075914711
    },
    {
        "code": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n{\n    DisplaySurface *surface = qemu_console_surface(s->con);\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n    int width, height, shift_control, line_offset, bwidth, bits;\n    ram_addr_t page0, page1;\n    DirtyBitmapSnapshot *snap = NULL;\n    int disp_width, multi_scan, multi_run;\n    uint8_t *d;\n    uint32_t v, addr1, addr;\n    vga_draw_line_func *vga_draw_line = NULL;\n    bool share_surface;\n    pixman_format_code_t format;\n#ifdef HOST_WORDS_BIGENDIAN\n    bool byteswap = !s->big_endian_fb;\n#else\n    bool byteswap = s->big_endian_fb;\n#endif\n\n    full_update |= update_basic_params(s);\n\n    s->get_resolution(s, &width, &height);\n    disp_width = width;\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n    if (shift_control != 1) {\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n            - 1;\n    } else {\n        /* in CGA modes, multi_scan is ignored */\n        /* XXX: is it correct ? */\n        multi_scan = double_scan;\n    }\n    multi_run = multi_scan;\n    if (shift_control != s->shift_control ||\n        double_scan != s->double_scan) {\n        full_update = 1;\n        s->shift_control = shift_control;\n        s->double_scan = double_scan;\n    }\n\n    if (shift_control == 0) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    } else if (shift_control == 1) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    }\n\n    depth = s->get_bpp(s);\n\n    /*\n     * Check whether we can share the surface with the backend\n     * or whether we need a shadow surface. We share native\n     * endian surfaces for 15bpp and above and byteswapped\n     * surfaces for 24bpp and above.\n     */\n    format = qemu_default_pixman_format(depth, !byteswap);\n    if (format) {\n        share_surface = dpy_gfx_check_format(s->con, format)\n            && !s->force_shadow;\n    } else {\n        share_surface = false;\n    }\n    if (s->line_offset != s->last_line_offset ||\n        disp_width != s->last_width ||\n        height != s->last_height ||\n        s->last_depth != depth ||\n        s->last_byteswap != byteswap ||\n        share_surface != is_buffer_shared(surface)) {\n        if (share_surface) {\n            surface = qemu_create_displaysurface_from(disp_width,\n                    height, format, s->line_offset,\n                    s->vram_ptr + (s->start_addr * 4));\n            dpy_gfx_replace_surface(s->con, surface);\n        } else {\n            qemu_console_resize(s->con, disp_width, height);\n            surface = qemu_console_surface(s->con);\n        }\n        s->last_scr_width = disp_width;\n        s->last_scr_height = height;\n        s->last_width = disp_width;\n        s->last_height = height;\n        s->last_line_offset = s->line_offset;\n        s->last_depth = depth;\n        s->last_byteswap = byteswap;\n        full_update = 1;\n    } else if (is_buffer_shared(surface) &&\n               (full_update || surface_data(surface) != s->vram_ptr\n                + (s->start_addr * 4))) {\n        pixman_format_code_t format =\n            qemu_default_pixman_format(depth, !byteswap);\n        surface = qemu_create_displaysurface_from(disp_width,\n                height, format, s->line_offset,\n                s->vram_ptr + (s->start_addr * 4));\n        dpy_gfx_replace_surface(s->con, surface);\n    }\n\n    if (shift_control == 0) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE4D2;\n        } else {\n            v = VGA_DRAW_LINE4;\n        }\n        bits = 4;\n    } else if (shift_control == 1) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE2D2;\n        } else {\n            v = VGA_DRAW_LINE2;\n        }\n        bits = 4;\n    } else {\n        switch(s->get_bpp(s)) {\n        default:\n        case 0:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8D2;\n            bits = 4;\n            break;\n        case 8:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8;\n            bits = 8;\n            break;\n        case 15:\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n            bits = 16;\n            break;\n        case 16:\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n            bits = 16;\n            break;\n        case 24:\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n            bits = 24;\n            break;\n        case 32:\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n            bits = 32;\n            break;\n        }\n    }\n    vga_draw_line = vga_draw_line_table[v];\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n        s->cursor_invalidate(s);\n    }\n\n    line_offset = s->line_offset;\n#if 0\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n#endif\n    addr1 = (s->start_addr * 4);\n    bwidth = (width * bits + 7) / 8;\n    y_start = -1;\n    d = surface_data(surface);\n    linesize = surface_stride(surface);\n    y1 = 0;\n\n     if (!full_update) {\n         vga_sync_dirty_bitmap(s);\n         snap = memory_region_snapshot_and_clear_dirty(&s->vram, addr1,\n                                                      bwidth * height,\n                                                       DIRTY_MEMORY_VGA);\n     }\n    for(y = 0; y < height; y++) {\n        addr = addr1;\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n            int shift;\n            /* CGA compatibility handling */\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n        }\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n        }\n        update = full_update;\n        page0 = addr;\n        page1 = addr + bwidth - 1;\n        if (full_update) {\n            update = 1;\n        } else {\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n                                                      page0, page1 - page0);\n        }\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n        update |= vga_scanline_invalidated(s, y);\n        if (update) {\n            if (y_start < 0)\n                y_start = y;\n            if (!(is_buffer_shared(surface))) {\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n                if (s->cursor_draw_line)\n                    s->cursor_draw_line(s, d, y);\n            }\n        } else {\n            if (y_start >= 0) {\n                /* flush to display */\n                dpy_gfx_update(s->con, 0, y_start,\n                               disp_width, y - y_start);\n                y_start = -1;\n            }\n        }\n        if (!multi_run) {\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n            if ((y1 & mask) == mask)\n                addr1 += line_offset;\n            y1++;\n            multi_run = multi_scan;\n        } else {\n            multi_run--;\n        }\n        /* line compare acts on the displayed lines */\n        if (y == s->line_compare)\n            addr1 = 0;\n        d += linesize;\n    }\n    if (y_start >= 0) {\n        /* flush to display */\n        dpy_gfx_update(s->con, 0, y_start,\n                       disp_width, y - y_start);\n    }\n    g_free(snap);\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n{\n    DisplaySurface *surface = qemu_console_surface(s->con);\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n    int width, height, shift_control, line_offset, bwidth, bits;\n    ram_addr_t page0, page1;\n    DirtyBitmapSnapshot *snap = NULL;\n    int disp_width, multi_scan, multi_run;\n    uint8_t *d;\n    uint32_t v, addr1, addr;\n    vga_draw_line_func *vga_draw_line = NULL;\n    bool share_surface;\n    pixman_format_code_t format;\n#ifdef HOST_WORDS_BIGENDIAN\n    bool byteswap = !s->big_endian_fb;\n#else\n    bool byteswap = s->big_endian_fb;\n#endif\n\n    full_update |= update_basic_params(s);\n\n    s->get_resolution(s, &width, &height);\n    disp_width = width;\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n    if (shift_control != 1) {\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n            - 1;\n    } else {\n        /* in CGA modes, multi_scan is ignored */\n        /* XXX: is it correct ? */\n        multi_scan = double_scan;\n    }\n    multi_run = multi_scan;\n    if (shift_control != s->shift_control ||\n        double_scan != s->double_scan) {\n        full_update = 1;\n        s->shift_control = shift_control;\n        s->double_scan = double_scan;\n    }\n\n    if (shift_control == 0) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    } else if (shift_control == 1) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    }\n\n    depth = s->get_bpp(s);\n\n    /*\n     * Check whether we can share the surface with the backend\n     * or whether we need a shadow surface. We share native\n     * endian surfaces for 15bpp and above and byteswapped\n     * surfaces for 24bpp and above.\n     */\n    format = qemu_default_pixman_format(depth, !byteswap);\n    if (format) {\n        share_surface = dpy_gfx_check_format(s->con, format)\n            && !s->force_shadow;\n    } else {\n        share_surface = false;\n    }\n    if (s->line_offset != s->last_line_offset ||\n        disp_width != s->last_width ||\n        height != s->last_height ||\n        s->last_depth != depth ||\n        s->last_byteswap != byteswap ||\n        share_surface != is_buffer_shared(surface)) {\n        if (share_surface) {\n            surface = qemu_create_displaysurface_from(disp_width,\n                    height, format, s->line_offset,\n                    s->vram_ptr + (s->start_addr * 4));\n            dpy_gfx_replace_surface(s->con, surface);\n        } else {\n            qemu_console_resize(s->con, disp_width, height);\n            surface = qemu_console_surface(s->con);\n        }\n        s->last_scr_width = disp_width;\n        s->last_scr_height = height;\n        s->last_width = disp_width;\n        s->last_height = height;\n        s->last_line_offset = s->line_offset;\n        s->last_depth = depth;\n        s->last_byteswap = byteswap;\n        full_update = 1;\n    } else if (is_buffer_shared(surface) &&\n               (full_update || surface_data(surface) != s->vram_ptr\n                + (s->start_addr * 4))) {\n        pixman_format_code_t format =\n            qemu_default_pixman_format(depth, !byteswap);\n        surface = qemu_create_displaysurface_from(disp_width,\n                height, format, s->line_offset,\n                s->vram_ptr + (s->start_addr * 4));\n        dpy_gfx_replace_surface(s->con, surface);\n    }\n\n    if (shift_control == 0) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE4D2;\n        } else {\n            v = VGA_DRAW_LINE4;\n        }\n        bits = 4;\n    } else if (shift_control == 1) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE2D2;\n        } else {\n            v = VGA_DRAW_LINE2;\n        }\n        bits = 4;\n    } else {\n        switch(s->get_bpp(s)) {\n        default:\n        case 0:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8D2;\n            bits = 4;\n            break;\n        case 8:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8;\n            bits = 8;\n            break;\n        case 15:\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n            bits = 16;\n            break;\n        case 16:\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n            bits = 16;\n            break;\n        case 24:\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n            bits = 24;\n            break;\n        case 32:\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n            bits = 32;\n            break;\n        }\n    }\n    vga_draw_line = vga_draw_line_table[v];\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n        s->cursor_invalidate(s);\n    }\n\n    line_offset = s->line_offset;\n#if 0\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n#endif\n    addr1 = (s->start_addr * 4);\n    bwidth = (width * bits + 7) / 8;\n    y_start = -1;\n    d = surface_data(surface);\n    linesize = surface_stride(surface);\n    y1 = 0;\n\n     if (!full_update) {\n         vga_sync_dirty_bitmap(s);\n         snap = memory_region_snapshot_and_clear_dirty(&s->vram, addr1,\n//flaw_line_below:\n                                                      bwidth * height,\n//fix_flaw_line_below:\n//                                                      line_offset * height,\n                                                       DIRTY_MEMORY_VGA);\n     }\n    for(y = 0; y < height; y++) {\n        addr = addr1;\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n            int shift;\n            /* CGA compatibility handling */\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n        }\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n        }\n        update = full_update;\n        page0 = addr;\n        page1 = addr + bwidth - 1;\n        if (full_update) {\n            update = 1;\n        } else {\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n                                                      page0, page1 - page0);\n        }\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n        update |= vga_scanline_invalidated(s, y);\n        if (update) {\n            if (y_start < 0)\n                y_start = y;\n            if (!(is_buffer_shared(surface))) {\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n                if (s->cursor_draw_line)\n                    s->cursor_draw_line(s, d, y);\n            }\n        } else {\n            if (y_start >= 0) {\n                /* flush to display */\n                dpy_gfx_update(s->con, 0, y_start,\n                               disp_width, y - y_start);\n                y_start = -1;\n            }\n        }\n        if (!multi_run) {\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n            if ((y1 & mask) == mask)\n                addr1 += line_offset;\n            y1++;\n            multi_run = multi_scan;\n        } else {\n            multi_run--;\n        }\n        /* line compare acts on the displayed lines */\n        if (y == s->line_compare)\n            addr1 = 0;\n        d += linesize;\n    }\n    if (y_start >= 0) {\n        /* flush to display */\n        dpy_gfx_update(s->con, 0, y_start,\n                       disp_width, y - y_start);\n    }\n    g_free(snap);\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n}\n",
        "linevul": 0.00993792898952961
    },
    {
        "code": "static uint64_t rx_desc_base(E1000State *s)\n{\n    uint64_t bah = s->mac_reg[RDBAH];\n    uint64_t bal = s->mac_reg[RDBAL] & ~0xf;\n\n    return (bah << 32) + bal;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb",
        "vul_func_with_fix": "static uint64_t rx_desc_base(E1000State *s)\n{\n    uint64_t bah = s->mac_reg[RDBAH];\n    uint64_t bal = s->mac_reg[RDBAL] & ~0xf;\n\n    return (bah << 32) + bal;\n}\n",
        "linevul": 5.38876629434526e-05
    },
    {
        "code": "int qemu_fdt_setprop_cell(void *fdt, const char *node_path,\n                          const char *property, uint32_t val)\n{\n    int r;\n\n    r = fdt_setprop_cell(fdt, findnode_nofail(fdt, node_path), property, val);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s = %#08x: %s\", __func__,\n                     node_path, property, val, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=da885fe1ee8b4589047484bd7fa05a4905b52b17",
        "vul_func_with_fix": "int qemu_fdt_setprop_cell(void *fdt, const char *node_path,\n                          const char *property, uint32_t val)\n{\n    int r;\n\n    r = fdt_setprop_cell(fdt, findnode_nofail(fdt, node_path), property, val);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s = %#08x: %s\", __func__,\n                     node_path, property, val, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n",
        "linevul": 4.828445889870636e-05
    },
    {
        "code": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n     s->catalog_size = le32_to_cpu(bochs.catalog);\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e3737b820b45e54b059656dc3f914f895ac7a88b",
        "vul_func_with_fix": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n//fix_flaw_line_below:\n//    /* Limit to 1M entries to avoid unbounded allocation. This is what is\n//fix_flaw_line_below:\n//     * needed for the largest image that bximage can create (~8 TB). */\n     s->catalog_size = le32_to_cpu(bochs.catalog);\n//fix_flaw_line_below:\n//    if (s->catalog_size > 0x100000) {\n//fix_flaw_line_below:\n//        error_setg(errp, \"Catalog size is too large\");\n//fix_flaw_line_below:\n//        return -EFBIG;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n//fix_flaw_line_below:\n//    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n//fix_flaw_line_below:\n//        error_setg(errp, \"Catalog size is too small for this disk size\");\n//fix_flaw_line_below:\n//        ret = -EINVAL;\n//fix_flaw_line_below:\n//        goto fail;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n",
        "linevul": 0.0003208575944881886
    },
    {
        "code": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n{\n    s->last_command = cmd;\n\n    switch (cmd) {\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_STATS:\n        VMW_CBPRN(\"Set: Get device statistics\");\n        vmxnet3_fill_stats(s);\n        break;\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n        vmxnet3_activate_device(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n        VMW_CBPRN(\"Set: Update rx mode\");\n        vmxnet3_update_rx_mode(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n        vmxnet3_update_vlan_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n        VMW_CBPRN(\"Set: Update MAC filters\");\n        vmxnet3_update_mcast_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n        VMW_CBPRN(\"Set: Update features\");\n        vmxnet3_update_features(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n        VMW_CBPRN(\"Set: Update power management config\");\n        vmxnet3_update_pm_state(s);\n        break;\n\n    case VMXNET3_CMD_GET_LINK:\n        VMW_CBPRN(\"Set: Get link\");\n        break;\n\n    case VMXNET3_CMD_RESET_DEV:\n        VMW_CBPRN(\"Set: Reset device\");\n        vmxnet3_reset(s);\n        break;\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - deactivate the device\");\n        vmxnet3_deactivate_device(s);\n        break;\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n        break;\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n                  \"adaptive ring info flags\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_LO:\n        VMW_CBPRN(\"Set: Get lower part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_HI:\n        VMW_CBPRN(\"Set: Get upper part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DEV_EXTRA_INFO:\n        VMW_CBPRN(\"Set: Get device extra info\");\n        break;\n\n    default:\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n        break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n{\n    s->last_command = cmd;\n\n    switch (cmd) {\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_STATS:\n        VMW_CBPRN(\"Set: Get device statistics\");\n        vmxnet3_fill_stats(s);\n        break;\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n        vmxnet3_activate_device(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n        VMW_CBPRN(\"Set: Update rx mode\");\n        vmxnet3_update_rx_mode(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n        vmxnet3_update_vlan_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n        VMW_CBPRN(\"Set: Update MAC filters\");\n        vmxnet3_update_mcast_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n        VMW_CBPRN(\"Set: Update features\");\n        vmxnet3_update_features(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n        VMW_CBPRN(\"Set: Update power management config\");\n        vmxnet3_update_pm_state(s);\n        break;\n\n    case VMXNET3_CMD_GET_LINK:\n        VMW_CBPRN(\"Set: Get link\");\n        break;\n\n    case VMXNET3_CMD_RESET_DEV:\n        VMW_CBPRN(\"Set: Reset device\");\n        vmxnet3_reset(s);\n        break;\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - deactivate the device\");\n        vmxnet3_deactivate_device(s);\n        break;\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n        break;\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n                  \"adaptive ring info flags\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_LO:\n        VMW_CBPRN(\"Set: Get lower part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_HI:\n        VMW_CBPRN(\"Set: Get upper part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DEV_EXTRA_INFO:\n        VMW_CBPRN(\"Set: Get device extra info\");\n        break;\n\n    default:\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n        break;\n    }\n}\n",
        "linevul": 4.7827652451815084e-05
    },
    {
        "code": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    if (num_sg >= VIRTQUEUE_MAX_SIZE) {\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n        exit(1);\n    }\n\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");\n            exit(1);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    if (num_sg >= VIRTQUEUE_MAX_SIZE) {\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n        exit(1);\n    }\n\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");\n            exit(1);\n        }\n    }\n}\n",
        "linevul": 6.374981603585184e-05
    },
    {
        "code": "static int64_t sector_lun2qemu(int64_t sector, IscsiLun *iscsilun)\n{\n    return sector * iscsilun->block_size / BDRV_SECTOR_SIZE;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static int64_t sector_lun2qemu(int64_t sector, IscsiLun *iscsilun)\n{\n    return sector * iscsilun->block_size / BDRV_SECTOR_SIZE;\n}\n",
        "linevul": 5.5506443459307775e-05
    },
    {
        "code": "static int coroutine_fn fid_to_qid(V9fsPDU *pdu, V9fsFidState *fidp,\n                                   V9fsQID *qidp)\n{\n    struct stat stbuf;\n    int err;\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        return err;\n    }\n    stat_to_qid(&stbuf, qidp);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn fid_to_qid(V9fsPDU *pdu, V9fsFidState *fidp,\n                                   V9fsQID *qidp)\n{\n    struct stat stbuf;\n    int err;\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        return err;\n    }\n    stat_to_qid(&stbuf, qidp);\n    return 0;\n}\n",
        "linevul": 5.8220161008648574e-05
    },
    {
        "code": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n    int chunk_size;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n    while (data_length) {\n        while (!sg.resid) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n        assert(data_length > 0);\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8",
        "vul_func_with_fix": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n//flaw_line_below:\n    int chunk_size;\n//fix_flaw_line_below:\n//    uint32_t chunk_size, elmcnt = 0;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n//flaw_line_below:\n    while (data_length) {\n//flaw_line_below:\n        while (!sg.resid) {\n//fix_flaw_line_below:\n//    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n//fix_flaw_line_below:\n//        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n//flaw_line_below:\n        assert(data_length > 0);\n//flaw_line_below:\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n//fix_flaw_line_below:\n//        chunk_size = MIN(data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}\n",
        "linevul": 0.0012049622600898147
    },
    {
        "code": "int qcow2_read_snapshots(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshotHeader h;\n    QCowSnapshotExtraData extra;\n    QCowSnapshot *sn;\n    int i, id_str_size, name_size;\n    int64_t offset;\n    uint32_t extra_data_size;\n    int ret;\n\n    if (!s->nb_snapshots) {\n        s->snapshots = NULL;\n        s->snapshots_size = 0;\n        return 0;\n    }\n\n    offset = s->snapshots_offset;\n    s->snapshots = g_malloc0(s->nb_snapshots * sizeof(QCowSnapshot));\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n        /* Read statically sized part of the snapshot header */\n        offset = align_offset(offset, 8);\n        ret = bdrv_pread(bs->file, offset, &h, sizeof(h));\n        if (ret < 0) {\n            goto fail;\n        }\n\n        offset += sizeof(h);\n        sn = s->snapshots + i;\n        sn->l1_table_offset = be64_to_cpu(h.l1_table_offset);\n        sn->l1_size = be32_to_cpu(h.l1_size);\n        sn->vm_state_size = be32_to_cpu(h.vm_state_size);\n        sn->date_sec = be32_to_cpu(h.date_sec);\n        sn->date_nsec = be32_to_cpu(h.date_nsec);\n        sn->vm_clock_nsec = be64_to_cpu(h.vm_clock_nsec);\n        extra_data_size = be32_to_cpu(h.extra_data_size);\n\n        id_str_size = be16_to_cpu(h.id_str_size);\n        name_size = be16_to_cpu(h.name_size);\n\n        /* Read extra data */\n        ret = bdrv_pread(bs->file, offset, &extra,\n                         MIN(sizeof(extra), extra_data_size));\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += extra_data_size;\n\n        if (extra_data_size >= 8) {\n            sn->vm_state_size = be64_to_cpu(extra.vm_state_size_large);\n        }\n\n        if (extra_data_size >= 16) {\n            sn->disk_size = be64_to_cpu(extra.disk_size);\n        } else {\n            sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n        }\n\n        /* Read snapshot ID */\n        sn->id_str = g_malloc(id_str_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->id_str, id_str_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += id_str_size;\n        sn->id_str[id_str_size] = '\\0';\n\n        /* Read snapshot name */\n        sn->name = g_malloc(name_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->name, name_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += name_size;\n        sn->name[name_size] = '\\0';\n    }\n\n    s->snapshots_size = offset - s->snapshots_offset;\n    return 0;\n\nfail:\n    qcow2_free_snapshots(bs);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c05e4667be91b46ab42b5a11babf8e84d476cc6b",
        "vul_func_with_fix": "int qcow2_read_snapshots(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshotHeader h;\n    QCowSnapshotExtraData extra;\n    QCowSnapshot *sn;\n    int i, id_str_size, name_size;\n    int64_t offset;\n    uint32_t extra_data_size;\n    int ret;\n\n    if (!s->nb_snapshots) {\n        s->snapshots = NULL;\n        s->snapshots_size = 0;\n        return 0;\n    }\n\n    offset = s->snapshots_offset;\n    s->snapshots = g_malloc0(s->nb_snapshots * sizeof(QCowSnapshot));\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n        /* Read statically sized part of the snapshot header */\n        offset = align_offset(offset, 8);\n        ret = bdrv_pread(bs->file, offset, &h, sizeof(h));\n        if (ret < 0) {\n            goto fail;\n        }\n\n        offset += sizeof(h);\n        sn = s->snapshots + i;\n        sn->l1_table_offset = be64_to_cpu(h.l1_table_offset);\n        sn->l1_size = be32_to_cpu(h.l1_size);\n        sn->vm_state_size = be32_to_cpu(h.vm_state_size);\n        sn->date_sec = be32_to_cpu(h.date_sec);\n        sn->date_nsec = be32_to_cpu(h.date_nsec);\n        sn->vm_clock_nsec = be64_to_cpu(h.vm_clock_nsec);\n        extra_data_size = be32_to_cpu(h.extra_data_size);\n\n        id_str_size = be16_to_cpu(h.id_str_size);\n        name_size = be16_to_cpu(h.name_size);\n\n        /* Read extra data */\n        ret = bdrv_pread(bs->file, offset, &extra,\n                         MIN(sizeof(extra), extra_data_size));\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += extra_data_size;\n\n        if (extra_data_size >= 8) {\n            sn->vm_state_size = be64_to_cpu(extra.vm_state_size_large);\n        }\n\n        if (extra_data_size >= 16) {\n            sn->disk_size = be64_to_cpu(extra.disk_size);\n        } else {\n            sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n        }\n\n        /* Read snapshot ID */\n        sn->id_str = g_malloc(id_str_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->id_str, id_str_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += id_str_size;\n        sn->id_str[id_str_size] = '\\0';\n\n        /* Read snapshot name */\n        sn->name = g_malloc(name_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->name, name_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += name_size;\n        sn->name[name_size] = '\\0';\n    }\n\n    s->snapshots_size = offset - s->snapshots_offset;\n    return 0;\n\nfail:\n    qcow2_free_snapshots(bs);\n    return ret;\n}\n",
        "linevul": 0.0002015849604504183
    },
    {
        "code": "static inline void gen_ldo_env_A0(DisasContext *s, int offset)\n{\n    int mem_index = s->mem_index;\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(0)));\n    tcg_gen_addi_tl(cpu_tmp0, cpu_A0, 8);\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_tmp0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(1)));\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline void gen_ldo_env_A0(DisasContext *s, int offset)\n{\n    int mem_index = s->mem_index;\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(0)));\n    tcg_gen_addi_tl(cpu_tmp0, cpu_A0, 8);\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_tmp0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(1)));\n}\n",
        "linevul": 4.902552973362617e-05
    },
    {
        "code": "static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCIInterrupter *intr = &xhci->intr[v];\n    XHCITRB ev_trb;\n    dma_addr_t addr;\n\n    ev_trb.parameter = cpu_to_le64(event->ptr);\n    ev_trb.status = cpu_to_le32(event->length | (event->ccode << 24));\n    ev_trb.control = (event->slotid << 24) | (event->epid << 16) |\n                     event->flags | (event->type << TRB_TYPE_SHIFT);\n    if (intr->er_pcs) {\n        ev_trb.control |= TRB_C;\n    }\n    ev_trb.control = cpu_to_le32(ev_trb.control);\n\n    trace_usb_xhci_queue_event(v, intr->er_ep_idx, trb_name(&ev_trb),\n                               event_name(event), ev_trb.parameter,\n                               ev_trb.status, ev_trb.control);\n\n    addr = intr->er_start + TRB_SIZE*intr->er_ep_idx;\n    pci_dma_write(pci_dev, addr, &ev_trb, TRB_SIZE);\n\n    intr->er_ep_idx++;\n    if (intr->er_ep_idx >= intr->er_size) {\n        intr->er_ep_idx = 0;\n        intr->er_pcs = !intr->er_pcs;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCIInterrupter *intr = &xhci->intr[v];\n    XHCITRB ev_trb;\n    dma_addr_t addr;\n\n    ev_trb.parameter = cpu_to_le64(event->ptr);\n    ev_trb.status = cpu_to_le32(event->length | (event->ccode << 24));\n    ev_trb.control = (event->slotid << 24) | (event->epid << 16) |\n                     event->flags | (event->type << TRB_TYPE_SHIFT);\n    if (intr->er_pcs) {\n        ev_trb.control |= TRB_C;\n    }\n    ev_trb.control = cpu_to_le32(ev_trb.control);\n\n    trace_usb_xhci_queue_event(v, intr->er_ep_idx, trb_name(&ev_trb),\n                               event_name(event), ev_trb.parameter,\n                               ev_trb.status, ev_trb.control);\n\n    addr = intr->er_start + TRB_SIZE*intr->er_ep_idx;\n    pci_dma_write(pci_dev, addr, &ev_trb, TRB_SIZE);\n\n    intr->er_ep_idx++;\n    if (intr->er_ep_idx >= intr->er_size) {\n        intr->er_ep_idx = 0;\n        intr->er_pcs = !intr->er_pcs;\n    }\n}\n",
        "linevul": 5.00804053444881e-05
    },
    {
        "code": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n            qemu_get_buffer(f, n->mac_table.macs,\n                            n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n            n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n            n->mac_table.in_use = 0;\n        }\n    }\n \n    if (version_id >= 6)\n        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n\n    if (version_id >= 7) {\n        if (qemu_get_be32(f) && !peer_has_vnet_hdr(n)) {\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n\n    if (version_id >= 9) {\n        n->mac_table.multi_overflow = qemu_get_byte(f);\n        n->mac_table.uni_overflow = qemu_get_byte(f);\n    }\n\n    if (version_id >= 10) {\n        n->alluni = qemu_get_byte(f);\n        n->nomulti = qemu_get_byte(f);\n        n->nouni = qemu_get_byte(f);\n        n->nobcast = qemu_get_byte(f);\n    }\n\n    if (version_id >= 11) {\n        if (qemu_get_byte(f) && !peer_has_ufo(n)) {\n            error_report(\"virtio-net: saved image requires TUN_F_UFO support\");\n            return -1;\n        }\n    }\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n         }\n \n         n->curr_queues = qemu_get_be16(f);\n         for (i = 1; i < n->curr_queues; i++) {\n             n->vqs[i].tx_waiting = qemu_get_be32(f);\n         }\n        n->curr_guest_offloads = virtio_net_supported_guest_offloads(n);\n    }\n\n    if (peer_has_vnet_hdr(n)) {\n        virtio_net_apply_guest_offloads(n);\n    }\n\n    virtio_net_set_queues(n);\n\n    /* Find the first multicast entry in the saved MAC filter */\n    for (i = 0; i < n->mac_table.in_use; i++) {\n        if (n->mac_table.macs[i * ETH_ALEN] & 1) {\n            break;\n        }\n    }\n    n->mac_table.first_multi = i;\n\n    /* nc.link_down can't be migrated, so infer link_down according\n     * to link status bit in n->status */\n    link_down = (n->status & VIRTIO_NET_S_LINK_UP) == 0;\n    for (i = 0; i < n->max_queues; i++) {\n        qemu_get_subqueue(n->nic, i)->link_down = link_down;\n    }\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n            qemu_get_buffer(f, n->mac_table.macs,\n                            n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n            n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n            n->mac_table.in_use = 0;\n        }\n    }\n \n    if (version_id >= 6)\n        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n\n    if (version_id >= 7) {\n        if (qemu_get_be32(f) && !peer_has_vnet_hdr(n)) {\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n\n    if (version_id >= 9) {\n        n->mac_table.multi_overflow = qemu_get_byte(f);\n        n->mac_table.uni_overflow = qemu_get_byte(f);\n    }\n\n    if (version_id >= 10) {\n        n->alluni = qemu_get_byte(f);\n        n->nomulti = qemu_get_byte(f);\n        n->nouni = qemu_get_byte(f);\n        n->nobcast = qemu_get_byte(f);\n    }\n\n    if (version_id >= 11) {\n        if (qemu_get_byte(f) && !peer_has_ufo(n)) {\n            error_report(\"virtio-net: saved image requires TUN_F_UFO support\");\n            return -1;\n        }\n    }\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n         }\n \n         n->curr_queues = qemu_get_be16(f);\n//fix_flaw_line_below:\n//        if (n->curr_queues > n->max_queues) {\n//fix_flaw_line_below:\n//            error_report(\"virtio-net: curr_queues %x > max_queues %x\",\n//fix_flaw_line_below:\n//                         n->curr_queues, n->max_queues);\n//fix_flaw_line_below:\n//            return -1;\n//fix_flaw_line_below:\n//        }\n         for (i = 1; i < n->curr_queues; i++) {\n             n->vqs[i].tx_waiting = qemu_get_be32(f);\n         }\n        n->curr_guest_offloads = virtio_net_supported_guest_offloads(n);\n    }\n\n    if (peer_has_vnet_hdr(n)) {\n        virtio_net_apply_guest_offloads(n);\n    }\n\n    virtio_net_set_queues(n);\n\n    /* Find the first multicast entry in the saved MAC filter */\n    for (i = 0; i < n->mac_table.in_use; i++) {\n        if (n->mac_table.macs[i * ETH_ALEN] & 1) {\n            break;\n        }\n    }\n    n->mac_table.first_multi = i;\n\n    /* nc.link_down can't be migrated, so infer link_down according\n     * to link status bit in n->status */\n    link_down = (n->status & VIRTIO_NET_S_LINK_UP) == 0;\n    for (i = 0; i < n->max_queues; i++) {\n        qemu_get_subqueue(n->nic, i)->link_down = link_down;\n    }\n\n    return 0;\n}\n",
        "linevul": 6.025639595463872e-05
    },
    {
        "code": "static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n                                int slot)\n{\n    NCQFrame *ncq_fis = (NCQFrame*)cmd_fis;\n    uint8_t tag = ncq_fis->tag >> 3;\n    NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[tag];\n\n    if (ncq_tfs->used) {\n        /* error - already in use */\n        fprintf(stderr, \"%s: tag %d already used\\n\", __FUNCTION__, tag);\n        return;\n    }\n\n    ncq_tfs->used = 1;\n    ncq_tfs->drive = &s->dev[port];\n    ncq_tfs->slot = slot;\n    ncq_tfs->lba = ((uint64_t)ncq_fis->lba5 << 40) |\n                   ((uint64_t)ncq_fis->lba4 << 32) |\n                   ((uint64_t)ncq_fis->lba3 << 24) |\n                   ((uint64_t)ncq_fis->lba2 << 16) |\n                   ((uint64_t)ncq_fis->lba1 << 8) |\n                   (uint64_t)ncq_fis->lba0;\n\n    /* Note: We calculate the sector count, but don't currently rely on it.\n     * The total size of the DMA buffer tells us the transfer size instead. */\n    ncq_tfs->sector_count = ((uint16_t)ncq_fis->sector_count_high << 8) |\n                                ncq_fis->sector_count_low;\n\n    DPRINTF(port, \"NCQ transfer LBA from %\"PRId64\" to %\"PRId64\", \"\n            \"drive max %\"PRId64\"\\n\",\n            ncq_tfs->lba, ncq_tfs->lba + ncq_tfs->sector_count - 2,\n            s->dev[port].port.ifs[0].nb_sectors - 1);\n\n    ahci_populate_sglist(&s->dev[port], &ncq_tfs->sglist, 0);\n    ncq_tfs->tag = tag;\n\n    switch(ncq_fis->command) {\n        case READ_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ reading %d sectors from LBA %\"PRId64\", \"\n                    \"tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio read %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_READ);\n            ncq_tfs->aiocb = dma_bdrv_read(ncq_tfs->drive->port.ifs[0].bs,\n                                           &ncq_tfs->sglist, ncq_tfs->lba,\n                                           ncq_cb, ncq_tfs);\n            break;\n        case WRITE_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ writing %d sectors to LBA %\"PRId64\", tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio write %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_WRITE);\n            ncq_tfs->aiocb = dma_bdrv_write(ncq_tfs->drive->port.ifs[0].bs,\n                                            &ncq_tfs->sglist, ncq_tfs->lba,\n                                            ncq_cb, ncq_tfs);\n            break;\n        default:\n            DPRINTF(port, \"error: tried to process non-NCQ command as NCQ\\n\");\n            qemu_sglist_destroy(&ncq_tfs->sglist);\n            break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n                                int slot)\n{\n    NCQFrame *ncq_fis = (NCQFrame*)cmd_fis;\n    uint8_t tag = ncq_fis->tag >> 3;\n    NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[tag];\n\n    if (ncq_tfs->used) {\n        /* error - already in use */\n        fprintf(stderr, \"%s: tag %d already used\\n\", __FUNCTION__, tag);\n        return;\n    }\n\n    ncq_tfs->used = 1;\n    ncq_tfs->drive = &s->dev[port];\n    ncq_tfs->slot = slot;\n    ncq_tfs->lba = ((uint64_t)ncq_fis->lba5 << 40) |\n                   ((uint64_t)ncq_fis->lba4 << 32) |\n                   ((uint64_t)ncq_fis->lba3 << 24) |\n                   ((uint64_t)ncq_fis->lba2 << 16) |\n                   ((uint64_t)ncq_fis->lba1 << 8) |\n                   (uint64_t)ncq_fis->lba0;\n\n    /* Note: We calculate the sector count, but don't currently rely on it.\n     * The total size of the DMA buffer tells us the transfer size instead. */\n    ncq_tfs->sector_count = ((uint16_t)ncq_fis->sector_count_high << 8) |\n                                ncq_fis->sector_count_low;\n\n    DPRINTF(port, \"NCQ transfer LBA from %\"PRId64\" to %\"PRId64\", \"\n            \"drive max %\"PRId64\"\\n\",\n            ncq_tfs->lba, ncq_tfs->lba + ncq_tfs->sector_count - 2,\n            s->dev[port].port.ifs[0].nb_sectors - 1);\n\n    ahci_populate_sglist(&s->dev[port], &ncq_tfs->sglist, 0);\n    ncq_tfs->tag = tag;\n\n    switch(ncq_fis->command) {\n        case READ_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ reading %d sectors from LBA %\"PRId64\", \"\n                    \"tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio read %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_READ);\n            ncq_tfs->aiocb = dma_bdrv_read(ncq_tfs->drive->port.ifs[0].bs,\n                                           &ncq_tfs->sglist, ncq_tfs->lba,\n                                           ncq_cb, ncq_tfs);\n            break;\n        case WRITE_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ writing %d sectors to LBA %\"PRId64\", tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio write %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_WRITE);\n            ncq_tfs->aiocb = dma_bdrv_write(ncq_tfs->drive->port.ifs[0].bs,\n                                            &ncq_tfs->sglist, ncq_tfs->lba,\n                                            ncq_cb, ncq_tfs);\n            break;\n        default:\n            DPRINTF(port, \"error: tried to process non-NCQ command as NCQ\\n\");\n            qemu_sglist_destroy(&ncq_tfs->sglist);\n            break;\n    }\n}\n",
        "linevul": 9.115479042520747e-05
    },
    {
        "code": "uint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "uint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n",
        "linevul": 0.005190023221075535
    },
    {
        "code": "static uint64_t virtio_gpu_get_features(VirtIODevice *vdev, uint64_t features,\n                                        Error **errp)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n\n    if (virtio_gpu_virgl_enabled(g->conf)) {\n        features |= (1 << VIRTIO_GPU_F_VIRGL);\n    }\n    return features;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static uint64_t virtio_gpu_get_features(VirtIODevice *vdev, uint64_t features,\n                                        Error **errp)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n\n    if (virtio_gpu_virgl_enabled(g->conf)) {\n        features |= (1 << VIRTIO_GPU_F_VIRGL);\n    }\n    return features;\n}\n",
        "linevul": 4.6437449782388285e-05
    },
    {
        "code": "void qemu_spice_create_host_memslot(SimpleSpiceDisplay *ssd)\n{\n    QXLDevMemSlot memslot;\n\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    memset(&memslot, 0, sizeof(memslot));\n    memslot.slot_group_id = MEMSLOT_GROUP_HOST;\n    memslot.virt_end = ~0;\n    qemu_spice_add_memslot(ssd, &memslot, QXL_SYNC);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "void qemu_spice_create_host_memslot(SimpleSpiceDisplay *ssd)\n{\n    QXLDevMemSlot memslot;\n\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    memset(&memslot, 0, sizeof(memslot));\n    memslot.slot_group_id = MEMSLOT_GROUP_HOST;\n    memslot.virt_end = ~0;\n    qemu_spice_add_memslot(ssd, &memslot, QXL_SYNC);\n}\n",
        "linevul": 4.544829425867647e-05
    }
]