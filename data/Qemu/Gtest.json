[
    {
        "code": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n     /* First allocate space in qemu for device tree */\n     fdt = g_malloc0(dt_size);\n \n    dt_file_load_size = load_image(filename_path, fdt);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=da885fe1ee8b4589047484bd7fa05a4905b52b17",
        "vul_func_with_fix": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n     /* First allocate space in qemu for device tree */\n     fdt = g_malloc0(dt_size);\n \n//flaw_line_below:\n    dt_file_load_size = load_image(filename_path, fdt);\n//fix_flaw_line_below:\n//    dt_file_load_size = load_image_size(filename_path, fdt, dt_size);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n",
        "linevul": 0.0031403943430632353,
        "sysevr": 0.4804791808128357,
        "devign": 0.9999574422836304
    },
    {
        "code": "static int vapic_prepare(VAPICROMState *s)\n{\n    if (vapic_map_rom_writable(s) < 0) {\n        return -1;\n    }\n\n    if (patch_hypercalls(s) < 0) {\n        return -1;\n    }\n\n    vapic_enable_tpr_reporting(true);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static int vapic_prepare(VAPICROMState *s)\n{\n    if (vapic_map_rom_writable(s) < 0) {\n        return -1;\n    }\n\n    if (patch_hypercalls(s) < 0) {\n        return -1;\n    }\n\n    vapic_enable_tpr_reporting(true);\n\n    return 0;\n}\n",
        "linevul": 5.328351107891649e-05,
        "sysevr": 0.466878205537796,
        "devign": 3.9182020827865927e-07
    },
    {
        "code": "static int parallels_read(BlockDriverState *bs, int64_t sector_num,\n                    uint8_t *buf, int nb_sectors)\n{\n    while (nb_sectors > 0) {\n        int64_t position = seek_to_sector(bs, sector_num);\n        if (position >= 0) {\n            if (bdrv_pread(bs->file, position, buf, 512) != 512)\n                return -1;\n        } else {\n            memset(buf, 0, 512);\n        }\n        nb_sectors--;\n        sector_num++;\n        buf += 512;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=afbcc40bee4ef51731102d7d4b499ee12fc182e1",
        "vul_func_with_fix": "static int parallels_read(BlockDriverState *bs, int64_t sector_num,\n                    uint8_t *buf, int nb_sectors)\n{\n    while (nb_sectors > 0) {\n        int64_t position = seek_to_sector(bs, sector_num);\n        if (position >= 0) {\n            if (bdrv_pread(bs->file, position, buf, 512) != 512)\n                return -1;\n        } else {\n            memset(buf, 0, 512);\n        }\n        nb_sectors--;\n        sector_num++;\n        buf += 512;\n    }\n    return 0;\n}\n",
        "linevul": 0.0003251306770835072,
        "sysevr": 0.4651494324207306,
        "devign": 1.8589505046406885e-08
    },
    {
        "code": "uint64_t ram_bytes_remaining(void)\n{\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "uint64_t ram_bytes_remaining(void)\n{\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n}\n",
        "linevul": 0.00018369346798863262,
        "sysevr": 0.46618369221687317,
        "devign": 0.036247722804546356
    },
    {
        "code": "static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)\n{\n    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);\n     info->num_memslots = NUM_MEMSLOTS;\n     info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;\n     info->internal_groupslot_id = 0;\n    info->qxl_ram_size = ssd->bufsize;\n     info->n_surfaces = ssd->num_surfaces;\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)\n{\n    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);\n     info->num_memslots = NUM_MEMSLOTS;\n     info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;\n     info->internal_groupslot_id = 0;\n//flaw_line_below:\n    info->qxl_ram_size = ssd->bufsize;\n//fix_flaw_line_below:\n//    info->qxl_ram_size = 16 * 1024 * 1024;\n     info->n_surfaces = ssd->num_surfaces;\n }\n",
        "linevul": 0.002524701878428459,
        "sysevr": 0.46104010939598083,
        "devign": 0.9654927849769592
    },
    {
        "code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4774718e5c194026ba5ee7a28d9be49be3080e42",
        "vul_func_with_fix": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "linevul": 0.00017687090439721942,
        "sysevr": 0.4753611981868744,
        "devign": 0.569030225276947
    },
    {
        "code": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n    trace_esp_mem_readb(saddr, s->rregs[saddr]);\n    switch (saddr) {\n    case ESP_FIFO:\n        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n            /* Data out.  */\n            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n            s->rregs[ESP_FIFO] = 0;\n            esp_raise_irq(s);\n        } else if (s->ti_rptr < s->ti_wptr) {\n            s->ti_size--;\n            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            esp_raise_irq(s);\n        }\n        if (s->ti_rptr == s->ti_wptr) {\n            s->ti_rptr = 0;\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n    return s->rregs[saddr];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n    trace_esp_mem_readb(saddr, s->rregs[saddr]);\n    switch (saddr) {\n    case ESP_FIFO:\n        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n            /* Data out.  */\n            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n            s->rregs[ESP_FIFO] = 0;\n            esp_raise_irq(s);\n        } else if (s->ti_rptr < s->ti_wptr) {\n            s->ti_size--;\n            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            esp_raise_irq(s);\n        }\n        if (s->ti_rptr == s->ti_wptr) {\n            s->ti_rptr = 0;\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n    return s->rregs[saddr];\n}\n",
        "linevul": 5.30669822182972e-05,
        "sysevr": 0.4647030830383301,
        "devign": 1.6543959666917826e-17
    },
    {
        "code": "static bool cmd_data_set_management(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case DSM_TRIM:\n        if (s->blk) {\n            ide_sector_start_dma(s, IDE_DMA_TRIM);\n            return false;\n        }\n        break;\n    }\n\n    ide_abort_command(s);\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_data_set_management(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case DSM_TRIM:\n        if (s->blk) {\n            ide_sector_start_dma(s, IDE_DMA_TRIM);\n            return false;\n        }\n        break;\n    }\n\n    ide_abort_command(s);\n    return true;\n}\n",
        "linevul": 4.6138171455822885e-05,
        "sysevr": 0.4652975797653198,
        "devign": 0.0004796395660378039
    },
    {
        "code": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n                                          hwaddr addr,\n                                          unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    /* XXX handle bitblt */\n    (void)s;\n    ret = 0xff;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n                                          hwaddr addr,\n                                          unsigned size)\n{\n    CirrusVGAState *s = opaque;\n    uint32_t ret;\n\n    /* XXX handle bitblt */\n    (void)s;\n    ret = 0xff;\n    return ret;\n}\n",
        "linevul": 4.506087861955166e-05,
        "sysevr": 0.4667862355709076,
        "devign": 0.0037118790205568075
    },
    {
        "code": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n     if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n         trace_usb_ohci_iso_td_read_failed(addr);\n         ohci_die(ohci);\n        return 0;\n     }\n \n     starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n     if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n         trace_usb_ohci_iso_td_read_failed(addr);\n         ohci_die(ohci);\n//flaw_line_below:\n        return 0;\n//fix_flaw_line_below:\n//        return 1;\n     }\n \n     starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}\n",
        "linevul": 0.014845466241240501,
        "sysevr": 0.4841472804546356,
        "devign": 0.7690466046333313
    },
    {
        "code": "static inline int xhci_running(XHCIState *xhci)\n{\n    return !(xhci->usbsts & USBSTS_HCH) && !xhci->intr[0].er_full;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static inline int xhci_running(XHCIState *xhci)\n{\n    return !(xhci->usbsts & USBSTS_HCH) && !xhci->intr[0].er_full;\n}\n",
        "linevul": 5.302995123201981e-05,
        "sysevr": 0.4656999111175537,
        "devign": 0.0002104397426592186
    },
    {
        "code": "size_t mptsas_config_manufacturing_10(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(10, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_manufacturing_10(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(10, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"*l\");\n}\n",
        "linevul": 5.1793969760183245e-05,
        "sysevr": 0.46867042779922485,
        "devign": 0.020678451284766197
    },
    {
        "code": "static int ram_save_complete(QEMUFile *f, void *opaque)\n{\n    qemu_mutex_lock_ramlist();\n    migration_bitmap_sync();\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n    /* try transferring iterative blocks of memory */\n\n    /* flush all remaining blocks regardless of rate limiting */\n    while (true) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, true);\n        /* no more blocks to sent */\n        if (bytes_sent == 0) {\n            break;\n        }\n        bytes_transferred += bytes_sent;\n    }\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n    migration_end();\n\n    qemu_mutex_unlock_ramlist();\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static int ram_save_complete(QEMUFile *f, void *opaque)\n{\n    qemu_mutex_lock_ramlist();\n    migration_bitmap_sync();\n\n    ram_control_before_iterate(f, RAM_CONTROL_FINISH);\n\n    /* try transferring iterative blocks of memory */\n\n    /* flush all remaining blocks regardless of rate limiting */\n    while (true) {\n        int bytes_sent;\n\n        bytes_sent = ram_find_and_save_block(f, true);\n        /* no more blocks to sent */\n        if (bytes_sent == 0) {\n            break;\n        }\n        bytes_transferred += bytes_sent;\n    }\n\n    ram_control_after_iterate(f, RAM_CONTROL_FINISH);\n    migration_end();\n\n    qemu_mutex_unlock_ramlist();\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n    return 0;\n}\n",
        "linevul": 5.163187233847566e-05,
        "sysevr": 0.4713943302631378,
        "devign": 2.5906779228535015e-06
    },
    {
        "code": "uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)\n{\n    VGACommonState *s = opaque;\n    uint32_t val;\n\n    if (s->vbe_index < VBE_DISPI_INDEX_NB) {\n        if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_GETCAPS) {\n            switch(s->vbe_index) {\n                /* XXX: do not hardcode ? */\n            case VBE_DISPI_INDEX_XRES:\n                val = VBE_DISPI_MAX_XRES;\n                break;\n            case VBE_DISPI_INDEX_YRES:\n                val = VBE_DISPI_MAX_YRES;\n                break;\n            case VBE_DISPI_INDEX_BPP:\n                val = VBE_DISPI_MAX_BPP;\n                break;\n            default:\n                val = s->vbe_regs[s->vbe_index];\n                break;\n            }\n        } else {\n            val = s->vbe_regs[s->vbe_index];\n        }\n    } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {\n        val = s->vbe_size / (64 * 1024);\n    } else {\n        val = 0;\n    }\n    trace_vga_vbe_read(s->vbe_index, val);\n    return val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)\n{\n    VGACommonState *s = opaque;\n    uint32_t val;\n\n    if (s->vbe_index < VBE_DISPI_INDEX_NB) {\n        if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_GETCAPS) {\n            switch(s->vbe_index) {\n                /* XXX: do not hardcode ? */\n            case VBE_DISPI_INDEX_XRES:\n                val = VBE_DISPI_MAX_XRES;\n                break;\n            case VBE_DISPI_INDEX_YRES:\n                val = VBE_DISPI_MAX_YRES;\n                break;\n            case VBE_DISPI_INDEX_BPP:\n                val = VBE_DISPI_MAX_BPP;\n                break;\n            default:\n                val = s->vbe_regs[s->vbe_index];\n                break;\n            }\n        } else {\n            val = s->vbe_regs[s->vbe_index];\n        }\n    } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {\n        val = s->vbe_size / (64 * 1024);\n    } else {\n        val = 0;\n    }\n    trace_vga_vbe_read(s->vbe_index, val);\n    return val;\n}\n",
        "linevul": 5.961220813333057e-05,
        "sysevr": 0.4502612352371216,
        "devign": 4.4611378480219344e-10
    },
    {
        "code": "static void mptsas_process_ioc_init(MPTSASState *s, MPIMsgIOCInit *req)\n{\n    MPIMsgIOCInitReply reply;\n\n    mptsas_fix_ioc_init_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    s->who_init               = req->WhoInit;\n    s->reply_frame_size       = req->ReplyFrameSize;\n    s->max_buses              = req->MaxBuses;\n    s->max_devices            = req->MaxDevices ? req->MaxDevices : 256;\n    s->host_mfa_high_addr     = (hwaddr)req->HostMfaHighAddr << 32;\n    s->sense_buffer_high_addr = (hwaddr)req->SenseBufferHighAddr << 32;\n\n    if (s->state == MPI_IOC_STATE_READY) {\n        s->state = MPI_IOC_STATE_OPERATIONAL;\n    }\n\n    memset(&reply, 0, sizeof(reply));\n    reply.WhoInit    = s->who_init;\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.MaxDevices = s->max_devices;\n    reply.MaxBuses   = s->max_buses;\n    reply.MsgContext = req->MsgContext;\n\n    mptsas_fix_ioc_init_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=670e56d3ed2918b3861d9216f2c0540d9e9ae0d5",
        "vul_func_with_fix": "static void mptsas_process_ioc_init(MPTSASState *s, MPIMsgIOCInit *req)\n{\n    MPIMsgIOCInitReply reply;\n\n    mptsas_fix_ioc_init_endianness(req);\n\n    QEMU_BUILD_BUG_ON(MPTSAS_MAX_REQUEST_SIZE < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_msg) < sizeof(*req));\n    QEMU_BUILD_BUG_ON(sizeof(s->doorbell_reply) < sizeof(reply));\n\n    s->who_init               = req->WhoInit;\n    s->reply_frame_size       = req->ReplyFrameSize;\n    s->max_buses              = req->MaxBuses;\n    s->max_devices            = req->MaxDevices ? req->MaxDevices : 256;\n    s->host_mfa_high_addr     = (hwaddr)req->HostMfaHighAddr << 32;\n    s->sense_buffer_high_addr = (hwaddr)req->SenseBufferHighAddr << 32;\n\n    if (s->state == MPI_IOC_STATE_READY) {\n        s->state = MPI_IOC_STATE_OPERATIONAL;\n    }\n\n    memset(&reply, 0, sizeof(reply));\n    reply.WhoInit    = s->who_init;\n    reply.MsgLength  = sizeof(reply) / 4;\n    reply.Function   = req->Function;\n    reply.MaxDevices = s->max_devices;\n    reply.MaxBuses   = s->max_buses;\n    reply.MsgContext = req->MsgContext;\n\n    mptsas_fix_ioc_init_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n}\n",
        "linevul": 4.970529334968887e-05,
        "sysevr": 0.4523579776287079,
        "devign": 3.301978495073854e-07
    },
    {
        "code": "static bool net_tx_pkt_parse_headers(struct NetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[NET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        l3_hdr->iov_len = 0;\n        pkt->packet_type = ETH_PKT_UCAST;\n        return false;\n    } else {\n        l2_hdr->iov_len = ETH_MAX_L2_HDR_LEN;\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n        pkt->packet_type = get_eth_packet_type(l2_hdr->iov_base);\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr, 1, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n\n        if (l3_hdr->iov_len < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        if (IP_HDR_GET_LEN(l3_hdr->iov_base) != sizeof(struct ip_header)) {\n            /* copy optional IPv4 header data if any*/\n            bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                    l2_hdr->iov_len + sizeof(struct ip_header),\n                                    l3_hdr->iov_base + sizeof(struct ip_header),\n                                    l3_hdr->iov_len - sizeof(struct ip_header));\n            if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n                l3_hdr->iov_len = 0;\n                return false;\n            }\n        }\n\n        break;\n\n    case ETH_P_IPV6:\n    {\n        eth_ip6_hdr_info hdrinfo;\n\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                &hdrinfo)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = hdrinfo.l4proto;\n        full_ip6hdr_len = hdrinfo.full_hdr_len;\n\n        if (full_ip6hdr_len > ETH_MAX_IP_DGRAM_LEN) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n    }\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n\n    net_tx_pkt_calculate_hdr_len(pkt);\n    return true;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "static bool net_tx_pkt_parse_headers(struct NetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[NET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        l3_hdr->iov_len = 0;\n        pkt->packet_type = ETH_PKT_UCAST;\n        return false;\n    } else {\n        l2_hdr->iov_len = ETH_MAX_L2_HDR_LEN;\n        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n        pkt->packet_type = get_eth_packet_type(l2_hdr->iov_base);\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr, 1, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n\n        if (l3_hdr->iov_len < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n\n        if (IP_HDR_GET_LEN(l3_hdr->iov_base) != sizeof(struct ip_header)) {\n            /* copy optional IPv4 header data if any*/\n            bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags,\n                                    l2_hdr->iov_len + sizeof(struct ip_header),\n                                    l3_hdr->iov_base + sizeof(struct ip_header),\n                                    l3_hdr->iov_len - sizeof(struct ip_header));\n            if (bytes_read < l3_hdr->iov_len - sizeof(struct ip_header)) {\n                l3_hdr->iov_len = 0;\n                return false;\n            }\n        }\n\n        break;\n\n    case ETH_P_IPV6:\n    {\n        eth_ip6_hdr_info hdrinfo;\n\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                &hdrinfo)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        pkt->l4proto = hdrinfo.l4proto;\n        full_ip6hdr_len = hdrinfo.full_hdr_len;\n\n        if (full_ip6hdr_len > ETH_MAX_IP_DGRAM_LEN) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n    }\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n\n    net_tx_pkt_calculate_hdr_len(pkt);\n    return true;\n}\n",
        "linevul": 0.0002931550261564553,
        "sysevr": 0.46926313638687134,
        "devign": 0.7468662858009338
    },
    {
        "code": "static void gen_cmovcc1(CPUX86State *env, DisasContext *s, TCGMemOp ot, int b,\n                        int modrm, int reg)\n{\n    CCPrepare cc;\n\n    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n    cc = gen_prepare_cc(s, b, cpu_T1);\n    if (cc.mask != -1) {\n        TCGv t0 = tcg_temp_new();\n        tcg_gen_andi_tl(t0, cc.reg, cc.mask);\n        cc.reg = t0;\n    }\n    if (!cc.use_reg2) {\n        cc.reg2 = tcg_const_tl(cc.imm);\n    }\n\n    tcg_gen_movcond_tl(cc.cond, cpu_T0, cc.reg, cc.reg2,\n                       cpu_T0, cpu_regs[reg]);\n    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n    if (cc.mask != -1) {\n        tcg_temp_free(cc.reg);\n    }\n    if (!cc.use_reg2) {\n        tcg_temp_free(cc.reg2);\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_cmovcc1(CPUX86State *env, DisasContext *s, TCGMemOp ot, int b,\n                        int modrm, int reg)\n{\n    CCPrepare cc;\n\n    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n    cc = gen_prepare_cc(s, b, cpu_T1);\n    if (cc.mask != -1) {\n        TCGv t0 = tcg_temp_new();\n        tcg_gen_andi_tl(t0, cc.reg, cc.mask);\n        cc.reg = t0;\n    }\n    if (!cc.use_reg2) {\n        cc.reg2 = tcg_const_tl(cc.imm);\n    }\n\n    tcg_gen_movcond_tl(cc.cond, cpu_T0, cc.reg, cc.reg2,\n                       cpu_T0, cpu_regs[reg]);\n    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n    if (cc.mask != -1) {\n        tcg_temp_free(cc.reg);\n    }\n    if (!cc.use_reg2) {\n        tcg_temp_free(cc.reg2);\n    }\n}\n",
        "linevul": 5.082053394289687e-05,
        "sysevr": 0.48517438769340515,
        "devign": 0.010317814536392689
    },
    {
        "code": "static void ehci_free_queue(EHCIQueue *q, const char *warn)\n{\n    EHCIQueueHead *head = q->async ? &q->ehci->aqueues : &q->ehci->pqueues;\n    int cancelled;\n\n    trace_usb_ehci_queue_action(q, \"free\");\n    cancelled = ehci_cancel_queue(q);\n    if (warn && cancelled > 0) {\n        ehci_trace_guest_bug(q->ehci, warn);\n    }\n    QTAILQ_REMOVE(head, q, next);\n    g_free(q);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_free_queue(EHCIQueue *q, const char *warn)\n{\n    EHCIQueueHead *head = q->async ? &q->ehci->aqueues : &q->ehci->pqueues;\n    int cancelled;\n\n    trace_usb_ehci_queue_action(q, \"free\");\n    cancelled = ehci_cancel_queue(q);\n    if (warn && cancelled > 0) {\n        ehci_trace_guest_bug(q->ehci, warn);\n    }\n    QTAILQ_REMOVE(head, q, next);\n    g_free(q);\n}\n",
        "linevul": 4.667840039473958e-05,
        "sysevr": 0.463488906621933,
        "devign": 3.531786933308467e-05
    },
    {
        "code": "void e1000e_core_pre_save(E1000ECore *core)\n{\n    int i;\n    NetClientState *nc = qemu_get_queue(core->owner_nic);\n\n    /*\n    * If link is down and auto-negotiation is supported and ongoing,\n    * complete auto-negotiation immediately. This allows us to look\n    * at MII_SR_AUTONEG_COMPLETE to infer link status on load.\n    */\n    if (nc->link_down && e1000e_have_autoneg(core)) {\n        core->phy[0][PHY_STATUS] |= MII_SR_AUTONEG_COMPLETE;\n        e1000e_update_flowctl_status(core);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(core->tx); i++) {\n        if (net_tx_pkt_has_fragments(core->tx[i].tx_pkt)) {\n            core->tx[i].skip_cp = true;\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "void e1000e_core_pre_save(E1000ECore *core)\n{\n    int i;\n    NetClientState *nc = qemu_get_queue(core->owner_nic);\n\n    /*\n    * If link is down and auto-negotiation is supported and ongoing,\n    * complete auto-negotiation immediately. This allows us to look\n    * at MII_SR_AUTONEG_COMPLETE to infer link status on load.\n    */\n    if (nc->link_down && e1000e_have_autoneg(core)) {\n        core->phy[0][PHY_STATUS] |= MII_SR_AUTONEG_COMPLETE;\n        e1000e_update_flowctl_status(core);\n    }\n\n    for (i = 0; i < ARRAY_SIZE(core->tx); i++) {\n        if (net_tx_pkt_has_fragments(core->tx[i].tx_pkt)) {\n            core->tx[i].skip_cp = true;\n        }\n    }\n}\n",
        "linevul": 5.682223491021432e-05,
        "sysevr": 0.46877554059028625,
        "devign": 9.533743286738172e-05
    },
    {
        "code": "size_t net_tx_pkt_get_total_len(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n\n    return pkt->hdr_len + pkt->payload_len;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "size_t net_tx_pkt_get_total_len(struct NetTxPkt *pkt)\n{\n    assert(pkt);\n\n    return pkt->hdr_len + pkt->payload_len;\n}\n",
        "linevul": 6.25452448730357e-05,
        "sysevr": 0.46465539932250977,
        "devign": 0.0011201691813766956
    },
    {
        "code": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=7f61f4690dd153be98900a2a508b88989e692753",
        "vul_func_with_fix": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n//flaw_line_below:\n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n//flaw_line_below:\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n//flaw_line_below:\n        return -1;\n//flaw_line_below:\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n",
        "linevul": 0.9993973970413208,
        "sysevr": 0.46051234006881714,
        "devign": 0.003442668356001377
    },
    {
        "code": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n {\n     AHCICmdHdr *cmd = ad->cur_cmd;\n     uint32_t opts = le32_to_cpu(cmd->opts);\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n     uint8_t *prdt;\n     int i;\n     int r = 0;\n    int sum = 0;\n     int off_idx = -1;\n    int off_pos = -1;\n     int tbl_entry_size;\n     IDEBus *bus = &ad->port;\n     BusState *qbus = BUS(bus);\n \n     if (!sglist_alloc_hint) {\n         DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n         return -1;\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (sglist_alloc_hint > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < sglist_alloc_hint; i++) {\n            /* flags_size is zero-based */\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset <= (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n         }\n         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n             DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                             __func__, off_idx, off_pos);\n             r = -1;\n             goto out;\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            prdt_tbl_entry_size(&tbl[i]));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n             /* flags_size is zero-based */\n             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                             prdt_tbl_entry_size(&tbl[i]));\n         }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n//fix_flaw_line_below:\n//static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n//fix_flaw_line_below:\n//                                int32_t offset)\n {\n     AHCICmdHdr *cmd = ad->cur_cmd;\n     uint32_t opts = le32_to_cpu(cmd->opts);\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n     uint8_t *prdt;\n     int i;\n     int r = 0;\n//flaw_line_below:\n    int sum = 0;\n//fix_flaw_line_below:\n//    uint64_t sum = 0;\n     int off_idx = -1;\n//flaw_line_below:\n    int off_pos = -1;\n//fix_flaw_line_below:\n//    int64_t off_pos = -1;\n     int tbl_entry_size;\n     IDEBus *bus = &ad->port;\n     BusState *qbus = BUS(bus);\n \n//fix_flaw_line_below:\n//    /*\n//fix_flaw_line_below:\n//     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support\n//fix_flaw_line_below:\n//     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n//fix_flaw_line_below:\n//     * 512 byte sector size. We limit the PRDT in this implementation to\n//fix_flaw_line_below:\n//     * a reasonably large 2GiB, which can accommodate the maximum transfer\n//fix_flaw_line_below:\n//     * request for sector sizes up to 32K.\n//fix_flaw_line_below:\n//     */\n//fix_flaw_line_below:\n//\n     if (!sglist_alloc_hint) {\n         DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n         return -1;\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (sglist_alloc_hint > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < sglist_alloc_hint; i++) {\n            /* flags_size is zero-based */\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset <= (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %d\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n         }\n         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n             DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n//flaw_line_below:\n                            \"off_idx: %d, off_pos: %d\\n\",\n//fix_flaw_line_below:\n//                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                             __func__, off_idx, off_pos);\n             r = -1;\n             goto out;\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            prdt_tbl_entry_size(&tbl[i]));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n             /* flags_size is zero-based */\n             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                             prdt_tbl_entry_size(&tbl[i]));\n//fix_flaw_line_below:\n//            if (sglist->size > INT32_MAX) {\n//fix_flaw_line_below:\n//                error_report(\"AHCI Physical Region Descriptor Table describes \"\n//fix_flaw_line_below:\n//                             \"more than 2 GiB.\\n\");\n//fix_flaw_line_below:\n//                qemu_sglist_destroy(sglist);\n//fix_flaw_line_below:\n//                r = -1;\n//fix_flaw_line_below:\n//                goto out;\n//fix_flaw_line_below:\n//            }\n         }\n",
        "linevul": 0.9443146586418152,
        "sysevr": 0.4635530412197113,
        "devign": 0.006661610212177038
    },
    {
        "code": "static void iscsi_block_init(void)\n{\n    bdrv_register(&bdrv_iscsi);\n    qemu_add_opts(&qemu_iscsi_opts);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_block_init(void)\n{\n    bdrv_register(&bdrv_iscsi);\n    qemu_add_opts(&qemu_iscsi_opts);\n}\n",
        "linevul": 5.992785736452788e-05,
        "sysevr": 0.4696255922317505,
        "devign": 0.0013914997689425945
    },
    {
        "code": " static void scsi_read_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n         }\n     }\n \n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n \n    n = r->iov.iov_len / 512;\n     r->sector += n;\n     r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": " static void scsi_read_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n         }\n     }\n \n//flaw_line_below:\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n//fix_flaw_line_below:\n//    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n \n//flaw_line_below:\n    n = r->iov.iov_len / 512;\n//fix_flaw_line_below:\n//    n = r->qiov.size / 512;\n     r->sector += n;\n     r->sector_count -= n;\n//flaw_line_below:\n    scsi_req_data(&r->req, r->iov.iov_len);\n//fix_flaw_line_below:\n//    scsi_req_data(&r->req, r->qiov.size);\n }\n",
        "linevul": 0.9969455599784851,
        "sysevr": 0.4760390520095825,
        "devign": 0.9999231100082397
    },
    {
        "code": "static void fdctrl_write (void *opaque, uint32_t reg, uint32_t value)\n{\n    FDCtrl *fdctrl = opaque;\n\n    FLOPPY_DPRINTF(\"write reg%d: 0x%02x\\n\", reg & 7, value);\n\n    reg &= 7;\n    switch (reg) {\n    case FD_REG_DOR:\n        fdctrl_write_dor(fdctrl, value);\n        break;\n    case FD_REG_TDR:\n        fdctrl_write_tape(fdctrl, value);\n        break;\n    case FD_REG_DSR:\n        fdctrl_write_rate(fdctrl, value);\n        break;\n    case FD_REG_FIFO:\n        fdctrl_write_data(fdctrl, value);\n        break;\n    case FD_REG_CCR:\n        fdctrl_write_ccr(fdctrl, value);\n        break;\n    default:\n        break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static void fdctrl_write (void *opaque, uint32_t reg, uint32_t value)\n{\n    FDCtrl *fdctrl = opaque;\n\n    FLOPPY_DPRINTF(\"write reg%d: 0x%02x\\n\", reg & 7, value);\n\n    reg &= 7;\n    switch (reg) {\n    case FD_REG_DOR:\n        fdctrl_write_dor(fdctrl, value);\n        break;\n    case FD_REG_TDR:\n        fdctrl_write_tape(fdctrl, value);\n        break;\n    case FD_REG_DSR:\n        fdctrl_write_rate(fdctrl, value);\n        break;\n    case FD_REG_FIFO:\n        fdctrl_write_data(fdctrl, value);\n        break;\n    case FD_REG_CCR:\n        fdctrl_write_ccr(fdctrl, value);\n        break;\n    default:\n        break;\n    }\n}\n",
        "linevul": 6.801044219173491e-05,
        "sysevr": 0.49343323707580566,
        "devign": 1.1110101727496158e-09
    },
    {
        "code": "static void write_response(ESPState *s)\n{\n    trace_esp_write_response(s->status);\n    s->ti_buf[0] = s->status;\n    s->ti_buf[1] = 0;\n    if (s->dma) {\n        s->dma_memory_write(s->dma_opaque, s->ti_buf, 2);\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n    } else {\n        s->ti_size = 2;\n        s->ti_rptr = 0;\n        s->ti_wptr = 0;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
        "vul_func_with_fix": "static void write_response(ESPState *s)\n{\n    trace_esp_write_response(s->status);\n    s->ti_buf[0] = s->status;\n    s->ti_buf[1] = 0;\n    if (s->dma) {\n        s->dma_memory_write(s->dma_opaque, s->ti_buf, 2);\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n    } else {\n        s->ti_size = 2;\n        s->ti_rptr = 0;\n        s->ti_wptr = 0;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}\n",
        "linevul": 0.00015951598470564932,
        "sysevr": 0.45070287585258484,
        "devign": 6.344008651737454e-12
    },
    {
        "code": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(ctx, fs_path->data, O_WRONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = ftruncate(fd, size);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(ctx, fs_path->data, O_WRONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = ftruncate(fd, size);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "linevul": 5.737041647080332e-05,
        "sysevr": 0.47579994797706604,
        "devign": 0.007008754648268223
    },
    {
        "code": "static void iscsi_attach_aio_context(BlockDriverState *bs,\n                                     AioContext *new_context)\n{\n    IscsiLun *iscsilun = bs->opaque;\n\n    iscsilun->aio_context = new_context;\n    iscsi_set_events(iscsilun);\n\n    /* Set up a timer for sending out iSCSI NOPs */\n    iscsilun->nop_timer = aio_timer_new(iscsilun->aio_context,\n                                        QEMU_CLOCK_REALTIME, SCALE_MS,\n                                        iscsi_nop_timed_event, iscsilun);\n    timer_mod(iscsilun->nop_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    /* Set up a timer for periodic calls to iscsi_set_events and to\n     * scan for command timeout */\n    iscsilun->event_timer = aio_timer_new(iscsilun->aio_context,\n                                          QEMU_CLOCK_REALTIME, SCALE_MS,\n                                          iscsi_timed_check_events, iscsilun);\n    timer_mod(iscsilun->event_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_attach_aio_context(BlockDriverState *bs,\n                                     AioContext *new_context)\n{\n    IscsiLun *iscsilun = bs->opaque;\n\n    iscsilun->aio_context = new_context;\n    iscsi_set_events(iscsilun);\n\n    /* Set up a timer for sending out iSCSI NOPs */\n    iscsilun->nop_timer = aio_timer_new(iscsilun->aio_context,\n                                        QEMU_CLOCK_REALTIME, SCALE_MS,\n                                        iscsi_nop_timed_event, iscsilun);\n    timer_mod(iscsilun->nop_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    /* Set up a timer for periodic calls to iscsi_set_events and to\n     * scan for command timeout */\n    iscsilun->event_timer = aio_timer_new(iscsilun->aio_context,\n                                          QEMU_CLOCK_REALTIME, SCALE_MS,\n                                          iscsi_timed_check_events, iscsilun);\n    timer_mod(iscsilun->event_timer,\n              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);\n}\n",
        "linevul": 5.892190529266372e-05,
        "sysevr": 0.46842917799949646,
        "devign": 0.004051356576383114
    },
    {
        "code": "static void ahci_reset_port(AHCIState *s, int port)\n{\n    AHCIDevice *d = &s->dev[port];\n    AHCIPortRegs *pr = &d->port_regs;\n    IDEState *ide_state = &d->port.ifs[0];\n    int i;\n\n    DPRINTF(port, \"reset port\\n\");\n\n    ide_bus_reset(&d->port);\n    ide_state->ncq_queues = AHCI_MAX_CMDS;\n\n    pr->scr_stat = 0;\n    pr->scr_err = 0;\n    pr->scr_act = 0;\n    d->busy_slot = -1;\n    d->init_d2h_sent = false;\n\n    ide_state = &s->dev[port].port.ifs[0];\n    if (!ide_state->bs) {\n        return;\n    }\n\n    /* reset ncq queue */\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[i];\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        if (ncq_tfs->aiocb) {\n            bdrv_aio_cancel(ncq_tfs->aiocb);\n            ncq_tfs->aiocb = NULL;\n        }\n\n        /* Maybe we just finished the request thanks to bdrv_aio_cancel() */\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        qemu_sglist_destroy(&ncq_tfs->sglist);\n        ncq_tfs->used = 0;\n    }\n\n    s->dev[port].port_state = STATE_RUN;\n    if (!ide_state->bs) {\n        s->dev[port].port_regs.sig = 0;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    } else if (ide_state->drive_kind == IDE_CD) {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_CDROM;\n        ide_state->lcyl = 0x14;\n        ide_state->hcyl = 0xeb;\n        DPRINTF(port, \"set lcyl = %d\\n\", ide_state->lcyl);\n        ide_state->status = SEEK_STAT | WRERR_STAT | READY_STAT;\n    } else {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_DISK;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    }\n\n    ide_state->error = 1;\n    ahci_init_d2h(d);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static void ahci_reset_port(AHCIState *s, int port)\n{\n    AHCIDevice *d = &s->dev[port];\n    AHCIPortRegs *pr = &d->port_regs;\n    IDEState *ide_state = &d->port.ifs[0];\n    int i;\n\n    DPRINTF(port, \"reset port\\n\");\n\n    ide_bus_reset(&d->port);\n    ide_state->ncq_queues = AHCI_MAX_CMDS;\n\n    pr->scr_stat = 0;\n    pr->scr_err = 0;\n    pr->scr_act = 0;\n    d->busy_slot = -1;\n    d->init_d2h_sent = false;\n\n    ide_state = &s->dev[port].port.ifs[0];\n    if (!ide_state->bs) {\n        return;\n    }\n\n    /* reset ncq queue */\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[i];\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        if (ncq_tfs->aiocb) {\n            bdrv_aio_cancel(ncq_tfs->aiocb);\n            ncq_tfs->aiocb = NULL;\n        }\n\n        /* Maybe we just finished the request thanks to bdrv_aio_cancel() */\n        if (!ncq_tfs->used) {\n            continue;\n        }\n\n        qemu_sglist_destroy(&ncq_tfs->sglist);\n        ncq_tfs->used = 0;\n    }\n\n    s->dev[port].port_state = STATE_RUN;\n    if (!ide_state->bs) {\n        s->dev[port].port_regs.sig = 0;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    } else if (ide_state->drive_kind == IDE_CD) {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_CDROM;\n        ide_state->lcyl = 0x14;\n        ide_state->hcyl = 0xeb;\n        DPRINTF(port, \"set lcyl = %d\\n\", ide_state->lcyl);\n        ide_state->status = SEEK_STAT | WRERR_STAT | READY_STAT;\n    } else {\n        s->dev[port].port_regs.sig = SATA_SIGNATURE_DISK;\n        ide_state->status = SEEK_STAT | WRERR_STAT;\n    }\n\n    ide_state->error = 1;\n    ahci_init_d2h(d);\n}\n",
        "linevul": 4.456137685338035e-05,
        "sysevr": 0.4601016938686371,
        "devign": 0.3905845582485199
    },
    {
        "code": "void virtio_queue_set_notification(VirtQueue *vq, int enable)\n{\n    vq->notification = enable;\n    if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vring_avail_idx(vq));\n    } else if (enable) {\n        vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);\n    } else {\n        vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);\n    }\n    if (enable) {\n        /* Expose avail event/used flags before caller checks the avail idx. */\n        smp_mb();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=973e7170dddefb491a48df5cba33b2ae151013a0",
        "vul_func_with_fix": "void virtio_queue_set_notification(VirtQueue *vq, int enable)\n{\n    vq->notification = enable;\n    if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vring_avail_idx(vq));\n    } else if (enable) {\n        vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);\n    } else {\n        vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);\n    }\n    if (enable) {\n        /* Expose avail event/used flags before caller checks the avail idx. */\n        smp_mb();\n    }\n}\n",
        "linevul": 5.9057812904939055e-05,
        "sysevr": 0.464186429977417,
        "devign": 0.09315771609544754
    },
    {
        "code": "static int ndis_query(USBNetState *s, uint32_t oid,\n                      uint8_t *inbuf, unsigned int inlen, uint8_t *outbuf,\n                      size_t outlen)\n{\n    unsigned int i;\n\n    switch (oid) {\n    /* general oids (table 4-1) */\n    /* mandatory */\n    case OID_GEN_SUPPORTED_LIST:\n        for (i = 0; i < ARRAY_SIZE(oid_supported_list); i++)\n            ((le32 *) outbuf)[i] = cpu_to_le32(oid_supported_list[i]);\n        return sizeof(oid_supported_list);\n\n    /* mandatory */\n    case OID_GEN_HARDWARE_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_SUPPORTED:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_IN_USE:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_FRAME_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_LINK_SPEED:\n        *((le32 *) outbuf) = cpu_to_le32(s->speed);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_TRANSMIT_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RECEIVE_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_ID:\n        *((le32 *) outbuf) = cpu_to_le32(s->vendorid);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_DESCRIPTION:\n        pstrcpy((char *)outbuf, outlen, \"QEMU USB RNDIS Net\");\n        return strlen((char *)outbuf) + 1;\n\n    case OID_GEN_VENDOR_DRIVER_VERSION:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_CURRENT_PACKET_FILTER:\n        *((le32 *) outbuf) = cpu_to_le32(s->filter);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_TOTAL_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(RNDIS_MAX_TOTAL_SIZE);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_CONNECT_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(s->media_state);\n        return sizeof(le32);\n\n    case OID_GEN_PHYSICAL_MEDIUM:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    case OID_GEN_MAC_OPTIONS:\n        *((le32 *) outbuf) = cpu_to_le32(\n                        NDIS_MAC_OPTION_RECEIVE_SERIALIZED |\n                        NDIS_MAC_OPTION_FULL_DUPLEX);\n        return sizeof(le32);\n\n    /* statistics OIDs (table 4-2) */\n    /* mandatory */\n    case OID_GEN_XMIT_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_XMIT_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_NO_BUFFER:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* ieee802.3 OIDs (table 4-3) */\n    /* mandatory */\n    case OID_802_3_PERMANENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_CURRENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_MULTICAST_LIST:\n        *((le32 *) outbuf) = cpu_to_le32(0xe0000000);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_MAXIMUM_LIST_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    case OID_802_3_MAC_OPTIONS:\n        return 0;\n\n    /* ieee802.3 statistics OIDs (table 4-4) */\n    /* mandatory */\n    case OID_802_3_RCV_ERROR_ALIGNMENT:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_ONE_COLLISION:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_MORE_COLLISIONS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    default:\n        fprintf(stderr, \"usbnet: unknown OID 0x%08x\\n\", oid);\n        return 0;\n    }\n    return -1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fe3c546c5ff2a6210f9a4d8561cc64051ca8603e",
        "vul_func_with_fix": "static int ndis_query(USBNetState *s, uint32_t oid,\n                      uint8_t *inbuf, unsigned int inlen, uint8_t *outbuf,\n                      size_t outlen)\n{\n    unsigned int i;\n\n    switch (oid) {\n    /* general oids (table 4-1) */\n    /* mandatory */\n    case OID_GEN_SUPPORTED_LIST:\n        for (i = 0; i < ARRAY_SIZE(oid_supported_list); i++)\n            ((le32 *) outbuf)[i] = cpu_to_le32(oid_supported_list[i]);\n        return sizeof(oid_supported_list);\n\n    /* mandatory */\n    case OID_GEN_HARDWARE_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_SUPPORTED:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_IN_USE:\n        *((le32 *) outbuf) = cpu_to_le32(s->medium);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_FRAME_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_LINK_SPEED:\n        *((le32 *) outbuf) = cpu_to_le32(s->speed);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_TRANSMIT_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RECEIVE_BLOCK_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(ETH_FRAME_LEN);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_ID:\n        *((le32 *) outbuf) = cpu_to_le32(s->vendorid);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_VENDOR_DESCRIPTION:\n        pstrcpy((char *)outbuf, outlen, \"QEMU USB RNDIS Net\");\n        return strlen((char *)outbuf) + 1;\n\n    case OID_GEN_VENDOR_DRIVER_VERSION:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_CURRENT_PACKET_FILTER:\n        *((le32 *) outbuf) = cpu_to_le32(s->filter);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MAXIMUM_TOTAL_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(RNDIS_MAX_TOTAL_SIZE);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_MEDIA_CONNECT_STATUS:\n        *((le32 *) outbuf) = cpu_to_le32(s->media_state);\n        return sizeof(le32);\n\n    case OID_GEN_PHYSICAL_MEDIUM:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    case OID_GEN_MAC_OPTIONS:\n        *((le32 *) outbuf) = cpu_to_le32(\n                        NDIS_MAC_OPTION_RECEIVE_SERIALIZED |\n                        NDIS_MAC_OPTION_FULL_DUPLEX);\n        return sizeof(le32);\n\n    /* statistics OIDs (table 4-2) */\n    /* mandatory */\n    case OID_GEN_XMIT_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_OK:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_XMIT_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_ERROR:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_GEN_RCV_NO_BUFFER:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* ieee802.3 OIDs (table 4-3) */\n    /* mandatory */\n    case OID_802_3_PERMANENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_CURRENT_ADDRESS:\n        memcpy(outbuf, s->conf.macaddr.a, 6);\n        return 6;\n\n    /* mandatory */\n    case OID_802_3_MULTICAST_LIST:\n        *((le32 *) outbuf) = cpu_to_le32(0xe0000000);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_MAXIMUM_LIST_SIZE:\n        *((le32 *) outbuf) = cpu_to_le32(1);\n        return sizeof(le32);\n\n    case OID_802_3_MAC_OPTIONS:\n        return 0;\n\n    /* ieee802.3 statistics OIDs (table 4-4) */\n    /* mandatory */\n    case OID_802_3_RCV_ERROR_ALIGNMENT:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_ONE_COLLISION:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    /* mandatory */\n    case OID_802_3_XMIT_MORE_COLLISIONS:\n        *((le32 *) outbuf) = cpu_to_le32(0);\n        return sizeof(le32);\n\n    default:\n        fprintf(stderr, \"usbnet: unknown OID 0x%08x\\n\", oid);\n        return 0;\n    }\n    return -1;\n}\n",
        "linevul": 0.0030339558143168688,
        "sysevr": 0.48690372705459595,
        "devign": 0.49432870745658875
    },
    {
        "code": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n                                AHCICmdHdr *cmd, int64_t limit, uint64_t offset)\n{\n    uint16_t opts = le16_to_cpu(cmd->opts);\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n    uint64_t prdt_addr = cfis_addr + 0x80;\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n    int i;\n    int r = 0;\n    uint64_t sum = 0;\n    int off_idx = -1;\n    int64_t off_pos = -1;\n    int tbl_entry_size;\n    IDEBus *bus = &ad->port;\n    BusState *qbus = BUS(bus);\n\n    if (!prdtl) {\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n        return -1;\n    }\n\n    /* map PRDT */\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n                                DMA_DIRECTION_TO_DEVICE))){\n        DPRINTF(ad->port_no, \"map failed\\n\");\n        return -1;\n    }\n\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (prdtl > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < prdtl; i++) {\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset < (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n                         ad->hba->as);\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n                            limit));\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n                                limit - sglist->size));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n    return r;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n                                AHCICmdHdr *cmd, int64_t limit, uint64_t offset)\n{\n    uint16_t opts = le16_to_cpu(cmd->opts);\n    uint16_t prdtl = le16_to_cpu(cmd->prdtl);\n    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);\n    uint64_t prdt_addr = cfis_addr + 0x80;\n    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));\n    dma_addr_t real_prdt_len = prdt_len;\n    uint8_t *prdt;\n    int i;\n    int r = 0;\n    uint64_t sum = 0;\n    int off_idx = -1;\n    int64_t off_pos = -1;\n    int tbl_entry_size;\n    IDEBus *bus = &ad->port;\n    BusState *qbus = BUS(bus);\n\n    if (!prdtl) {\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n        return -1;\n    }\n\n    /* map PRDT */\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n                                DMA_DIRECTION_TO_DEVICE))){\n        DPRINTF(ad->port_no, \"map failed\\n\");\n        return -1;\n    }\n\n    if (prdt_len < real_prdt_len) {\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n        r = -1;\n        goto out;\n    }\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n    if (prdtl > 0) {\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n        sum = 0;\n        for (i = 0; i < prdtl; i++) {\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n            if (offset < (sum + tbl_entry_size)) {\n                off_idx = i;\n                off_pos = offset - sum;\n                break;\n            }\n            sum += tbl_entry_size;\n        }\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                            __func__, off_idx, off_pos);\n            r = -1;\n            goto out;\n        }\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n                         ad->hba->as);\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n                            limit));\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n                                limit - sglist->size));\n        }\n    }\n\nout:\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n    return r;\n}\n",
        "linevul": 4.8125402827281505e-05,
        "sysevr": 0.4668659269809723,
        "devign": 0.003502351464703679
    },
    {
        "code": "static EHCIPacket *ehci_alloc_packet(EHCIQueue *q)\n{\n    EHCIPacket *p;\n\n    p = g_new0(EHCIPacket, 1);\n    p->queue = q;\n    usb_packet_init(&p->packet);\n    QTAILQ_INSERT_TAIL(&q->packets, p, next);\n    trace_usb_ehci_packet_action(p->queue, p, \"alloc\");\n    return p;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static EHCIPacket *ehci_alloc_packet(EHCIQueue *q)\n{\n    EHCIPacket *p;\n\n    p = g_new0(EHCIPacket, 1);\n    p->queue = q;\n    usb_packet_init(&p->packet);\n    QTAILQ_INSERT_TAIL(&q->packets, p, next);\n    trace_usb_ehci_packet_action(p->queue, p, \"alloc\");\n    return p;\n}\n",
        "linevul": 4.7578272642567754e-05,
        "sysevr": 0.4559953510761261,
        "devign": 0.0007266582106240094
    },
    {
        "code": "static inline void gen_string_movl_A0_EDI(DisasContext *s)\n{\n    gen_lea_v_seg(s, s->aflag, cpu_regs[R_EDI], R_ES, -1);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline void gen_string_movl_A0_EDI(DisasContext *s)\n{\n    gen_lea_v_seg(s, s->aflag, cpu_regs[R_EDI], R_ES, -1);\n}\n",
        "linevul": 4.8694335418986157e-05,
        "sysevr": 0.46952322125434875,
        "devign": 0.0005935647641308606
    },
    {
        "code": "void net_checksum_calculate(uint8_t *data, int length)\n{\n     int hlen, plen, proto, csum_offset;\n     uint16_t csum;\n \n     if ((data[14] & 0xf0) != 0x40)\n        return; /* not IPv4 */\n     hlen  = (data[14] & 0x0f) * 4;\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=362786f14a753d8a5256ef97d7c10ed576d6572b",
        "vul_func_with_fix": "void net_checksum_calculate(uint8_t *data, int length)\n{\n     int hlen, plen, proto, csum_offset;\n     uint16_t csum;\n \n//fix_flaw_line_below:\n//    /* Ensure data has complete L2 & L3 headers. */\n//fix_flaw_line_below:\n//    if (length < 14 + 20) {\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     if ((data[14] & 0xf0) != 0x40)\n        return; /* not IPv4 */\n     hlen  = (data[14] & 0x0f) * 4;\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n",
        "linevul": 0.9987840056419373,
        "sysevr": 0.471712201833725,
        "devign": 0.9422985315322876
    },
    {
        "code": "static int proxy_lremovexattr(FsContext *ctx, V9fsPath *fs_path,\n                              const char *name)\n{\n    int retval;\n    V9fsString xname;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n    retval = v9fs_request(ctx->private, T_LREMOVEXATTR, NULL, fs_path, &xname);\n    v9fs_string_free(&xname);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_lremovexattr(FsContext *ctx, V9fsPath *fs_path,\n                              const char *name)\n{\n    int retval;\n    V9fsString xname;\n\n    v9fs_string_init(&xname);\n    v9fs_string_sprintf(&xname, \"%s\", name);\n    retval = v9fs_request(ctx->private, T_LREMOVEXATTR, NULL, fs_path, &xname);\n    v9fs_string_free(&xname);\n    if (retval < 0) {\n        errno = -retval;\n    }\n    return retval;\n}\n",
        "linevul": 4.796499706571922e-05,
        "sysevr": 0.47277501225471497,
        "devign": 0.0010521088261157274
    },
    {
        "code": "static void zrle_write_u32(VncState *vs, uint32_t value)\n{\n    vnc_write(vs, (uint8_t *)&value, 4);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9f64916da20eea67121d544698676295bbb105a7",
        "vul_func_with_fix": "static void zrle_write_u32(VncState *vs, uint32_t value)\n{\n    vnc_write(vs, (uint8_t *)&value, 4);\n}\n",
        "linevul": 4.925937173538841e-05,
        "sysevr": 0.4710380733013153,
        "devign": 0.03224873170256615
    },
    {
        "code": "static int handle_cmd(AHCIState *s, int port, int slot)\n{\n    IDEState *ide_state;\n    uint32_t opts;\n    uint64_t tbl_addr;\n    AHCICmdHdr *cmd;\n    uint8_t *cmd_fis;\n    dma_addr_t cmd_len;\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* Engine currently busy, try again later */\n        DPRINTF(port, \"engine busy\\n\");\n        return -1;\n    }\n\n    cmd = &((AHCICmdHdr *)s->dev[port].lst)[slot];\n\n    if (!s->dev[port].lst) {\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n        return -1;\n    }\n\n    /* remember current slot handle for later */\n    s->dev[port].cur_cmd = cmd;\n\n    opts = le32_to_cpu(cmd->opts);\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n\n    cmd_len = 0x80;\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n                             DMA_DIRECTION_FROM_DEVICE);\n\n    if (!cmd_fis) {\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n        return -1;\n    }\n\n    /* The device we are working for */\n    ide_state = &s->dev[port].port.ifs[0];\n\n    if (!ide_state->bs) {\n        DPRINTF(port, \"error: guest accessed unused port\");\n        goto out;\n    }\n\n    debug_print_fis(cmd_fis, 0x90);\n\n    switch (cmd_fis[0]) {\n        case SATA_FIS_TYPE_REGISTER_H2D:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (cmd_fis[1]) {\n        case SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER:\n            break;\n        case 0:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (s->dev[port].port_state) {\n        case STATE_RUN:\n            if (cmd_fis[15] & ATA_SRST) {\n                s->dev[port].port_state = STATE_RESET;\n            }\n            break;\n        case STATE_RESET:\n            if (!(cmd_fis[15] & ATA_SRST)) {\n                ahci_reset_port(s, port);\n            }\n            break;\n    }\n\n    if (cmd_fis[1] == SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER) {\n\n        /* Check for NCQ command */\n        if ((cmd_fis[2] == READ_FPDMA_QUEUED) ||\n            (cmd_fis[2] == WRITE_FPDMA_QUEUED)) {\n            process_ncq_command(s, port, cmd_fis, slot);\n            goto out;\n        }\n\n        /* Decompose the FIS  */\n        ide_state->nsector = (int64_t)((cmd_fis[13] << 8) | cmd_fis[12]);\n        ide_state->feature = cmd_fis[3];\n        if (!ide_state->nsector) {\n            ide_state->nsector = 256;\n        }\n\n        if (ide_state->drive_kind != IDE_CD) {\n            /*\n             * We set the sector depending on the sector defined in the FIS.\n             * Unfortunately, the spec isn't exactly obvious on this one.\n             *\n             * Apparently LBA48 commands set fis bytes 10,9,8,6,5,4 to the\n             * 48 bit sector number. ATA_CMD_READ_DMA_EXT is an example for\n             * such a command.\n             *\n             * Non-LBA48 commands however use 7[lower 4 bits],6,5,4 to define a\n             * 28-bit sector number. ATA_CMD_READ_DMA is an example for such\n             * a command.\n             *\n             * Since the spec doesn't explicitly state what each field should\n             * do, I simply assume non-used fields as reserved and OR everything\n             * together, independent of the command.\n             */\n            ide_set_sector(ide_state, ((uint64_t)cmd_fis[10] << 40)\n                                    | ((uint64_t)cmd_fis[9] << 32)\n                                    /* This is used for LBA48 commands */\n                                    | ((uint64_t)cmd_fis[8] << 24)\n                                    /* This is used for non-LBA48 commands */\n                                    | ((uint64_t)(cmd_fis[7] & 0xf) << 24)\n                                    | ((uint64_t)cmd_fis[6] << 16)\n                                    | ((uint64_t)cmd_fis[5] << 8)\n                                    | cmd_fis[4]);\n        }\n\n        /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command\n         * table to ide_state->io_buffer\n         */\n        if (opts & AHCI_CMD_ATAPI) {\n            memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n            ide_state->lcyl = 0x14;\n            ide_state->hcyl = 0xeb;\n            debug_print_fis(ide_state->io_buffer, 0x10);\n            ide_state->feature = IDE_FEATURE_DMA;\n            s->dev[port].done_atapi_packet = false;\n            /* XXX send PIO setup FIS */\n        }\n\n        ide_state->error = 0;\n\n        /* Reset transferred byte counter */\n        cmd->status = 0;\n\n        /* We're ready to process the command in FIS byte 2. */\n        ide_exec_cmd(&s->dev[port].port, cmd_fis[2]);\n\n        if ((s->dev[port].port.ifs[0].status & (READY_STAT|DRQ_STAT|BUSY_STAT)) ==\n            READY_STAT) {\n            ahci_write_fis_d2h(&s->dev[port], cmd_fis);\n        }\n    }\n\nout:\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n                     cmd_len);\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* async command, complete later */\n        s->dev[port].busy_slot = slot;\n        return -1;\n    }\n\n    /* done handling the command */\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static int handle_cmd(AHCIState *s, int port, int slot)\n{\n    IDEState *ide_state;\n    uint32_t opts;\n    uint64_t tbl_addr;\n    AHCICmdHdr *cmd;\n    uint8_t *cmd_fis;\n    dma_addr_t cmd_len;\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* Engine currently busy, try again later */\n        DPRINTF(port, \"engine busy\\n\");\n        return -1;\n    }\n\n    cmd = &((AHCICmdHdr *)s->dev[port].lst)[slot];\n\n    if (!s->dev[port].lst) {\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n        return -1;\n    }\n\n    /* remember current slot handle for later */\n    s->dev[port].cur_cmd = cmd;\n\n    opts = le32_to_cpu(cmd->opts);\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n\n    cmd_len = 0x80;\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n                             DMA_DIRECTION_FROM_DEVICE);\n\n    if (!cmd_fis) {\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n        return -1;\n    }\n\n    /* The device we are working for */\n    ide_state = &s->dev[port].port.ifs[0];\n\n    if (!ide_state->bs) {\n        DPRINTF(port, \"error: guest accessed unused port\");\n        goto out;\n    }\n\n    debug_print_fis(cmd_fis, 0x90);\n    //debug_print_fis(cmd_fis, (opts & AHCI_CMD_HDR_CMD_FIS_LEN) * 4);\n\n    switch (cmd_fis[0]) {\n        case SATA_FIS_TYPE_REGISTER_H2D:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (cmd_fis[1]) {\n        case SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER:\n            break;\n        case 0:\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            goto out;\n            break;\n    }\n\n    switch (s->dev[port].port_state) {\n        case STATE_RUN:\n            if (cmd_fis[15] & ATA_SRST) {\n                s->dev[port].port_state = STATE_RESET;\n            }\n            break;\n        case STATE_RESET:\n            if (!(cmd_fis[15] & ATA_SRST)) {\n                ahci_reset_port(s, port);\n            }\n            break;\n    }\n\n    if (cmd_fis[1] == SATA_FIS_REG_H2D_UPDATE_COMMAND_REGISTER) {\n\n        /* Check for NCQ command */\n        if ((cmd_fis[2] == READ_FPDMA_QUEUED) ||\n            (cmd_fis[2] == WRITE_FPDMA_QUEUED)) {\n            process_ncq_command(s, port, cmd_fis, slot);\n            goto out;\n        }\n\n        /* Decompose the FIS  */\n        ide_state->nsector = (int64_t)((cmd_fis[13] << 8) | cmd_fis[12]);\n        ide_state->feature = cmd_fis[3];\n        if (!ide_state->nsector) {\n            ide_state->nsector = 256;\n        }\n\n        if (ide_state->drive_kind != IDE_CD) {\n            /*\n             * We set the sector depending on the sector defined in the FIS.\n             * Unfortunately, the spec isn't exactly obvious on this one.\n             *\n             * Apparently LBA48 commands set fis bytes 10,9,8,6,5,4 to the\n             * 48 bit sector number. ATA_CMD_READ_DMA_EXT is an example for\n             * such a command.\n             *\n             * Non-LBA48 commands however use 7[lower 4 bits],6,5,4 to define a\n             * 28-bit sector number. ATA_CMD_READ_DMA is an example for such\n             * a command.\n             *\n             * Since the spec doesn't explicitly state what each field should\n             * do, I simply assume non-used fields as reserved and OR everything\n             * together, independent of the command.\n             */\n            ide_set_sector(ide_state, ((uint64_t)cmd_fis[10] << 40)\n                                    | ((uint64_t)cmd_fis[9] << 32)\n                                    /* This is used for LBA48 commands */\n                                    | ((uint64_t)cmd_fis[8] << 24)\n                                    /* This is used for non-LBA48 commands */\n                                    | ((uint64_t)(cmd_fis[7] & 0xf) << 24)\n                                    | ((uint64_t)cmd_fis[6] << 16)\n                                    | ((uint64_t)cmd_fis[5] << 8)\n                                    | cmd_fis[4]);\n        }\n\n        /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command\n         * table to ide_state->io_buffer\n         */\n        if (opts & AHCI_CMD_ATAPI) {\n            memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n            ide_state->lcyl = 0x14;\n            ide_state->hcyl = 0xeb;\n            debug_print_fis(ide_state->io_buffer, 0x10);\n            ide_state->feature = IDE_FEATURE_DMA;\n            s->dev[port].done_atapi_packet = false;\n            /* XXX send PIO setup FIS */\n        }\n\n        ide_state->error = 0;\n\n        /* Reset transferred byte counter */\n        cmd->status = 0;\n\n        /* We're ready to process the command in FIS byte 2. */\n        ide_exec_cmd(&s->dev[port].port, cmd_fis[2]);\n\n        if ((s->dev[port].port.ifs[0].status & (READY_STAT|DRQ_STAT|BUSY_STAT)) ==\n            READY_STAT) {\n            ahci_write_fis_d2h(&s->dev[port], cmd_fis);\n        }\n    }\n\nout:\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n                     cmd_len);\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* async command, complete later */\n        s->dev[port].busy_slot = slot;\n        return -1;\n    }\n\n    /* done handling the command */\n    return 0;\n}\n",
        "linevul": 5.9411704569356516e-05,
        "sysevr": 0.486178994178772,
        "devign": 0.00544821796938777
    },
    {
        "code": "v9fs_path_sprintf(V9fsPath *path, const char *fmt, ...)\n{\n    va_list ap;\n\n    v9fs_path_free(path);\n\n    va_start(ap, fmt);\n    /* Bump the size for including terminating NULL */\n    path->size = g_vasprintf(&path->data, fmt, ap) + 1;\n    va_end(ap);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "v9fs_path_sprintf(V9fsPath *path, const char *fmt, ...)\n{\n    va_list ap;\n\n    v9fs_path_free(path);\n\n    va_start(ap, fmt);\n    /* Bump the size for including terminating NULL */\n    path->size = g_vasprintf(&path->data, fmt, ap) + 1;\n    va_end(ap);\n}\n",
        "linevul": 6.096134166000411e-05,
        "sysevr": 0.4675557315349579,
        "devign": 0.19985124468803406
    },
    {
        "code": "static int virtio_validate_features(VirtIODevice *vdev)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    if (k->validate_features) {\n        return k->validate_features(vdev);\n    } else {\n        return 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static int virtio_validate_features(VirtIODevice *vdev)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n\n    if (k->validate_features) {\n        return k->validate_features(vdev);\n    } else {\n        return 0;\n    }\n}\n",
        "linevul": 4.5843360567232594e-05,
        "sysevr": 0.4632837176322937,
        "devign": 0.0002486401062924415
    },
    {
        "code": "static FILE *local_fopenat(int dirfd, const char *name, const char *mode)\n{\n    int fd, o_mode = 0;\n    FILE *fp;\n    int flags;\n    /*\n     * only supports two modes\n     */\n    if (mode[0] == 'r') {\n        flags = O_RDONLY;\n    } else if (mode[0] == 'w') {\n        flags = O_WRONLY | O_TRUNC | O_CREAT;\n        o_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n    } else {\n        return NULL;\n    }\n    fd = openat_file(dirfd, name, flags, o_mode);\n    if (fd == -1) {\n        return NULL;\n    }\n    fp = fdopen(fd, mode);\n    if (!fp) {\n        close(fd);\n    }\n    return fp;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static FILE *local_fopenat(int dirfd, const char *name, const char *mode)\n{\n    int fd, o_mode = 0;\n    FILE *fp;\n    int flags;\n    /*\n     * only supports two modes\n     */\n    if (mode[0] == 'r') {\n        flags = O_RDONLY;\n    } else if (mode[0] == 'w') {\n        flags = O_WRONLY | O_TRUNC | O_CREAT;\n        o_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n    } else {\n        return NULL;\n    }\n    fd = openat_file(dirfd, name, flags, o_mode);\n    if (fd == -1) {\n        return NULL;\n    }\n    fp = fdopen(fd, mode);\n    if (!fp) {\n        close(fd);\n    }\n    return fp;\n}\n",
        "linevul": 8.367785630980507e-05,
        "sysevr": 0.4571947753429413,
        "devign": 1.0607163147824394e-08
    },
    {
        "code": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a",
        "vul_func_with_fix": "static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    uint64_t nb_sectors;\n    int buflen = 0;\n\n    switch (req->cmd.buf[0]) {\n    case TEST_UNIT_READY:\n        if (s->tray_open || !bdrv_is_inserted(s->bs))\n            goto not_ready;\n        break;\n    case INQUIRY:\n        buflen = scsi_disk_emulate_inquiry(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n        buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case READ_TOC:\n        buflen = scsi_disk_emulate_read_toc(req, outbuf);\n        if (buflen < 0)\n            goto illegal_request;\n        break;\n    case RESERVE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RESERVE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case RELEASE:\n        if (req->cmd.buf[1] & 1)\n            goto illegal_request;\n        break;\n    case RELEASE_10:\n        if (req->cmd.buf[1] & 3)\n            goto illegal_request;\n        break;\n    case START_STOP:\n        if (scsi_disk_emulate_start_stop(r) < 0) {\n            return -1;\n        }\n        break;\n    case ALLOW_MEDIUM_REMOVAL:\n        s->tray_locked = req->cmd.buf[4] & 1;\n        bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1);\n        break;\n    case READ_CAPACITY_10:\n        /* The normal LEN field for this command is zero.  */\n        memset(outbuf, 0, 8);\n        bdrv_get_geometry(s->bs, &nb_sectors);\n        if (!nb_sectors)\n            goto not_ready;\n        nb_sectors /= s->cluster_size;\n        /* Returned value is the address of the last sector.  */\n        nb_sectors--;\n        /* Remember the new size for read/write sanity checking. */\n        s->max_lba = nb_sectors;\n        /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n        if (nb_sectors > UINT32_MAX)\n            nb_sectors = UINT32_MAX;\n        outbuf[0] = (nb_sectors >> 24) & 0xff;\n        outbuf[1] = (nb_sectors >> 16) & 0xff;\n        outbuf[2] = (nb_sectors >> 8) & 0xff;\n        outbuf[3] = nb_sectors & 0xff;\n        outbuf[4] = 0;\n        outbuf[5] = 0;\n        outbuf[6] = s->cluster_size * 2;\n        outbuf[7] = 0;\n        buflen = 8;\n        break;\n    case GET_CONFIGURATION:\n        memset(outbuf, 0, 8);\n        /* ??? This should probably return much more information.  For now\n           just return the basic header indicating the CD-ROM profile.  */\n        outbuf[7] = 8; // CD-ROM\n        buflen = 8;\n        break;\n    case SERVICE_ACTION_IN_16:\n        /* Service Action In subcommands. */\n        if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n            DPRINTF(\"SAI READ CAPACITY(16)\\n\");\n            memset(outbuf, 0, req->cmd.xfer);\n            bdrv_get_geometry(s->bs, &nb_sectors);\n            if (!nb_sectors)\n                goto not_ready;\n            nb_sectors /= s->cluster_size;\n            /* Returned value is the address of the last sector.  */\n            nb_sectors--;\n            /* Remember the new size for read/write sanity checking. */\n            s->max_lba = nb_sectors;\n            outbuf[0] = (nb_sectors >> 56) & 0xff;\n            outbuf[1] = (nb_sectors >> 48) & 0xff;\n            outbuf[2] = (nb_sectors >> 40) & 0xff;\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n            outbuf[7] = nb_sectors & 0xff;\n            outbuf[8] = 0;\n            outbuf[9] = 0;\n            outbuf[10] = s->cluster_size * 2;\n            outbuf[11] = 0;\n            outbuf[12] = 0;\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n            /* set TPE bit if the format supports discard */\n            if (s->qdev.conf.discard_granularity) {\n                outbuf[14] = 0x80;\n            }\n\n            /* Protection, exponent and lowest lba field left blank. */\n            buflen = req->cmd.xfer;\n            break;\n        }\n        DPRINTF(\"Unsupported Service Action In\\n\");\n        goto illegal_request;\n    case VERIFY_10:\n        break;\n    default:\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return -1;\n    }\n    return buflen;\n\nnot_ready:\n    if (s->tray_open || !bdrv_is_inserted(s->bs)) {\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n    } else {\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n    }\n    return -1;\n\nillegal_request:\n    if (r->req.status == -1) {\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n    }\n    return -1;\n}\n",
        "linevul": 0.00019968952983617783,
        "sysevr": 0.467387855052948,
        "devign": 0.7552290558815002
    },
    {
        "code": "static void xhci_complete(USBPort *port, USBPacket *packet)\n{\n    XHCITransfer *xfer = container_of(packet, XHCITransfer, packet);\n\n    if (packet->status == USB_RET_REMOVE_FROM_QUEUE) {\n        xhci_ep_nuke_one_xfer(xfer, 0);\n        return;\n    }\n    xhci_try_complete_packet(xfer);\n    xhci_kick_epctx(xfer->epctx, xfer->streamid);\n    if (xfer->complete) {\n        xhci_ep_free_xfer(xfer);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_complete(USBPort *port, USBPacket *packet)\n{\n    XHCITransfer *xfer = container_of(packet, XHCITransfer, packet);\n\n    if (packet->status == USB_RET_REMOVE_FROM_QUEUE) {\n        xhci_ep_nuke_one_xfer(xfer, 0);\n        return;\n    }\n    xhci_try_complete_packet(xfer);\n    xhci_kick_epctx(xfer->epctx, xfer->streamid);\n    if (xfer->complete) {\n        xhci_ep_free_xfer(xfer);\n    }\n}\n",
        "linevul": 7.369366358034313e-05,
        "sysevr": 0.4655340909957886,
        "devign": 0.007820882834494114
    },
    {
        "code": "void bdrv_disable_copy_on_read(BlockDriverState *bs)\n{\n    assert(bs->copy_on_read > 0);\n    bs->copy_on_read--;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "void bdrv_disable_copy_on_read(BlockDriverState *bs)\n{\n    assert(bs->copy_on_read > 0);\n    bs->copy_on_read--;\n}\n",
        "linevul": 7.849774556234479e-05,
        "sysevr": 0.46789151430130005,
        "devign": 0.0011784902308136225
    },
    {
        "code": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n     g_free(name);\n     close_preserve_errno(dirfd);\n     if (xattr_len < 0) {\n         return -1;\n     }\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n     g_free(name);\n     close_preserve_errno(dirfd);\n     if (xattr_len < 0) {\n//fix_flaw_line_below:\n//        g_free(orig_value);\n         return -1;\n     }\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}\n",
        "linevul": 0.2418675273656845,
        "sysevr": 0.4675217568874359,
        "devign": 0.9999986886978149
    },
    {
        "code": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n{\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n        s->redraw_fifo_first = s->redraw_fifo_last;\n        return;\n    }\n    /* Overlapping region updates can be optimised out here - if someone\n     * knows a smart algorithm to do that, please share.  */\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n        rect = &s->redraw_fifo[s->redraw_fifo_first++];\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n{\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n        s->redraw_fifo_first = s->redraw_fifo_last;\n        return;\n    }\n    /* Overlapping region updates can be optimised out here - if someone\n     * knows a smart algorithm to do that, please share.  */\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n        rect = &s->redraw_fifo[s->redraw_fifo_first++];\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n    }\n}\n",
        "linevul": 4.694978997576982e-05,
        "sysevr": 0.4684104025363922,
        "devign": 5.2601450755904167e-14
    },
    {
        "code": "static size_t fill(uint8_t *data, size_t size, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vfill(data, size, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "static size_t fill(uint8_t *data, size_t size, const char *fmt, ...)\n{\n    va_list ap;\n    size_t ret;\n\n    va_start(ap, fmt);\n    ret = vfill(data, size, fmt, ap);\n    va_end(ap);\n\n    return ret;\n}\n",
        "linevul": 6.158114410936832e-05,
        "sysevr": 0.47405916452407837,
        "devign": 0.00970908161252737
    },
    {
        "code": "static void ahci_idp_write(void *opaque, hwaddr addr,\n                           uint64_t val, unsigned size)\n{\n    AHCIState *s = opaque;\n\n    if (addr == s->idp_offset) {\n        /* index register - mask off reserved bits */\n        s->idp_index = (uint32_t)val & ((AHCI_MEM_BAR_SIZE - 1) & ~3);\n    } else if (addr == s->idp_offset + 4) {\n        /* data register - do memory write at location selected by index */\n        ahci_mem_write(opaque, s->idp_index, val, size);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d68f0f778e7f4fbd674627274267f269e40f0b04",
        "vul_func_with_fix": "static void ahci_idp_write(void *opaque, hwaddr addr,\n                           uint64_t val, unsigned size)\n{\n    AHCIState *s = opaque;\n\n    if (addr == s->idp_offset) {\n        /* index register - mask off reserved bits */\n        s->idp_index = (uint32_t)val & ((AHCI_MEM_BAR_SIZE - 1) & ~3);\n    } else if (addr == s->idp_offset + 4) {\n        /* data register - do memory write at location selected by index */\n        ahci_mem_write(opaque, s->idp_index, val, size);\n    }\n}\n",
        "linevul": 4.675766103900969e-05,
        "sysevr": 0.45675128698349,
        "devign": 1.923296082395609e-07
    },
    {
        "code": "static void virtio_queue_host_notifier_aio_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_aio_vq(vq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtio_queue_host_notifier_aio_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_aio_vq(vq);\n    }\n}\n",
        "linevul": 5.359303759178147e-05,
        "sysevr": 0.46562692523002625,
        "devign": 0.00681965472176671
    },
    {
        "code": " pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n \n    if (ready_ptr != mgr->consumed_ptr) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": " pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n//fix_flaw_line_below:\n//    uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING\n//fix_flaw_line_below:\n//                            * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n \n//flaw_line_below:\n    if (ready_ptr != mgr->consumed_ptr) {\n//fix_flaw_line_below:\n//    if (ready_ptr != mgr->consumed_ptr\n//fix_flaw_line_below:\n//        && ready_ptr - mgr->consumed_ptr < ring_size) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}\n",
        "linevul": 0.9994491934776306,
        "sysevr": 0.4598690867424011,
        "devign": 0.8255226612091064
    },
    {
        "code": "static void vga_draw_cursor_line(uint8_t *d1,\n                                 const uint8_t *src1,\n                                 int poffset, int w,\n                                 unsigned int color0,\n                                 unsigned int color1,\n                                 unsigned int color_xor)\n{\n    const uint8_t *plane0, *plane1;\n    int x, b0, b1;\n    uint8_t *d;\n\n    d = d1;\n    plane0 = src1;\n    plane1 = src1 + poffset;\n    for (x = 0; x < w; x++) {\n        b0 = (plane0[x >> 3] >> (7 - (x & 7))) & 1;\n        b1 = (plane1[x >> 3] >> (7 - (x & 7))) & 1;\n        switch (b0 | (b1 << 1)) {\n        case 0:\n            break;\n        case 1:\n            ((uint32_t *)d)[0] ^= color_xor;\n            break;\n        case 2:\n            ((uint32_t *)d)[0] = color0;\n            break;\n        case 3:\n            ((uint32_t *)d)[0] = color1;\n            break;\n        }\n        d += 4;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static void vga_draw_cursor_line(uint8_t *d1,\n                                 const uint8_t *src1,\n                                 int poffset, int w,\n                                 unsigned int color0,\n                                 unsigned int color1,\n                                 unsigned int color_xor)\n{\n    const uint8_t *plane0, *plane1;\n    int x, b0, b1;\n    uint8_t *d;\n\n    d = d1;\n    plane0 = src1;\n    plane1 = src1 + poffset;\n    for (x = 0; x < w; x++) {\n        b0 = (plane0[x >> 3] >> (7 - (x & 7))) & 1;\n        b1 = (plane1[x >> 3] >> (7 - (x & 7))) & 1;\n        switch (b0 | (b1 << 1)) {\n        case 0:\n            break;\n        case 1:\n            ((uint32_t *)d)[0] ^= color_xor;\n            break;\n        case 2:\n            ((uint32_t *)d)[0] = color0;\n            break;\n        case 3:\n            ((uint32_t *)d)[0] = color1;\n            break;\n        }\n        d += 4;\n    }\n}\n",
        "linevul": 5.486106965690851e-05,
        "sysevr": 0.4937257468700409,
        "devign": 0.21615256369113922
    },
    {
        "code": "static void ehci_advance_async_state(EHCIState *ehci)\n{\n    const int async = 1;\n\n    switch(ehci_get_state(ehci, async)) {\n    case EST_INACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            break;\n        }\n        ehci_set_state(ehci, async, EST_ACTIVE);\n\n    case EST_ACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            ehci_queues_rip_all(ehci, async);\n            ehci_set_state(ehci, async, EST_INACTIVE);\n            break;\n        }\n\n        /* make sure guest has acknowledged the doorbell interrupt */\n        /* TO-DO: is this really needed? */\n        if (ehci->usbsts & USBSTS_IAA) {\n            DPRINTF(\"IAA status bit still set.\\n\");\n            break;\n        }\n\n        /* check that address register has been set */\n        if (ehci->asynclistaddr == 0) {\n            break;\n        }\n\n        ehci_set_state(ehci, async, EST_WAITLISTHEAD);\n        ehci_advance_state(ehci, async);\n\n        /* If the doorbell is set, the guest wants to make a change to the\n         * schedule. The host controller needs to release cached data.\n         * (section 4.8.2)\n         */\n        if (ehci->usbcmd & USBCMD_IAAD) {\n            /* Remove all unseen qhs from the async qhs queue */\n            ehci_queues_rip_unseen(ehci, async);\n            trace_usb_ehci_doorbell_ack();\n            ehci->usbcmd &= ~USBCMD_IAAD;\n            ehci_raise_irq(ehci, USBSTS_IAA);\n        }\n        break;\n\n    default:\n        /* this should only be due to a developer mistake */\n        fprintf(stderr, \"ehci: Bad asynchronous state %d. \"\n                \"Resetting to active\\n\", ehci->astate);\n        g_assert_not_reached();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_advance_async_state(EHCIState *ehci)\n{\n    const int async = 1;\n\n    switch(ehci_get_state(ehci, async)) {\n    case EST_INACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            break;\n        }\n        ehci_set_state(ehci, async, EST_ACTIVE);\n        // No break, fall through to ACTIVE\n\n    case EST_ACTIVE:\n        if (!ehci_async_enabled(ehci)) {\n            ehci_queues_rip_all(ehci, async);\n            ehci_set_state(ehci, async, EST_INACTIVE);\n            break;\n        }\n\n        /* make sure guest has acknowledged the doorbell interrupt */\n        /* TO-DO: is this really needed? */\n        if (ehci->usbsts & USBSTS_IAA) {\n            DPRINTF(\"IAA status bit still set.\\n\");\n            break;\n        }\n\n        /* check that address register has been set */\n        if (ehci->asynclistaddr == 0) {\n            break;\n        }\n\n        ehci_set_state(ehci, async, EST_WAITLISTHEAD);\n        ehci_advance_state(ehci, async);\n\n        /* If the doorbell is set, the guest wants to make a change to the\n         * schedule. The host controller needs to release cached data.\n         * (section 4.8.2)\n         */\n        if (ehci->usbcmd & USBCMD_IAAD) {\n            /* Remove all unseen qhs from the async qhs queue */\n            ehci_queues_rip_unseen(ehci, async);\n            trace_usb_ehci_doorbell_ack();\n            ehci->usbcmd &= ~USBCMD_IAAD;\n            ehci_raise_irq(ehci, USBSTS_IAA);\n        }\n        break;\n\n    default:\n        /* this should only be due to a developer mistake */\n        fprintf(stderr, \"ehci: Bad asynchronous state %d. \"\n                \"Resetting to active\\n\", ehci->astate);\n        g_assert_not_reached();\n    }\n}\n",
        "linevul": 4.609753523254767e-05,
        "sysevr": 0.4838782250881195,
        "devign": 1.0460096788733608e-08
    },
    {
        "code": "iscsi_abort_task_cb(struct iscsi_context *iscsi, int status, void *command_data,\n                    void *private_data)\n{\n    IscsiAIOCB *acb = private_data;\n\n    acb->status = -ECANCELED;\n    iscsi_schedule_bh(acb);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_abort_task_cb(struct iscsi_context *iscsi, int status, void *command_data,\n                    void *private_data)\n{\n    IscsiAIOCB *acb = private_data;\n\n    acb->status = -ECANCELED;\n    iscsi_schedule_bh(acb);\n}\n",
        "linevul": 4.660105696530081e-05,
        "sysevr": 0.4764634668827057,
        "devign": 0.23092201352119446
    },
    {
        "code": "pvscsi_pre_save(void *opaque)\n{\n    PVSCSIState *s = (PVSCSIState *) opaque;\n\n    trace_pvscsi_state(\"presave\");\n\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    assert(QTAILQ_EMPTY(&s->completion_queue));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": "pvscsi_pre_save(void *opaque)\n{\n    PVSCSIState *s = (PVSCSIState *) opaque;\n\n    trace_pvscsi_state(\"presave\");\n\n    assert(QTAILQ_EMPTY(&s->pending_queue));\n    assert(QTAILQ_EMPTY(&s->completion_queue));\n}\n",
        "linevul": 4.639942926587537e-05,
        "sysevr": 0.4619702398777008,
        "devign": 1.3069869737591944e-06
    },
    {
        "code": "static void ide_cfata_identify_size(IDEState *s)\n{\n    uint16_t *p = (uint16_t *)s->identify_data;\n    put_le16(p + 7, s->nb_sectors >> 16);  /* Sectors per card */\n    put_le16(p + 8, s->nb_sectors);        /* Sectors per card */\n    put_le16(p + 60, s->nb_sectors);       /* Total LBA sectors */\n    put_le16(p + 61, s->nb_sectors >> 16); /* Total LBA sectors */\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_cfata_identify_size(IDEState *s)\n{\n    uint16_t *p = (uint16_t *)s->identify_data;\n    put_le16(p + 7, s->nb_sectors >> 16);  /* Sectors per card */\n    put_le16(p + 8, s->nb_sectors);        /* Sectors per card */\n    put_le16(p + 60, s->nb_sectors);       /* Total LBA sectors */\n    put_le16(p + 61, s->nb_sectors >> 16); /* Total LBA sectors */\n}\n",
        "linevul": 4.748268111143261e-05,
        "sysevr": 0.46253663301467896,
        "devign": 7.341463788179681e-05
    },
    {
        "code": "static void v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    /*\n     * Currently we only support BASIC fields in stat, so there is no\n     * need to look at request_mask.\n     */\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n    /*  fill st_gen if requested and supported by underlying fs */\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            /* we have valid st_gen: update result mask */\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            /* request cancelled, e.g. by Tflush */\n            goto out;\n        default:\n            /* failed to get st_gen: not fatal, ignore */\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    /*\n     * Currently we only support BASIC fields in stat, so there is no\n     * need to look at request_mask.\n     */\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n    /*  fill st_gen if requested and supported by underlying fs */\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            /* we have valid st_gen: update result mask */\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            /* request cancelled, e.g. by Tflush */\n            goto out;\n        default:\n            /* failed to get st_gen: not fatal, ignore */\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n",
        "linevul": 9.192575816996396e-05,
        "sysevr": 0.472517728805542,
        "devign": 1.1253620335312895e-19
    },
    {
        "code": "static void vga_update_memory_access(VGACommonState *s)\n{\n    hwaddr base, offset, size;\n\n    if (s->legacy_address_space == NULL) {\n        return;\n    }\n\n    if (s->has_chain4_alias) {\n        memory_region_del_subregion(s->legacy_address_space, &s->chain4_alias);\n        object_unparent(OBJECT(&s->chain4_alias));\n        s->has_chain4_alias = false;\n        s->plane_updated = 0xf;\n    }\n    if ((s->sr[VGA_SEQ_PLANE_WRITE] & VGA_SR02_ALL_PLANES) ==\n        VGA_SR02_ALL_PLANES && s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n        offset = 0;\n        switch ((s->gr[VGA_GFX_MISC] >> 2) & 3) {\n        case 0:\n            base = 0xa0000;\n            size = 0x20000;\n            break;\n        case 1:\n            base = 0xa0000;\n            size = 0x10000;\n            offset = s->bank_offset;\n            break;\n        case 2:\n            base = 0xb0000;\n            size = 0x8000;\n            break;\n        case 3:\n        default:\n            base = 0xb8000;\n            size = 0x8000;\n            break;\n        }\n        base += isa_mem_base;\n        memory_region_init_alias(&s->chain4_alias, memory_region_owner(&s->vram),\n                                 \"vga.chain4\", &s->vram, offset, size);\n        memory_region_add_subregion_overlap(s->legacy_address_space, base,\n                                            &s->chain4_alias, 2);\n        s->has_chain4_alias = true;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=c1b886c45dc70f247300f549dce9833f3fa2def5",
        "vul_func_with_fix": "static void vga_update_memory_access(VGACommonState *s)\n{\n    hwaddr base, offset, size;\n\n    if (s->legacy_address_space == NULL) {\n        return;\n    }\n\n    if (s->has_chain4_alias) {\n        memory_region_del_subregion(s->legacy_address_space, &s->chain4_alias);\n        object_unparent(OBJECT(&s->chain4_alias));\n        s->has_chain4_alias = false;\n        s->plane_updated = 0xf;\n    }\n    if ((s->sr[VGA_SEQ_PLANE_WRITE] & VGA_SR02_ALL_PLANES) ==\n        VGA_SR02_ALL_PLANES && s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n        offset = 0;\n        switch ((s->gr[VGA_GFX_MISC] >> 2) & 3) {\n        case 0:\n            base = 0xa0000;\n            size = 0x20000;\n            break;\n        case 1:\n            base = 0xa0000;\n            size = 0x10000;\n            offset = s->bank_offset;\n            break;\n        case 2:\n            base = 0xb0000;\n            size = 0x8000;\n            break;\n        case 3:\n        default:\n            base = 0xb8000;\n            size = 0x8000;\n            break;\n        }\n        base += isa_mem_base;\n        memory_region_init_alias(&s->chain4_alias, memory_region_owner(&s->vram),\n                                 \"vga.chain4\", &s->vram, offset, size);\n        memory_region_add_subregion_overlap(s->legacy_address_space, base,\n                                            &s->chain4_alias, 2);\n        s->has_chain4_alias = true;\n    }\n}\n",
        "linevul": 5.052045889897272e-05,
        "sysevr": 0.45798933506011963,
        "devign": 2.4696749060680503e-16
    },
    {
        "code": "static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (qemu_has_vnet_hdr(nc->peer)) {\n        return true;\n    }\n\n    VMW_WRPRN(\"Peer has no virtio extension. Task offloads will be emulated.\");\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3c99afc779c2c78718a565ad8c5e98de7c2c7484",
        "vul_func_with_fix": "static bool vmxnet3_peer_has_vnet_hdr(VMXNET3State *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (qemu_has_vnet_hdr(nc->peer)) {\n        return true;\n    }\n\n    VMW_WRPRN(\"Peer has no virtio extension. Task offloads will be emulated.\");\n    return false;\n}\n",
        "linevul": 4.880851702182554e-05,
        "sysevr": 0.462973415851593,
        "devign": 0.006379860453307629
    },
    {
        "code": "iscsi_co_writev_flags(BlockDriverState *bs, int64_t sector_num, int nb_sectors,\n                      QEMUIOVector *iov, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct IscsiTask iTask;\n    uint64_t lba;\n    uint32_t num_sectors;\n    bool fua = flags & BDRV_REQ_FUA;\n\n    if (fua) {\n        assert(iscsilun->dpofua);\n    }\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n        return -EINVAL;\n    }\n\n    if (bs->bl.max_transfer_length && nb_sectors > bs->bl.max_transfer_length) {\n        error_report(\"iSCSI Error: Write of %d sectors exceeds max_xfer_len \"\n                     \"of %d sectors\", nb_sectors, bs->bl.max_transfer_length);\n        return -EINVAL;\n    }\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n    num_sectors = sector_qemu2lun(nb_sectors, iscsilun);\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\nretry:\n    if (iscsilun->use_16_for_rw) {\n        iTask.task = iscsi_write16_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    } else {\n        iTask.task = iscsi_write10_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    }\n    if (iTask.task == NULL) {\n        return -ENOMEM;\n    }\n    scsi_task_set_iov_out(iTask.task, (struct scsi_iovec *) iov->iov,\n                          iov->niov);\n    while (!iTask.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_coroutine_yield();\n    }\n\n    if (iTask.task != NULL) {\n        scsi_free_scsi_task(iTask.task);\n        iTask.task = NULL;\n    }\n\n    if (iTask.do_retry) {\n        iTask.complete = 0;\n        goto retry;\n    }\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n        return iTask.err_code;\n    }\n\n    iscsi_allocationmap_set(iscsilun, sector_num, nb_sectors);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "iscsi_co_writev_flags(BlockDriverState *bs, int64_t sector_num, int nb_sectors,\n                      QEMUIOVector *iov, int flags)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    struct IscsiTask iTask;\n    uint64_t lba;\n    uint32_t num_sectors;\n    bool fua = flags & BDRV_REQ_FUA;\n\n    if (fua) {\n        assert(iscsilun->dpofua);\n    }\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n        return -EINVAL;\n    }\n\n    if (bs->bl.max_transfer_length && nb_sectors > bs->bl.max_transfer_length) {\n        error_report(\"iSCSI Error: Write of %d sectors exceeds max_xfer_len \"\n                     \"of %d sectors\", nb_sectors, bs->bl.max_transfer_length);\n        return -EINVAL;\n    }\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n    num_sectors = sector_qemu2lun(nb_sectors, iscsilun);\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\nretry:\n    if (iscsilun->use_16_for_rw) {\n        iTask.task = iscsi_write16_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    } else {\n        iTask.task = iscsi_write10_task(iscsilun->iscsi, iscsilun->lun, lba,\n                                        NULL, num_sectors * iscsilun->block_size,\n                                        iscsilun->block_size, 0, 0, fua, 0, 0,\n                                        iscsi_co_generic_cb, &iTask);\n    }\n    if (iTask.task == NULL) {\n        return -ENOMEM;\n    }\n    scsi_task_set_iov_out(iTask.task, (struct scsi_iovec *) iov->iov,\n                          iov->niov);\n    while (!iTask.complete) {\n        iscsi_set_events(iscsilun);\n        qemu_coroutine_yield();\n    }\n\n    if (iTask.task != NULL) {\n        scsi_free_scsi_task(iTask.task);\n        iTask.task = NULL;\n    }\n\n    if (iTask.do_retry) {\n        iTask.complete = 0;\n        goto retry;\n    }\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n        return iTask.err_code;\n    }\n\n    iscsi_allocationmap_set(iscsilun, sector_num, nb_sectors);\n\n    return 0;\n}\n",
        "linevul": 0.0007140474626794457,
        "sysevr": 0.46830177307128906,
        "devign": 0.8826195001602173
    },
    {
        "code": "static void net_tx_pkt_rebuild_payload(struct NetTxPkt *pkt)\n{\n    pkt->payload_len = iov_size(pkt->raw, pkt->raw_frags) - pkt->hdr_len;\n    pkt->payload_frags = iov_copy(&pkt->vec[NET_TX_PKT_PL_START_FRAG],\n                                pkt->max_payload_frags,\n                                pkt->raw, pkt->raw_frags,\n                                pkt->hdr_len, pkt->payload_len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "static void net_tx_pkt_rebuild_payload(struct NetTxPkt *pkt)\n{\n    pkt->payload_len = iov_size(pkt->raw, pkt->raw_frags) - pkt->hdr_len;\n    pkt->payload_frags = iov_copy(&pkt->vec[NET_TX_PKT_PL_START_FRAG],\n                                pkt->max_payload_frags,\n                                pkt->raw, pkt->raw_frags,\n                                pkt->hdr_len, pkt->payload_len);\n}\n",
        "linevul": 5.7543446018826216e-05,
        "sysevr": 0.4635452628135681,
        "devign": 0.010373956523835659
    },
    {
        "code": "static void iscsi_allocationmap_clear(IscsiLun *iscsilun, int64_t sector_num,\n                                      int nb_sectors)\n{\n    int64_t cluster_num, nb_clusters;\n    if (iscsilun->allocationmap == NULL) {\n        return;\n    }\n    cluster_num = DIV_ROUND_UP(sector_num, iscsilun->cluster_sectors);\n    nb_clusters = (sector_num + nb_sectors) / iscsilun->cluster_sectors\n                  - cluster_num;\n    if (nb_clusters > 0) {\n        bitmap_clear(iscsilun->allocationmap, cluster_num, nb_clusters);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static void iscsi_allocationmap_clear(IscsiLun *iscsilun, int64_t sector_num,\n                                      int nb_sectors)\n{\n    int64_t cluster_num, nb_clusters;\n    if (iscsilun->allocationmap == NULL) {\n        return;\n    }\n    cluster_num = DIV_ROUND_UP(sector_num, iscsilun->cluster_sectors);\n    nb_clusters = (sector_num + nb_sectors) / iscsilun->cluster_sectors\n                  - cluster_num;\n    if (nb_clusters > 0) {\n        bitmap_clear(iscsilun->allocationmap, cluster_num, nb_clusters);\n    }\n}\n",
        "linevul": 5.611166125163436e-05,
        "sysevr": 0.466692179441452,
        "devign": 0.0004892894066870213
    },
    {
        "code": "e1000e_set_ics(E1000ECore *core, int index, uint32_t val)\n{\n    trace_e1000e_irq_write_ics(val);\n    e1000e_set_interrupt_cause(core, val);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_set_ics(E1000ECore *core, int index, uint32_t val)\n{\n    trace_e1000e_irq_write_ics(val);\n    e1000e_set_interrupt_cause(core, val);\n}\n",
        "linevul": 5.535162199521437e-05,
        "sysevr": 0.4700249135494232,
        "devign": 0.0008671287214383483
    },
    {
        "code": "static int handle_opendir(FsContext *ctx,\n                          V9fsPath *fs_path, V9fsFidOpenState *fs)\n{\n    int ret;\n    ret = handle_open(ctx, fs_path, O_DIRECTORY, fs);\n    if (ret < 0) {\n        return -1;\n    }\n    fs->dir.stream = fdopendir(ret);\n    if (!fs->dir.stream) {\n        return -1;\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=971f406b77a6eb84e0ad27dcc416b663765aee30",
        "vul_func_with_fix": "static int handle_opendir(FsContext *ctx,\n                          V9fsPath *fs_path, V9fsFidOpenState *fs)\n{\n    int ret;\n    ret = handle_open(ctx, fs_path, O_DIRECTORY, fs);\n    if (ret < 0) {\n        return -1;\n    }\n    fs->dir.stream = fdopendir(ret);\n    if (!fs->dir.stream) {\n        return -1;\n    }\n    return 0;\n}\n",
        "linevul": 5.34731698280666e-05,
        "sysevr": 0.4720183312892914,
        "devign": 1.8769656662254164e-10
    },
    {
        "code": "static int coroutine_fn v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)\n{\n    int err = 1;\n    if (f->fid_type == P9_FID_FILE) {\n        if (f->fs.fd == -1) {\n            do {\n                err = v9fs_co_open(pdu, f, f->open_flags);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    } else if (f->fid_type == P9_FID_DIR) {\n        if (f->fs.dir.stream == NULL) {\n            do {\n                err = v9fs_co_opendir(pdu, f);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    }\n    return err;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)\n{\n    int err = 1;\n    if (f->fid_type == P9_FID_FILE) {\n        if (f->fs.fd == -1) {\n            do {\n                err = v9fs_co_open(pdu, f, f->open_flags);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    } else if (f->fid_type == P9_FID_DIR) {\n        if (f->fs.dir.stream == NULL) {\n            do {\n                err = v9fs_co_opendir(pdu, f);\n            } while (err == -EINTR && !pdu->cancelled);\n        }\n    }\n    return err;\n}\n",
        "linevul": 0.00011803462984971702,
        "sysevr": 0.46754103899002075,
        "devign": 0.560860812664032
    },
    {
        "code": "size_t mptsas_config_io_unit_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x01,\n                              \"*b*b*w*l\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=65a8e1f6413a0f6f79894da710b5d6d43361d27d",
        "vul_func_with_fix": "size_t mptsas_config_io_unit_3(MPTSASState *s, uint8_t **data, int address)\n{\n    return MPTSAS_CONFIG_PACK(3, MPI_CONFIG_PAGETYPE_IO_UNIT, 0x01,\n                              \"*b*b*w*l\");\n}\n",
        "linevul": 5.106411117594689e-05,
        "sysevr": 0.47023528814315796,
        "devign": 0.019313080236315727
    },
    {
        "code": "static void gen_lea_modrm(CPUX86State *env, DisasContext *s, int modrm)\n{\n    AddressParts a = gen_lea_modrm_0(env, s, modrm);\n    TCGv ea = gen_lea_modrm_1(a);\n    gen_lea_v_seg(s, s->aflag, ea, a.def_seg, s->override);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_lea_modrm(CPUX86State *env, DisasContext *s, int modrm)\n{\n    AddressParts a = gen_lea_modrm_0(env, s, modrm);\n    TCGv ea = gen_lea_modrm_1(a);\n    gen_lea_v_seg(s, s->aflag, ea, a.def_seg, s->override);\n}\n",
        "linevul": 7.279474812094122e-05,
        "sysevr": 0.4688778817653656,
        "devign": 0.016475219279527664
    },
    {
        "code": "static uint64_t vmxnet3_get_mac_high(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[4]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[5]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static uint64_t vmxnet3_get_mac_high(MACAddr *addr)\n{\n    return VMXNET3_MAKE_BYTE(0, addr->a[4]) |\n           VMXNET3_MAKE_BYTE(1, addr->a[5]);\n}\n",
        "linevul": 5.1787552365567535e-05,
        "sysevr": 0.4684275984764099,
        "devign": 0.00044195970986038446
    },
    {
        "code": "static int coroutine_fn stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                                       const struct stat *stbuf,\n                                       V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=702dbcc274e2ca43be20ba64c758c0ca57dab91d",
        "vul_func_with_fix": "static int coroutine_fn stat_to_v9stat(V9fsPDU *pdu, V9fsPath *name,\n                                       const struct stat *stbuf,\n                                       V9fsStat *v9stat)\n{\n    int err;\n    const char *str;\n\n    memset(v9stat, 0, sizeof(*v9stat));\n\n    stat_to_qid(stbuf, &v9stat->qid);\n    v9stat->mode = stat_to_v9mode(stbuf);\n    v9stat->atime = stbuf->st_atime;\n    v9stat->mtime = stbuf->st_mtime;\n    v9stat->length = stbuf->st_size;\n\n    v9fs_string_free(&v9stat->uid);\n    v9fs_string_free(&v9stat->gid);\n    v9fs_string_free(&v9stat->muid);\n\n    v9stat->n_uid = stbuf->st_uid;\n    v9stat->n_gid = stbuf->st_gid;\n    v9stat->n_muid = 0;\n\n    v9fs_string_free(&v9stat->extension);\n\n    if (v9stat->mode & P9_STAT_MODE_SYMLINK) {\n        err = v9fs_co_readlink(pdu, name, &v9stat->extension);\n        if (err < 0) {\n            return err;\n        }\n    } else if (v9stat->mode & P9_STAT_MODE_DEVICE) {\n        v9fs_string_sprintf(&v9stat->extension, \"%c %u %u\",\n                S_ISCHR(stbuf->st_mode) ? 'c' : 'b',\n                major(stbuf->st_rdev), minor(stbuf->st_rdev));\n    } else if (S_ISDIR(stbuf->st_mode) || S_ISREG(stbuf->st_mode)) {\n        v9fs_string_sprintf(&v9stat->extension, \"%s %lu\",\n                \"HARDLINKCOUNT\", (unsigned long)stbuf->st_nlink);\n    }\n\n    str = strrchr(name->data, '/');\n    if (str) {\n        str += 1;\n    } else {\n        str = name->data;\n    }\n\n    v9fs_string_sprintf(&v9stat->name, \"%s\", str);\n\n    v9stat->size = 61 +\n        v9fs_string_size(&v9stat->name) +\n        v9fs_string_size(&v9stat->uid) +\n        v9fs_string_size(&v9stat->gid) +\n        v9fs_string_size(&v9stat->muid) +\n        v9fs_string_size(&v9stat->extension);\n    return 0;\n}\n",
        "linevul": 0.00010399038001196459,
        "sysevr": 0.4685342013835907,
        "devign": 0.5707065463066101
    },
    {
        "code": "static inline void gen_ins(DisasContext *s, TCGMemOp ot)\n{\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_start();\n    }\n    gen_string_movl_A0_EDI(s);\n    /* Note: we must do this dummy write first to be restartable in\n       case of page fault. */\n    tcg_gen_movi_tl(cpu_T0, 0);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n    gen_helper_in_func(ot, cpu_T0, cpu_tmp2_i32);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    gen_op_movl_T0_Dshift(ot);\n    gen_op_add_reg_T0(s->aflag, R_EDI);\n    gen_bpt_io(s, cpu_tmp2_i32, ot);\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_end();\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline void gen_ins(DisasContext *s, TCGMemOp ot)\n{\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_start();\n    }\n    gen_string_movl_A0_EDI(s);\n    /* Note: we must do this dummy write first to be restartable in\n       case of page fault. */\n    tcg_gen_movi_tl(cpu_T0, 0);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n    gen_helper_in_func(ot, cpu_T0, cpu_tmp2_i32);\n    gen_op_st_v(s, ot, cpu_T0, cpu_A0);\n    gen_op_movl_T0_Dshift(ot);\n    gen_op_add_reg_T0(s->aflag, R_EDI);\n    gen_bpt_io(s, cpu_tmp2_i32, ot);\n    if (s->tb->cflags & CF_USE_ICOUNT) {\n        gen_io_end();\n    }\n}\n",
        "linevul": 6.282309186644852e-05,
        "sysevr": 0.5127285718917847,
        "devign": 5.642400768834932e-09
    },
    {
        "code": "vmxnet3_on_rx_done_update_stats(VMXNET3State *s,\n                                int qidx,\n                                Vmxnet3PktStatus status)\n{\n    struct UPT1_RxStats *stats = &s->rxq_descr[qidx].rxq_stats;\n    size_t tot_len = net_rx_pkt_get_total_len(s->rx_pkt);\n\n    switch (status) {\n    case VMXNET3_PKT_STATUS_OUT_OF_BUF:\n        stats->pktsRxOutOfBuf++;\n        break;\n\n    case VMXNET3_PKT_STATUS_ERROR:\n        stats->pktsRxError++;\n        break;\n    case VMXNET3_PKT_STATUS_OK:\n        switch (net_rx_pkt_get_packet_type(s->rx_pkt)) {\n        case ETH_PKT_BCAST:\n            stats->bcastPktsRxOK++;\n            stats->bcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_MCAST:\n            stats->mcastPktsRxOK++;\n            stats->mcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_UCAST:\n            stats->ucastPktsRxOK++;\n            stats->ucastBytesRxOK += tot_len;\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (tot_len > s->mtu) {\n            stats->LROPktsRxOK++;\n            stats->LROBytesRxOK += tot_len;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_on_rx_done_update_stats(VMXNET3State *s,\n                                int qidx,\n                                Vmxnet3PktStatus status)\n{\n    struct UPT1_RxStats *stats = &s->rxq_descr[qidx].rxq_stats;\n    size_t tot_len = net_rx_pkt_get_total_len(s->rx_pkt);\n\n    switch (status) {\n    case VMXNET3_PKT_STATUS_OUT_OF_BUF:\n        stats->pktsRxOutOfBuf++;\n        break;\n\n    case VMXNET3_PKT_STATUS_ERROR:\n        stats->pktsRxError++;\n        break;\n    case VMXNET3_PKT_STATUS_OK:\n        switch (net_rx_pkt_get_packet_type(s->rx_pkt)) {\n        case ETH_PKT_BCAST:\n            stats->bcastPktsRxOK++;\n            stats->bcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_MCAST:\n            stats->mcastPktsRxOK++;\n            stats->mcastBytesRxOK += tot_len;\n            break;\n        case ETH_PKT_UCAST:\n            stats->ucastPktsRxOK++;\n            stats->ucastBytesRxOK += tot_len;\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (tot_len > s->mtu) {\n            stats->LROPktsRxOK++;\n            stats->LROBytesRxOK += tot_len;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n}\n",
        "linevul": 5.211512325331569e-05,
        "sysevr": 0.4701460897922516,
        "devign": 0.5334373712539673
    },
    {
        "code": "static int megasas_cluster_reset_ld(MegasasState *s, MegasasCmd *cmd)\n{\n    uint16_t target_id;\n    int i;\n\n    /* mbox0 contains the device index */\n    target_id = le16_to_cpu(cmd->frame->dcmd.mbox[0]);\n    trace_megasas_dcmd_reset_ld(cmd->index, target_id);\n    for (i = 0; i < s->fw_cmds; i++) {\n        MegasasCmd *tmp_cmd = &s->frames[i];\n        if (tmp_cmd->req && tmp_cmd->req->dev->id == target_id) {\n            SCSIDevice *d = tmp_cmd->req->dev;\n            qdev_reset_all(&d->qdev);\n        }\n    }\n    return MFI_STAT_OK;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_cluster_reset_ld(MegasasState *s, MegasasCmd *cmd)\n{\n    uint16_t target_id;\n    int i;\n\n    /* mbox0 contains the device index */\n    target_id = le16_to_cpu(cmd->frame->dcmd.mbox[0]);\n    trace_megasas_dcmd_reset_ld(cmd->index, target_id);\n    for (i = 0; i < s->fw_cmds; i++) {\n        MegasasCmd *tmp_cmd = &s->frames[i];\n        if (tmp_cmd->req && tmp_cmd->req->dev->id == target_id) {\n            SCSIDevice *d = tmp_cmd->req->dev;\n            qdev_reset_all(&d->qdev);\n        }\n    }\n    return MFI_STAT_OK;\n}\n",
        "linevul": 5.313655856298283e-05,
        "sysevr": 0.46612975001335144,
        "devign": 1.9206249774201637e-19
    },
    {
        "code": "static void gen_shiftd_rm_T1(DisasContext *s, TCGMemOp ot, int op1,\n                             bool is_right, TCGv count_in)\n{\n    target_ulong mask = (ot == MO_64 ? 63 : 31);\n    TCGv count;\n\n    /* load */\n    if (op1 == OR_TMP0) {\n        gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n    } else {\n        gen_op_mov_v_reg(ot, cpu_T0, op1);\n    }\n\n    count = tcg_temp_new();\n    tcg_gen_andi_tl(count, count_in, mask);\n\n    switch (ot) {\n    case MO_16:\n        /* Note: we implement the Intel behaviour for shift count > 16.\n           This means \"shrdw C, B, A\" shifts A:B:A >> C.  Build the B:A\n           portion by constructing it as a 32-bit value.  */\n        if (is_right) {\n            tcg_gen_deposit_tl(cpu_tmp0, cpu_T0, cpu_T1, 16, 16);\n            tcg_gen_mov_tl(cpu_T1, cpu_T0);\n            tcg_gen_mov_tl(cpu_T0, cpu_tmp0);\n        } else {\n            tcg_gen_deposit_tl(cpu_T1, cpu_T0, cpu_T1, 16, 16);\n        }\n        /* FALLTHRU */\n#ifdef TARGET_X86_64\n    case MO_32:\n        /* Concatenate the two 32-bit values and use a 64-bit shift.  */\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_shr_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shr_i64(cpu_T0, cpu_T0, count);\n        } else {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T1, cpu_T0);\n            tcg_gen_shl_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shl_i64(cpu_T0, cpu_T0, count);\n            tcg_gen_shri_i64(cpu_tmp0, cpu_tmp0, 32);\n            tcg_gen_shri_i64(cpu_T0, cpu_T0, 32);\n        }\n        break;\n#endif\n    default:\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_shr_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shr_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        } else {\n            tcg_gen_shl_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n            if (ot == MO_16) {\n                /* Only needed if count > 16, for Intel behaviour.  */\n                tcg_gen_subfi_tl(cpu_tmp4, 33, count);\n                tcg_gen_shr_tl(cpu_tmp4, cpu_T1, cpu_tmp4);\n                tcg_gen_or_tl(cpu_tmp0, cpu_tmp0, cpu_tmp4);\n            }\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shl_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shr_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        }\n        tcg_gen_movi_tl(cpu_tmp4, 0);\n        tcg_gen_movcond_tl(TCG_COND_EQ, cpu_T1, count, cpu_tmp4,\n                           cpu_tmp4, cpu_T1);\n        tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_T1);\n        break;\n    }\n\n    /* store */\n    gen_op_st_rm_T0_A0(s, ot, op1);\n\n    gen_shift_flags(s, ot, cpu_T0, cpu_tmp0, count, is_right);\n    tcg_temp_free(count);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_shiftd_rm_T1(DisasContext *s, TCGMemOp ot, int op1,\n                             bool is_right, TCGv count_in)\n{\n    target_ulong mask = (ot == MO_64 ? 63 : 31);\n    TCGv count;\n\n    /* load */\n    if (op1 == OR_TMP0) {\n        gen_op_ld_v(s, ot, cpu_T0, cpu_A0);\n    } else {\n        gen_op_mov_v_reg(ot, cpu_T0, op1);\n    }\n\n    count = tcg_temp_new();\n    tcg_gen_andi_tl(count, count_in, mask);\n\n    switch (ot) {\n    case MO_16:\n        /* Note: we implement the Intel behaviour for shift count > 16.\n           This means \"shrdw C, B, A\" shifts A:B:A >> C.  Build the B:A\n           portion by constructing it as a 32-bit value.  */\n        if (is_right) {\n            tcg_gen_deposit_tl(cpu_tmp0, cpu_T0, cpu_T1, 16, 16);\n            tcg_gen_mov_tl(cpu_T1, cpu_T0);\n            tcg_gen_mov_tl(cpu_T0, cpu_tmp0);\n        } else {\n            tcg_gen_deposit_tl(cpu_T1, cpu_T0, cpu_T1, 16, 16);\n        }\n        /* FALLTHRU */\n#ifdef TARGET_X86_64\n    case MO_32:\n        /* Concatenate the two 32-bit values and use a 64-bit shift.  */\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T0, cpu_T1);\n            tcg_gen_shr_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shr_i64(cpu_T0, cpu_T0, count);\n        } else {\n            tcg_gen_concat_tl_i64(cpu_T0, cpu_T1, cpu_T0);\n            tcg_gen_shl_i64(cpu_tmp0, cpu_T0, cpu_tmp0);\n            tcg_gen_shl_i64(cpu_T0, cpu_T0, count);\n            tcg_gen_shri_i64(cpu_tmp0, cpu_tmp0, 32);\n            tcg_gen_shri_i64(cpu_T0, cpu_T0, 32);\n        }\n        break;\n#endif\n    default:\n        tcg_gen_subi_tl(cpu_tmp0, count, 1);\n        if (is_right) {\n            tcg_gen_shr_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shr_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        } else {\n            tcg_gen_shl_tl(cpu_tmp0, cpu_T0, cpu_tmp0);\n            if (ot == MO_16) {\n                /* Only needed if count > 16, for Intel behaviour.  */\n                tcg_gen_subfi_tl(cpu_tmp4, 33, count);\n                tcg_gen_shr_tl(cpu_tmp4, cpu_T1, cpu_tmp4);\n                tcg_gen_or_tl(cpu_tmp0, cpu_tmp0, cpu_tmp4);\n            }\n\n            tcg_gen_subfi_tl(cpu_tmp4, mask + 1, count);\n            tcg_gen_shl_tl(cpu_T0, cpu_T0, count);\n            tcg_gen_shr_tl(cpu_T1, cpu_T1, cpu_tmp4);\n        }\n        tcg_gen_movi_tl(cpu_tmp4, 0);\n        tcg_gen_movcond_tl(TCG_COND_EQ, cpu_T1, count, cpu_tmp4,\n                           cpu_tmp4, cpu_T1);\n        tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_T1);\n        break;\n    }\n\n    /* store */\n    gen_op_st_rm_T0_A0(s, ot, op1);\n\n    gen_shift_flags(s, ot, cpu_T0, cpu_tmp0, count, is_right);\n    tcg_temp_free(count);\n}\n",
        "linevul": 4.67812133138068e-05,
        "sysevr": 0.5138975977897644,
        "devign": 0.0009404271841049194
    },
    {
        "code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n \n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n    if (blit_is_unsafe(s, false))\n        return 0;\n\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=f153b563f8cf121aebf5a2fff5f0110faf58ccb3",
        "vul_func_with_fix": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n     int off_cur;\n     int off_cur_end;\n \n//fix_flaw_line_below:\n//    if (off_pitch < 0) {\n//fix_flaw_line_below:\n//        off_begin -= bytesperline - 1;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     for (y = 0; y < lines; y++) {\n        off_cur = off_begin;\n        off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n//fix_flaw_line_below:\n//        assert(off_cur_end >= off_cur);\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n        off_begin += off_pitch;\n     }\n    uint8_t *dst;\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n    if (blit_is_unsafe(s, false))\n        return 0;\n\n    (*s->cirrus_rop) (s, dst, src,\n                      s->cirrus_blt_dstpitch, 0,\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n                             s->cirrus_blt_height);\n    return 1;\n}\n",
        "linevul": 0.9975045323371887,
        "sysevr": 0.48203548789024353,
        "devign": 0.999997615814209
    },
    {
        "code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n     unsigned num_sg = *p_num_sg;\n     assert(num_sg <= max_num_sg);\n \n     while (sz) {\n         hwaddr len = sz;\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n     unsigned num_sg = *p_num_sg;\n     assert(num_sg <= max_num_sg);\n \n//fix_flaw_line_below:\n//    if (!sz) {\n//fix_flaw_line_below:\n//        error_report(\"virtio: zero sized buffers are not allowed\");\n//fix_flaw_line_below:\n//        exit(1);\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     while (sz) {\n         hwaddr len = sz;\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}\n",
        "linevul": 0.9966753721237183,
        "sysevr": 0.47420138120651245,
        "devign": 0.0028956832829862833
    },
    {
        "code": "static bool vring_notify(VirtIODevice *vdev, VirtQueue *vq)\n{\n    uint16_t old, new;\n    bool v;\n    /* We need to expose used array entries before checking used event. */\n    smp_mb();\n    /* Always notify when queue is empty (when feature acknowledge) */\n    if (((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n         !vq->inuse && vring_avail_idx(vq) == vq->last_avail_idx)) {\n        return true;\n    }\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n        return !(vring_avail_flags(vq) & VRING_AVAIL_F_NO_INTERRUPT);\n    }\n\n    v = vq->signalled_used_valid;\n    vq->signalled_used_valid = true;\n    old = vq->signalled_used;\n    new = vq->signalled_used = vring_used_idx(vq);\n    return !v || vring_need_event(vring_used_event(vq), new, old);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "static bool vring_notify(VirtIODevice *vdev, VirtQueue *vq)\n{\n    uint16_t old, new;\n    bool v;\n    /* We need to expose used array entries before checking used event. */\n    smp_mb();\n    /* Always notify when queue is empty (when feature acknowledge) */\n    if (((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n         !vq->inuse && vring_avail_idx(vq) == vq->last_avail_idx)) {\n        return true;\n    }\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n        return !(vring_avail_flags(vq) & VRING_AVAIL_F_NO_INTERRUPT);\n    }\n\n    v = vq->signalled_used_valid;\n    vq->signalled_used_valid = true;\n    old = vq->signalled_used;\n    new = vq->signalled_used = vring_used_idx(vq);\n    return !v || vring_need_event(vring_used_event(vq), new, old);\n}\n",
        "linevul": 5.990957288304344e-05,
        "sysevr": 0.45367005467414856,
        "devign": 1.0687546847520935e-07
    },
    {
        "code": "vmxnet3_dump_conf_descr(const char *name,\n                        struct Vmxnet3_VariableLenConfDesc *pm_descr)\n{\n    VMW_CFPRN(\"%s descriptor dump: Version %u, Length %u\",\n              name, pm_descr->confVer, pm_descr->confLen);\n\n};\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_dump_conf_descr(const char *name,\n                        struct Vmxnet3_VariableLenConfDesc *pm_descr)\n{\n    VMW_CFPRN(\"%s descriptor dump: Version %u, Length %u\",\n              name, pm_descr->confVer, pm_descr->confLen);\n\n};\n",
        "linevul": 4.925194662064314e-05,
        "sysevr": 0.46459028124809265,
        "devign": 0.02242930419743061
    },
    {
        "code": "static int put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static int put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "linevul": 0.00016637856606394053,
        "sysevr": 0.4808705449104309,
        "devign": 1.643355937441804e-11
    },
    {
        "code": "static void GCC_FMT_ATTR(3, 4) report_unsupported(BlockDriverState *bs,\n    Error **errp, const char *fmt, ...)\n{\n    char msg[64];\n    va_list ap;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE, bs->device_name, \"qcow2\",\n              msg);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=6a83f8b5bec6f59e56cc49bd49e4c3f8f805d56f",
        "vul_func_with_fix": "static void GCC_FMT_ATTR(3, 4) report_unsupported(BlockDriverState *bs,\n    Error **errp, const char *fmt, ...)\n{\n    char msg[64];\n    va_list ap;\n\n    va_start(ap, fmt);\n    vsnprintf(msg, sizeof(msg), fmt, ap);\n    va_end(ap);\n\n    error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE, bs->device_name, \"qcow2\",\n              msg);\n}\n",
        "linevul": 4.8361136578023434e-05,
        "sysevr": 0.47015926241874695,
        "devign": 0.5693864822387695
    },
    {
        "code": "static inline bool stellaris_tx_thr_reached(stellaris_enet_state *s)\n{\n    return (s->thr < 0x3f &&\n            (s->tx_fifo_len >= 4 * (s->thr * 8 + 1)));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3a15cc0e1ee7168db0782133d2607a6bfa422d66",
        "vul_func_with_fix": "static inline bool stellaris_tx_thr_reached(stellaris_enet_state *s)\n{\n    return (s->thr < 0x3f &&\n            (s->tx_fifo_len >= 4 * (s->thr * 8 + 1)));\n}\n",
        "linevul": 5.7401932281209156e-05,
        "sysevr": 0.46769389510154724,
        "devign": 0.0015680312644690275
    },
    {
        "code": "e1000e_ring_head_descr(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return e1000e_ring_base(core, r) + E1000_RING_DESC_LEN * core->mac[r->dh];\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_ring_head_descr(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return e1000e_ring_base(core, r) + E1000_RING_DESC_LEN * core->mac[r->dh];\n}\n",
        "linevul": 4.9950478569371626e-05,
        "sysevr": 0.4700849652290344,
        "devign": 0.010734210722148418
    },
    {
        "code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n//fix_flaw_line_below:\n//    if (s->stop <= s->start) {\n//fix_flaw_line_below:\n//        return 1;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
        "linevul": 0.999388575553894,
        "sysevr": 0.470566064119339,
        "devign": 0.00034171045990660787
    },
    {
        "code": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n                        void *opaque)\n{\n    VMStateField *field = vmsd->fields;\n\n    if (vmsd->pre_save) {\n        vmsd->pre_save(opaque);\n    }\n    while (field->name) {\n        if (!field->field_exists ||\n            field->field_exists(opaque, vmsd->version_id)) {\n            void *base_addr = vmstate_base_addr(opaque, field);\n            int i, n_elems = vmstate_n_elems(opaque, field);\n            int size = vmstate_size(opaque, field);\n\n            for (i = 0; i < n_elems; i++) {\n                void *addr = base_addr + size * i;\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n                    addr = *(void **)addr;\n                }\n                if (field->flags & VMS_STRUCT) {\n                    vmstate_save_state(f, field->vmsd, addr);\n                } else {\n                    field->info->put(f, addr, size);\n                }\n            }\n        } else {\n            if (field->flags & VMS_MUST_EXIST) {\n                fprintf(stderr, \"Output state validation failed: %s/%s\\n\",\n                        vmsd->name, field->name);\n                assert(!(field->flags & VMS_MUST_EXIST));\n            }\n        }\n        field++;\n    }\n    vmstate_subsection_save(f, vmsd, opaque);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n                        void *opaque)\n{\n    VMStateField *field = vmsd->fields;\n\n    if (vmsd->pre_save) {\n        vmsd->pre_save(opaque);\n    }\n    while (field->name) {\n        if (!field->field_exists ||\n            field->field_exists(opaque, vmsd->version_id)) {\n            void *base_addr = vmstate_base_addr(opaque, field);\n            int i, n_elems = vmstate_n_elems(opaque, field);\n            int size = vmstate_size(opaque, field);\n\n            for (i = 0; i < n_elems; i++) {\n                void *addr = base_addr + size * i;\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n                    addr = *(void **)addr;\n                }\n                if (field->flags & VMS_STRUCT) {\n                    vmstate_save_state(f, field->vmsd, addr);\n                } else {\n                    field->info->put(f, addr, size);\n                }\n            }\n        } else {\n            if (field->flags & VMS_MUST_EXIST) {\n                fprintf(stderr, \"Output state validation failed: %s/%s\\n\",\n                        vmsd->name, field->name);\n                assert(!(field->flags & VMS_MUST_EXIST));\n            }\n        }\n        field++;\n    }\n    vmstate_subsection_save(f, vmsd, opaque);\n}\n",
        "linevul": 7.30837564333342e-05,
        "sysevr": 0.468690425157547,
        "devign": 4.449816515261773e-06
    },
    {
        "code": " static int get_int32_le(QEMUFile *f, void *pv, size_t size)\n {\n    int32_t loaded;\n     int32_t loaded;\n     qemu_get_sbe32s(f, &loaded);\n \n    if (loaded <= *cur) {\n         *cur = loaded;\n         return 0;\n     }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d2ef4b61fe6d33d2a5dcf100a9b9440de341ad62",
        "vul_func_with_fix": " static int get_int32_le(QEMUFile *f, void *pv, size_t size)\n {\n    int32_t loaded;\n     int32_t loaded;\n     qemu_get_sbe32s(f, &loaded);\n \n//flaw_line_below:\n    if (loaded <= *cur) {\n//fix_flaw_line_below:\n//    if (loaded >= 0 && loaded <= *cur) {\n         *cur = loaded;\n         return 0;\n     }\n}\n",
        "linevul": 0.9992620348930359,
        "sysevr": 0.4791189432144165,
        "devign": 0.9566859602928162
    },
    {
        "code": "e1000e_process_snap_option(E1000ECore *core, uint32_t cmd_and_length)\n{\n    if (cmd_and_length & E1000_TXD_CMD_SNAP) {\n        trace_e1000e_wrn_no_snap_support();\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_process_snap_option(E1000ECore *core, uint32_t cmd_and_length)\n{\n    if (cmd_and_length & E1000_TXD_CMD_SNAP) {\n        trace_e1000e_wrn_no_snap_support();\n    }\n}\n",
        "linevul": 5.3890591516392305e-05,
        "sysevr": 0.4576261043548584,
        "devign": 0.131584033370018
    },
    {
        "code": "static ssize_t fremovexattrat_nofollow(int dirfd, const char *filename,\n                                       const char *name)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = lremovexattr(proc_path, name);\n    g_free(proc_path);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "static ssize_t fremovexattrat_nofollow(int dirfd, const char *filename,\n                                       const char *name)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = lremovexattr(proc_path, name);\n    g_free(proc_path);\n    return ret;\n}\n",
        "linevul": 5.283158316160552e-05,
        "sysevr": 0.47404664754867554,
        "devign": 0.011749095283448696
    },
    {
        "code": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n{\n    printf(\"%s: what are we supposed to return?\\n\", __func__);\n    return 0xcafe;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n{\n    printf(\"%s: what are we supposed to return?\\n\", __func__);\n    return 0xcafe;\n}\n",
        "linevul": 5.044622957939282e-05,
        "sysevr": 0.46758052706718445,
        "devign": 0.07819101214408875
    },
    {
        "code": "static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "linevul": 6.743663834640756e-05,
        "sysevr": 0.45746055245399475,
        "devign": 5.78033686906565e-05
    },
    {
        "code": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n \n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n         return;\n     }\n \n//fix_flaw_line_below:\n//    switch (bits_per_pixel) {\n//fix_flaw_line_below:\n//    case 8:\n//fix_flaw_line_below:\n//    case 16:\n//fix_flaw_line_below:\n//    case 32:\n//fix_flaw_line_below:\n//        break;\n//fix_flaw_line_below:\n//    default:\n//fix_flaw_line_below:\n//        vnc_client_error(vs);\n//fix_flaw_line_below:\n//        return;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);\n}\n",
        "linevul": 0.9960359930992126,
        "sysevr": 0.49395740032196045,
        "devign": 5.286241488988708e-08
    },
    {
        "code": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n \n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n        return;\n    }\n     /* Read the message header from the guest first. */\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=06630554ccbdd25780aa03c3548aaff1eb56dffd",
        "vul_func_with_fix": "static void mptsas_fetch_request(MPTSASState *s)\n{\n    PCIDevice *pci = (PCIDevice *) s;\n    char req[MPTSAS_MAX_REQUEST_SIZE];\n    MPIRequestHeader *hdr = (MPIRequestHeader *)req;\n     hwaddr addr;\n     int size;\n \n//flaw_line_below:\n    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n//flaw_line_below:\n        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n//flaw_line_below:\n        return;\n//flaw_line_below:\n    }\n//flaw_line_below:\n\n     /* Read the message header from the guest first. */\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n    }\n",
        "linevul": 0.9969598054885864,
        "sysevr": 0.462668776512146,
        "devign": 0.9480178356170654
    },
    {
        "code": "static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)\n{\n    hwaddr pa;\n    pa = vq->vring.avail + offsetof(VRingAvail, ring[i]);\n    return lduw_phys(&address_space_memory, pa);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)\n{\n    hwaddr pa;\n    pa = vq->vring.avail + offsetof(VRingAvail, ring[i]);\n    return lduw_phys(&address_space_memory, pa);\n}\n",
        "linevul": 4.971420639776625e-05,
        "sysevr": 0.4715457260608673,
        "devign": 0.00024103690520860255
    },
    {
        "code": "static uint32_t vmxnet3_get_interrupt_config(VMXNET3State *s)\n{\n    uint32_t interrupt_mode = VMXNET3_IT_AUTO | (VMXNET3_IMM_AUTO << 2);\n    VMW_CFPRN(\"Interrupt config is 0x%X\", interrupt_mode);\n    return interrupt_mode;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static uint32_t vmxnet3_get_interrupt_config(VMXNET3State *s)\n{\n    uint32_t interrupt_mode = VMXNET3_IT_AUTO | (VMXNET3_IMM_AUTO << 2);\n    VMW_CFPRN(\"Interrupt config is 0x%X\", interrupt_mode);\n    return interrupt_mode;\n}\n",
        "linevul": 5.0134160119341686e-05,
        "sysevr": 0.4630359709262848,
        "devign": 0.12959568202495575
    },
    {
        "code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n     assert(s->cirrus_blt_width > 0);\n     assert(s->cirrus_blt_height > 0);\n \n     if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                               s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n         return true;\n    }\n\n    return false;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    /* should be the case, see cirrus_bitblt_start */\n     assert(s->cirrus_blt_width > 0);\n     assert(s->cirrus_blt_height > 0);\n \n//fix_flaw_line_below:\n//    if (s->cirrus_blt_width > CIRRUS_BLTBUFSIZE) {\n//fix_flaw_line_below:\n//        return true;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                               s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n         return true;\n    }\n\n    return false;\n}\n",
        "linevul": 0.9970898628234863,
        "sysevr": 0.4548054337501526,
        "devign": 3.890373250214907e-07
    },
    {
        "code": "static int virtio_net_handle_vlan_table(VirtIONet *n, uint8_t cmd,\n                                        struct iovec *iov, unsigned int iov_cnt)\n{\n    uint16_t vid;\n    size_t s;\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    s = iov_to_buf(iov, iov_cnt, 0, &vid, sizeof(vid));\n    vid = lduw_p(&vid);\n    if (s != sizeof(vid)) {\n        return VIRTIO_NET_ERR;\n    }\n\n    if (vid >= MAX_VLAN)\n        return VIRTIO_NET_ERR;\n\n    if (cmd == VIRTIO_NET_CTRL_VLAN_ADD)\n        n->vlans[vid >> 5] |= (1U << (vid & 0x1f));\n    else if (cmd == VIRTIO_NET_CTRL_VLAN_DEL)\n        n->vlans[vid >> 5] &= ~(1U << (vid & 0x1f));\n    else\n        return VIRTIO_NET_ERR;\n\n    rxfilter_notify(nc);\n\n    return VIRTIO_NET_OK;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static int virtio_net_handle_vlan_table(VirtIONet *n, uint8_t cmd,\n                                        struct iovec *iov, unsigned int iov_cnt)\n{\n    uint16_t vid;\n    size_t s;\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    s = iov_to_buf(iov, iov_cnt, 0, &vid, sizeof(vid));\n    vid = lduw_p(&vid);\n    if (s != sizeof(vid)) {\n        return VIRTIO_NET_ERR;\n    }\n\n    if (vid >= MAX_VLAN)\n        return VIRTIO_NET_ERR;\n\n    if (cmd == VIRTIO_NET_CTRL_VLAN_ADD)\n        n->vlans[vid >> 5] |= (1U << (vid & 0x1f));\n    else if (cmd == VIRTIO_NET_CTRL_VLAN_DEL)\n        n->vlans[vid >> 5] &= ~(1U << (vid & 0x1f));\n    else\n        return VIRTIO_NET_ERR;\n\n    rxfilter_notify(nc);\n\n    return VIRTIO_NET_OK;\n}\n",
        "linevul": 4.65977682324592e-05,
        "sysevr": 0.4734865725040436,
        "devign": 6.264038333175792e-12
    },
    {
        "code": "vmxnet3_msix_save(QEMUFile *f, void *opaque)\n{\n    PCIDevice *d = PCI_DEVICE(opaque);\n    msix_save(d, f);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_msix_save(QEMUFile *f, void *opaque)\n{\n    PCIDevice *d = PCI_DEVICE(opaque);\n    msix_save(d, f);\n}\n",
        "linevul": 6.40894504613243e-05,
        "sysevr": 0.46714112162590027,
        "devign": 0.0037689285818487406
    },
    {
        "code": "void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    unsigned int offset;\n    int i;\n\n    trace_virtqueue_fill(vq, elem, len, idx);\n\n    offset = 0;\n    for (i = 0; i < elem->in_num; i++) {\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n                                  elem->in_sg[i].iov_len,\n                                  1, size);\n\n        offset += size;\n    }\n\n    for (i = 0; i < elem->out_num; i++)\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n                                  elem->out_sg[i].iov_len,\n                                  0, elem->out_sg[i].iov_len);\n\n    idx = (idx + vring_used_idx(vq)) % vq->vring.num;\n\n    /* Get a pointer to the next entry in the used ring. */\n    vring_used_ring_id(vq, idx, elem->index);\n    vring_used_ring_len(vq, idx, len);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,\n                    unsigned int len, unsigned int idx)\n{\n    unsigned int offset;\n    int i;\n\n    trace_virtqueue_fill(vq, elem, len, idx);\n\n    offset = 0;\n    for (i = 0; i < elem->in_num; i++) {\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n                                  elem->in_sg[i].iov_len,\n                                  1, size);\n\n        offset += size;\n    }\n\n    for (i = 0; i < elem->out_num; i++)\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n                                  elem->out_sg[i].iov_len,\n                                  0, elem->out_sg[i].iov_len);\n\n    idx = (idx + vring_used_idx(vq)) % vq->vring.num;\n\n    /* Get a pointer to the next entry in the used ring. */\n    vring_used_ring_id(vq, idx, elem->index);\n    vring_used_ring_len(vq, idx, len);\n}\n",
        "linevul": 5.4456588259199634e-05,
        "sysevr": 0.4757215976715088,
        "devign": 0.036637287586927414
    },
    {
        "code": "static void ne2000_asic_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    NE2000State *s = opaque;\n\n#ifdef DEBUG_NE2000\n    printf(\"NE2000: asic write val=0x%04x\\n\", val);\n#endif\n    if (s->rcnt == 0)\n        return;\n    if (s->dcfg & 0x01) {\n        /* 16 bit access */\n        ne2000_mem_writew(s, s->rsar, val);\n        ne2000_dma_update(s, 2);\n    } else {\n        /* 8 bit access */\n        ne2000_mem_writeb(s, s->rsar, val);\n        ne2000_dma_update(s, 1);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=415ab35a441eca767d033a2702223e785b9d5190",
        "vul_func_with_fix": "static void ne2000_asic_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n{\n    NE2000State *s = opaque;\n\n#ifdef DEBUG_NE2000\n    printf(\"NE2000: asic write val=0x%04x\\n\", val);\n#endif\n    if (s->rcnt == 0)\n        return;\n    if (s->dcfg & 0x01) {\n        /* 16 bit access */\n        ne2000_mem_writew(s, s->rsar, val);\n        ne2000_dma_update(s, 2);\n    } else {\n        /* 8 bit access */\n        ne2000_mem_writeb(s, s->rsar, val);\n        ne2000_dma_update(s, 1);\n    }\n}\n",
        "linevul": 5.8526929933577776e-05,
        "sysevr": 0.4665290117263794,
        "devign": 7.121688794242687e-10
    },
    {
        "code": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n             cursor.bpp = vmsvga_fifo_read(s);\n \n             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n            if (cursor.width > 256 ||\n                cursor.height > 256 ||\n                cursor.bpp > 32 ||\n                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n                     goto badcmd;\n             }\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=167d97a3def77ee2dbf6e908b0ecbfe2103977db",
        "vul_func_with_fix": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n             cursor.bpp = vmsvga_fifo_read(s);\n \n             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n//flaw_line_below:\n            if (cursor.width > 256 ||\n//flaw_line_below:\n                cursor.height > 256 ||\n//flaw_line_below:\n                cursor.bpp > 32 ||\n//flaw_line_below:\n                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n//flaw_line_below:\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n//fix_flaw_line_below:\n//            if (cursor.width > 256\n//fix_flaw_line_below:\n//                || cursor.height > 256\n//fix_flaw_line_below:\n//                || cursor.bpp > 32\n//fix_flaw_line_below:\n//                || SVGA_BITMAP_SIZE(x, y)\n//fix_flaw_line_below:\n//                    > sizeof(cursor.mask) / sizeof(cursor.mask[0])\n//fix_flaw_line_below:\n//                || SVGA_PIXMAP_SIZE(x, y, cursor.bpp)\n//fix_flaw_line_below:\n//                    > sizeof(cursor.image) / sizeof(cursor.image[0])) {\n                     goto badcmd;\n             }\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n",
        "linevul": 0.00021398261014837772,
        "sysevr": 0.4880485534667969,
        "devign": 1.0
    },
    {
        "code": "static void ohci_roothub_reset(OHCIState *ohci)\n{\n    OHCIPort *port;\n    int i;\n\n    ohci_bus_stop(ohci);\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n    ohci->rhstatus = 0;\n\n    for (i = 0; i < ohci->num_ports; i++) {\n        port = &ohci->rhport[i];\n        port->ctrl = 0;\n        if (port->port.dev && port->port.dev->attached) {\n            usb_port_reset(&port->port);\n        }\n    }\n    if (ohci->async_td) {\n        usb_cancel_packet(&ohci->usb_packet);\n        ohci->async_td = 0;\n    }\n    ohci_stop_endpoints(ohci);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=26f670a244982335cc08943fb1ec099a2c81e42d",
        "vul_func_with_fix": "static void ohci_roothub_reset(OHCIState *ohci)\n{\n    OHCIPort *port;\n    int i;\n\n    ohci_bus_stop(ohci);\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n    ohci->rhstatus = 0;\n\n    for (i = 0; i < ohci->num_ports; i++) {\n        port = &ohci->rhport[i];\n        port->ctrl = 0;\n        if (port->port.dev && port->port.dev->attached) {\n            usb_port_reset(&port->port);\n        }\n    }\n    if (ohci->async_td) {\n        usb_cancel_packet(&ohci->usb_packet);\n        ohci->async_td = 0;\n    }\n    ohci_stop_endpoints(ohci);\n}\n",
        "linevul": 4.6566492528654635e-05,
        "sysevr": 0.4611181616783142,
        "devign": 5.4981257583850904e-14
    },
    {
        "code": "static void ssd0323_cd(void *opaque, int n, int level)\n{\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    DPRINTF(\"%s mode\\n\", level ? \"Data\" : \"Command\");\n    s->mode = level ? SSD0323_DATA : SSD0323_CMD;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ead7a57df37d2187813a121308213f41591bd811",
        "vul_func_with_fix": "static void ssd0323_cd(void *opaque, int n, int level)\n{\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    DPRINTF(\"%s mode\\n\", level ? \"Data\" : \"Command\");\n    s->mode = level ? SSD0323_DATA : SSD0323_CMD;\n}\n",
        "linevul": 4.821488982997835e-05,
        "sysevr": 0.4698316752910614,
        "devign": 0.006181575357913971
    },
    {
        "code": "int bdrv_create_file(const char* filename, QEMUOptionParameter *options,\n                     Error **errp)\n{\n    BlockDriver *drv;\n    Error *local_err = NULL;\n    int ret;\n\n    drv = bdrv_find_protocol(filename, true);\n    if (drv == NULL) {\n        error_setg(errp, \"Could not find protocol for file '%s'\", filename);\n        return -ENOENT;\n    }\n\n    ret = bdrv_create(drv, filename, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    }\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "int bdrv_create_file(const char* filename, QEMUOptionParameter *options,\n                     Error **errp)\n{\n    BlockDriver *drv;\n    Error *local_err = NULL;\n    int ret;\n\n    drv = bdrv_find_protocol(filename, true);\n    if (drv == NULL) {\n        error_setg(errp, \"Could not find protocol for file '%s'\", filename);\n        return -ENOENT;\n    }\n\n    ret = bdrv_create(drv, filename, options, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n    }\n    return ret;\n}\n",
        "linevul": 4.9335249059367925e-05,
        "sysevr": 0.4617530107498169,
        "devign": 7.41723706596531e-05
    },
    {
        "code": "void ide_transfer_stop(IDEState *s)\n{\n    s->end_transfer_func = ide_transfer_stop;\n    s->data_ptr = s->io_buffer;\n    s->data_end = s->io_buffer;\n    s->status &= ~DRQ_STAT;\n    ide_cmd_done(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "void ide_transfer_stop(IDEState *s)\n{\n    s->end_transfer_func = ide_transfer_stop;\n    s->data_ptr = s->io_buffer;\n    s->data_end = s->io_buffer;\n    s->status &= ~DRQ_STAT;\n    ide_cmd_done(s);\n}\n",
        "linevul": 5.595494440058246e-05,
        "sysevr": 0.46012383699417114,
        "devign": 9.834161028265953e-05
    },
    {
        "code": "int pt_removexattr(FsContext *ctx, const char *path, const char *name)\n{\n    return local_removexattr_nofollow(ctx, path, name);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "int pt_removexattr(FsContext *ctx, const char *path, const char *name)\n{\n    return local_removexattr_nofollow(ctx, path, name);\n}\n",
        "linevul": 5.384210089687258e-05,
        "sysevr": 0.471232533454895,
        "devign": 0.20302382111549377
    },
    {
        "code": "static int ehci_state_fetchsitd(EHCIState *ehci, int async)\n{\n    uint32_t entry;\n    EHCIsitd sitd;\n\n    assert(!async);\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    if (get_dwords(ehci, NLPTR_GET(entry), (uint32_t *)&sitd,\n                   sizeof(EHCIsitd) >> 2) < 0) {\n        return 0;\n    }\n    ehci_trace_sitd(ehci, entry, &sitd);\n\n    if (!(sitd.results & SITD_RESULTS_ACTIVE)) {\n        /* siTD is not active, nothing to do */;\n    } else {\n        /* TODO: split transfers are not implemented */\n        fprintf(stderr, \"WARNING: Skipping active siTD\\n\");\n    }\n\n    ehci_set_fetch_addr(ehci, async, sitd.next);\n    ehci_set_state(ehci, async, EST_FETCHENTRY);\n    return 1;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_state_fetchsitd(EHCIState *ehci, int async)\n{\n    uint32_t entry;\n    EHCIsitd sitd;\n\n    assert(!async);\n    entry = ehci_get_fetch_addr(ehci, async);\n\n    if (get_dwords(ehci, NLPTR_GET(entry), (uint32_t *)&sitd,\n                   sizeof(EHCIsitd) >> 2) < 0) {\n        return 0;\n    }\n    ehci_trace_sitd(ehci, entry, &sitd);\n\n    if (!(sitd.results & SITD_RESULTS_ACTIVE)) {\n        /* siTD is not active, nothing to do */;\n    } else {\n        /* TODO: split transfers are not implemented */\n        fprintf(stderr, \"WARNING: Skipping active siTD\\n\");\n    }\n\n    ehci_set_fetch_addr(ehci, async, sitd.next);\n    ehci_set_state(ehci, async, EST_FETCHENTRY);\n    return 1;\n}\n",
        "linevul": 4.684701707446948e-05,
        "sysevr": 0.46878471970558167,
        "devign": 0.0010002532508224249
    },
    {
        "code": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n    return core->mac[r->dh] == core->mac[r->dt];\n }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n//flaw_line_below:\n    return core->mac[r->dh] == core->mac[r->dt];\n//fix_flaw_line_below:\n//    return core->mac[r->dh] == core->mac[r->dt] ||\n//fix_flaw_line_below:\n//                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;\n }\n",
        "linevul": 9.258696081815287e-05,
        "sysevr": 0.46272438764572144,
        "devign": 6.223580567166209e-05
    },
    {
        "code": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n        uint32_t size;\n    } prd;\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n//fix_flaw_line_below:\n///**\n//fix_flaw_line_below:\n// * Return the number of bytes successfully prepared.\n//fix_flaw_line_below:\n// * -1 on error.\n//fix_flaw_line_below:\n// */\n//fix_flaw_line_below:\n//static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n        uint32_t size;\n    } prd;\n",
        "linevul": 0.02598501741886139,
        "sysevr": 0.4727693796157837,
        "devign": 0.9129851460456848
    },
    {
        "code": " static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n {\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n     qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     return r->qiov.size / 512;\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": " static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n {\n//flaw_line_below:\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n//fix_flaw_line_below:\n//    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n//fix_flaw_line_below:\n//\n//fix_flaw_line_below:\n//    if (!r->iov.iov_base) {\n//fix_flaw_line_below:\n//        r->buflen = SCSI_DMA_BUF_SIZE;\n//fix_flaw_line_below:\n//        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n     qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     return r->qiov.size / 512;\n }\n",
        "linevul": 0.0013680682750418782,
        "sysevr": 0.46438902616500854,
        "devign": 0.9886444807052612
    },
    {
        "code": "static void ide_cfata_metadata_read(IDEState *s)\n{\n    uint16_t *p;\n\n    if (((s->hcyl << 16) | s->lcyl) << 9 > s->mdata_size + 2) {\n        s->status = ERR_STAT;\n        s->error = ABRT_ERR;\n        return;\n    }\n\n    p = (uint16_t *) s->io_buffer;\n    memset(p, 0, 0x200);\n\n    put_le16(p + 0, s->media_changed);\t\t/* Media status */\n    memcpy(p + 1, s->mdata_storage + (((s->hcyl << 16) | s->lcyl) << 9),\n                    MIN(MIN(s->mdata_size - (((s->hcyl << 16) | s->lcyl) << 9),\n                                    s->nsector << 9), 0x200 - 2));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_cfata_metadata_read(IDEState *s)\n{\n    uint16_t *p;\n\n    if (((s->hcyl << 16) | s->lcyl) << 9 > s->mdata_size + 2) {\n        s->status = ERR_STAT;\n        s->error = ABRT_ERR;\n        return;\n    }\n\n    p = (uint16_t *) s->io_buffer;\n    memset(p, 0, 0x200);\n\n    put_le16(p + 0, s->media_changed);\t\t/* Media status */\n    memcpy(p + 1, s->mdata_storage + (((s->hcyl << 16) | s->lcyl) << 9),\n                    MIN(MIN(s->mdata_size - (((s->hcyl << 16) | s->lcyl) << 9),\n                                    s->nsector << 9), 0x200 - 2));\n}\n",
        "linevul": 5.361061994335614e-05,
        "sysevr": 0.4560149312019348,
        "devign": 5.216409335734307e-12
    },
    {
        "code": "static uint8_t vga_dumb_retrace(VGACommonState *s)\n{\n    return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "static uint8_t vga_dumb_retrace(VGACommonState *s)\n{\n    return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);\n}\n",
        "linevul": 4.8708170652389526e-05,
        "sysevr": 0.46391111612319946,
        "devign": 0.0008295864099636674
    },
    {
        "code": "static int xhci_submit(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    uint64_t mfindex;\n\n    DPRINTF(\"xhci_submit(slotid=%d,epid=%d)\\n\", xfer->slotid, xfer->epid);\n\n    xfer->in_xfer = epctx->type>>2;\n\n    switch(epctx->type) {\n    case ET_INTR_OUT:\n    case ET_INTR_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_intr_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    case ET_BULK_OUT:\n    case ET_BULK_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = false;\n        break;\n    case ET_ISO_OUT:\n    case ET_ISO_IN:\n        xfer->pkts = 1;\n        xfer->iso_xfer = true;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_iso_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"endpoint type\", epctx->type);\n        return -1;\n    }\n\n    if (xhci_setup_packet(xfer) < 0) {\n        return -1;\n    }\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n    xhci_try_complete_packet(xfer);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static int xhci_submit(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n{\n    uint64_t mfindex;\n\n    DPRINTF(\"xhci_submit(slotid=%d,epid=%d)\\n\", xfer->slotid, xfer->epid);\n\n    xfer->in_xfer = epctx->type>>2;\n\n    switch(epctx->type) {\n    case ET_INTR_OUT:\n    case ET_INTR_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_intr_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    case ET_BULK_OUT:\n    case ET_BULK_IN:\n        xfer->pkts = 0;\n        xfer->iso_xfer = false;\n        xfer->timed_xfer = false;\n        break;\n    case ET_ISO_OUT:\n    case ET_ISO_IN:\n        xfer->pkts = 1;\n        xfer->iso_xfer = true;\n        xfer->timed_xfer = true;\n        mfindex = xhci_mfindex_get(xhci);\n        xhci_calc_iso_kick(xhci, xfer, epctx, mfindex);\n        xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n        if (xfer->running_retry) {\n            return -1;\n        }\n        break;\n    default:\n        trace_usb_xhci_unimplemented(\"endpoint type\", epctx->type);\n        return -1;\n    }\n\n    if (xhci_setup_packet(xfer) < 0) {\n        return -1;\n    }\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n    xhci_try_complete_packet(xfer);\n    return 0;\n}\n",
        "linevul": 4.7620938858017325e-05,
        "sysevr": 0.4568060040473938,
        "devign": 0.9952934384346008
    },
    {
        "code": "static bool megasas_use_queue64(MegasasState *s)\n{\n    return s->flags & MEGASAS_MASK_USE_QUEUE64;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static bool megasas_use_queue64(MegasasState *s)\n{\n    return s->flags & MEGASAS_MASK_USE_QUEUE64;\n}\n",
        "linevul": 5.86838141316548e-05,
        "sysevr": 0.46395057439804077,
        "devign": 0.00018958523287437856
    },
    {
        "code": "static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    /* hdr_len refers to the header we supply to the guest */\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement elem;\n        int len, total;\n        const struct iovec *sg = elem.in_sg;\n\n        total = 0;\n\n        if (virtqueue_pop(q->rx_vq, &elem) == 0) {\n            if (i == 0)\n                return -1;\n            error_report(\"virtio-net unexpected empty queue: \"\n                    \"i %zd mergeable %d offset %zd, size %zd, \"\n                    \"guest hdr len %zd, host hdr len %zd guest features 0x%x\",\n                    i, n->mergeable_rx_bufs, offset, size,\n                    n->guest_hdr_len, n->host_hdr_len, vdev->guest_features);\n            exit(1);\n        }\n\n        if (elem.in_num < 1) {\n            error_report(\"virtio-net receive queue contains no in buffers\");\n            exit(1);\n        }\n\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem.in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem.in_num, buf, size);\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        /* copy in packet.  ugh */\n        len = iov_from_buf(sg, elem.in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        /* If buffers can't be merged, at this point we\n         * must have consumed the complete packet.\n         * Otherwise, drop it. */\n        if (!n->mergeable_rx_bufs && offset < size) {\n#if 0\n            error_report(\"virtio-net truncated non-mergeable packet: \"\n                         \"i %zd mergeable %d offset %zd, size %zd, \"\n                         \"guest hdr len %zd, host hdr len %zd\",\n                         i, n->mergeable_rx_bufs,\n                         offset, size, n->guest_hdr_len, n->host_hdr_len);\n#endif\n            return size;\n        }\n\n        /* signal other side */\n        virtqueue_fill(q->rx_vq, &elem, total, i++);\n    }\n\n    if (mhdr_cnt) {\n        stw_p(&mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    /* hdr_len refers to the header we supply to the guest */\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement elem;\n        int len, total;\n        const struct iovec *sg = elem.in_sg;\n\n        total = 0;\n\n        if (virtqueue_pop(q->rx_vq, &elem) == 0) {\n            if (i == 0)\n                return -1;\n            error_report(\"virtio-net unexpected empty queue: \"\n                    \"i %zd mergeable %d offset %zd, size %zd, \"\n                    \"guest hdr len %zd, host hdr len %zd guest features 0x%x\",\n                    i, n->mergeable_rx_bufs, offset, size,\n                    n->guest_hdr_len, n->host_hdr_len, vdev->guest_features);\n            exit(1);\n        }\n\n        if (elem.in_num < 1) {\n            error_report(\"virtio-net receive queue contains no in buffers\");\n            exit(1);\n        }\n\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem.in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem.in_num, buf, size);\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        /* copy in packet.  ugh */\n        len = iov_from_buf(sg, elem.in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        /* If buffers can't be merged, at this point we\n         * must have consumed the complete packet.\n         * Otherwise, drop it. */\n        if (!n->mergeable_rx_bufs && offset < size) {\n#if 0\n            error_report(\"virtio-net truncated non-mergeable packet: \"\n                         \"i %zd mergeable %d offset %zd, size %zd, \"\n                         \"guest hdr len %zd, host hdr len %zd\",\n                         i, n->mergeable_rx_bufs,\n                         offset, size, n->guest_hdr_len, n->host_hdr_len);\n#endif\n            return size;\n        }\n\n        /* signal other side */\n        virtqueue_fill(q->rx_vq, &elem, total, i++);\n    }\n\n    if (mhdr_cnt) {\n        stw_p(&mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n}\n",
        "linevul": 9.264552500098944e-05,
        "sysevr": 0.4709896743297577,
        "devign": 1.696430018682804e-08
    },
    {
        "code": "static void v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_remove(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_remove(pdu->tag, pdu->id, fid);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* if fs driver is not path based, return EOPNOTSUPP */\n    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {\n        err = -EOPNOTSUPP;\n        goto out_err;\n    }\n    /*\n     * IF the file is unlinked, we cannot reopen\n     * the file later. So don't reclaim fd\n     */\n    err = v9fs_mark_fids_unreclaim(pdu, &fidp->path);\n    if (err < 0) {\n        goto out_err;\n    }\n    err = v9fs_co_remove(pdu, &fidp->path);\n    if (!err) {\n        err = offset;\n    }\nout_err:\n    /* For TREMOVE we need to clunk the fid even on failed remove */\n    clunk_fid(pdu->s, fidp->fid);\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.0001377365697408095,
        "sysevr": 0.47319746017456055,
        "devign": 7.626079678857423e-08
    },
    {
        "code": "static ssize_t flistxattrat_nofollow(int dirfd, const char *filename,\n                                     char *list, size_t size)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = llistxattr(proc_path, list, size);\n    g_free(proc_path);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "vul_func_with_fix": "static ssize_t flistxattrat_nofollow(int dirfd, const char *filename,\n                                     char *list, size_t size)\n{\n    char *proc_path = g_strdup_printf(\"/proc/self/fd/%d/%s\", dirfd, filename);\n    int ret;\n\n    ret = llistxattr(proc_path, list, size);\n    g_free(proc_path);\n    return ret;\n}\n",
        "linevul": 5.1360158977331594e-05,
        "sysevr": 0.4734446704387665,
        "devign": 0.00109579018317163
    },
    {
        "code": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd;\n    EHCIqh qh;\n    int state;\n\n    /* Verify the qh + qtd, like we do when going through fetchqh & fetchqtd */\n    get_dwords(q->ehci, NLPTR_GET(q->qhaddr),\n               (uint32_t *) &qh, sizeof(EHCIqh) >> 2);\n    get_dwords(q->ehci, NLPTR_GET(q->qtdaddr),\n               (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2);\n    if (!ehci_verify_qh(q, &qh) || !ehci_verify_qtd(p, &qtd)) {\n        p->async = EHCI_ASYNC_INITIALIZED;\n        ehci_free_packet(p);\n        return;\n    }\n\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    }\n    ehci_set_state(q->ehci, q->async, state);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    EHCIqtd qtd;\n    EHCIqh qh;\n    int state;\n\n    /* Verify the qh + qtd, like we do when going through fetchqh & fetchqtd */\n    get_dwords(q->ehci, NLPTR_GET(q->qhaddr),\n               (uint32_t *) &qh, sizeof(EHCIqh) >> 2);\n    get_dwords(q->ehci, NLPTR_GET(q->qtdaddr),\n               (uint32_t *) &qtd, sizeof(EHCIqtd) >> 2);\n    if (!ehci_verify_qh(q, &qh) || !ehci_verify_qtd(p, &qtd)) {\n        p->async = EHCI_ASYNC_INITIALIZED;\n        ehci_free_packet(p);\n        return;\n    }\n\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    }\n    ehci_set_state(q->ehci, q->async, state);\n}\n",
        "linevul": 5.006722858524881e-05,
        "sysevr": 0.461500346660614,
        "devign": 9.676459740148857e-05
    },
    {
        "code": "static void vmxnet3_trigger_interrupt(VMXNET3State *s, int lidx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    s->interrupt_states[lidx].is_pending = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n\n    if (s->msix_used && msix_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    if (msi_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    return;\n\ndo_automask:\n    s->interrupt_states[lidx].is_masked = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_trigger_interrupt(VMXNET3State *s, int lidx)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    s->interrupt_states[lidx].is_pending = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n\n    if (s->msix_used && msix_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    if (msi_enabled(d) && s->auto_int_masking) {\n        goto do_automask;\n    }\n\n    return;\n\ndo_automask:\n    s->interrupt_states[lidx].is_masked = true;\n    vmxnet3_update_interrupt_line_state(s, lidx);\n}\n",
        "linevul": 4.610764517565258e-05,
        "sysevr": 0.4636119306087494,
        "devign": 6.6706610368783e-07
    },
    {
        "code": "static void v9fs_read(void *opaque)\n{\n    int32_t fid;\n    uint64_t off;\n    ssize_t err = 0;\n    int32_t count = 0;\n    size_t offset = 7;\n    uint32_t max_count;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_DIR) {\n\n        if (off == 0) {\n            v9fs_co_rewinddir(pdu, fidp);\n        }\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n        if (count < 0) {\n            err = count;\n            goto out;\n        }\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n    } else if (fidp->fid_type == P9_FID_FILE) {\n        QEMUIOVector qiov_full;\n        QEMUIOVector qiov;\n        int32_t len;\n\n        v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\n        qemu_iovec_init(&qiov, qiov_full.niov);\n        do {\n            qemu_iovec_reset(&qiov);\n            qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\n            if (0) {\n                print_sg(qiov.iov, qiov.niov);\n            }\n            /* Loop in case of EINTR */\n            do {\n                len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\n                if (len >= 0) {\n                    off   += len;\n                    count += len;\n                }\n            } while (len == -EINTR && !pdu->cancelled);\n             if (len < 0) {\n                 /* IO error return the error */\n                 err = len;\n                goto out;\n             }\n         } while (count < max_count && len > 0);\n         err = pdu_marshal(pdu, offset, \"d\", count);\n         if (err < 0) {\n            goto out;\n         }\n         err += offset + count;\n         qemu_iovec_destroy(&qiov);\n         qemu_iovec_destroy(&qiov_full);\n     } else if (fidp->fid_type == P9_FID_XATTR) {\n    } else {\n        err = -EINVAL;\n    }\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "vul_func_with_fix": "static void v9fs_read(void *opaque)\n{\n    int32_t fid;\n    uint64_t off;\n    ssize_t err = 0;\n    int32_t count = 0;\n    size_t offset = 7;\n    uint32_t max_count;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_DIR) {\n\n        if (off == 0) {\n            v9fs_co_rewinddir(pdu, fidp);\n        }\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n        if (count < 0) {\n            err = count;\n            goto out;\n        }\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n    } else if (fidp->fid_type == P9_FID_FILE) {\n        QEMUIOVector qiov_full;\n        QEMUIOVector qiov;\n        int32_t len;\n\n        v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\n        qemu_iovec_init(&qiov, qiov_full.niov);\n        do {\n            qemu_iovec_reset(&qiov);\n            qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\n            if (0) {\n                print_sg(qiov.iov, qiov.niov);\n            }\n            /* Loop in case of EINTR */\n            do {\n                len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\n                if (len >= 0) {\n                    off   += len;\n                    count += len;\n                }\n            } while (len == -EINTR && !pdu->cancelled);\n             if (len < 0) {\n                 /* IO error return the error */\n                 err = len;\n//flaw_line_below:\n                goto out;\n//fix_flaw_line_below:\n//                goto out_free_iovec;\n             }\n         } while (count < max_count && len > 0);\n         err = pdu_marshal(pdu, offset, \"d\", count);\n         if (err < 0) {\n//flaw_line_below:\n            goto out;\n//fix_flaw_line_below:\n//            goto out_free_iovec;\n         }\n         err += offset + count;\n//fix_flaw_line_below:\n//out_free_iovec:\n         qemu_iovec_destroy(&qiov);\n         qemu_iovec_destroy(&qiov_full);\n     } else if (fidp->fid_type == P9_FID_XATTR) {\n    } else {\n        err = -EINVAL;\n    }\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
        "linevul": 0.00014208948414307088,
        "sysevr": 0.4689009487628937,
        "devign": 0.9999973773956299
    },
    {
        "code": "static void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void ext_key_event(VncState *vs, int down,\n                          uint32_t sym, uint16_t keycode)\n{\n    /* if the user specifies a keyboard layout, always use it */\n    if (keyboard_layout) {\n        key_event(vs, down, sym);\n    } else {\n        trace_vnc_key_event_ext(down, sym, keycode, code2name(keycode));\n        do_key_event(vs, down, keycode, sym);\n    }\n}\n",
        "linevul": 4.5638735173270106e-05,
        "sysevr": 0.4733700156211853,
        "devign": 0.00023326771042775363
    },
    {
        "code": "static int megasas_handle_scsi(MegasasState *s, MegasasCmd *cmd,\n                               bool is_logical)\n{\n    uint8_t *cdb;\n    bool is_write;\n    struct SCSIDevice *sdev = NULL;\n\n    cdb = cmd->frame->pass.cdb;\n\n    if (is_logical) {\n        if (cmd->frame->header.target_id >= MFI_MAX_LD ||\n            cmd->frame->header.lun_id != 0) {\n            trace_megasas_scsi_target_not_present(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n            return MFI_STAT_DEVICE_NOT_FOUND;\n        }\n    }\n    sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id);\n\n    cmd->iov_size = le32_to_cpu(cmd->frame->header.data_len);\n    trace_megasas_handle_scsi(mfi_frame_desc[cmd->frame->header.frame_cmd],\n                              is_logical, cmd->frame->header.target_id,\n                              cmd->frame->header.lun_id, sdev, cmd->iov_size);\n\n    if (!sdev || (megasas_is_jbod(s) && is_logical)) {\n        trace_megasas_scsi_target_not_present(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id,\n                cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    if (megasas_map_sgl(s, cmd, &cmd->frame->pass.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n                mfi_frame_desc[cmd->frame->header.frame_cmd],\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    is_write = (cmd->req->cmd.mode == SCSI_XFER_TO_DEV);\n    if (cmd->iov_size) {\n        if (is_write) {\n            trace_megasas_scsi_write_start(cmd->index, cmd->iov_size);\n        } else {\n            trace_megasas_scsi_read_start(cmd->index, cmd->iov_size);\n        }\n    } else {\n        trace_megasas_scsi_nodata(cmd->index);\n    }\n    megasas_enqueue_req(cmd, is_write);\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_handle_scsi(MegasasState *s, MegasasCmd *cmd,\n                               bool is_logical)\n{\n    uint8_t *cdb;\n    bool is_write;\n    struct SCSIDevice *sdev = NULL;\n\n    cdb = cmd->frame->pass.cdb;\n\n    if (is_logical) {\n        if (cmd->frame->header.target_id >= MFI_MAX_LD ||\n            cmd->frame->header.lun_id != 0) {\n            trace_megasas_scsi_target_not_present(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n            return MFI_STAT_DEVICE_NOT_FOUND;\n        }\n    }\n    sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id);\n\n    cmd->iov_size = le32_to_cpu(cmd->frame->header.data_len);\n    trace_megasas_handle_scsi(mfi_frame_desc[cmd->frame->header.frame_cmd],\n                              is_logical, cmd->frame->header.target_id,\n                              cmd->frame->header.lun_id, sdev, cmd->iov_size);\n\n    if (!sdev || (megasas_is_jbod(s) && is_logical)) {\n        trace_megasas_scsi_target_not_present(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n                mfi_frame_desc[cmd->frame->header.frame_cmd], is_logical,\n                cmd->frame->header.target_id, cmd->frame->header.lun_id,\n                cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    if (megasas_map_sgl(s, cmd, &cmd->frame->pass.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n                mfi_frame_desc[cmd->frame->header.frame_cmd],\n                cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    is_write = (cmd->req->cmd.mode == SCSI_XFER_TO_DEV);\n    if (cmd->iov_size) {\n        if (is_write) {\n            trace_megasas_scsi_write_start(cmd->index, cmd->iov_size);\n        } else {\n            trace_megasas_scsi_read_start(cmd->index, cmd->iov_size);\n        }\n    } else {\n        trace_megasas_scsi_nodata(cmd->index);\n    }\n    megasas_enqueue_req(cmd, is_write);\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "linevul": 5.757237886427902e-05,
        "sysevr": 0.4718343913555145,
        "devign": 0.05031930282711983
    },
    {
        "code": "static void ide_issue_trim_cb(void *opaque, int ret)\n{\n    TrimAIOCB *iocb = opaque;\n    if (ret >= 0) {\n        while (iocb->j < iocb->qiov->niov) {\n            int j = iocb->j;\n            while (++iocb->i < iocb->qiov->iov[j].iov_len / 8) {\n                int i = iocb->i;\n                uint64_t *buffer = iocb->qiov->iov[j].iov_base;\n\n                /* 6-byte LBA + 2-byte range per entry */\n                uint64_t entry = le64_to_cpu(buffer[i]);\n                uint64_t sector = entry & 0x0000ffffffffffffULL;\n                uint16_t count = entry >> 48;\n\n                if (count == 0) {\n                    continue;\n                }\n\n                /* Got an entry! Submit and exit.  */\n                iocb->aiocb = blk_aio_discard(iocb->blk, sector, count,\n                                              ide_issue_trim_cb, opaque);\n                return;\n            }\n\n            iocb->j++;\n            iocb->i = -1;\n        }\n    } else {\n        iocb->ret = ret;\n    }\n\n    iocb->aiocb = NULL;\n    if (iocb->bh) {\n        qemu_bh_schedule(iocb->bh);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ide_issue_trim_cb(void *opaque, int ret)\n{\n    TrimAIOCB *iocb = opaque;\n    if (ret >= 0) {\n        while (iocb->j < iocb->qiov->niov) {\n            int j = iocb->j;\n            while (++iocb->i < iocb->qiov->iov[j].iov_len / 8) {\n                int i = iocb->i;\n                uint64_t *buffer = iocb->qiov->iov[j].iov_base;\n\n                /* 6-byte LBA + 2-byte range per entry */\n                uint64_t entry = le64_to_cpu(buffer[i]);\n                uint64_t sector = entry & 0x0000ffffffffffffULL;\n                uint16_t count = entry >> 48;\n\n                if (count == 0) {\n                    continue;\n                }\n\n                /* Got an entry! Submit and exit.  */\n                iocb->aiocb = blk_aio_discard(iocb->blk, sector, count,\n                                              ide_issue_trim_cb, opaque);\n                return;\n            }\n\n            iocb->j++;\n            iocb->i = -1;\n        }\n    } else {\n        iocb->ret = ret;\n    }\n\n    iocb->aiocb = NULL;\n    if (iocb->bh) {\n        qemu_bh_schedule(iocb->bh);\n    }\n}\n",
        "linevul": 5.1975850510643795e-05,
        "sysevr": 0.4703642725944519,
        "devign": 1.0200496944889892e-05
    },
    {
        "code": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    bool start = req->cmd.buf[4] & 1;\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n        if (!start && !s->tray_open && s->tray_locked) {\n            scsi_check_condition(r,\n                                 bdrv_is_inserted(s->bs)\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n            return -1;\n        }\n        bdrv_eject(s->bs, !start);\n        s->tray_open = !start;\n    }\n     return 0;\n }\n",
        "label": "0",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n{\n    SCSIRequest *req = &r->req;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    bool start = req->cmd.buf[4] & 1;\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n        if (!start && !s->tray_open && s->tray_locked) {\n            scsi_check_condition(r,\n                                 bdrv_is_inserted(s->bs)\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n            return -1;\n        }\n        bdrv_eject(s->bs, !start);\n        s->tray_open = !start;\n    }\n     return 0;\n }\n",
        "linevul": 4.698911652667448e-05,
        "sysevr": 0.4525092840194702,
        "devign": 6.083162738921627e-19
    },
    {
        "code": "static int32_t coroutine_fn get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int32_t coroutine_fn get_iounit(V9fsPDU *pdu, V9fsPath *path)\n{\n    struct statfs stbuf;\n    int32_t iounit = 0;\n    V9fsState *s = pdu->s;\n\n    /*\n     * iounit should be multiples of f_bsize (host filesystem block size\n     * and as well as less than (client msize - P9_IOHDRSZ))\n     */\n    if (!v9fs_co_statfs(pdu, path, &stbuf)) {\n        iounit = stbuf.f_bsize;\n        iounit *= (s->msize - P9_IOHDRSZ)/stbuf.f_bsize;\n    }\n    if (!iounit) {\n        iounit = s->msize - P9_IOHDRSZ;\n    }\n    return iounit;\n}\n",
        "linevul": 6.724969716742635e-05,
        "sysevr": 0.45826026797294617,
        "devign": 0.5749273300170898
    },
    {
        "code": "pvscsi_send_msg(PVSCSIState *s, SCSIDevice *dev, uint32_t msg_type)\n{\n    if (s->msg_ring_info_valid && pvscsi_ring_msg_has_room(&s->rings)) {\n        PVSCSIMsgDescDevStatusChanged msg = {0};\n\n        msg.type = msg_type;\n        msg.bus = dev->channel;\n        msg.target = dev->id;\n        msg.lun[1] = dev->lun;\n\n        pvscsi_msg_ring_put(s, (PVSCSIRingMsgDesc *)&msg);\n        pvscsi_ring_flush_msg(&s->rings);\n        pvscsi_raise_message_interrupt(s);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d251157ac1928191af851d199a9ff255d330bec9",
        "vul_func_with_fix": "pvscsi_send_msg(PVSCSIState *s, SCSIDevice *dev, uint32_t msg_type)\n{\n    if (s->msg_ring_info_valid && pvscsi_ring_msg_has_room(&s->rings)) {\n        PVSCSIMsgDescDevStatusChanged msg = {0};\n\n        msg.type = msg_type;\n        msg.bus = dev->channel;\n        msg.target = dev->id;\n        msg.lun[1] = dev->lun;\n\n        pvscsi_msg_ring_put(s, (PVSCSIRingMsgDesc *)&msg);\n        pvscsi_ring_flush_msg(&s->rings);\n        pvscsi_raise_message_interrupt(s);\n    }\n}\n",
        "linevul": 4.721271398011595e-05,
        "sysevr": 0.4503715932369232,
        "devign": 5.13082718672786e-12
    },
    {
        "code": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(s, fs_path->data, O_RDONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = fstatfs(fd, stbuf);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "vul_func_with_fix": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n{\n    int fd, ret;\n\n    fd = local_open_nofollow(s, fs_path->data, O_RDONLY, 0);\n    if (fd == -1) {\n        return -1;\n    }\n    ret = fstatfs(fd, stbuf);\n    close_preserve_errno(fd);\n    return ret;\n}\n",
        "linevul": 5.154248356120661e-05,
        "sysevr": 0.47829923033714294,
        "devign": 0.004978231620043516
    },
    {
        "code": "static uint64_t ehci_port_read(void *ptr, hwaddr addr,\n                               unsigned size)\n{\n    EHCIState *s = ptr;\n    uint32_t val;\n\n    val = s->portsc[addr >> 2];\n    trace_usb_ehci_portsc_read(addr + s->portscbase, addr >> 2, val);\n    return val;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static uint64_t ehci_port_read(void *ptr, hwaddr addr,\n                               unsigned size)\n{\n    EHCIState *s = ptr;\n    uint32_t val;\n\n    val = s->portsc[addr >> 2];\n    trace_usb_ehci_portsc_read(addr + s->portscbase, addr >> 2, val);\n    return val;\n}\n",
        "linevul": 5.220097227720544e-05,
        "sysevr": 0.4619758427143097,
        "devign": 8.990063693481432e-10
    },
    {
        "code": "static int proxy_fsync(FsContext *ctx, int fid_type,\n                       V9fsFidOpenState *fs, int datasync)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n\n    if (datasync) {\n        return qemu_fdatasync(fd);\n    } else {\n        return fsync(fd);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=898ae90a44551d25b8e956fd87372d303c82fe68",
        "vul_func_with_fix": "static int proxy_fsync(FsContext *ctx, int fid_type,\n                       V9fsFidOpenState *fs, int datasync)\n{\n    int fd;\n\n    if (fid_type == P9_FID_DIR) {\n        fd = dirfd(fs->dir.stream);\n    } else {\n        fd = fs->fd;\n    }\n\n    if (datasync) {\n        return qemu_fdatasync(fd);\n    } else {\n        return fsync(fd);\n    }\n}\n",
        "linevul": 4.85314303659834e-05,
        "sysevr": 0.4762423038482666,
        "devign": 9.988735109800473e-05
    },
    {
        "code": "static void cirrus_vga_write_palette(CirrusVGAState * s, int reg_value)\n{\n    s->vga.dac_cache[s->vga.dac_sub_index] = reg_value;\n    if (++s->vga.dac_sub_index == 3) {\n        if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {\n            memcpy(&s->cirrus_hidden_palette[(s->vga.dac_write_index & 0x0f) * 3],\n                   s->vga.dac_cache, 3);\n        } else {\n            memcpy(&s->vga.palette[s->vga.dac_write_index * 3], s->vga.dac_cache, 3);\n        }\n        /* XXX update cursor */\n\ts->vga.dac_sub_index = 0;\n\ts->vga.dac_write_index++;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static void cirrus_vga_write_palette(CirrusVGAState * s, int reg_value)\n{\n    s->vga.dac_cache[s->vga.dac_sub_index] = reg_value;\n    if (++s->vga.dac_sub_index == 3) {\n        if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {\n            memcpy(&s->cirrus_hidden_palette[(s->vga.dac_write_index & 0x0f) * 3],\n                   s->vga.dac_cache, 3);\n        } else {\n            memcpy(&s->vga.palette[s->vga.dac_write_index * 3], s->vga.dac_cache, 3);\n        }\n        /* XXX update cursor */\n\ts->vga.dac_sub_index = 0;\n\ts->vga.dac_write_index++;\n    }\n}\n",
        "linevul": 4.657155659515411e-05,
        "sysevr": 0.4709678590297699,
        "devign": 1.9213231798957044e-17
    },
    {
        "code": "int64_t xbzrle_cache_resize(int64_t new_size)\n{\n    PageCache *new_cache;\n    int64_t ret;\n\n    if (new_size < TARGET_PAGE_SIZE) {\n        return -1;\n    }\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache != NULL) {\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n            goto out_new_size;\n        }\n        new_cache = cache_init(new_size / TARGET_PAGE_SIZE,\n                                        TARGET_PAGE_SIZE);\n        if (!new_cache) {\n            error_report(\"Error creating cache\");\n            ret = -1;\n            goto out;\n        }\n\n        cache_fini(XBZRLE.cache);\n        XBZRLE.cache = new_cache;\n    }\n\nout_new_size:\n    ret = pow2floor(new_size);\nout:\n    XBZRLE_cache_unlock();\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "int64_t xbzrle_cache_resize(int64_t new_size)\n{\n    PageCache *new_cache;\n    int64_t ret;\n\n    if (new_size < TARGET_PAGE_SIZE) {\n        return -1;\n    }\n\n    XBZRLE_cache_lock();\n\n    if (XBZRLE.cache != NULL) {\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n            goto out_new_size;\n        }\n        new_cache = cache_init(new_size / TARGET_PAGE_SIZE,\n                                        TARGET_PAGE_SIZE);\n        if (!new_cache) {\n            error_report(\"Error creating cache\");\n            ret = -1;\n            goto out;\n        }\n\n        cache_fini(XBZRLE.cache);\n        XBZRLE.cache = new_cache;\n    }\n\nout_new_size:\n    ret = pow2floor(new_size);\nout:\n    XBZRLE_cache_unlock();\n    return ret;\n}\n",
        "linevul": 0.0002333522425033152,
        "sysevr": 0.4539858400821686,
        "devign": 2.3551399408461293e-06
    },
    {
        "code": " static void v9fs_walk(void *opaque)\n {\n     int name_idx;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n     V9fsFidState *newfidp = NULL;\n     V9fsPDU *pdu = opaque;\n     V9fsState *s = pdu->s;\n \n     err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n     if (err < 0) {\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n         err = -ENOENT;\n         goto out_nofid;\n     }\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=56f101ecce0eafd09e2daf1c4eeb1377d6959261",
        "vul_func_with_fix": " static void v9fs_walk(void *opaque)\n {\n     int name_idx;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n     V9fsFidState *newfidp = NULL;\n     V9fsPDU *pdu = opaque;\n     V9fsState *s = pdu->s;\n//fix_flaw_line_below:\n//    V9fsQID qid;\n \n     err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n     if (err < 0) {\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n         err = -ENOENT;\n         goto out_nofid;\n     }\n",
        "linevul": 0.9984464049339294,
        "sysevr": 0.4726060926914215,
        "devign": 0.9999984502792358
    },
    {
        "code": "static void vapic_reset(DeviceState *dev)\n{\n    VAPICROMState *s = VAPIC(dev);\n\n    s->state = VAPIC_INACTIVE;\n    s->rom_state_paddr = 0;\n    vapic_enable_tpr_reporting(false);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=691a02e2ce0c413236a78dee6f2651c937b09fb0",
        "vul_func_with_fix": "static void vapic_reset(DeviceState *dev)\n{\n    VAPICROMState *s = VAPIC(dev);\n\n    s->state = VAPIC_INACTIVE;\n    s->rom_state_paddr = 0;\n    vapic_enable_tpr_reporting(false);\n}\n",
        "linevul": 4.810227619600482e-05,
        "sysevr": 0.4636697769165039,
        "devign": 2.7123801373818424e-06
    },
    {
        "code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n {\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n     SCSIRequest *req;\n    SCSIDiskReq *r;\n \n     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n     return req;\n }\n",
        "label": "1",
        "addr": "https://github.com/bonzini/qemu/commit/7285477ab11831b1cf56e45878a89170dd06d9b9",
        "vul_func_with_fix": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n {\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n     SCSIRequest *req;\n//flaw_line_below:\n    SCSIDiskReq *r;\n \n     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n//flaw_line_below:\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n//flaw_line_below:\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n     return req;\n }\n",
        "linevul": 0.99899822473526,
        "sysevr": 0.46339356899261475,
        "devign": 0.9980809688568115
    },
    {
        "code": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n    to_device = (s->ti_size < 0);\n    len = s->dma_left;\n    if (s->do_cmd) {\n        trace_esp_do_dma(s->cmdlen, len);\n        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n        s->ti_size = 0;\n        s->cmdlen = 0;\n        s->do_cmd = 0;\n        do_cmd(s, s->cmdbuf);\n        return;\n    }\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n    if (len > s->async_len) {\n        len = s->async_len;\n    }\n    if (to_device) {\n        s->dma_memory_read(s->dma_opaque, s->async_buf, len);\n    } else {\n        s->dma_memory_write(s->dma_opaque, s->async_buf, len);\n    }\n    s->dma_left -= len;\n    s->async_buf += len;\n    s->async_len -= len;\n    if (to_device)\n        s->ti_size += len;\n    else\n        s->ti_size -= len;\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        /* If there is still data to be read from the device then\n           complete the DMA operation immediately.  Otherwise defer\n           until the scsi layer has completed.  */\n        if (to_device || s->dma_left != 0 || s->ti_size == 0) {\n            return;\n        }\n    }\n\n    /* Partially filled a scsi buffer. Complete immediately.  */\n    esp_dma_done(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ff589551c8e8e9e95e211b9d8daafb4ed39f1aec",
        "vul_func_with_fix": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n\n    to_device = (s->ti_size < 0);\n    len = s->dma_left;\n    if (s->do_cmd) {\n        trace_esp_do_dma(s->cmdlen, len);\n        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n        s->ti_size = 0;\n        s->cmdlen = 0;\n        s->do_cmd = 0;\n        do_cmd(s, s->cmdbuf);\n        return;\n    }\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n    if (len > s->async_len) {\n        len = s->async_len;\n    }\n    if (to_device) {\n        s->dma_memory_read(s->dma_opaque, s->async_buf, len);\n    } else {\n        s->dma_memory_write(s->dma_opaque, s->async_buf, len);\n    }\n    s->dma_left -= len;\n    s->async_buf += len;\n    s->async_len -= len;\n    if (to_device)\n        s->ti_size += len;\n    else\n        s->ti_size -= len;\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        /* If there is still data to be read from the device then\n           complete the DMA operation immediately.  Otherwise defer\n           until the scsi layer has completed.  */\n        if (to_device || s->dma_left != 0 || s->ti_size == 0) {\n            return;\n        }\n    }\n\n    /* Partially filled a scsi buffer. Complete immediately.  */\n    esp_dma_done(s);\n}\n",
        "linevul": 0.09847528487443924,
        "sysevr": 0.47117534279823303,
        "devign": 8.743985381443053e-05
    },
    {
        "code": "static void esp_soft_reset(ESPState *s)\n{\n    qemu_irq_lower(s->irq);\n    esp_hard_reset(s);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "static void esp_soft_reset(ESPState *s)\n{\n    qemu_irq_lower(s->irq);\n    esp_hard_reset(s);\n}\n",
        "linevul": 4.842634734814055e-05,
        "sysevr": 0.4696255922317505,
        "devign": 0.0006014030077494681
    },
    {
        "code": "static uint64_t xhci_doorbell_read(void *ptr, hwaddr reg,\n                                   unsigned size)\n{\n    /* doorbells always read as 0 */\n    trace_usb_xhci_doorbell_read(reg, 0);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static uint64_t xhci_doorbell_read(void *ptr, hwaddr reg,\n                                   unsigned size)\n{\n    /* doorbells always read as 0 */\n    trace_usb_xhci_doorbell_read(reg, 0);\n    return 0;\n}\n",
        "linevul": 5.2839546697214246e-05,
        "sysevr": 0.46476683020591736,
        "devign": 0.0005556822288781404
    },
    {
        "code": "static void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void audio_capture(void *opaque, void *buf, int size)\n{\n    VncState *vs = opaque;\n\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n    vnc_write_u32(vs, size);\n    vnc_write(vs, buf, size);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n",
        "linevul": 4.5371467422228307e-05,
        "sysevr": 0.480170875787735,
        "devign": 0.00022091701976023614
    },
    {
        "code": "int nbd_client(int fd)\n{\n    int ret;\n    int serrno;\n\n    TRACE(\"Doing NBD loop\");\n\n    ret = ioctl(fd, NBD_DO_IT);\n    if (ret < 0 && errno == EPIPE) {\n        /* NBD_DO_IT normally returns EPIPE when someone has disconnected\n         * the socket via NBD_DISCONNECT.  We do not want to return 1 in\n         * that case.\n         */\n        ret = 0;\n    }\n    serrno = errno;\n\n    TRACE(\"NBD loop returned %d: %s\", ret, strerror(serrno));\n\n    TRACE(\"Clearing NBD queue\");\n    ioctl(fd, NBD_CLEAR_QUE);\n\n    TRACE(\"Clearing NBD socket\");\n    ioctl(fd, NBD_CLEAR_SOCK);\n\n    errno = serrno;\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=ff82911cd3f69f028f2537825c9720ff78bc3f19",
        "vul_func_with_fix": "int nbd_client(int fd)\n{\n    int ret;\n    int serrno;\n\n    TRACE(\"Doing NBD loop\");\n\n    ret = ioctl(fd, NBD_DO_IT);\n    if (ret < 0 && errno == EPIPE) {\n        /* NBD_DO_IT normally returns EPIPE when someone has disconnected\n         * the socket via NBD_DISCONNECT.  We do not want to return 1 in\n         * that case.\n         */\n        ret = 0;\n    }\n    serrno = errno;\n\n    TRACE(\"NBD loop returned %d: %s\", ret, strerror(serrno));\n\n    TRACE(\"Clearing NBD queue\");\n    ioctl(fd, NBD_CLEAR_QUE);\n\n    TRACE(\"Clearing NBD socket\");\n    ioctl(fd, NBD_CLEAR_SOCK);\n\n    errno = serrno;\n    return ret;\n}\n",
        "linevul": 5.282120400806889e-05,
        "sysevr": 0.4757201671600342,
        "devign": 2.161227030228474e-06
    },
    {
        "code": "static bool esp_mem_accepts(void *opaque, hwaddr addr,\n                            unsigned size, bool is_write)\n{\n    return (size == 1) || (is_write && size == 4);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=cc96677469388bad3d66479379735cf75db069e3",
        "vul_func_with_fix": "static bool esp_mem_accepts(void *opaque, hwaddr addr,\n                            unsigned size, bool is_write)\n{\n    return (size == 1) || (is_write && size == 4);\n}\n",
        "linevul": 4.991409878130071e-05,
        "sysevr": 0.46280115842819214,
        "devign": 0.0004733899550046772
    },
    {
        "code": "static void gen_op_update2_cc(void)\n{\n    tcg_gen_mov_tl(cpu_cc_src, cpu_T1);\n    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_op_update2_cc(void)\n{\n    tcg_gen_mov_tl(cpu_cc_src, cpu_T1);\n    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n}\n",
        "linevul": 6.33067247690633e-05,
        "sysevr": 0.4696255922317505,
        "devign": 0.0007507369737140834
    },
    {
        "code": "static void ahci_write_fis_sdb(AHCIState *s, int port, uint32_t finished)\n{\n    AHCIDevice *ad = &s->dev[port];\n    AHCIPortRegs *pr = &ad->port_regs;\n    IDEState *ide_state;\n    SDBFIS *sdb_fis;\n\n    if (!s->dev[port].res_fis ||\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n\n    sdb_fis = (SDBFIS *)&ad->res_fis[RES_FIS_SDBFIS];\n    ide_state = &ad->port.ifs[0];\n\n    sdb_fis->type = 0xA1;\n    /* Interrupt pending & Notification bit */\n    sdb_fis->flags = (ad->hba->control_regs.irqstatus ? (1 << 6) : 0);\n    sdb_fis->status = ide_state->status & 0x77;\n    sdb_fis->error = ide_state->error;\n    /* update SAct field in SDB_FIS */\n    s->dev[port].finished |= finished;\n    sdb_fis->payload = cpu_to_le32(ad->finished);\n\n    /* Update shadow registers (except BSY 0x80 and DRQ 0x08) */\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        (ad->port.ifs[0].status & 0x77) |\n        (pr->tfdata & 0x88);\n\n    ahci_trigger_irq(s, ad, PORT_IRQ_SDB_FIS);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ahci_write_fis_sdb(AHCIState *s, int port, uint32_t finished)\n{\n    AHCIDevice *ad = &s->dev[port];\n    AHCIPortRegs *pr = &ad->port_regs;\n    IDEState *ide_state;\n    SDBFIS *sdb_fis;\n\n    if (!s->dev[port].res_fis ||\n        !(pr->cmd & PORT_CMD_FIS_RX)) {\n        return;\n    }\n\n    sdb_fis = (SDBFIS *)&ad->res_fis[RES_FIS_SDBFIS];\n    ide_state = &ad->port.ifs[0];\n\n    sdb_fis->type = 0xA1;\n    /* Interrupt pending & Notification bit */\n    sdb_fis->flags = (ad->hba->control_regs.irqstatus ? (1 << 6) : 0);\n    sdb_fis->status = ide_state->status & 0x77;\n    sdb_fis->error = ide_state->error;\n    /* update SAct field in SDB_FIS */\n    s->dev[port].finished |= finished;\n    sdb_fis->payload = cpu_to_le32(ad->finished);\n\n    /* Update shadow registers (except BSY 0x80 and DRQ 0x08) */\n    pr->tfdata = (ad->port.ifs[0].error << 8) |\n        (ad->port.ifs[0].status & 0x77) |\n        (pr->tfdata & 0x88);\n\n    ahci_trigger_irq(s, ad, PORT_IRQ_SDB_FIS);\n}\n",
        "linevul": 5.850176603416912e-05,
        "sysevr": 0.4671477675437927,
        "devign": 2.3997688534146792e-14
    },
    {
        "code": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_vq(vq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_vq(vq);\n    }\n}\n",
        "linevul": 5.146821786183864e-05,
        "sysevr": 0.46562692523002625,
        "devign": 0.006856178864836693
    },
    {
        "code": "static void lsi_request_cancelled(SCSIRequest *req)\n{\n    LSIState *s = LSI53C895A(req->bus->qbus.parent);\n    lsi_request *p = req->hba_private;\n\n    req->hba_private = NULL;\n    lsi_request_free(s, p);\n    scsi_req_unref(req);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=de594e47659029316bbf9391efb79da0a1a08e08",
        "vul_func_with_fix": "static void lsi_request_cancelled(SCSIRequest *req)\n{\n    LSIState *s = LSI53C895A(req->bus->qbus.parent);\n    lsi_request *p = req->hba_private;\n\n    req->hba_private = NULL;\n    lsi_request_free(s, p);\n    scsi_req_unref(req);\n}\n",
        "linevul": 4.77922658319585e-05,
        "sysevr": 0.46301695704460144,
        "devign": 0.04040371626615524
    },
    {
        "code": "static void usb_net_handle_data(USBDevice *dev, USBPacket *p)\n{\n    USBNetState *s = (USBNetState *) dev;\n\n    switch(p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->ep->nr) {\n        case 1:\n            usb_net_handle_statusin(s, p);\n            break;\n\n        case 2:\n            usb_net_handle_datain(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    case USB_TOKEN_OUT:\n        switch (p->ep->nr) {\n        case 2:\n            usb_net_handle_dataout(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    default:\n    fail:\n        p->status = USB_RET_STALL;\n        break;\n    }\n\n    if (p->status == USB_RET_STALL) {\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n                        p->pid, p->ep->nr, p->iov.size);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=80eecda8e5d09c442c24307f340840a5b70ea3b9",
        "vul_func_with_fix": "static void usb_net_handle_data(USBDevice *dev, USBPacket *p)\n{\n    USBNetState *s = (USBNetState *) dev;\n\n    switch(p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->ep->nr) {\n        case 1:\n            usb_net_handle_statusin(s, p);\n            break;\n\n        case 2:\n            usb_net_handle_datain(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    case USB_TOKEN_OUT:\n        switch (p->ep->nr) {\n        case 2:\n            usb_net_handle_dataout(s, p);\n            break;\n\n        default:\n            goto fail;\n        }\n        break;\n\n    default:\n    fail:\n        p->status = USB_RET_STALL;\n        break;\n    }\n\n    if (p->status == USB_RET_STALL) {\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n                        p->pid, p->ep->nr, p->iov.size);\n    }\n}\n",
        "linevul": 8.648396760690957e-05,
        "sysevr": 0.46132126450538635,
        "devign": 1.408972548233578e-05
    },
    {
        "code": "void virtio_queue_invalidate_signalled_used(VirtIODevice *vdev, int n)\n{\n    vdev->vq[n].signalled_used_valid = false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1e7aed70144b4673fc26e73062064b6724795e5f",
        "vul_func_with_fix": "void virtio_queue_invalidate_signalled_used(VirtIODevice *vdev, int n)\n{\n    vdev->vq[n].signalled_used_valid = false;\n}\n",
        "linevul": 4.733249079436064e-05,
        "sysevr": 0.47149458527565,
        "devign": 0.00010835755529114977
    },
    {
        "code": "static coroutine_fn int qcow2_co_discard(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_discard_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors, QCOW2_DISCARD_REQUEST);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=11b128f4062dd7f89b14abc8877ff20d41b28be9",
        "vul_func_with_fix": "static coroutine_fn int qcow2_co_discard(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_discard_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors, QCOW2_DISCARD_REQUEST);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n",
        "linevul": 5.0040493078995496e-05,
        "sysevr": 0.48214808106422424,
        "devign": 0.5727599859237671
    },
    {
        "code": "static void pmac_ide_writew (void *opaque,\n                             hwaddr addr, uint32_t val)\n{\n    MACIOIDEState *d = opaque;\n\n    addr = (addr & 0xFFF) >> 4;\n    val = bswap16(val);\n    if (addr == 0) {\n        ide_data_writew(&d->bus, 0, val);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void pmac_ide_writew (void *opaque,\n                             hwaddr addr, uint32_t val)\n{\n    MACIOIDEState *d = opaque;\n\n    addr = (addr & 0xFFF) >> 4;\n    val = bswap16(val);\n    if (addr == 0) {\n        ide_data_writew(&d->bus, 0, val);\n    }\n}\n",
        "linevul": 4.964825711795129e-05,
        "sysevr": 0.46263566613197327,
        "devign": 5.404999114944076e-07
    },
    {
        "code": "e1000e_intrmgr_pause(E1000ECore *core)\n{\n    int i;\n\n    e1000e_intmgr_timer_pause(&core->radv);\n    e1000e_intmgr_timer_pause(&core->rdtr);\n    e1000e_intmgr_timer_pause(&core->raid);\n    e1000e_intmgr_timer_pause(&core->tidv);\n    e1000e_intmgr_timer_pause(&core->tadv);\n\n    e1000e_intmgr_timer_pause(&core->itr);\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        e1000e_intmgr_timer_pause(&core->eitr[i]);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=4154c7e03fa55b4cf52509a83d50d6c09d743b7",
        "vul_func_with_fix": "e1000e_intrmgr_pause(E1000ECore *core)\n{\n    int i;\n\n    e1000e_intmgr_timer_pause(&core->radv);\n    e1000e_intmgr_timer_pause(&core->rdtr);\n    e1000e_intmgr_timer_pause(&core->raid);\n    e1000e_intmgr_timer_pause(&core->tidv);\n    e1000e_intmgr_timer_pause(&core->tadv);\n\n    e1000e_intmgr_timer_pause(&core->itr);\n\n    for (i = 0; i < E1000E_MSIX_VEC_NUM; i++) {\n        e1000e_intmgr_timer_pause(&core->eitr[i]);\n    }\n}\n",
        "linevul": 4.613949204212986e-05,
        "sysevr": 0.46887537837028503,
        "devign": 0.00033406418515369296
    },
    {
        "code": "static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)\n{\n    BusChild *kid, *next;\n    int slot = ffs(slots) - 1;\n    PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);\n\n    if (!bus) {\n        return;\n    }\n\n    /* Mark request as complete */\n    s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);\n    s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);\n\n    QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {\n        DeviceState *qdev = kid->child;\n        PCIDevice *dev = PCI_DEVICE(qdev);\n        if (PCI_SLOT(dev->devfn) == slot) {\n            if (!acpi_pcihp_pc_no_hotplug(s, dev)) {\n                object_unparent(OBJECT(qdev));\n            }\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fa365d7cd11185237471823a5a33d36765454e16",
        "vul_func_with_fix": "static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)\n{\n    BusChild *kid, *next;\n    int slot = ffs(slots) - 1;\n    PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);\n\n    if (!bus) {\n        return;\n    }\n\n    /* Mark request as complete */\n    s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);\n    s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);\n\n    QTAILQ_FOREACH_SAFE(kid, &bus->qbus.children, sibling, next) {\n        DeviceState *qdev = kid->child;\n        PCIDevice *dev = PCI_DEVICE(qdev);\n        if (PCI_SLOT(dev->devfn) == slot) {\n            if (!acpi_pcihp_pc_no_hotplug(s, dev)) {\n                object_unparent(OBJECT(qdev));\n            }\n        }\n    }\n}\n",
        "linevul": 4.9339203542331234e-05,
        "sysevr": 0.4671943783760071,
        "devign": 9.09954621874931e-07
    },
    {
        "code": "static uint64_t pxa2xx_cppmnc_read(CPUARMState *env, const ARMCPRegInfo *ri)\n{\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n    return s->pmnc;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=caa881abe0e01f9931125a0977ec33c5343e4aa7",
        "vul_func_with_fix": "static uint64_t pxa2xx_cppmnc_read(CPUARMState *env, const ARMCPRegInfo *ri)\n{\n    PXA2xxState *s = (PXA2xxState *)ri->opaque;\n    return s->pmnc;\n}\n",
        "linevul": 5.397298446041532e-05,
        "sysevr": 0.46686771512031555,
        "devign": 0.010717210359871387
    },
    {
        "code": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n    /* destroy msix memory region */\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        msix_uninit(dev, &xhci->mem, &xhci->mem);\n    }\n\n    usb_bus_release(&xhci->bus);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n    /* destroy msix memory region */\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        msix_uninit(dev, &xhci->mem, &xhci->mem);\n    }\n\n    usb_bus_release(&xhci->bus);\n}\n",
        "linevul": 5.195845733396709e-05,
        "sysevr": 0.4634655714035034,
        "devign": 0.0002242153132101521
    },
    {
        "code": "static int ehci_qh_do_overlay(EHCIQueue *q)\n{\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n    int i;\n    int dtoggle;\n    int ping;\n    int eps;\n    int reload;\n\n    assert(p != NULL);\n    assert(p->qtdaddr == q->qtdaddr);\n\n\n    dtoggle = q->qh.token & QTD_TOKEN_DTOGGLE;\n    ping    = q->qh.token & QTD_TOKEN_PING;\n\n    q->qh.current_qtd = p->qtdaddr;\n    q->qh.next_qtd    = p->qtd.next;\n    q->qh.altnext_qtd = p->qtd.altnext;\n    q->qh.token       = p->qtd.token;\n\n\n    eps = get_field(q->qh.epchar, QH_EPCHAR_EPS);\n    if (eps == EHCI_QH_EPS_HIGH) {\n        q->qh.token &= ~QTD_TOKEN_PING;\n        q->qh.token |= ping;\n    }\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n    set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    for (i = 0; i < 5; i++) {\n        q->qh.bufptr[i] = p->qtd.bufptr[i];\n    }\n\n    if (!(q->qh.epchar & QH_EPCHAR_DTC)) {\n        q->qh.token &= ~QTD_TOKEN_DTOGGLE;\n        q->qh.token |= dtoggle;\n    }\n\n    q->qh.bufptr[1] &= ~BUFPTR_CPROGMASK_MASK;\n    q->qh.bufptr[2] &= ~BUFPTR_FRAMETAG_MASK;\n\n    ehci_flush_qh(q);\n\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=d710e1e7bd3d5bfc26b631f02ae87901ebe646b0",
        "vul_func_with_fix": "static int ehci_qh_do_overlay(EHCIQueue *q)\n{\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n    int i;\n    int dtoggle;\n    int ping;\n    int eps;\n    int reload;\n\n    assert(p != NULL);\n    assert(p->qtdaddr == q->qtdaddr);\n\n    // remember values in fields to preserve in qh after overlay\n\n    dtoggle = q->qh.token & QTD_TOKEN_DTOGGLE;\n    ping    = q->qh.token & QTD_TOKEN_PING;\n\n    q->qh.current_qtd = p->qtdaddr;\n    q->qh.next_qtd    = p->qtd.next;\n    q->qh.altnext_qtd = p->qtd.altnext;\n    q->qh.token       = p->qtd.token;\n\n\n    eps = get_field(q->qh.epchar, QH_EPCHAR_EPS);\n    if (eps == EHCI_QH_EPS_HIGH) {\n        q->qh.token &= ~QTD_TOKEN_PING;\n        q->qh.token |= ping;\n    }\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n    set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    for (i = 0; i < 5; i++) {\n        q->qh.bufptr[i] = p->qtd.bufptr[i];\n    }\n\n    if (!(q->qh.epchar & QH_EPCHAR_DTC)) {\n        // preserve QH DT bit\n        q->qh.token &= ~QTD_TOKEN_DTOGGLE;\n        q->qh.token |= dtoggle;\n    }\n\n    q->qh.bufptr[1] &= ~BUFPTR_CPROGMASK_MASK;\n    q->qh.bufptr[2] &= ~BUFPTR_FRAMETAG_MASK;\n\n    ehci_flush_qh(q);\n\n    return 0;\n}\n",
        "linevul": 8.517022797605023e-05,
        "sysevr": 0.4746527373790741,
        "devign": 1.6174354078302144e-09
    },
    {
        "code": "vmxnet3_is_allowed_mcast_group(VMXNET3State *s, const uint8_t *group_mac)\n{\n    int i;\n    for (i = 0; i < s->mcast_list_len; i++) {\n        if (!memcmp(group_mac, s->mcast_list[i].a, sizeof(s->mcast_list[i]))) {\n            return true;\n        }\n    }\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "vmxnet3_is_allowed_mcast_group(VMXNET3State *s, const uint8_t *group_mac)\n{\n    int i;\n    for (i = 0; i < s->mcast_list_len; i++) {\n        if (!memcmp(group_mac, s->mcast_list[i].a, sizeof(s->mcast_list[i]))) {\n            return true;\n        }\n    }\n    return false;\n}\n",
        "linevul": 4.935990727972239e-05,
        "sysevr": 0.46966665983200073,
        "devign": 1.825024853463475e-10
    },
    {
        "code": "static int megasas_handle_io(MegasasState *s, MegasasCmd *cmd)\n{\n    uint32_t lba_count, lba_start_hi, lba_start_lo;\n    uint64_t lba_start;\n    bool is_write = (cmd->frame->header.frame_cmd == MFI_CMD_LD_WRITE);\n    uint8_t cdb[16];\n    int len;\n    struct SCSIDevice *sdev = NULL;\n\n    lba_count = le32_to_cpu(cmd->frame->io.header.data_len);\n    lba_start_lo = le32_to_cpu(cmd->frame->io.lba_lo);\n    lba_start_hi = le32_to_cpu(cmd->frame->io.lba_hi);\n    lba_start = ((uint64_t)lba_start_hi << 32) | lba_start_lo;\n\n    if (cmd->frame->header.target_id < MFI_MAX_LD &&\n        cmd->frame->header.lun_id == 0) {\n        sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                                cmd->frame->header.lun_id);\n    }\n\n    trace_megasas_handle_io(cmd->index,\n                            mfi_frame_desc[cmd->frame->header.frame_cmd],\n                            cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id,\n                            (unsigned long)lba_start, (unsigned long)lba_count);\n    if (!sdev) {\n        trace_megasas_io_target_not_present(cmd->index,\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], 1,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id,\n            cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->iov_size = lba_count * sdev->blocksize;\n    if (megasas_map_sgl(s, cmd, &cmd->frame->io.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    megasas_encode_lba(cdb, lba_start, lba_count, is_write);\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n    len = megasas_enqueue_req(cmd, is_write);\n    if (len > 0) {\n        if (is_write) {\n            trace_megasas_io_write_start(cmd->index, lba_start, lba_count, len);\n        } else {\n            trace_megasas_io_read_start(cmd->index, lba_start, lba_count, len);\n        }\n    }\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=844864fbae66935951529408831c2f22367a57b6",
        "vul_func_with_fix": "static int megasas_handle_io(MegasasState *s, MegasasCmd *cmd)\n{\n    uint32_t lba_count, lba_start_hi, lba_start_lo;\n    uint64_t lba_start;\n    bool is_write = (cmd->frame->header.frame_cmd == MFI_CMD_LD_WRITE);\n    uint8_t cdb[16];\n    int len;\n    struct SCSIDevice *sdev = NULL;\n\n    lba_count = le32_to_cpu(cmd->frame->io.header.data_len);\n    lba_start_lo = le32_to_cpu(cmd->frame->io.lba_lo);\n    lba_start_hi = le32_to_cpu(cmd->frame->io.lba_hi);\n    lba_start = ((uint64_t)lba_start_hi << 32) | lba_start_lo;\n\n    if (cmd->frame->header.target_id < MFI_MAX_LD &&\n        cmd->frame->header.lun_id == 0) {\n        sdev = scsi_device_find(&s->bus, 0, cmd->frame->header.target_id,\n                                cmd->frame->header.lun_id);\n    }\n\n    trace_megasas_handle_io(cmd->index,\n                            mfi_frame_desc[cmd->frame->header.frame_cmd],\n                            cmd->frame->header.target_id,\n                            cmd->frame->header.lun_id,\n                            (unsigned long)lba_start, (unsigned long)lba_count);\n    if (!sdev) {\n        trace_megasas_io_target_not_present(cmd->index,\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        return MFI_STAT_DEVICE_NOT_FOUND;\n    }\n\n    if (cmd->frame->header.cdb_len > 16) {\n        trace_megasas_scsi_invalid_cdb_len(\n            mfi_frame_desc[cmd->frame->header.frame_cmd], 1,\n            cmd->frame->header.target_id, cmd->frame->header.lun_id,\n            cmd->frame->header.cdb_len);\n        megasas_write_sense(cmd, SENSE_CODE(INVALID_OPCODE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    cmd->iov_size = lba_count * sdev->blocksize;\n    if (megasas_map_sgl(s, cmd, &cmd->frame->io.sgl)) {\n        megasas_write_sense(cmd, SENSE_CODE(TARGET_FAILURE));\n        cmd->frame->header.scsi_status = CHECK_CONDITION;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n\n    megasas_encode_lba(cdb, lba_start, lba_count, is_write);\n    cmd->req = scsi_req_new(sdev, cmd->index,\n                            cmd->frame->header.lun_id, cdb, cmd);\n    if (!cmd->req) {\n        trace_megasas_scsi_req_alloc_failed(\n            mfi_frame_desc[cmd->frame->header.frame_cmd],\n            cmd->frame->header.target_id, cmd->frame->header.lun_id);\n        megasas_write_sense(cmd, SENSE_CODE(NO_SENSE));\n        cmd->frame->header.scsi_status = BUSY;\n        s->event_count++;\n        return MFI_STAT_SCSI_DONE_WITH_ERROR;\n    }\n    len = megasas_enqueue_req(cmd, is_write);\n    if (len > 0) {\n        if (is_write) {\n            trace_megasas_io_write_start(cmd->index, lba_start, lba_count, len);\n        } else {\n            trace_megasas_io_read_start(cmd->index, lba_start, lba_count, len);\n        }\n    }\n    return MFI_STAT_INVALID_STATUS;\n}\n",
        "linevul": 7.441069465130568e-05,
        "sysevr": 0.47048038244247437,
        "devign": 7.240587729029357e-05
    },
    {
        "code": "static void receive_header(VirtIONet *n, const struct iovec *iov, int iov_cnt,\n                           const void *buf, size_t size)\n{\n    if (n->has_vnet_hdr) {\n        /* FIXME this cast is evil */\n        void *wbuf = (void *)buf;\n        work_around_broken_dhclient(wbuf, wbuf + n->host_hdr_len,\n                                    size - n->host_hdr_len);\n        iov_from_buf(iov, iov_cnt, 0, buf, sizeof(struct virtio_net_hdr));\n    } else {\n        struct virtio_net_hdr hdr = {\n            .flags = 0,\n            .gso_type = VIRTIO_NET_HDR_GSO_NONE\n        };\n        iov_from_buf(iov, iov_cnt, 0, &hdr, sizeof hdr);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void receive_header(VirtIONet *n, const struct iovec *iov, int iov_cnt,\n                           const void *buf, size_t size)\n{\n    if (n->has_vnet_hdr) {\n        /* FIXME this cast is evil */\n        void *wbuf = (void *)buf;\n        work_around_broken_dhclient(wbuf, wbuf + n->host_hdr_len,\n                                    size - n->host_hdr_len);\n        iov_from_buf(iov, iov_cnt, 0, buf, sizeof(struct virtio_net_hdr));\n    } else {\n        struct virtio_net_hdr hdr = {\n            .flags = 0,\n            .gso_type = VIRTIO_NET_HDR_GSO_NONE\n        };\n        iov_from_buf(iov, iov_cnt, 0, &hdr, sizeof hdr);\n    }\n}\n",
        "linevul": 9.654468885855749e-05,
        "sysevr": 0.4747886657714844,
        "devign": 6.063809792067332e-07
    },
    {
        "code": "static bool cmd_read_dma(IDEState *s, uint8_t cmd)\n{\n    bool lba48 = (cmd == WIN_READDMA_EXT);\n\n    if (!s->blk) {\n        ide_abort_command(s);\n        return true;\n    }\n\n    ide_cmd_lba48_transform(s, lba48);\n    ide_sector_start_dma(s, IDE_DMA_READ);\n\n    return false;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static bool cmd_read_dma(IDEState *s, uint8_t cmd)\n{\n    bool lba48 = (cmd == WIN_READDMA_EXT);\n\n    if (!s->blk) {\n        ide_abort_command(s);\n        return true;\n    }\n\n    ide_cmd_lba48_transform(s, lba48);\n    ide_sector_start_dma(s, IDE_DMA_READ);\n\n    return false;\n}\n",
        "linevul": 4.994419214199297e-05,
        "sysevr": 0.4671679437160492,
        "devign": 5.743274414271582e-06
    },
    {
        "code": "static void virtio_net_set_status(struct VirtIODevice *vdev, uint8_t status)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q;\n    int i;\n    uint8_t queue_status;\n\n    virtio_net_vhost_status(n, status);\n\n    for (i = 0; i < n->max_queues; i++) {\n        q = &n->vqs[i];\n\n        if ((!n->multiqueue && i != 0) || i >= n->curr_queues) {\n            queue_status = 0;\n        } else {\n            queue_status = status;\n        }\n\n        if (!q->tx_waiting) {\n            continue;\n        }\n\n        if (virtio_net_started(n, queue_status) && !n->vhost_started) {\n            if (q->tx_timer) {\n                timer_mod(q->tx_timer,\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n            } else {\n                qemu_bh_schedule(q->tx_bh);\n            }\n        } else {\n            if (q->tx_timer) {\n                timer_del(q->tx_timer);\n            } else {\n                qemu_bh_cancel(q->tx_bh);\n            }\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_set_status(struct VirtIODevice *vdev, uint8_t status)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q;\n    int i;\n    uint8_t queue_status;\n\n    virtio_net_vhost_status(n, status);\n\n    for (i = 0; i < n->max_queues; i++) {\n        q = &n->vqs[i];\n\n        if ((!n->multiqueue && i != 0) || i >= n->curr_queues) {\n            queue_status = 0;\n        } else {\n            queue_status = status;\n        }\n\n        if (!q->tx_waiting) {\n            continue;\n        }\n\n        if (virtio_net_started(n, queue_status) && !n->vhost_started) {\n            if (q->tx_timer) {\n                timer_mod(q->tx_timer,\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n            } else {\n                qemu_bh_schedule(q->tx_bh);\n            }\n        } else {\n            if (q->tx_timer) {\n                timer_del(q->tx_timer);\n            } else {\n                qemu_bh_cancel(q->tx_bh);\n            }\n        }\n    }\n}\n",
        "linevul": 4.594954225467518e-05,
        "sysevr": 0.46971824765205383,
        "devign": 1.5255555336785714e-13
    },
    {
        "code": "static void gen_set_hflag(DisasContext *s, uint32_t mask)\n{\n    if ((s->flags & mask) == 0) {\n        TCGv_i32 t = tcg_temp_new_i32();\n        tcg_gen_ld_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_gen_ori_i32(t, t, mask);\n        tcg_gen_st_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_temp_free_i32(t);\n        s->flags |= mask;\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_set_hflag(DisasContext *s, uint32_t mask)\n{\n    if ((s->flags & mask) == 0) {\n        TCGv_i32 t = tcg_temp_new_i32();\n        tcg_gen_ld_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_gen_ori_i32(t, t, mask);\n        tcg_gen_st_i32(t, cpu_env, offsetof(CPUX86State, hflags));\n        tcg_temp_free_i32(t);\n        s->flags |= mask;\n    }\n}\n",
        "linevul": 5.7135643146466464e-05,
        "sysevr": 0.47526511549949646,
        "devign": 2.1441479702843935e-09
    },
    {
        "code": "static void vmxnet3_ack_events(VMXNET3State *s, uint32_t val)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t events;\n\n    VMW_CBPRN(\"Clearing events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, ecr) & ~val;\n    VMXNET3_WRITE_DRV_SHARED32(d, s->drv_shmem, ecr, events);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_ack_events(VMXNET3State *s, uint32_t val)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t events;\n\n    VMW_CBPRN(\"Clearing events: 0x%x\", val);\n    events = VMXNET3_READ_DRV_SHARED32(d, s->drv_shmem, ecr) & ~val;\n    VMXNET3_WRITE_DRV_SHARED32(d, s->drv_shmem, ecr, events);\n}\n",
        "linevul": 4.5501627027988434e-05,
        "sysevr": 0.46838727593421936,
        "devign": 0.07620090991258621
    },
    {
        "code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n    if (!nc->peer) {\n        return;\n    }\n    if (nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {\n        return;\n    }\n\n    if (!tap_get_vhost_net(nc->peer)) {\n        return;\n    }\n\n    if (!!n->vhost_started ==\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r;\n        if (!vhost_net_query(tap_get_vhost_net(nc->peer), vdev)) {\n            return;\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n        n->vhost_started = 0;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n    if (!nc->peer) {\n        return;\n    }\n    if (nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {\n        return;\n    }\n\n    if (!tap_get_vhost_net(nc->peer)) {\n        return;\n    }\n\n    if (!!n->vhost_started ==\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r;\n        if (!vhost_net_query(tap_get_vhost_net(nc->peer), vdev)) {\n            return;\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n        n->vhost_started = 0;\n    }\n}\n",
        "linevul": 5.288370084599592e-05,
        "sysevr": 0.46499961614608765,
        "devign": 0.0019373344257473946
    },
    {
        "code": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n{\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n    PCIDevice *pci_dev =\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n    DPRINTF(0, \"raise irq\\n\");\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n        msi_notify(pci_dev, 0);\n    } else {\n        qemu_irq_raise(s->irq);\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3251bdcf1c67427d964517053c3d185b46e618e8",
        "vul_func_with_fix": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n{\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n    PCIDevice *pci_dev =\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n    DPRINTF(0, \"raise irq\\n\");\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n        msi_notify(pci_dev, 0);\n    } else {\n        qemu_irq_raise(s->irq);\n    }\n}\n",
        "linevul": 4.533682295004837e-05,
        "sysevr": 0.46595078706741333,
        "devign": 0.0026171121280640364
    },
    {
        "code": "static void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static void client_cut_text(VncState *vs, size_t len, uint8_t *text)\n{\n}\n",
        "linevul": 4.936979530612007e-05,
        "sysevr": 0.471686989068985,
        "devign": 0.1295168548822403
    },
    {
        "code": "static uint32_t fdctrl_read_statusA(FDCtrl *fdctrl)\n{\n    uint32_t retval = fdctrl->sra;\n\n    FLOPPY_DPRINTF(\"status register A: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=e907746266721f305d67bc0718795fedee2e824c",
        "vul_func_with_fix": "static uint32_t fdctrl_read_statusA(FDCtrl *fdctrl)\n{\n    uint32_t retval = fdctrl->sra;\n\n    FLOPPY_DPRINTF(\"status register A: 0x%02x\\n\", retval);\n\n    return retval;\n}\n",
        "linevul": 4.7729368816362694e-05,
        "sysevr": 0.46797388792037964,
        "devign": 0.051630184054374695
    },
    {
        "code": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n     uint8_t len;\n \n     if (flags & RAM_SAVE_FLAG_CONTINUE) {\n        if (!block) {\n             error_report(\"Ack, bad migration stream!\");\n             return NULL;\n         }\n\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n     id[len] = 0;\n \n     QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        if (!strncmp(id, block->idstr, sizeof(id)))\n             return memory_region_get_ram_ptr(block->mr) + offset;\n     }\n \n     error_report(\"Can't find block %s!\", id);\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=0be839a2701369f669532ea5884c15bead1c6e08",
        "vul_func_with_fix": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n     uint8_t len;\n \n     if (flags & RAM_SAVE_FLAG_CONTINUE) {\n//flaw_line_below:\n        if (!block) {\n//fix_flaw_line_below:\n//        if (!block || block->length <= offset) {\n             error_report(\"Ack, bad migration stream!\");\n             return NULL;\n         }\n\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n     id[len] = 0;\n \n     QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n//flaw_line_below:\n        if (!strncmp(id, block->idstr, sizeof(id)))\n//fix_flaw_line_below:\n//        if (!strncmp(id, block->idstr, sizeof(id)) && block->length > offset) {\n             return memory_region_get_ram_ptr(block->mr) + offset;\n//fix_flaw_line_below:\n//        }\n     }\n \n     error_report(\"Can't find block %s!\", id);\n}\n",
        "linevul": 0.9967419505119324,
        "sysevr": 0.4742621183395386,
        "devign": 8.736491707850291e-08
    },
    {
        "code": "static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    PCIDevice *dev = opaque;\n    if (dev->msix_vector_poll_notifier) {\n        unsigned vector_start = addr * 8;\n        unsigned vector_end = MIN(addr + size * 8, dev->msix_entries_nr);\n        dev->msix_vector_poll_notifier(dev, vector_start, vector_end);\n    }\n\n     return pci_get_long(dev->msix_pba + addr);\n }\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=43b11a91dd861a946b231b89b754285",
        "vul_func_with_fix": "static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    PCIDevice *dev = opaque;\n    if (dev->msix_vector_poll_notifier) {\n        unsigned vector_start = addr * 8;\n        unsigned vector_end = MIN(addr + size * 8, dev->msix_entries_nr);\n        dev->msix_vector_poll_notifier(dev, vector_start, vector_end);\n    }\n\n     return pci_get_long(dev->msix_pba + addr);\n }\n",
        "linevul": 0.0009350088657811284,
        "sysevr": 0.4685218334197998,
        "devign": 0.025008294731378555
    },
    {
        "code": "static void stellaris_enet_send(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n\n    /* Ethernet header is in the FIFO but not in the datacount.\n     * We don't implement explicit CRC, so just ignore any\n     * CRC value in the FIFO.\n     */\n    framelen += 14;\n    if ((s->tctl & SE_TCTL_PADEN) && framelen < 60) {\n        memset(&s->tx_fifo[framelen + 2], 0, 60 - framelen);\n        framelen = 60;\n    }\n    /* This MIN will have no effect unless the FIFO data is corrupt\n     * (eg bad data from an incoming migration); otherwise the check\n     * on the datalen at the start of writing the data into the FIFO\n     * will have caught this. Silently write a corrupt half-packet,\n     * which is what the hardware does in FIFO underrun situations.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo) - 2);\n    qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo + 2, framelen);\n    s->tx_fifo_len = 0;\n    s->ris |= SE_INT_TXEMP;\n    stellaris_enet_update(s);\n    DPRINTF(\"Done TX\\n\");\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=3a15cc0e1ee7168db0782133d2607a6bfa422d66",
        "vul_func_with_fix": "static void stellaris_enet_send(stellaris_enet_state *s)\n{\n    int framelen = stellaris_txpacket_datalen(s);\n\n    /* Ethernet header is in the FIFO but not in the datacount.\n     * We don't implement explicit CRC, so just ignore any\n     * CRC value in the FIFO.\n     */\n    framelen += 14;\n    if ((s->tctl & SE_TCTL_PADEN) && framelen < 60) {\n        memset(&s->tx_fifo[framelen + 2], 0, 60 - framelen);\n        framelen = 60;\n    }\n    /* This MIN will have no effect unless the FIFO data is corrupt\n     * (eg bad data from an incoming migration); otherwise the check\n     * on the datalen at the start of writing the data into the FIFO\n     * will have caught this. Silently write a corrupt half-packet,\n     * which is what the hardware does in FIFO underrun situations.\n     */\n    framelen = MIN(framelen, ARRAY_SIZE(s->tx_fifo) - 2);\n    qemu_send_packet(qemu_get_queue(s->nic), s->tx_fifo + 2, framelen);\n    s->tx_fifo_len = 0;\n    s->ris |= SE_INT_TXEMP;\n    stellaris_enet_update(s);\n    DPRINTF(\"Done TX\\n\");\n}\n",
        "linevul": 7.294985698536038e-05,
        "sysevr": 0.4815911054611206,
        "devign": 2.696835651205863e-18
    },
    {
        "code": "bool net_tx_pkt_send_loopback(struct NetTxPkt *pkt, NetClientState *nc)\n{\n    bool res;\n\n    pkt->is_loopback = true;\n    res = net_tx_pkt_send(pkt, nc);\n    pkt->is_loopback = false;\n\n    return res;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=47882fa4975bf0b58dd74474329fdd7154e8f04c",
        "vul_func_with_fix": "bool net_tx_pkt_send_loopback(struct NetTxPkt *pkt, NetClientState *nc)\n{\n    bool res;\n\n    pkt->is_loopback = true;\n    res = net_tx_pkt_send(pkt, nc);\n    pkt->is_loopback = false;\n\n    return res;\n}\n",
        "linevul": 4.7323235776275396e-05,
        "sysevr": 0.4548698663711548,
        "devign": 0.002652975032106042
    },
    {
        "code": "static void bdrv_io_limits_intercept(BlockDriverState *bs,\n                                     unsigned int bytes,\n                                     bool is_write)\n{\n    /* does this io must wait */\n    bool must_wait = throttle_schedule_timer(&bs->throttle_state, is_write);\n\n    /* if must wait or any request of this type throttled queue the IO */\n    if (must_wait ||\n        !qemu_co_queue_empty(&bs->throttled_reqs[is_write])) {\n        qemu_co_queue_wait(&bs->throttled_reqs[is_write]);\n    }\n\n    /* the IO will be executed, do the accounting */\n    throttle_account(&bs->throttle_state, is_write, bytes);\n\n\n    /* if the next request must wait -> do nothing */\n    if (throttle_schedule_timer(&bs->throttle_state, is_write)) {\n        return;\n    }\n\n    /* else queue next request for execution */\n    qemu_co_queue_next(&bs->throttled_reqs[is_write]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=8f4754ede56e3f9ea3fd7207f4a7c4453e59285b",
        "vul_func_with_fix": "static void bdrv_io_limits_intercept(BlockDriverState *bs,\n                                     unsigned int bytes,\n                                     bool is_write)\n{\n    /* does this io must wait */\n    bool must_wait = throttle_schedule_timer(&bs->throttle_state, is_write);\n\n    /* if must wait or any request of this type throttled queue the IO */\n    if (must_wait ||\n        !qemu_co_queue_empty(&bs->throttled_reqs[is_write])) {\n        qemu_co_queue_wait(&bs->throttled_reqs[is_write]);\n    }\n\n    /* the IO will be executed, do the accounting */\n    throttle_account(&bs->throttle_state, is_write, bytes);\n\n\n    /* if the next request must wait -> do nothing */\n    if (throttle_schedule_timer(&bs->throttle_state, is_write)) {\n        return;\n    }\n\n    /* else queue next request for execution */\n    qemu_co_queue_next(&bs->throttled_reqs[is_write]);\n}\n",
        "linevul": 5.910885738558136e-05,
        "sysevr": 0.4760001003742218,
        "devign": 0.0006199778290465474
    },
    {
        "code": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n    int refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return refcount;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=db8a31d11d6a60f48d6817530640d75aa72a9a2f",
        "vul_func_with_fix": " static int get_refcount(BlockDriverState *bs, int64_t cluster_index)\n {\n     BDRVQcowState *s = bs->opaque;\n//flaw_line_below:\n    int refcount_table_index, block_index;\n//fix_flaw_line_below:\n//    uint64_t refcount_table_index, block_index;\n     int64_t refcount_block_offset;\n     int ret;\n     uint16_t *refcount_block;\n    uint16_t refcount;\n\n    refcount_table_index = cluster_index >> (s->cluster_bits - REFCOUNT_SHIFT);\n    if (refcount_table_index >= s->refcount_table_size)\n        return 0;\n    refcount_block_offset =\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n    if (!refcount_block_offset)\n        return 0;\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    block_index = cluster_index &\n        ((1 << (s->cluster_bits - REFCOUNT_SHIFT)) - 1);\n    refcount = be16_to_cpu(refcount_block[block_index]);\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n        (void**) &refcount_block);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return refcount;\n}\n",
        "linevul": 7.816132711013779e-05,
        "sysevr": 0.4739404618740082,
        "devign": 1.0
    },
    {
        "code": "static long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "static long vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n                                size_t datalen)\n{\n    long ret = gnutls_read(*session, data, datalen);\n    if (ret < 0) {\n        if (ret == GNUTLS_E_AGAIN) {\n            errno = EAGAIN;\n        } else {\n            errno = EIO;\n        }\n        ret = -1;\n    }\n    return ret;\n}\n",
        "linevul": 6.935292185517028e-05,
        "sysevr": 0.4638693630695343,
        "devign": 6.21720687377092e-07
    },
    {
        "code": "void sl_bootparam_write(hwaddr ptr)\n{\n    cpu_physical_memory_write(ptr, &zaurus_bootparam,\n                              sizeof(struct sl_param_info));\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=52f91c3723932f8340fe36c8ec8b18a757c37b2b",
        "vul_func_with_fix": "void sl_bootparam_write(hwaddr ptr)\n{\n    cpu_physical_memory_write(ptr, &zaurus_bootparam,\n                              sizeof(struct sl_param_info));\n}\n",
        "linevul": 8.748648542677984e-05,
        "sysevr": 0.4678516387939453,
        "devign": 0.05386707931756973
    },
    {
        "code": "void v9fs_path_free(V9fsPath *path)\n{\n    g_free(path->data);\n    path->data = NULL;\n    path->size = 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "void v9fs_path_free(V9fsPath *path)\n{\n    g_free(path->data);\n    path->data = NULL;\n    path->size = 0;\n}\n",
        "linevul": 0.00010528470738790929,
        "sysevr": 0.46330755949020386,
        "devign": 0.022475697100162506
    },
    {
        "code": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n{\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n     CirrusVGAState *s = &d->cirrus_vga;\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n     int16_t device_id = pc->device_id;\n\n     /* follow real hardware, cirrus card emulated has 4 MB video memory.\n       Also accept 8 MB/16 MB for backward compatibility. */\n     if (s->vga.vram_size_mb != 4 && s->vga.vram_size_mb != 8 &&\n         s->vga.vram_size_mb != 16) {\n         error_report(\"Invalid cirrus_vga ram size '%u'\",\n                      s->vga.vram_size_mb);\n         return -1;\n     }\n     /* setup VGA */\n     vga_common_init(&s->vga, OBJECT(dev), true);\n     cirrus_init_common(s, OBJECT(dev), device_id, 1, pci_address_space(dev),\n                        pci_address_space_io(dev));\n     s->vga.con = graphic_console_init(DEVICE(dev), 0, s->vga.hw_ops, &s->vga);\n\n     /* setup PCI */\n\n    memory_region_init(&s->pci_bar, OBJECT(dev), \"cirrus-pci-bar0\", 0x2000000);\n\n    /* XXX: add byte swapping apertures */\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n                                &s->cirrus_linear_bitblt_io);\n\n     /* setup memory space */\n     /* memory #0 LFB */\n     /* memory #1 memory-mapped I/O */\n     /* XXX: s->vga.vram_size must be a power of two */\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n     if (device_id == CIRRUS_ID_CLGD5446) {\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n     }\n     return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=bf25983345ca44aec3dd92c57142be45452bd38a",
        "vul_func_with_fix": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n{\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n     CirrusVGAState *s = &d->cirrus_vga;\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n     int16_t device_id = pc->device_id;\n\n     /* follow real hardware, cirrus card emulated has 4 MB video memory.\n       Also accept 8 MB/16 MB for backward compatibility. */\n     if (s->vga.vram_size_mb != 4 && s->vga.vram_size_mb != 8 &&\n         s->vga.vram_size_mb != 16) {\n         error_report(\"Invalid cirrus_vga ram size '%u'\",\n                      s->vga.vram_size_mb);\n         return -1;\n     }\n     /* setup VGA */\n     vga_common_init(&s->vga, OBJECT(dev), true);\n     cirrus_init_common(s, OBJECT(dev), device_id, 1, pci_address_space(dev),\n                        pci_address_space_io(dev));\n     s->vga.con = graphic_console_init(DEVICE(dev), 0, s->vga.hw_ops, &s->vga);\n\n     /* setup PCI */\n\n    memory_region_init(&s->pci_bar, OBJECT(dev), \"cirrus-pci-bar0\", 0x2000000);\n\n    /* XXX: add byte swapping apertures */\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n                                &s->cirrus_linear_bitblt_io);\n\n     /* setup memory space */\n     /* memory #0 LFB */\n     /* memory #1 memory-mapped I/O */\n     /* XXX: s->vga.vram_size must be a power of two */\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n     if (device_id == CIRRUS_ID_CLGD5446) {\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n     }\n     return 0;\n}\n",
        "linevul": 0.01349408645182848,
        "sysevr": 0.45710673928260803,
        "devign": 4.707855284135027e-15
    },
    {
        "code": "static void gen_sse(CPUX86State *env, DisasContext *s, int b,\n                    target_ulong pc_start, int rex_r)\n{\n    int b1, op1_offset, op2_offset, is_xmm, val;\n    int modrm, mod, rm, reg;\n    SSEFunc_0_epp sse_fn_epp;\n    SSEFunc_0_eppi sse_fn_eppi;\n    SSEFunc_0_ppi sse_fn_ppi;\n    SSEFunc_0_eppt sse_fn_eppt;\n    TCGMemOp ot;\n\n    b &= 0xff;\n    if (s->prefix & PREFIX_DATA)\n        b1 = 1;\n    else if (s->prefix & PREFIX_REPZ)\n        b1 = 2;\n    else if (s->prefix & PREFIX_REPNZ)\n        b1 = 3;\n    else\n        b1 = 0;\n    sse_fn_epp = sse_op_table1[b][b1];\n    if (!sse_fn_epp) {\n        goto unknown_op;\n    }\n    if ((b <= 0x5f && b >= 0x10) || b == 0xc6 || b == 0xc2) {\n        is_xmm = 1;\n    } else {\n        if (b1 == 0) {\n            /* MMX case */\n            is_xmm = 0;\n        } else {\n            is_xmm = 1;\n        }\n    }\n    /* simple MMX/SSE operation */\n    if (s->flags & HF_TS_MASK) {\n        gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        return;\n    }\n    if (s->flags & HF_EM_MASK) {\n    illegal_op:\n        gen_illegal_opcode(s);\n        return;\n    }\n    if (is_xmm\n        && !(s->flags & HF_OSFXSR_MASK)\n        && ((b != 0x38 && b != 0x3a) || (s->prefix & PREFIX_DATA))) {\n        goto unknown_op;\n    }\n    if (b == 0x0e) {\n        if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n            /* If we were fully decoding this we might use illegal_op.  */\n            goto unknown_op;\n        }\n        /* femms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    if (b == 0x77) {\n        /* emms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    /* prepare MMX state (XXX: optimize by storing fptt and fptags in\n       the static cpu state) */\n    if (!is_xmm) {\n        gen_helper_enter_mmx(cpu_env);\n    }\n\n    modrm = cpu_ldub_code(env, s->pc++);\n    reg = ((modrm >> 3) & 7);\n    if (is_xmm)\n        reg |= rex_r;\n    mod = (modrm >> 6) & 3;\n    if (sse_fn_epp == SSE_SPECIAL) {\n        b |= (b1 << 8);\n        switch(b) {\n        case 0x0e7: /* movntq */\n            if (mod == 3) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            break;\n        case 0x1e7: /* movntdq */\n        case 0x02b: /* movntps */\n        case 0x12b: /* movntps */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x3f0: /* lddqu */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x22b: /* movntss */\n        case 0x32b: /* movntsd */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if (b1 & 1) {\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                    xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            }\n            break;\n        case 0x6e: /* movd mm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State,fpregs[reg].mmx));\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,fpregs[reg].mmx));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_mmx(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x16e: /* movd xmm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                gen_helper_movq_mm_T0_xmm(cpu_ptr0, cpu_T0);\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_xmm(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x6f: /* movq mm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[rm].mmx));\n                tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x010: /* movups */\n        case 0x110: /* movupd */\n        case 0x028: /* movaps */\n        case 0x128: /* movapd */\n        case 0x16f: /* movdqa xmm, ea */\n        case 0x26f: /* movdqu xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[reg]),\n                            offsetof(CPUX86State,xmm_regs[rm]));\n            }\n            break;\n        case 0x210: /* movss xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n            }\n            break;\n        case 0x310: /* movsd xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x012: /* movlps */\n        case 0x112: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                /* movhlps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x212: /* movsldup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(2)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n            break;\n        case 0x312: /* movddup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            break;\n        case 0x016: /* movhps */\n        case 0x116: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                /* movlhps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x216: /* movshdup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(1)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(3)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            break;\n        case 0x178:\n        case 0x378:\n            {\n                int bit_index, field_length;\n\n                if (b1 == 1 && reg != 0)\n                    goto illegal_op;\n                field_length = cpu_ldub_code(env, s->pc++) & 0x3F;\n                bit_index = cpu_ldub_code(env, s->pc++) & 0x3F;\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env,\n                    offsetof(CPUX86State,xmm_regs[reg]));\n                if (b1 == 1)\n                    gen_helper_extrq_i(cpu_env, cpu_ptr0,\n                                       tcg_const_i32(bit_index),\n                                       tcg_const_i32(field_length));\n                else\n                    gen_helper_insertq_i(cpu_env, cpu_ptr0,\n                                         tcg_const_i32(bit_index),\n                                         tcg_const_i32(field_length));\n            }\n            break;\n        case 0x7e: /* movd ea, mm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,fpregs[reg].mmx.MMX_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x17e: /* movd ea, xmm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x27e: /* movq xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x7f: /* movq ea, mm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                gen_op_movq(offsetof(CPUX86State,fpregs[rm].mmx),\n                            offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x011: /* movups */\n        case 0x111: /* movupd */\n        case 0x029: /* movaps */\n        case 0x129: /* movapd */\n        case 0x17f: /* movdqa ea, xmm */\n        case 0x27f: /* movdqu ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[rm]),\n                            offsetof(CPUX86State,xmm_regs[reg]));\n            }\n            break;\n        case 0x211: /* movss ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            }\n            break;\n        case 0x311: /* movsd ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            }\n            break;\n        case 0x013: /* movlps */\n        case 0x113: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x017: /* movhps */\n        case 0x117: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x71: /* shift mm, im */\n        case 0x72:\n        case 0x73:\n        case 0x171: /* shift xmm, im */\n        case 0x172:\n        case 0x173:\n            if (b1 >= 2) {\n\t        goto unknown_op;\n            }\n            val = cpu_ldub_code(env, s->pc++);\n            if (is_xmm) {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(1)));\n                op1_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(1)));\n                op1_offset = offsetof(CPUX86State,mmx_t0);\n            }\n            sse_fn_epp = sse_op_table2[((b - 1) & 3) * 8 +\n                                       (((modrm >> 3)) & 7)][b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (is_xmm) {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op1_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x050: /* movmskps */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskps(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x150: /* movmskpd */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskpd(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x02a: /* cvtpi2ps */\n        case 0x12a: /* cvtpi2pd */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b >> 8) {\n            case 0x0:\n                gen_helper_cvtpi2ps(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            default:\n            case 0x1:\n                gen_helper_cvtpi2pd(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22a: /* cvtsi2ss */\n        case 0x32a: /* cvtsi2sd */\n            ot = mo_64_32(s->dflag);\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            if (ot == MO_32) {\n                SSEFunc_0_epi sse_fn_epi = sse_op_table3ai[(b >> 8) & 1];\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                sse_fn_epi(cpu_env, cpu_ptr0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_0_epl sse_fn_epl = sse_op_table3aq[(b >> 8) & 1];\n                sse_fn_epl(cpu_env, cpu_ptr0, cpu_T0);\n#else\n                goto illegal_op;\n#endif\n            }\n            break;\n        case 0x02c: /* cvttps2pi */\n        case 0x12c: /* cvttpd2pi */\n        case 0x02d: /* cvtps2pi */\n        case 0x12d: /* cvtpd2pi */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n                gen_ldo_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            op1_offset = offsetof(CPUX86State,fpregs[reg & 7].mmx);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b) {\n            case 0x02c:\n                gen_helper_cvttps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12c:\n                gen_helper_cvttpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x02d:\n                gen_helper_cvtps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12d:\n                gen_helper_cvtpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22c: /* cvttss2si */\n        case 0x32c: /* cvttsd2si */\n        case 0x22d: /* cvtss2si */\n        case 0x32d: /* cvtsd2si */\n            ot = mo_64_32(s->dflag);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                if ((b >> 8) & 1) {\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_Q(0)));\n                } else {\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                }\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            if (ot == MO_32) {\n                SSEFunc_i_ep sse_fn_i_ep =\n                    sse_op_table3bi[((b >> 7) & 2) | (b & 1)];\n                sse_fn_i_ep(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n                tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_l_ep sse_fn_l_ep =\n                    sse_op_table3bq[((b >> 7) & 2) | (b & 1)];\n                sse_fn_l_ep(cpu_T0, cpu_env, cpu_ptr0);\n#else\n                goto illegal_op;\n#endif\n            }\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0xc4: /* pinsrw */\n        case 0x1c4:\n            s->rip_offset = 1;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,xmm_regs[reg].ZMM_W(val)));\n            } else {\n                val &= 3;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[reg].mmx.MMX_W(val)));\n            }\n            break;\n        case 0xc5: /* pextrw */\n        case 0x1c5:\n            if (mod != 3)\n                goto illegal_op;\n            ot = mo_64_32(s->dflag);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[rm].ZMM_W(val)));\n            } else {\n                val &= 3;\n                rm = (modrm & 7);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[rm].mmx.MMX_W(val)));\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0x1d6: /* movq ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x2d6: /* movq2dq */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7);\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                        offsetof(CPUX86State,fpregs[rm].mmx));\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x3d6: /* movdq2q */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_movq(offsetof(CPUX86State,fpregs[reg & 7].mmx),\n                        offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            break;\n        case 0xd7: /* pmovmskb */\n        case 0x1d7:\n            if (mod != 3)\n                goto illegal_op;\n            if (b1) {\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,xmm_regs[rm]));\n                gen_helper_pmovmskb_xmm(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,fpregs[rm].mmx));\n                gen_helper_pmovmskb_mmx(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n\n        case 0x138:\n        case 0x038:\n            b = modrm;\n            if ((b & 0xf0) == 0xf0) {\n                goto do_0f_38_fx;\n            }\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_epp = sse_op_table6[b].op[b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table6[b].ext_mask))\n                goto illegal_op;\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    switch (b) {\n                    case 0x20: case 0x30: /* pmovsxbw, pmovzxbw */\n                    case 0x23: case 0x33: /* pmovsxwd, pmovzxwd */\n                    case 0x25: case 0x35: /* pmovsxdq, pmovzxdq */\n                        gen_ldq_env_A0(s, op2_offset +\n                                        offsetof(ZMMReg, ZMM_Q(0)));\n                        break;\n                    case 0x21: case 0x31: /* pmovsxbd, pmovzxbd */\n                    case 0x24: case 0x34: /* pmovsxwq, pmovzxwq */\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_L(0)));\n                        break;\n                    case 0x22: case 0x32: /* pmovsxbq, pmovzxbq */\n                        tcg_gen_qemu_ld_tl(cpu_tmp0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                        tcg_gen_st16_tl(cpu_tmp0, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_W(0)));\n                        break;\n                    case 0x2a:            /* movntqda */\n                        gen_ldo_env_A0(s, op1_offset);\n                        return;\n                    default:\n                        gen_ldo_env_A0(s, op2_offset);\n                    }\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            if (sse_fn_epp == SSE_SPECIAL) {\n                goto unknown_op;\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            if (b == 0x17) {\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n            break;\n\n        case 0x238:\n        case 0x338:\n        do_0f_38_fx:\n            /* Various integer extensions at 0f 38 f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* crc32 Gd,Eb */\n            case 0x3f1: /* crc32 Gd,Ey */\n            do_crc32:\n                if (!(s->cpuid_ext_features & CPUID_EXT_SSE42)) {\n                    goto illegal_op;\n                }\n                if ((b & 0xff) == 0xf0) {\n                    ot = MO_8;\n                } else if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[reg]);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                gen_helper_crc32(cpu_T0, cpu_tmp2_i32,\n                                 cpu_T0, tcg_const_i32(8 << ot));\n\n                ot = mo_64_32(s->dflag);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x1f0: /* crc32 or movbe */\n            case 0x1f1:\n                /* For these insns, the f3 prefix is supposed to have priority\n                   over the 66 prefix, but that's not what we implement above\n                   setting b1.  */\n                if (s->prefix & PREFIX_REPNZ) {\n                    goto do_crc32;\n                }\n                /* FALLTHRU */\n            case 0x0f0: /* movbe Gy,My */\n            case 0x0f1: /* movbe My,Gy */\n                if (!(s->cpuid_ext_features & CPUID_EXT_MOVBE)) {\n                    goto illegal_op;\n                }\n                if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                gen_lea_modrm(env, s, modrm);\n                if ((b & 1) == 0) {\n                    tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                } else {\n                    tcg_gen_qemu_st_tl(cpu_regs[reg], cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                }\n                break;\n\n            case 0x0f2: /* andn Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_andc_tl(cpu_T0, cpu_regs[s->vex_v], cpu_T0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_LOGICB + ot);\n                break;\n\n            case 0x0f7: /* bextr Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                {\n                    TCGv bound, zero;\n\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                    /* Extract START, and shift the operand.\n                       Shifts larger than operand size get zeros.  */\n                    tcg_gen_ext8u_tl(cpu_A0, cpu_regs[s->vex_v]);\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_A0);\n\n                    bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    zero = tcg_const_tl(0);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_T0, cpu_A0, bound,\n                                       cpu_T0, zero);\n                    tcg_temp_free(zero);\n\n                    /* Extract the LEN into a mask.  Lengths larger than\n                       operand size get all ones.  */\n                    tcg_gen_extract_tl(cpu_A0, cpu_regs[s->vex_v], 8, 8);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_A0, cpu_A0, bound,\n                                       cpu_A0, bound);\n                    tcg_temp_free(bound);\n                    tcg_gen_movi_tl(cpu_T1, 1);\n                    tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_A0);\n                    tcg_gen_subi_tl(cpu_T1, cpu_T1, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                    gen_op_update1_cc();\n                    set_cc_op(s, CC_OP_LOGICB + ot);\n                }\n                break;\n\n            case 0x0f5: /* bzhi Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                {\n                    TCGv bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    /* Note that since we're using BMILG (in order to get O\n                       cleared) we need to store the inverse into C.  */\n                    tcg_gen_setcond_tl(TCG_COND_LT, cpu_cc_src,\n                                       cpu_T1, bound);\n                    tcg_gen_movcond_tl(TCG_COND_GT, cpu_T1, cpu_T1,\n                                       bound, bound, cpu_T1);\n                    tcg_temp_free(bound);\n                }\n                tcg_gen_movi_tl(cpu_A0, -1);\n                tcg_gen_shl_tl(cpu_A0, cpu_A0, cpu_T1);\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_BMILGB + ot);\n                break;\n\n            case 0x3f6: /* mulx By, Gy, rdx, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                switch (ot) {\n                default:\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EDX]);\n                    tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                      cpu_tmp2_i32, cpu_tmp3_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[s->vex_v], cpu_tmp2_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp3_i32);\n                    break;\n#ifdef TARGET_X86_64\n                case MO_64:\n                    tcg_gen_mulu2_i64(cpu_T0, cpu_T1,\n                                      cpu_T0, cpu_regs[R_EDX]);\n                    tcg_gen_mov_i64(cpu_regs[s->vex_v], cpu_T0);\n                    tcg_gen_mov_i64(cpu_regs[reg], cpu_T1);\n                    break;\n#endif\n                }\n                break;\n\n            case 0x3f5: /* pdep Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pdep(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x2f5: /* pext Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pext(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x1f6: /* adcx Gy, Ey */\n            case 0x2f6: /* adox Gy, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_ADX)) {\n                    goto illegal_op;\n                } else {\n                    TCGv carry_in, carry_out, zero;\n                    int end_op;\n\n                    ot = mo_64_32(s->dflag);\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                    /* Re-use the carry-out from a previous round.  */\n                    TCGV_UNUSED(carry_in);\n                    carry_out = (b == 0x1f6 ? cpu_cc_dst : cpu_cc_src2);\n                    switch (s->cc_op) {\n                    case CC_OP_ADCX:\n                        if (b == 0x1f6) {\n                            carry_in = cpu_cc_dst;\n                            end_op = CC_OP_ADCX;\n                        } else {\n                            end_op = CC_OP_ADCOX;\n                        }\n                        break;\n                    case CC_OP_ADOX:\n                        if (b == 0x1f6) {\n                            end_op = CC_OP_ADCOX;\n                        } else {\n                            carry_in = cpu_cc_src2;\n                            end_op = CC_OP_ADOX;\n                        }\n                        break;\n                    case CC_OP_ADCOX:\n                        end_op = CC_OP_ADCOX;\n                        carry_in = carry_out;\n                        break;\n                    default:\n                        end_op = (b == 0x1f6 ? CC_OP_ADCX : CC_OP_ADOX);\n                        break;\n                    }\n                    /* If we can't reuse carry-out, get it out of EFLAGS.  */\n                    if (TCGV_IS_UNUSED(carry_in)) {\n                        if (s->cc_op != CC_OP_ADCX && s->cc_op != CC_OP_ADOX) {\n                            gen_compute_eflags(s);\n                        }\n                        carry_in = cpu_tmp0;\n                        tcg_gen_extract_tl(carry_in, cpu_cc_src,\n                                           ctz32(b == 0x1f6 ? CC_C : CC_O), 1);\n                    }\n\n                    switch (ot) {\n#ifdef TARGET_X86_64\n                    case MO_32:\n                        /* If we know TL is 64-bit, and we want a 32-bit\n                           result, just do everything in 64-bit arithmetic.  */\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_regs[reg]);\n                        tcg_gen_ext32u_i64(cpu_T0, cpu_T0);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, cpu_regs[reg]);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, carry_in);\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_T0);\n                        tcg_gen_shri_i64(carry_out, cpu_T0, 32);\n                        break;\n#endif\n                    default:\n                        /* Otherwise compute the carry-out in two steps.  */\n                        zero = tcg_const_tl(0);\n                        tcg_gen_add2_tl(cpu_T0, carry_out,\n                                        cpu_T0, zero,\n                                        carry_in, zero);\n                        tcg_gen_add2_tl(cpu_regs[reg], carry_out,\n                                        cpu_regs[reg], carry_out,\n                                        cpu_T0, zero);\n                        tcg_temp_free(zero);\n                        break;\n                    }\n                    set_cc_op(s, end_op);\n                }\n                break;\n\n            case 0x1f7: /* shlx Gy, Ey, By */\n            case 0x2f7: /* sarx Gy, Ey, By */\n            case 0x3f7: /* shrx Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                if (ot == MO_64) {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 63);\n                } else {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 31);\n                }\n                if (b == 0x1f7) {\n                    tcg_gen_shl_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else if (b == 0x2f7) {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_sar_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_T1);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x0f3:\n            case 0x1f3:\n            case 0x2f3:\n            case 0x3f3: /* Group 17 */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                switch (reg & 7) {\n                case 1: /* blsr By,Ey */\n                    tcg_gen_neg_tl(cpu_T1, cpu_T0);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n                    gen_op_mov_reg_v(ot, s->vex_v, cpu_T0);\n                    gen_op_update2_cc();\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 2: /* blsmsk By,Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 3: /* blsi By, Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                default:\n                    goto unknown_op;\n                }\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        case 0x03a:\n        case 0x13a:\n            b = modrm;\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_eppi = sse_op_table7[b].op[b1];\n            if (!sse_fn_eppi) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table7[b].ext_mask))\n                goto illegal_op;\n\n            if (sse_fn_eppi == SSE_SPECIAL) {\n                ot = mo_64_32(s->dflag);\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3)\n                    gen_lea_modrm(env, s, modrm);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                val = cpu_ldub_code(env, s->pc++);\n                switch (b) {\n                case 0x14: /* pextrb */\n                    tcg_gen_ld8u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    break;\n                case 0x15: /* pextrw */\n                    tcg_gen_ld16u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_W(val & 7)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                    }\n                    break;\n                case 0x16:\n                    if (ot == MO_32) { /* pextrd */\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                        if (mod == 3) {\n                            tcg_gen_extu_i32_tl(cpu_regs[rm], cpu_tmp2_i32);\n                        } else {\n                            tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                    } else { /* pextrq */\n#ifdef TARGET_X86_64\n                        tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n                        if (mod == 3) {\n                            tcg_gen_mov_i64(cpu_regs[rm], cpu_tmp1_i64);\n                        } else {\n                            tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                case 0x17: /* extractps */\n                    tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_L(val & 3)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUL);\n                    }\n                    break;\n                case 0x20: /* pinsrb */\n                    if (mod == 3) {\n                        gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n                    } else {\n                        tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    tcg_gen_st8_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    break;\n                case 0x21: /* insertps */\n                    if (mod == 3) {\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,xmm_regs[rm]\n                                                .ZMM_L((val >> 6) & 3)));\n                    } else {\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                    tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                    offsetof(CPUX86State,xmm_regs[reg]\n                                            .ZMM_L((val >> 4) & 3)));\n                    if ((val >> 0) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(0)));\n                    if ((val >> 1) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(1)));\n                    if ((val >> 2) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(2)));\n                    if ((val >> 3) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(3)));\n                    break;\n                case 0x22:\n                    if (ot == MO_32) { /* pinsrd */\n                        if (mod == 3) {\n                            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[rm]);\n                        } else {\n                            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                    } else { /* pinsrq */\n#ifdef TARGET_X86_64\n                        if (mod == 3) {\n                            gen_op_mov_v_reg(ot, cpu_tmp1_i64, rm);\n                        } else {\n                            tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n                        tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                }\n                return;\n            }\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldo_env_A0(s, op2_offset);\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            val = cpu_ldub_code(env, s->pc++);\n\n            if ((b & 0xfc) == 0x60) { /* pcmpXstrX */\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                if (s->dflag == MO_64) {\n                    /* The helper must use entire 64-bit gp registers */\n                    val |= 1 << 8;\n                }\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_eppi(cpu_env, cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n\n        case 0x33a:\n            /* Various integer extensions at 0f 3a f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* rorx Gy,Ey, Ib */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                b = cpu_ldub_code(env, s->pc++);\n                if (ot == MO_64) {\n                    tcg_gen_rotri_tl(cpu_T0, cpu_T0, b & 63);\n                } else {\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_rotri_i32(cpu_tmp2_i32, cpu_tmp2_i32, b & 31);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        default:\n        unknown_op:\n            gen_unknown_opcode(env, s);\n            return;\n        }\n    } else {\n        /* generic MMX or SSE operation */\n        switch(b) {\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n        case 0xc2: /* compare insns */\n            s->rip_offset = 1;\n            break;\n        default:\n            break;\n        }\n        if (is_xmm) {\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            if (mod != 3) {\n                int sz = 4;\n\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                switch (b) {\n                case 0x50 ... 0x5a:\n                case 0x5c ... 0x5f:\n                case 0xc2:\n                    /* Most sse scalar operations.  */\n                    if (b1 == 2) {\n                        sz = 2;\n                    } else if (b1 == 3) {\n                        sz = 3;\n                    }\n                    break;\n\n                case 0x2e:  /* ucomis[sd] */\n                case 0x2f:  /* comis[sd] */\n                    if (b1 == 0) {\n                        sz = 2;\n                    } else {\n                        sz = 3;\n                    }\n                    break;\n                }\n\n                switch (sz) {\n                case 2:\n                    /* 32 bit access */\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env,\n                                    offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                    break;\n                case 3:\n                    /* 64 bit access */\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_D(0)));\n                    break;\n                default:\n                    /* 128 bit access */\n                    gen_ldo_env_A0(s, op2_offset);\n                    break;\n                }\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n        } else {\n            op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n        }\n        switch(b) {\n        case 0x0f: /* 3DNow! data insns */\n            val = cpu_ldub_code(env, s->pc++);\n            sse_fn_epp = sse_op_table5[val];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n                goto illegal_op;\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n            val = cpu_ldub_code(env, s->pc++);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_ppi = (SSEFunc_0_ppi)sse_fn_epp;\n            sse_fn_ppi(cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n        case 0xc2:\n            /* compare insns */\n            val = cpu_ldub_code(env, s->pc++);\n            if (val >= 8)\n                goto unknown_op;\n            sse_fn_epp = sse_op_table4[val][b1];\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0xf7:\n            /* maskmov : we must prepare A0 */\n            if (mod != 3)\n                goto illegal_op;\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EDI]);\n            gen_extu(s->aflag, cpu_A0);\n            gen_add_A0_ds_seg(s);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_eppt = (SSEFunc_0_eppt)sse_fn_epp;\n            sse_fn_eppt(cpu_env, cpu_ptr0, cpu_ptr1, cpu_A0);\n            break;\n        default:\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        }\n        if (b == 0x2e || b == 0x2f) {\n            set_cc_op(s, CC_OP_EFLAGS);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static void gen_sse(CPUX86State *env, DisasContext *s, int b,\n                    target_ulong pc_start, int rex_r)\n{\n    int b1, op1_offset, op2_offset, is_xmm, val;\n    int modrm, mod, rm, reg;\n    SSEFunc_0_epp sse_fn_epp;\n    SSEFunc_0_eppi sse_fn_eppi;\n    SSEFunc_0_ppi sse_fn_ppi;\n    SSEFunc_0_eppt sse_fn_eppt;\n    TCGMemOp ot;\n\n    b &= 0xff;\n    if (s->prefix & PREFIX_DATA)\n        b1 = 1;\n    else if (s->prefix & PREFIX_REPZ)\n        b1 = 2;\n    else if (s->prefix & PREFIX_REPNZ)\n        b1 = 3;\n    else\n        b1 = 0;\n    sse_fn_epp = sse_op_table1[b][b1];\n    if (!sse_fn_epp) {\n        goto unknown_op;\n    }\n    if ((b <= 0x5f && b >= 0x10) || b == 0xc6 || b == 0xc2) {\n        is_xmm = 1;\n    } else {\n        if (b1 == 0) {\n            /* MMX case */\n            is_xmm = 0;\n        } else {\n            is_xmm = 1;\n        }\n    }\n    /* simple MMX/SSE operation */\n    if (s->flags & HF_TS_MASK) {\n        gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);\n        return;\n    }\n    if (s->flags & HF_EM_MASK) {\n    illegal_op:\n        gen_illegal_opcode(s);\n        return;\n    }\n    if (is_xmm\n        && !(s->flags & HF_OSFXSR_MASK)\n        && ((b != 0x38 && b != 0x3a) || (s->prefix & PREFIX_DATA))) {\n        goto unknown_op;\n    }\n    if (b == 0x0e) {\n        if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n            /* If we were fully decoding this we might use illegal_op.  */\n            goto unknown_op;\n        }\n        /* femms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    if (b == 0x77) {\n        /* emms */\n        gen_helper_emms(cpu_env);\n        return;\n    }\n    /* prepare MMX state (XXX: optimize by storing fptt and fptags in\n       the static cpu state) */\n    if (!is_xmm) {\n        gen_helper_enter_mmx(cpu_env);\n    }\n\n    modrm = cpu_ldub_code(env, s->pc++);\n    reg = ((modrm >> 3) & 7);\n    if (is_xmm)\n        reg |= rex_r;\n    mod = (modrm >> 6) & 3;\n    if (sse_fn_epp == SSE_SPECIAL) {\n        b |= (b1 << 8);\n        switch(b) {\n        case 0x0e7: /* movntq */\n            if (mod == 3) {\n                goto illegal_op;\n            }\n            gen_lea_modrm(env, s, modrm);\n            gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            break;\n        case 0x1e7: /* movntdq */\n        case 0x02b: /* movntps */\n        case 0x12b: /* movntps */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x3f0: /* lddqu */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            break;\n        case 0x22b: /* movntss */\n        case 0x32b: /* movntsd */\n            if (mod == 3)\n                goto illegal_op;\n            gen_lea_modrm(env, s, modrm);\n            if (b1 & 1) {\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                    xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            }\n            break;\n        case 0x6e: /* movd mm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State,fpregs[reg].mmx));\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,fpregs[reg].mmx));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_mmx(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x16e: /* movd xmm, ea */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                gen_helper_movq_mm_T0_xmm(cpu_ptr0, cpu_T0);\n            } else\n#endif\n            {\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 0);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                                 offsetof(CPUX86State,xmm_regs[reg]));\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                gen_helper_movl_mm_T0_xmm(cpu_ptr0, cpu_tmp2_i32);\n            }\n            break;\n        case 0x6f: /* movq mm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[rm].mmx));\n                tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x010: /* movups */\n        case 0x110: /* movupd */\n        case 0x028: /* movaps */\n        case 0x128: /* movapd */\n        case 0x16f: /* movdqa xmm, ea */\n        case 0x26f: /* movdqu xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[reg]),\n                            offsetof(CPUX86State,xmm_regs[rm]));\n            }\n            break;\n        case 0x210: /* movss xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n            }\n            break;\n        case 0x310: /* movsd xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x012: /* movlps */\n        case 0x112: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                /* movhlps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x212: /* movsldup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(2)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)));\n            break;\n        case 0x312: /* movddup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            break;\n        case 0x016: /* movhps */\n        case 0x116: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                /* movlhps */\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            break;\n        case 0x216: /* movshdup */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldo_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(1)));\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_L(3)));\n            }\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(1)));\n            gen_op_movl(offsetof(CPUX86State,xmm_regs[reg].ZMM_L(2)),\n                        offsetof(CPUX86State,xmm_regs[reg].ZMM_L(3)));\n            break;\n        case 0x178:\n        case 0x378:\n            {\n                int bit_index, field_length;\n\n                if (b1 == 1 && reg != 0)\n                    goto illegal_op;\n                field_length = cpu_ldub_code(env, s->pc++) & 0x3F;\n                bit_index = cpu_ldub_code(env, s->pc++) & 0x3F;\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env,\n                    offsetof(CPUX86State,xmm_regs[reg]));\n                if (b1 == 1)\n                    gen_helper_extrq_i(cpu_env, cpu_ptr0,\n                                       tcg_const_i32(bit_index),\n                                       tcg_const_i32(field_length));\n                else\n                    gen_helper_insertq_i(cpu_env, cpu_ptr0,\n                                         tcg_const_i32(bit_index),\n                                         tcg_const_i32(field_length));\n            }\n            break;\n        case 0x7e: /* movd ea, mm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,fpregs[reg].mmx));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,fpregs[reg].mmx.MMX_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x17e: /* movd ea, xmm */\n#ifdef TARGET_X86_64\n            if (s->dflag == MO_64) {\n                tcg_gen_ld_i64(cpu_T0, cpu_env,\n                               offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_ldst_modrm(env, s, modrm, MO_64, OR_TMP0, 1);\n            } else\n#endif\n            {\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_ldst_modrm(env, s, modrm, MO_32, OR_TMP0, 1);\n            }\n            break;\n        case 0x27e: /* movq xmm, ea */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_ldq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            }\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x7f: /* movq ea, mm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State, fpregs[reg].mmx));\n            } else {\n                rm = (modrm & 7);\n                gen_op_movq(offsetof(CPUX86State,fpregs[rm].mmx),\n                            offsetof(CPUX86State,fpregs[reg].mmx));\n            }\n            break;\n        case 0x011: /* movups */\n        case 0x111: /* movupd */\n        case 0x029: /* movaps */\n        case 0x129: /* movapd */\n        case 0x17f: /* movdqa ea, xmm */\n        case 0x27f: /* movdqu ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_sto_env_A0(s, offsetof(CPUX86State, xmm_regs[reg]));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movo(offsetof(CPUX86State,xmm_regs[rm]),\n                            offsetof(CPUX86State,xmm_regs[reg]));\n            }\n            break;\n        case 0x211: /* movss ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n                gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movl(offsetof(CPUX86State,xmm_regs[rm].ZMM_L(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_L(0)));\n            }\n            break;\n        case 0x311: /* movsd ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n            }\n            break;\n        case 0x013: /* movlps */\n        case 0x113: /* movlpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x017: /* movhps */\n        case 0x117: /* movhpd */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(1)));\n            } else {\n                goto illegal_op;\n            }\n            break;\n        case 0x71: /* shift mm, im */\n        case 0x72:\n        case 0x73:\n        case 0x171: /* shift xmm, im */\n        case 0x172:\n        case 0x173:\n            if (b1 >= 2) {\n\t        goto unknown_op;\n            }\n            val = cpu_ldub_code(env, s->pc++);\n            if (is_xmm) {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(1)));\n                op1_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                tcg_gen_movi_tl(cpu_T0, val);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(0)));\n                tcg_gen_movi_tl(cpu_T0, 0);\n                tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,mmx_t0.MMX_L(1)));\n                op1_offset = offsetof(CPUX86State,mmx_t0);\n            }\n            sse_fn_epp = sse_op_table2[((b - 1) & 3) * 8 +\n                                       (((modrm >> 3)) & 7)][b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (is_xmm) {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op1_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x050: /* movmskps */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskps(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x150: /* movmskpd */\n            rm = (modrm & 7) | REX_B(s);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, \n                             offsetof(CPUX86State,xmm_regs[rm]));\n            gen_helper_movmskpd(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n        case 0x02a: /* cvtpi2ps */\n        case 0x12a: /* cvtpi2pd */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b >> 8) {\n            case 0x0:\n                gen_helper_cvtpi2ps(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            default:\n            case 0x1:\n                gen_helper_cvtpi2pd(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22a: /* cvtsi2ss */\n        case 0x32a: /* cvtsi2sd */\n            ot = mo_64_32(s->dflag);\n            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            if (ot == MO_32) {\n                SSEFunc_0_epi sse_fn_epi = sse_op_table3ai[(b >> 8) & 1];\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                sse_fn_epi(cpu_env, cpu_ptr0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_0_epl sse_fn_epl = sse_op_table3aq[(b >> 8) & 1];\n                sse_fn_epl(cpu_env, cpu_ptr0, cpu_T0);\n#else\n                goto illegal_op;\n#endif\n            }\n            break;\n        case 0x02c: /* cvttps2pi */\n        case 0x12c: /* cvttpd2pi */\n        case 0x02d: /* cvtps2pi */\n        case 0x12d: /* cvtpd2pi */\n            gen_helper_enter_mmx(cpu_env);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n                gen_ldo_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            op1_offset = offsetof(CPUX86State,fpregs[reg & 7].mmx);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            switch(b) {\n            case 0x02c:\n                gen_helper_cvttps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12c:\n                gen_helper_cvttpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x02d:\n                gen_helper_cvtps2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            case 0x12d:\n                gen_helper_cvtpd2pi(cpu_env, cpu_ptr0, cpu_ptr1);\n                break;\n            }\n            break;\n        case 0x22c: /* cvttss2si */\n        case 0x32c: /* cvttsd2si */\n        case 0x22d: /* cvtss2si */\n        case 0x32d: /* cvtsd2si */\n            ot = mo_64_32(s->dflag);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                if ((b >> 8) & 1) {\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_Q(0)));\n                } else {\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env, offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                }\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op2_offset);\n            if (ot == MO_32) {\n                SSEFunc_i_ep sse_fn_i_ep =\n                    sse_op_table3bi[((b >> 7) & 2) | (b & 1)];\n                sse_fn_i_ep(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n                tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n            } else {\n#ifdef TARGET_X86_64\n                SSEFunc_l_ep sse_fn_l_ep =\n                    sse_op_table3bq[((b >> 7) & 2) | (b & 1)];\n                sse_fn_l_ep(cpu_T0, cpu_env, cpu_ptr0);\n#else\n                goto illegal_op;\n#endif\n            }\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0xc4: /* pinsrw */\n        case 0x1c4:\n            s->rip_offset = 1;\n            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,xmm_regs[reg].ZMM_W(val)));\n            } else {\n                val &= 3;\n                tcg_gen_st16_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[reg].mmx.MMX_W(val)));\n            }\n            break;\n        case 0xc5: /* pextrw */\n        case 0x1c5:\n            if (mod != 3)\n                goto illegal_op;\n            ot = mo_64_32(s->dflag);\n            val = cpu_ldub_code(env, s->pc++);\n            if (b1) {\n                val &= 7;\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                 offsetof(CPUX86State,xmm_regs[rm].ZMM_W(val)));\n            } else {\n                val &= 3;\n                rm = (modrm & 7);\n                tcg_gen_ld16u_tl(cpu_T0, cpu_env,\n                                offsetof(CPUX86State,fpregs[rm].mmx.MMX_W(val)));\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            gen_op_mov_reg_v(ot, reg, cpu_T0);\n            break;\n        case 0x1d6: /* movq ea, xmm */\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                gen_stq_env_A0(s, offsetof(CPUX86State,\n                                           xmm_regs[reg].ZMM_Q(0)));\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                gen_op_movq(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)),\n                            offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)));\n                gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(1)));\n            }\n            break;\n        case 0x2d6: /* movq2dq */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7);\n            gen_op_movq(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(0)),\n                        offsetof(CPUX86State,fpregs[rm].mmx));\n            gen_op_movq_env_0(offsetof(CPUX86State,xmm_regs[reg].ZMM_Q(1)));\n            break;\n        case 0x3d6: /* movdq2q */\n            gen_helper_enter_mmx(cpu_env);\n            rm = (modrm & 7) | REX_B(s);\n            gen_op_movq(offsetof(CPUX86State,fpregs[reg & 7].mmx),\n                        offsetof(CPUX86State,xmm_regs[rm].ZMM_Q(0)));\n            break;\n        case 0xd7: /* pmovmskb */\n        case 0x1d7:\n            if (mod != 3)\n                goto illegal_op;\n            if (b1) {\n                rm = (modrm & 7) | REX_B(s);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,xmm_regs[rm]));\n                gen_helper_pmovmskb_xmm(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            } else {\n                rm = (modrm & 7);\n                tcg_gen_addi_ptr(cpu_ptr0, cpu_env, offsetof(CPUX86State,fpregs[rm].mmx));\n                gen_helper_pmovmskb_mmx(cpu_tmp2_i32, cpu_env, cpu_ptr0);\n            }\n            reg = ((modrm >> 3) & 7) | rex_r;\n            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);\n            break;\n\n        case 0x138:\n        case 0x038:\n            b = modrm;\n            if ((b & 0xf0) == 0xf0) {\n                goto do_0f_38_fx;\n            }\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_epp = sse_op_table6[b].op[b1];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table6[b].ext_mask))\n                goto illegal_op;\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    switch (b) {\n                    case 0x20: case 0x30: /* pmovsxbw, pmovzxbw */\n                    case 0x23: case 0x33: /* pmovsxwd, pmovzxwd */\n                    case 0x25: case 0x35: /* pmovsxdq, pmovzxdq */\n                        gen_ldq_env_A0(s, op2_offset +\n                                        offsetof(ZMMReg, ZMM_Q(0)));\n                        break;\n                    case 0x21: case 0x31: /* pmovsxbd, pmovzxbd */\n                    case 0x24: case 0x34: /* pmovsxwq, pmovzxwq */\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_L(0)));\n                        break;\n                    case 0x22: case 0x32: /* pmovsxbq, pmovzxbq */\n                        tcg_gen_qemu_ld_tl(cpu_tmp0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                        tcg_gen_st16_tl(cpu_tmp0, cpu_env, op2_offset +\n                                        offsetof(ZMMReg, ZMM_W(0)));\n                        break;\n                    case 0x2a:            /* movntqda */\n                        gen_ldo_env_A0(s, op1_offset);\n                        return;\n                    default:\n                        gen_ldo_env_A0(s, op2_offset);\n                    }\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            if (sse_fn_epp == SSE_SPECIAL) {\n                goto unknown_op;\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n\n            if (b == 0x17) {\n                set_cc_op(s, CC_OP_EFLAGS);\n            }\n            break;\n\n        case 0x238:\n        case 0x338:\n        do_0f_38_fx:\n            /* Various integer extensions at 0f 38 f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* crc32 Gd,Eb */\n            case 0x3f1: /* crc32 Gd,Ey */\n            do_crc32:\n                if (!(s->cpuid_ext_features & CPUID_EXT_SSE42)) {\n                    goto illegal_op;\n                }\n                if ((b & 0xff) == 0xf0) {\n                    ot = MO_8;\n                } else if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[reg]);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                gen_helper_crc32(cpu_T0, cpu_tmp2_i32,\n                                 cpu_T0, tcg_const_i32(8 << ot));\n\n                ot = mo_64_32(s->dflag);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x1f0: /* crc32 or movbe */\n            case 0x1f1:\n                /* For these insns, the f3 prefix is supposed to have priority\n                   over the 66 prefix, but that's not what we implement above\n                   setting b1.  */\n                if (s->prefix & PREFIX_REPNZ) {\n                    goto do_crc32;\n                }\n                /* FALLTHRU */\n            case 0x0f0: /* movbe Gy,My */\n            case 0x0f1: /* movbe My,Gy */\n                if (!(s->cpuid_ext_features & CPUID_EXT_MOVBE)) {\n                    goto illegal_op;\n                }\n                if (s->dflag != MO_64) {\n                    ot = (s->prefix & PREFIX_DATA ? MO_16 : MO_32);\n                } else {\n                    ot = MO_64;\n                }\n\n                gen_lea_modrm(env, s, modrm);\n                if ((b & 1) == 0) {\n                    tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                } else {\n                    tcg_gen_qemu_st_tl(cpu_regs[reg], cpu_A0,\n                                       s->mem_index, ot | MO_BE);\n                }\n                break;\n\n            case 0x0f2: /* andn Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_andc_tl(cpu_T0, cpu_regs[s->vex_v], cpu_T0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_LOGICB + ot);\n                break;\n\n            case 0x0f7: /* bextr Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                {\n                    TCGv bound, zero;\n\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                    /* Extract START, and shift the operand.\n                       Shifts larger than operand size get zeros.  */\n                    tcg_gen_ext8u_tl(cpu_A0, cpu_regs[s->vex_v]);\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_A0);\n\n                    bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    zero = tcg_const_tl(0);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_T0, cpu_A0, bound,\n                                       cpu_T0, zero);\n                    tcg_temp_free(zero);\n\n                    /* Extract the LEN into a mask.  Lengths larger than\n                       operand size get all ones.  */\n                    tcg_gen_extract_tl(cpu_A0, cpu_regs[s->vex_v], 8, 8);\n                    tcg_gen_movcond_tl(TCG_COND_LEU, cpu_A0, cpu_A0, bound,\n                                       cpu_A0, bound);\n                    tcg_temp_free(bound);\n                    tcg_gen_movi_tl(cpu_T1, 1);\n                    tcg_gen_shl_tl(cpu_T1, cpu_T1, cpu_A0);\n                    tcg_gen_subi_tl(cpu_T1, cpu_T1, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n\n                    gen_op_mov_reg_v(ot, reg, cpu_T0);\n                    gen_op_update1_cc();\n                    set_cc_op(s, CC_OP_LOGICB + ot);\n                }\n                break;\n\n            case 0x0f5: /* bzhi Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                tcg_gen_ext8u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                {\n                    TCGv bound = tcg_const_tl(ot == MO_64 ? 63 : 31);\n                    /* Note that since we're using BMILG (in order to get O\n                       cleared) we need to store the inverse into C.  */\n                    tcg_gen_setcond_tl(TCG_COND_LT, cpu_cc_src,\n                                       cpu_T1, bound);\n                    tcg_gen_movcond_tl(TCG_COND_GT, cpu_T1, cpu_T1,\n                                       bound, bound, cpu_T1);\n                    tcg_temp_free(bound);\n                }\n                tcg_gen_movi_tl(cpu_A0, -1);\n                tcg_gen_shl_tl(cpu_A0, cpu_A0, cpu_T1);\n                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_A0);\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                gen_op_update1_cc();\n                set_cc_op(s, CC_OP_BMILGB + ot);\n                break;\n\n            case 0x3f6: /* mulx By, Gy, rdx, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                switch (ot) {\n                default:\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EDX]);\n                    tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,\n                                      cpu_tmp2_i32, cpu_tmp3_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[s->vex_v], cpu_tmp2_i32);\n                    tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp3_i32);\n                    break;\n#ifdef TARGET_X86_64\n                case MO_64:\n                    tcg_gen_mulu2_i64(cpu_T0, cpu_T1,\n                                      cpu_T0, cpu_regs[R_EDX]);\n                    tcg_gen_mov_i64(cpu_regs[s->vex_v], cpu_T0);\n                    tcg_gen_mov_i64(cpu_regs[reg], cpu_T1);\n                    break;\n#endif\n                }\n                break;\n\n            case 0x3f5: /* pdep Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pdep(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x2f5: /* pext Gy, By, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                /* Note that by zero-extending the mask operand, we\n                   automatically handle zero-extending the result.  */\n                if (ot == MO_64) {\n                    tcg_gen_mov_tl(cpu_T1, cpu_regs[s->vex_v]);\n                } else {\n                    tcg_gen_ext32u_tl(cpu_T1, cpu_regs[s->vex_v]);\n                }\n                gen_helper_pext(cpu_regs[reg], cpu_T0, cpu_T1);\n                break;\n\n            case 0x1f6: /* adcx Gy, Ey */\n            case 0x2f6: /* adox Gy, Ey */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_ADX)) {\n                    goto illegal_op;\n                } else {\n                    TCGv carry_in, carry_out, zero;\n                    int end_op;\n\n                    ot = mo_64_32(s->dflag);\n                    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                    /* Re-use the carry-out from a previous round.  */\n                    TCGV_UNUSED(carry_in);\n                    carry_out = (b == 0x1f6 ? cpu_cc_dst : cpu_cc_src2);\n                    switch (s->cc_op) {\n                    case CC_OP_ADCX:\n                        if (b == 0x1f6) {\n                            carry_in = cpu_cc_dst;\n                            end_op = CC_OP_ADCX;\n                        } else {\n                            end_op = CC_OP_ADCOX;\n                        }\n                        break;\n                    case CC_OP_ADOX:\n                        if (b == 0x1f6) {\n                            end_op = CC_OP_ADCOX;\n                        } else {\n                            carry_in = cpu_cc_src2;\n                            end_op = CC_OP_ADOX;\n                        }\n                        break;\n                    case CC_OP_ADCOX:\n                        end_op = CC_OP_ADCOX;\n                        carry_in = carry_out;\n                        break;\n                    default:\n                        end_op = (b == 0x1f6 ? CC_OP_ADCX : CC_OP_ADOX);\n                        break;\n                    }\n                    /* If we can't reuse carry-out, get it out of EFLAGS.  */\n                    if (TCGV_IS_UNUSED(carry_in)) {\n                        if (s->cc_op != CC_OP_ADCX && s->cc_op != CC_OP_ADOX) {\n                            gen_compute_eflags(s);\n                        }\n                        carry_in = cpu_tmp0;\n                        tcg_gen_extract_tl(carry_in, cpu_cc_src,\n                                           ctz32(b == 0x1f6 ? CC_C : CC_O), 1);\n                    }\n\n                    switch (ot) {\n#ifdef TARGET_X86_64\n                    case MO_32:\n                        /* If we know TL is 64-bit, and we want a 32-bit\n                           result, just do everything in 64-bit arithmetic.  */\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_regs[reg]);\n                        tcg_gen_ext32u_i64(cpu_T0, cpu_T0);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, cpu_regs[reg]);\n                        tcg_gen_add_i64(cpu_T0, cpu_T0, carry_in);\n                        tcg_gen_ext32u_i64(cpu_regs[reg], cpu_T0);\n                        tcg_gen_shri_i64(carry_out, cpu_T0, 32);\n                        break;\n#endif\n                    default:\n                        /* Otherwise compute the carry-out in two steps.  */\n                        zero = tcg_const_tl(0);\n                        tcg_gen_add2_tl(cpu_T0, carry_out,\n                                        cpu_T0, zero,\n                                        carry_in, zero);\n                        tcg_gen_add2_tl(cpu_regs[reg], carry_out,\n                                        cpu_regs[reg], carry_out,\n                                        cpu_T0, zero);\n                        tcg_temp_free(zero);\n                        break;\n                    }\n                    set_cc_op(s, end_op);\n                }\n                break;\n\n            case 0x1f7: /* shlx Gy, Ey, By */\n            case 0x2f7: /* sarx Gy, Ey, By */\n            case 0x3f7: /* shrx Gy, Ey, By */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                if (ot == MO_64) {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 63);\n                } else {\n                    tcg_gen_andi_tl(cpu_T1, cpu_regs[s->vex_v], 31);\n                }\n                if (b == 0x1f7) {\n                    tcg_gen_shl_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else if (b == 0x2f7) {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32s_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_sar_tl(cpu_T0, cpu_T0, cpu_T1);\n                } else {\n                    if (ot != MO_64) {\n                        tcg_gen_ext32u_tl(cpu_T0, cpu_T0);\n                    }\n                    tcg_gen_shr_tl(cpu_T0, cpu_T0, cpu_T1);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            case 0x0f3:\n            case 0x1f3:\n            case 0x2f3:\n            case 0x3f3: /* Group 17 */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n                switch (reg & 7) {\n                case 1: /* blsr By,Ey */\n                    tcg_gen_neg_tl(cpu_T1, cpu_T0);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_T1);\n                    gen_op_mov_reg_v(ot, s->vex_v, cpu_T0);\n                    gen_op_update2_cc();\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 2: /* blsmsk By,Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                case 3: /* blsi By, Ey */\n                    tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n                    tcg_gen_subi_tl(cpu_T0, cpu_T0, 1);\n                    tcg_gen_and_tl(cpu_T0, cpu_T0, cpu_cc_src);\n                    tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);\n                    set_cc_op(s, CC_OP_BMILGB + ot);\n                    break;\n\n                default:\n                    goto unknown_op;\n                }\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        case 0x03a:\n        case 0x13a:\n            b = modrm;\n            modrm = cpu_ldub_code(env, s->pc++);\n            rm = modrm & 7;\n            reg = ((modrm >> 3) & 7) | rex_r;\n            mod = (modrm >> 6) & 3;\n            if (b1 >= 2) {\n                goto unknown_op;\n            }\n\n            sse_fn_eppi = sse_op_table7[b].op[b1];\n            if (!sse_fn_eppi) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext_features & sse_op_table7[b].ext_mask))\n                goto illegal_op;\n\n            if (sse_fn_eppi == SSE_SPECIAL) {\n                ot = mo_64_32(s->dflag);\n                rm = (modrm & 7) | REX_B(s);\n                if (mod != 3)\n                    gen_lea_modrm(env, s, modrm);\n                reg = ((modrm >> 3) & 7) | rex_r;\n                val = cpu_ldub_code(env, s->pc++);\n                switch (b) {\n                case 0x14: /* pextrb */\n                    tcg_gen_ld8u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    break;\n                case 0x15: /* pextrw */\n                    tcg_gen_ld16u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_W(val & 7)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUW);\n                    }\n                    break;\n                case 0x16:\n                    if (ot == MO_32) { /* pextrd */\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                        if (mod == 3) {\n                            tcg_gen_extu_i32_tl(cpu_regs[rm], cpu_tmp2_i32);\n                        } else {\n                            tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                    } else { /* pextrq */\n#ifdef TARGET_X86_64\n                        tcg_gen_ld_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n                        if (mod == 3) {\n                            tcg_gen_mov_i64(cpu_regs[rm], cpu_tmp1_i64);\n                        } else {\n                            tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                case 0x17: /* extractps */\n                    tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_L(val & 3)));\n                    if (mod == 3) {\n                        gen_op_mov_reg_v(ot, rm, cpu_T0);\n                    } else {\n                        tcg_gen_qemu_st_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_LEUL);\n                    }\n                    break;\n                case 0x20: /* pinsrb */\n                    if (mod == 3) {\n                        gen_op_mov_v_reg(MO_32, cpu_T0, rm);\n                    } else {\n                        tcg_gen_qemu_ld_tl(cpu_T0, cpu_A0,\n                                           s->mem_index, MO_UB);\n                    }\n                    tcg_gen_st8_tl(cpu_T0, cpu_env, offsetof(CPUX86State,\n                                            xmm_regs[reg].ZMM_B(val & 15)));\n                    break;\n                case 0x21: /* insertps */\n                    if (mod == 3) {\n                        tcg_gen_ld_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,xmm_regs[rm]\n                                                .ZMM_L((val >> 6) & 3)));\n                    } else {\n                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                            s->mem_index, MO_LEUL);\n                    }\n                    tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                    offsetof(CPUX86State,xmm_regs[reg]\n                                            .ZMM_L((val >> 4) & 3)));\n                    if ((val >> 0) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(0)));\n                    if ((val >> 1) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(1)));\n                    if ((val >> 2) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(2)));\n                    if ((val >> 3) & 1)\n                        tcg_gen_st_i32(tcg_const_i32(0 /*float32_zero*/),\n                                        cpu_env, offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(3)));\n                    break;\n                case 0x22:\n                    if (ot == MO_32) { /* pinsrd */\n                        if (mod == 3) {\n                            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[rm]);\n                        } else {\n                            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,\n                                                s->mem_index, MO_LEUL);\n                        }\n                        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_L(val & 3)));\n                    } else { /* pinsrq */\n#ifdef TARGET_X86_64\n                        if (mod == 3) {\n                            gen_op_mov_v_reg(ot, cpu_tmp1_i64, rm);\n                        } else {\n                            tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,\n                                                s->mem_index, MO_LEQ);\n                        }\n                        tcg_gen_st_i64(cpu_tmp1_i64, cpu_env,\n                                        offsetof(CPUX86State,\n                                                xmm_regs[reg].ZMM_Q(val & 1)));\n#else\n                        goto illegal_op;\n#endif\n                    }\n                    break;\n                }\n                return;\n            }\n\n            if (b1) {\n                op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,xmm_regs[rm | REX_B(s)]);\n                } else {\n                    op2_offset = offsetof(CPUX86State,xmm_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldo_env_A0(s, op2_offset);\n                }\n            } else {\n                op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n                if (mod == 3) {\n                    op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n                } else {\n                    op2_offset = offsetof(CPUX86State,mmx_t0);\n                    gen_lea_modrm(env, s, modrm);\n                    gen_ldq_env_A0(s, op2_offset);\n                }\n            }\n            val = cpu_ldub_code(env, s->pc++);\n\n            if ((b & 0xfc) == 0x60) { /* pcmpXstrX */\n                set_cc_op(s, CC_OP_EFLAGS);\n\n                if (s->dflag == MO_64) {\n                    /* The helper must use entire 64-bit gp registers */\n                    val |= 1 << 8;\n                }\n            }\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_eppi(cpu_env, cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n\n        case 0x33a:\n            /* Various integer extensions at 0f 3a f[0-f].  */\n            b = modrm | (b1 << 8);\n            modrm = cpu_ldub_code(env, s->pc++);\n            reg = ((modrm >> 3) & 7) | rex_r;\n\n            switch (b) {\n            case 0x3f0: /* rorx Gy,Ey, Ib */\n                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI2)\n                    || !(s->prefix & PREFIX_VEX)\n                    || s->vex_l != 0) {\n                    goto illegal_op;\n                }\n                ot = mo_64_32(s->dflag);\n                gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n                b = cpu_ldub_code(env, s->pc++);\n                if (ot == MO_64) {\n                    tcg_gen_rotri_tl(cpu_T0, cpu_T0, b & 63);\n                } else {\n                    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n                    tcg_gen_rotri_i32(cpu_tmp2_i32, cpu_tmp2_i32, b & 31);\n                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);\n                }\n                gen_op_mov_reg_v(ot, reg, cpu_T0);\n                break;\n\n            default:\n                goto unknown_op;\n            }\n            break;\n\n        default:\n        unknown_op:\n            gen_unknown_opcode(env, s);\n            return;\n        }\n    } else {\n        /* generic MMX or SSE operation */\n        switch(b) {\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n        case 0xc2: /* compare insns */\n            s->rip_offset = 1;\n            break;\n        default:\n            break;\n        }\n        if (is_xmm) {\n            op1_offset = offsetof(CPUX86State,xmm_regs[reg]);\n            if (mod != 3) {\n                int sz = 4;\n\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,xmm_t0);\n\n                switch (b) {\n                case 0x50 ... 0x5a:\n                case 0x5c ... 0x5f:\n                case 0xc2:\n                    /* Most sse scalar operations.  */\n                    if (b1 == 2) {\n                        sz = 2;\n                    } else if (b1 == 3) {\n                        sz = 3;\n                    }\n                    break;\n\n                case 0x2e:  /* ucomis[sd] */\n                case 0x2f:  /* comis[sd] */\n                    if (b1 == 0) {\n                        sz = 2;\n                    } else {\n                        sz = 3;\n                    }\n                    break;\n                }\n\n                switch (sz) {\n                case 2:\n                    /* 32 bit access */\n                    gen_op_ld_v(s, MO_32, cpu_T0, cpu_A0);\n                    tcg_gen_st32_tl(cpu_T0, cpu_env,\n                                    offsetof(CPUX86State,xmm_t0.ZMM_L(0)));\n                    break;\n                case 3:\n                    /* 64 bit access */\n                    gen_ldq_env_A0(s, offsetof(CPUX86State, xmm_t0.ZMM_D(0)));\n                    break;\n                default:\n                    /* 128 bit access */\n                    gen_ldo_env_A0(s, op2_offset);\n                    break;\n                }\n            } else {\n                rm = (modrm & 7) | REX_B(s);\n                op2_offset = offsetof(CPUX86State,xmm_regs[rm]);\n            }\n        } else {\n            op1_offset = offsetof(CPUX86State,fpregs[reg].mmx);\n            if (mod != 3) {\n                gen_lea_modrm(env, s, modrm);\n                op2_offset = offsetof(CPUX86State,mmx_t0);\n                gen_ldq_env_A0(s, op2_offset);\n            } else {\n                rm = (modrm & 7);\n                op2_offset = offsetof(CPUX86State,fpregs[rm].mmx);\n            }\n        }\n        switch(b) {\n        case 0x0f: /* 3DNow! data insns */\n            val = cpu_ldub_code(env, s->pc++);\n            sse_fn_epp = sse_op_table5[val];\n            if (!sse_fn_epp) {\n                goto unknown_op;\n            }\n            if (!(s->cpuid_ext2_features & CPUID_EXT2_3DNOW)) {\n                goto illegal_op;\n            }\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0x70: /* pshufx insn */\n        case 0xc6: /* pshufx insn */\n            val = cpu_ldub_code(env, s->pc++);\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_ppi = (SSEFunc_0_ppi)sse_fn_epp;\n            sse_fn_ppi(cpu_ptr0, cpu_ptr1, tcg_const_i32(val));\n            break;\n        case 0xc2:\n            /* compare insns */\n            val = cpu_ldub_code(env, s->pc++);\n            if (val >= 8)\n                goto unknown_op;\n            sse_fn_epp = sse_op_table4[val][b1];\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        case 0xf7:\n            /* maskmov : we must prepare A0 */\n            if (mod != 3)\n                goto illegal_op;\n            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EDI]);\n            gen_extu(s->aflag, cpu_A0);\n            gen_add_A0_ds_seg(s);\n\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            /* XXX: introduce a new table? */\n            sse_fn_eppt = (SSEFunc_0_eppt)sse_fn_epp;\n            sse_fn_eppt(cpu_env, cpu_ptr0, cpu_ptr1, cpu_A0);\n            break;\n        default:\n            tcg_gen_addi_ptr(cpu_ptr0, cpu_env, op1_offset);\n            tcg_gen_addi_ptr(cpu_ptr1, cpu_env, op2_offset);\n            sse_fn_epp(cpu_env, cpu_ptr0, cpu_ptr1);\n            break;\n        }\n        if (b == 0x2e || b == 0x2f) {\n            set_cc_op(s, CC_OP_EFLAGS);\n        }\n    }\n}\n",
        "linevul": 0.0003404050075914711,
        "sysevr": 0.52274090051651,
        "devign": 0.9962425231933594
    },
    {
        "code": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n{\n    DisplaySurface *surface = qemu_console_surface(s->con);\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n    int width, height, shift_control, line_offset, bwidth, bits;\n    ram_addr_t page0, page1;\n    DirtyBitmapSnapshot *snap = NULL;\n    int disp_width, multi_scan, multi_run;\n    uint8_t *d;\n    uint32_t v, addr1, addr;\n    vga_draw_line_func *vga_draw_line = NULL;\n    bool share_surface;\n    pixman_format_code_t format;\n#ifdef HOST_WORDS_BIGENDIAN\n    bool byteswap = !s->big_endian_fb;\n#else\n    bool byteswap = s->big_endian_fb;\n#endif\n\n    full_update |= update_basic_params(s);\n\n    s->get_resolution(s, &width, &height);\n    disp_width = width;\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n    if (shift_control != 1) {\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n            - 1;\n    } else {\n        /* in CGA modes, multi_scan is ignored */\n        /* XXX: is it correct ? */\n        multi_scan = double_scan;\n    }\n    multi_run = multi_scan;\n    if (shift_control != s->shift_control ||\n        double_scan != s->double_scan) {\n        full_update = 1;\n        s->shift_control = shift_control;\n        s->double_scan = double_scan;\n    }\n\n    if (shift_control == 0) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    } else if (shift_control == 1) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    }\n\n    depth = s->get_bpp(s);\n\n    /*\n     * Check whether we can share the surface with the backend\n     * or whether we need a shadow surface. We share native\n     * endian surfaces for 15bpp and above and byteswapped\n     * surfaces for 24bpp and above.\n     */\n    format = qemu_default_pixman_format(depth, !byteswap);\n    if (format) {\n        share_surface = dpy_gfx_check_format(s->con, format)\n            && !s->force_shadow;\n    } else {\n        share_surface = false;\n    }\n    if (s->line_offset != s->last_line_offset ||\n        disp_width != s->last_width ||\n        height != s->last_height ||\n        s->last_depth != depth ||\n        s->last_byteswap != byteswap ||\n        share_surface != is_buffer_shared(surface)) {\n        if (share_surface) {\n            surface = qemu_create_displaysurface_from(disp_width,\n                    height, format, s->line_offset,\n                    s->vram_ptr + (s->start_addr * 4));\n            dpy_gfx_replace_surface(s->con, surface);\n        } else {\n            qemu_console_resize(s->con, disp_width, height);\n            surface = qemu_console_surface(s->con);\n        }\n        s->last_scr_width = disp_width;\n        s->last_scr_height = height;\n        s->last_width = disp_width;\n        s->last_height = height;\n        s->last_line_offset = s->line_offset;\n        s->last_depth = depth;\n        s->last_byteswap = byteswap;\n        full_update = 1;\n    } else if (is_buffer_shared(surface) &&\n               (full_update || surface_data(surface) != s->vram_ptr\n                + (s->start_addr * 4))) {\n        pixman_format_code_t format =\n            qemu_default_pixman_format(depth, !byteswap);\n        surface = qemu_create_displaysurface_from(disp_width,\n                height, format, s->line_offset,\n                s->vram_ptr + (s->start_addr * 4));\n        dpy_gfx_replace_surface(s->con, surface);\n    }\n\n    if (shift_control == 0) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE4D2;\n        } else {\n            v = VGA_DRAW_LINE4;\n        }\n        bits = 4;\n    } else if (shift_control == 1) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE2D2;\n        } else {\n            v = VGA_DRAW_LINE2;\n        }\n        bits = 4;\n    } else {\n        switch(s->get_bpp(s)) {\n        default:\n        case 0:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8D2;\n            bits = 4;\n            break;\n        case 8:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8;\n            bits = 8;\n            break;\n        case 15:\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n            bits = 16;\n            break;\n        case 16:\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n            bits = 16;\n            break;\n        case 24:\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n            bits = 24;\n            break;\n        case 32:\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n            bits = 32;\n            break;\n        }\n    }\n    vga_draw_line = vga_draw_line_table[v];\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n        s->cursor_invalidate(s);\n    }\n\n    line_offset = s->line_offset;\n#if 0\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n#endif\n    addr1 = (s->start_addr * 4);\n    bwidth = (width * bits + 7) / 8;\n    y_start = -1;\n    d = surface_data(surface);\n    linesize = surface_stride(surface);\n    y1 = 0;\n\n     if (!full_update) {\n         vga_sync_dirty_bitmap(s);\n         snap = memory_region_snapshot_and_clear_dirty(&s->vram, addr1,\n                                                      bwidth * height,\n                                                       DIRTY_MEMORY_VGA);\n     }\n    for(y = 0; y < height; y++) {\n        addr = addr1;\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n            int shift;\n            /* CGA compatibility handling */\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n        }\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n        }\n        update = full_update;\n        page0 = addr;\n        page1 = addr + bwidth - 1;\n        if (full_update) {\n            update = 1;\n        } else {\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n                                                      page0, page1 - page0);\n        }\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n        update |= vga_scanline_invalidated(s, y);\n        if (update) {\n            if (y_start < 0)\n                y_start = y;\n            if (!(is_buffer_shared(surface))) {\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n                if (s->cursor_draw_line)\n                    s->cursor_draw_line(s, d, y);\n            }\n        } else {\n            if (y_start >= 0) {\n                /* flush to display */\n                dpy_gfx_update(s->con, 0, y_start,\n                               disp_width, y - y_start);\n                y_start = -1;\n            }\n        }\n        if (!multi_run) {\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n            if ((y1 & mask) == mask)\n                addr1 += line_offset;\n            y1++;\n            multi_run = multi_scan;\n        } else {\n            multi_run--;\n        }\n        /* line compare acts on the displayed lines */\n        if (y == s->line_compare)\n            addr1 = 0;\n        d += linesize;\n    }\n    if (y_start >= 0) {\n        /* flush to display */\n        dpy_gfx_update(s->con, 0, y_start,\n                       disp_width, y - y_start);\n    }\n    g_free(snap);\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/gitweb.cgi?p=qemu.git;a=commit;h=bfc56535f793c557aa754c50213fc5f882e6482d",
        "vul_func_with_fix": "static void vga_draw_graphic(VGACommonState *s, int full_update)\n{\n    DisplaySurface *surface = qemu_console_surface(s->con);\n    int y1, y, update, linesize, y_start, double_scan, mask, depth;\n    int width, height, shift_control, line_offset, bwidth, bits;\n    ram_addr_t page0, page1;\n    DirtyBitmapSnapshot *snap = NULL;\n    int disp_width, multi_scan, multi_run;\n    uint8_t *d;\n    uint32_t v, addr1, addr;\n    vga_draw_line_func *vga_draw_line = NULL;\n    bool share_surface;\n    pixman_format_code_t format;\n#ifdef HOST_WORDS_BIGENDIAN\n    bool byteswap = !s->big_endian_fb;\n#else\n    bool byteswap = s->big_endian_fb;\n#endif\n\n    full_update |= update_basic_params(s);\n\n    s->get_resolution(s, &width, &height);\n    disp_width = width;\n\n    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;\n    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);\n    if (shift_control != 1) {\n        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)\n            - 1;\n    } else {\n        /* in CGA modes, multi_scan is ignored */\n        /* XXX: is it correct ? */\n        multi_scan = double_scan;\n    }\n    multi_run = multi_scan;\n    if (shift_control != s->shift_control ||\n        double_scan != s->double_scan) {\n        full_update = 1;\n        s->shift_control = shift_control;\n        s->double_scan = double_scan;\n    }\n\n    if (shift_control == 0) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    } else if (shift_control == 1) {\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            disp_width <<= 1;\n        }\n    }\n\n    depth = s->get_bpp(s);\n\n    /*\n     * Check whether we can share the surface with the backend\n     * or whether we need a shadow surface. We share native\n     * endian surfaces for 15bpp and above and byteswapped\n     * surfaces for 24bpp and above.\n     */\n    format = qemu_default_pixman_format(depth, !byteswap);\n    if (format) {\n        share_surface = dpy_gfx_check_format(s->con, format)\n            && !s->force_shadow;\n    } else {\n        share_surface = false;\n    }\n    if (s->line_offset != s->last_line_offset ||\n        disp_width != s->last_width ||\n        height != s->last_height ||\n        s->last_depth != depth ||\n        s->last_byteswap != byteswap ||\n        share_surface != is_buffer_shared(surface)) {\n        if (share_surface) {\n            surface = qemu_create_displaysurface_from(disp_width,\n                    height, format, s->line_offset,\n                    s->vram_ptr + (s->start_addr * 4));\n            dpy_gfx_replace_surface(s->con, surface);\n        } else {\n            qemu_console_resize(s->con, disp_width, height);\n            surface = qemu_console_surface(s->con);\n        }\n        s->last_scr_width = disp_width;\n        s->last_scr_height = height;\n        s->last_width = disp_width;\n        s->last_height = height;\n        s->last_line_offset = s->line_offset;\n        s->last_depth = depth;\n        s->last_byteswap = byteswap;\n        full_update = 1;\n    } else if (is_buffer_shared(surface) &&\n               (full_update || surface_data(surface) != s->vram_ptr\n                + (s->start_addr * 4))) {\n        pixman_format_code_t format =\n            qemu_default_pixman_format(depth, !byteswap);\n        surface = qemu_create_displaysurface_from(disp_width,\n                height, format, s->line_offset,\n                s->vram_ptr + (s->start_addr * 4));\n        dpy_gfx_replace_surface(s->con, surface);\n    }\n\n    if (shift_control == 0) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE4D2;\n        } else {\n            v = VGA_DRAW_LINE4;\n        }\n        bits = 4;\n    } else if (shift_control == 1) {\n        full_update |= update_palette16(s);\n        if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n            v = VGA_DRAW_LINE2D2;\n        } else {\n            v = VGA_DRAW_LINE2;\n        }\n        bits = 4;\n    } else {\n        switch(s->get_bpp(s)) {\n        default:\n        case 0:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8D2;\n            bits = 4;\n            break;\n        case 8:\n            full_update |= update_palette256(s);\n            v = VGA_DRAW_LINE8;\n            bits = 8;\n            break;\n        case 15:\n            v = s->big_endian_fb ? VGA_DRAW_LINE15_BE : VGA_DRAW_LINE15_LE;\n            bits = 16;\n            break;\n        case 16:\n            v = s->big_endian_fb ? VGA_DRAW_LINE16_BE : VGA_DRAW_LINE16_LE;\n            bits = 16;\n            break;\n        case 24:\n            v = s->big_endian_fb ? VGA_DRAW_LINE24_BE : VGA_DRAW_LINE24_LE;\n            bits = 24;\n            break;\n        case 32:\n            v = s->big_endian_fb ? VGA_DRAW_LINE32_BE : VGA_DRAW_LINE32_LE;\n            bits = 32;\n            break;\n        }\n    }\n    vga_draw_line = vga_draw_line_table[v];\n\n    if (!is_buffer_shared(surface) && s->cursor_invalidate) {\n        s->cursor_invalidate(s);\n    }\n\n    line_offset = s->line_offset;\n#if 0\n    printf(\"w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\",\n           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],\n           s->line_compare, sr(s, VGA_SEQ_CLOCK_MODE));\n#endif\n    addr1 = (s->start_addr * 4);\n    bwidth = (width * bits + 7) / 8;\n    y_start = -1;\n    d = surface_data(surface);\n    linesize = surface_stride(surface);\n    y1 = 0;\n\n     if (!full_update) {\n         vga_sync_dirty_bitmap(s);\n         snap = memory_region_snapshot_and_clear_dirty(&s->vram, addr1,\n//flaw_line_below:\n                                                      bwidth * height,\n//fix_flaw_line_below:\n//                                                      line_offset * height,\n                                                       DIRTY_MEMORY_VGA);\n     }\n    for(y = 0; y < height; y++) {\n        addr = addr1;\n        if (!(s->cr[VGA_CRTC_MODE] & 1)) {\n            int shift;\n            /* CGA compatibility handling */\n            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);\n            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);\n        }\n        if (!(s->cr[VGA_CRTC_MODE] & 2)) {\n            addr = (addr & ~0x8000) | ((y1 & 2) << 14);\n        }\n        update = full_update;\n        page0 = addr;\n        page1 = addr + bwidth - 1;\n        if (full_update) {\n            update = 1;\n        } else {\n            update = memory_region_snapshot_get_dirty(&s->vram, snap,\n                                                      page0, page1 - page0);\n        }\n        /* explicit invalidation for the hardware cursor (cirrus only) */\n        update |= vga_scanline_invalidated(s, y);\n        if (update) {\n            if (y_start < 0)\n                y_start = y;\n            if (!(is_buffer_shared(surface))) {\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n                if (s->cursor_draw_line)\n                    s->cursor_draw_line(s, d, y);\n            }\n        } else {\n            if (y_start >= 0) {\n                /* flush to display */\n                dpy_gfx_update(s->con, 0, y_start,\n                               disp_width, y - y_start);\n                y_start = -1;\n            }\n        }\n        if (!multi_run) {\n            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;\n            if ((y1 & mask) == mask)\n                addr1 += line_offset;\n            y1++;\n            multi_run = multi_scan;\n        } else {\n            multi_run--;\n        }\n        /* line compare acts on the displayed lines */\n        if (y == s->line_compare)\n            addr1 = 0;\n        d += linesize;\n    }\n    if (y_start >= 0) {\n        /* flush to display */\n        dpy_gfx_update(s->con, 0, y_start,\n                       disp_width, y - y_start);\n    }\n    g_free(snap);\n    memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));\n}\n",
        "linevul": 0.00993792898952961,
        "sysevr": 0.4717501401901245,
        "devign": 1.0
    },
    {
        "code": "static uint64_t rx_desc_base(E1000State *s)\n{\n    uint64_t bah = s->mac_reg[RDBAH];\n    uint64_t bal = s->mac_reg[RDBAL] & ~0xf;\n\n    return (bah << 32) + bal;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=b0d9ffcd0251161c7c92f94804dcf599dfa3edeb",
        "vul_func_with_fix": "static uint64_t rx_desc_base(E1000State *s)\n{\n    uint64_t bah = s->mac_reg[RDBAH];\n    uint64_t bal = s->mac_reg[RDBAL] & ~0xf;\n\n    return (bah << 32) + bal;\n}\n",
        "linevul": 5.38876629434526e-05,
        "sysevr": 0.46188053488731384,
        "devign": 2.5156814444926567e-06
    },
    {
        "code": "int qemu_fdt_setprop_cell(void *fdt, const char *node_path,\n                          const char *property, uint32_t val)\n{\n    int r;\n\n    r = fdt_setprop_cell(fdt, findnode_nofail(fdt, node_path), property, val);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s = %#08x: %s\", __func__,\n                     node_path, property, val, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=da885fe1ee8b4589047484bd7fa05a4905b52b17",
        "vul_func_with_fix": "int qemu_fdt_setprop_cell(void *fdt, const char *node_path,\n                          const char *property, uint32_t val)\n{\n    int r;\n\n    r = fdt_setprop_cell(fdt, findnode_nofail(fdt, node_path), property, val);\n    if (r < 0) {\n        error_report(\"%s: Couldn't set %s/%s = %#08x: %s\", __func__,\n                     node_path, property, val, fdt_strerror(r));\n        exit(1);\n    }\n\n    return r;\n}\n",
        "linevul": 4.828445889870636e-05,
        "sysevr": 0.467798113822937,
        "devign": 6.8172600897753455e-09
    },
    {
        "code": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n     s->catalog_size = le32_to_cpu(bochs.catalog);\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e3737b820b45e54b059656dc3f914f895ac7a88b",
        "vul_func_with_fix": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n//fix_flaw_line_below:\n//    /* Limit to 1M entries to avoid unbounded allocation. This is what is\n//fix_flaw_line_below:\n//     * needed for the largest image that bximage can create (~8 TB). */\n     s->catalog_size = le32_to_cpu(bochs.catalog);\n//fix_flaw_line_below:\n//    if (s->catalog_size > 0x100000) {\n//fix_flaw_line_below:\n//        error_setg(errp, \"Catalog size is too large\");\n//fix_flaw_line_below:\n//        return -EFBIG;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n//fix_flaw_line_below:\n//    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n//fix_flaw_line_below:\n//        error_setg(errp, \"Catalog size is too small for this disk size\");\n//fix_flaw_line_below:\n//        ret = -EINVAL;\n//fix_flaw_line_below:\n//        goto fail;\n//fix_flaw_line_below:\n//    }\n//fix_flaw_line_below:\n//\n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n",
        "linevul": 0.0003208575944881886,
        "sysevr": 0.47193485498428345,
        "devign": 0.9546496868133545
    },
    {
        "code": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n{\n    s->last_command = cmd;\n\n    switch (cmd) {\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_STATS:\n        VMW_CBPRN(\"Set: Get device statistics\");\n        vmxnet3_fill_stats(s);\n        break;\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n        vmxnet3_activate_device(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n        VMW_CBPRN(\"Set: Update rx mode\");\n        vmxnet3_update_rx_mode(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n        vmxnet3_update_vlan_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n        VMW_CBPRN(\"Set: Update MAC filters\");\n        vmxnet3_update_mcast_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n        VMW_CBPRN(\"Set: Update features\");\n        vmxnet3_update_features(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n        VMW_CBPRN(\"Set: Update power management config\");\n        vmxnet3_update_pm_state(s);\n        break;\n\n    case VMXNET3_CMD_GET_LINK:\n        VMW_CBPRN(\"Set: Get link\");\n        break;\n\n    case VMXNET3_CMD_RESET_DEV:\n        VMW_CBPRN(\"Set: Reset device\");\n        vmxnet3_reset(s);\n        break;\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - deactivate the device\");\n        vmxnet3_deactivate_device(s);\n        break;\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n        break;\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n                  \"adaptive ring info flags\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_LO:\n        VMW_CBPRN(\"Set: Get lower part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_HI:\n        VMW_CBPRN(\"Set: Get upper part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DEV_EXTRA_INFO:\n        VMW_CBPRN(\"Set: Get device extra info\");\n        break;\n\n    default:\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n        break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "vul_func_with_fix": "static void vmxnet3_handle_command(VMXNET3State *s, uint64_t cmd)\n{\n    s->last_command = cmd;\n\n    switch (cmd) {\n    case VMXNET3_CMD_GET_PERM_MAC_HI:\n        VMW_CBPRN(\"Set: Get upper part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_PERM_MAC_LO:\n        VMW_CBPRN(\"Set: Get lower part of permanent MAC\");\n        break;\n\n    case VMXNET3_CMD_GET_STATS:\n        VMW_CBPRN(\"Set: Get device statistics\");\n        vmxnet3_fill_stats(s);\n        break;\n\n    case VMXNET3_CMD_ACTIVATE_DEV:\n        VMW_CBPRN(\"Set: Activating vmxnet3 device\");\n        vmxnet3_activate_device(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_RX_MODE:\n        VMW_CBPRN(\"Set: Update rx mode\");\n        vmxnet3_update_rx_mode(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_VLAN_FILTERS:\n        VMW_CBPRN(\"Set: Update VLAN filters\");\n        vmxnet3_update_vlan_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_MAC_FILTERS:\n        VMW_CBPRN(\"Set: Update MAC filters\");\n        vmxnet3_update_mcast_filters(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_FEATURE:\n        VMW_CBPRN(\"Set: Update features\");\n        vmxnet3_update_features(s);\n        break;\n\n    case VMXNET3_CMD_UPDATE_PMCFG:\n        VMW_CBPRN(\"Set: Update power management config\");\n        vmxnet3_update_pm_state(s);\n        break;\n\n    case VMXNET3_CMD_GET_LINK:\n        VMW_CBPRN(\"Set: Get link\");\n        break;\n\n    case VMXNET3_CMD_RESET_DEV:\n        VMW_CBPRN(\"Set: Reset device\");\n        vmxnet3_reset(s);\n        break;\n\n    case VMXNET3_CMD_QUIESCE_DEV:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_QUIESCE_DEV - deactivate the device\");\n        vmxnet3_deactivate_device(s);\n        break;\n\n    case VMXNET3_CMD_GET_CONF_INTR:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_CONF_INTR - interrupt configuration\");\n        break;\n\n    case VMXNET3_CMD_GET_ADAPTIVE_RING_INFO:\n        VMW_CBPRN(\"Set: VMXNET3_CMD_GET_ADAPTIVE_RING_INFO - \"\n                  \"adaptive ring info flags\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_LO:\n        VMW_CBPRN(\"Set: Get lower part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DID_HI:\n        VMW_CBPRN(\"Set: Get upper part of device ID\");\n        break;\n\n    case VMXNET3_CMD_GET_DEV_EXTRA_INFO:\n        VMW_CBPRN(\"Set: Get device extra info\");\n        break;\n\n    default:\n        VMW_CBPRN(\"Received unknown command: %\" PRIx64, cmd);\n        break;\n    }\n}\n",
        "linevul": 4.7827652451815084e-05,
        "sysevr": 0.4849039316177368,
        "devign": 0.0005494189681485295
    },
    {
        "code": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    if (num_sg >= VIRTQUEUE_MAX_SIZE) {\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n        exit(1);\n    }\n\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");\n            exit(1);\n        }\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commitdiff;h=a890a2f9137ac3cf5b607649e66a6f3a5512d8dc",
        "vul_func_with_fix": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n\n    if (num_sg >= VIRTQUEUE_MAX_SIZE) {\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n        exit(1);\n    }\n\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");\n            exit(1);\n        }\n    }\n}\n",
        "linevul": 6.374981603585184e-05,
        "sysevr": 0.4644993841648102,
        "devign": 2.6104654549108375e-10
    },
    {
        "code": "static int64_t sector_lun2qemu(int64_t sector, IscsiLun *iscsilun)\n{\n    return sector * iscsilun->block_size / BDRV_SECTOR_SIZE;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=a6b3167fa0e825aebb5a7cd8b437b6d41584a196",
        "vul_func_with_fix": "static int64_t sector_lun2qemu(int64_t sector, IscsiLun *iscsilun)\n{\n    return sector * iscsilun->block_size / BDRV_SECTOR_SIZE;\n}\n",
        "linevul": 5.5506443459307775e-05,
        "sysevr": 0.4694848656654358,
        "devign": 0.03544649854302406
    },
    {
        "code": "static int coroutine_fn fid_to_qid(V9fsPDU *pdu, V9fsFidState *fidp,\n                                   V9fsQID *qidp)\n{\n    struct stat stbuf;\n    int err;\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        return err;\n    }\n    stat_to_qid(&stbuf, qidp);\n    return 0;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=1d20398694a3b67a388d955b7a945ba4aa90a8a8",
        "vul_func_with_fix": "static int coroutine_fn fid_to_qid(V9fsPDU *pdu, V9fsFidState *fidp,\n                                   V9fsQID *qidp)\n{\n    struct stat stbuf;\n    int err;\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (err < 0) {\n        return err;\n    }\n    stat_to_qid(&stbuf, qidp);\n    return 0;\n}\n",
        "linevul": 5.8220161008648574e-05,
        "sysevr": 0.4754847288131714,
        "devign": 0.5702147483825684
    },
    {
        "code": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n    int chunk_size;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n    while (data_length) {\n        while (!sg.resid) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n        assert(data_length > 0);\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8",
        "vul_func_with_fix": " pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n//flaw_line_below:\n    int chunk_size;\n//fix_flaw_line_below:\n//    uint32_t chunk_size, elmcnt = 0;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n//flaw_line_below:\n    while (data_length) {\n//flaw_line_below:\n        while (!sg.resid) {\n//fix_flaw_line_below:\n//    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n//fix_flaw_line_below:\n//        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n//flaw_line_below:\n        assert(data_length > 0);\n//flaw_line_below:\n        chunk_size = MIN((unsigned) data_length, sg.resid);\n//fix_flaw_line_below:\n//        chunk_size = MIN(data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n        sg.dataAddr += chunk_size;\n        data_length -= chunk_size;\n        sg.resid -= chunk_size;\n    }\n}\n",
        "linevul": 0.0012049622600898147,
        "sysevr": 0.4525448679924011,
        "devign": 0.08260460942983627
    },
    {
        "code": "int qcow2_read_snapshots(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshotHeader h;\n    QCowSnapshotExtraData extra;\n    QCowSnapshot *sn;\n    int i, id_str_size, name_size;\n    int64_t offset;\n    uint32_t extra_data_size;\n    int ret;\n\n    if (!s->nb_snapshots) {\n        s->snapshots = NULL;\n        s->snapshots_size = 0;\n        return 0;\n    }\n\n    offset = s->snapshots_offset;\n    s->snapshots = g_malloc0(s->nb_snapshots * sizeof(QCowSnapshot));\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n        /* Read statically sized part of the snapshot header */\n        offset = align_offset(offset, 8);\n        ret = bdrv_pread(bs->file, offset, &h, sizeof(h));\n        if (ret < 0) {\n            goto fail;\n        }\n\n        offset += sizeof(h);\n        sn = s->snapshots + i;\n        sn->l1_table_offset = be64_to_cpu(h.l1_table_offset);\n        sn->l1_size = be32_to_cpu(h.l1_size);\n        sn->vm_state_size = be32_to_cpu(h.vm_state_size);\n        sn->date_sec = be32_to_cpu(h.date_sec);\n        sn->date_nsec = be32_to_cpu(h.date_nsec);\n        sn->vm_clock_nsec = be64_to_cpu(h.vm_clock_nsec);\n        extra_data_size = be32_to_cpu(h.extra_data_size);\n\n        id_str_size = be16_to_cpu(h.id_str_size);\n        name_size = be16_to_cpu(h.name_size);\n\n        /* Read extra data */\n        ret = bdrv_pread(bs->file, offset, &extra,\n                         MIN(sizeof(extra), extra_data_size));\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += extra_data_size;\n\n        if (extra_data_size >= 8) {\n            sn->vm_state_size = be64_to_cpu(extra.vm_state_size_large);\n        }\n\n        if (extra_data_size >= 16) {\n            sn->disk_size = be64_to_cpu(extra.disk_size);\n        } else {\n            sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n        }\n\n        /* Read snapshot ID */\n        sn->id_str = g_malloc(id_str_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->id_str, id_str_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += id_str_size;\n        sn->id_str[id_str_size] = '\\0';\n\n        /* Read snapshot name */\n        sn->name = g_malloc(name_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->name, name_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += name_size;\n        sn->name[name_size] = '\\0';\n    }\n\n    s->snapshots_size = offset - s->snapshots_offset;\n    return 0;\n\nfail:\n    qcow2_free_snapshots(bs);\n    return ret;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=c05e4667be91b46ab42b5a11babf8e84d476cc6b",
        "vul_func_with_fix": "int qcow2_read_snapshots(BlockDriverState *bs)\n{\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshotHeader h;\n    QCowSnapshotExtraData extra;\n    QCowSnapshot *sn;\n    int i, id_str_size, name_size;\n    int64_t offset;\n    uint32_t extra_data_size;\n    int ret;\n\n    if (!s->nb_snapshots) {\n        s->snapshots = NULL;\n        s->snapshots_size = 0;\n        return 0;\n    }\n\n    offset = s->snapshots_offset;\n    s->snapshots = g_malloc0(s->nb_snapshots * sizeof(QCowSnapshot));\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n        /* Read statically sized part of the snapshot header */\n        offset = align_offset(offset, 8);\n        ret = bdrv_pread(bs->file, offset, &h, sizeof(h));\n        if (ret < 0) {\n            goto fail;\n        }\n\n        offset += sizeof(h);\n        sn = s->snapshots + i;\n        sn->l1_table_offset = be64_to_cpu(h.l1_table_offset);\n        sn->l1_size = be32_to_cpu(h.l1_size);\n        sn->vm_state_size = be32_to_cpu(h.vm_state_size);\n        sn->date_sec = be32_to_cpu(h.date_sec);\n        sn->date_nsec = be32_to_cpu(h.date_nsec);\n        sn->vm_clock_nsec = be64_to_cpu(h.vm_clock_nsec);\n        extra_data_size = be32_to_cpu(h.extra_data_size);\n\n        id_str_size = be16_to_cpu(h.id_str_size);\n        name_size = be16_to_cpu(h.name_size);\n\n        /* Read extra data */\n        ret = bdrv_pread(bs->file, offset, &extra,\n                         MIN(sizeof(extra), extra_data_size));\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += extra_data_size;\n\n        if (extra_data_size >= 8) {\n            sn->vm_state_size = be64_to_cpu(extra.vm_state_size_large);\n        }\n\n        if (extra_data_size >= 16) {\n            sn->disk_size = be64_to_cpu(extra.disk_size);\n        } else {\n            sn->disk_size = bs->total_sectors * BDRV_SECTOR_SIZE;\n        }\n\n        /* Read snapshot ID */\n        sn->id_str = g_malloc(id_str_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->id_str, id_str_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += id_str_size;\n        sn->id_str[id_str_size] = '\\0';\n\n        /* Read snapshot name */\n        sn->name = g_malloc(name_size + 1);\n        ret = bdrv_pread(bs->file, offset, sn->name, name_size);\n        if (ret < 0) {\n            goto fail;\n        }\n        offset += name_size;\n        sn->name[name_size] = '\\0';\n    }\n\n    s->snapshots_size = offset - s->snapshots_offset;\n    return 0;\n\nfail:\n    qcow2_free_snapshots(bs);\n    return ret;\n}\n",
        "linevul": 0.0002015849604504183,
        "sysevr": 0.46816354990005493,
        "devign": 2.871493506972911e-06
    },
    {
        "code": "static inline void gen_ldo_env_A0(DisasContext *s, int offset)\n{\n    int mem_index = s->mem_index;\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(0)));\n    tcg_gen_addi_tl(cpu_tmp0, cpu_A0, 8);\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_tmp0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(1)));\n}\n",
        "label": "0",
        "addr": "https://github.com/qemu/qemu/commit/30663fd26c0307e414622c7a8607fbc04f92ec14",
        "vul_func_with_fix": "static inline void gen_ldo_env_A0(DisasContext *s, int offset)\n{\n    int mem_index = s->mem_index;\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(0)));\n    tcg_gen_addi_tl(cpu_tmp0, cpu_A0, 8);\n    tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_tmp0, mem_index, MO_LEQ);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, offset + offsetof(ZMMReg, ZMM_Q(1)));\n}\n",
        "linevul": 4.902552973362617e-05,
        "sysevr": 0.48698946833610535,
        "devign": 1.256315158570942e-07
    },
    {
        "code": "static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCIInterrupter *intr = &xhci->intr[v];\n    XHCITRB ev_trb;\n    dma_addr_t addr;\n\n    ev_trb.parameter = cpu_to_le64(event->ptr);\n    ev_trb.status = cpu_to_le32(event->length | (event->ccode << 24));\n    ev_trb.control = (event->slotid << 24) | (event->epid << 16) |\n                     event->flags | (event->type << TRB_TYPE_SHIFT);\n    if (intr->er_pcs) {\n        ev_trb.control |= TRB_C;\n    }\n    ev_trb.control = cpu_to_le32(ev_trb.control);\n\n    trace_usb_xhci_queue_event(v, intr->er_ep_idx, trb_name(&ev_trb),\n                               event_name(event), ev_trb.parameter,\n                               ev_trb.status, ev_trb.control);\n\n    addr = intr->er_start + TRB_SIZE*intr->er_ep_idx;\n    pci_dma_write(pci_dev, addr, &ev_trb, TRB_SIZE);\n\n    intr->er_ep_idx++;\n    if (intr->er_ep_idx >= intr->er_size) {\n        intr->er_ep_idx = 0;\n        intr->er_pcs = !intr->er_pcs;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "vul_func_with_fix": "static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCIInterrupter *intr = &xhci->intr[v];\n    XHCITRB ev_trb;\n    dma_addr_t addr;\n\n    ev_trb.parameter = cpu_to_le64(event->ptr);\n    ev_trb.status = cpu_to_le32(event->length | (event->ccode << 24));\n    ev_trb.control = (event->slotid << 24) | (event->epid << 16) |\n                     event->flags | (event->type << TRB_TYPE_SHIFT);\n    if (intr->er_pcs) {\n        ev_trb.control |= TRB_C;\n    }\n    ev_trb.control = cpu_to_le32(ev_trb.control);\n\n    trace_usb_xhci_queue_event(v, intr->er_ep_idx, trb_name(&ev_trb),\n                               event_name(event), ev_trb.parameter,\n                               ev_trb.status, ev_trb.control);\n\n    addr = intr->er_start + TRB_SIZE*intr->er_ep_idx;\n    pci_dma_write(pci_dev, addr, &ev_trb, TRB_SIZE);\n\n    intr->er_ep_idx++;\n    if (intr->er_ep_idx >= intr->er_size) {\n        intr->er_ep_idx = 0;\n        intr->er_pcs = !intr->er_pcs;\n    }\n}\n",
        "linevul": 5.00804053444881e-05,
        "sysevr": 0.45470452308654785,
        "devign": 3.6283622772970148e-09
    },
    {
        "code": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n            qemu_get_buffer(f, n->mac_table.macs,\n                            n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n            n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n            n->mac_table.in_use = 0;\n        }\n    }\n \n    if (version_id >= 6)\n        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n\n    if (version_id >= 7) {\n        if (qemu_get_be32(f) && !peer_has_vnet_hdr(n)) {\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n\n    if (version_id >= 9) {\n        n->mac_table.multi_overflow = qemu_get_byte(f);\n        n->mac_table.uni_overflow = qemu_get_byte(f);\n    }\n\n    if (version_id >= 10) {\n        n->alluni = qemu_get_byte(f);\n        n->nomulti = qemu_get_byte(f);\n        n->nouni = qemu_get_byte(f);\n        n->nobcast = qemu_get_byte(f);\n    }\n\n    if (version_id >= 11) {\n        if (qemu_get_byte(f) && !peer_has_ufo(n)) {\n            error_report(\"virtio-net: saved image requires TUN_F_UFO support\");\n            return -1;\n        }\n    }\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n         }\n \n         n->curr_queues = qemu_get_be16(f);\n         for (i = 1; i < n->curr_queues; i++) {\n             n->vqs[i].tx_waiting = qemu_get_be32(f);\n         }\n        n->curr_guest_offloads = virtio_net_supported_guest_offloads(n);\n    }\n\n    if (peer_has_vnet_hdr(n)) {\n        virtio_net_apply_guest_offloads(n);\n    }\n\n    virtio_net_set_queues(n);\n\n    /* Find the first multicast entry in the saved MAC filter */\n    for (i = 0; i < n->mac_table.in_use; i++) {\n        if (n->mac_table.macs[i * ETH_ALEN] & 1) {\n            break;\n        }\n    }\n    n->mac_table.first_multi = i;\n\n    /* nc.link_down can't be migrated, so infer link_down according\n     * to link status bit in n->status */\n    link_down = (n->status & VIRTIO_NET_S_LINK_UP) == 0;\n    for (i = 0; i < n->max_queues; i++) {\n        qemu_get_subqueue(n->nic, i)->link_down = link_down;\n    }\n\n    return 0;\n}\n",
        "label": "1",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=eea750a5623ddac7a61982eec8f1c93481857578",
        "vul_func_with_fix": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n            qemu_get_buffer(f, n->mac_table.macs,\n                            n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n            n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n            n->mac_table.in_use = 0;\n        }\n    }\n \n    if (version_id >= 6)\n        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n\n    if (version_id >= 7) {\n        if (qemu_get_be32(f) && !peer_has_vnet_hdr(n)) {\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n\n    if (version_id >= 9) {\n        n->mac_table.multi_overflow = qemu_get_byte(f);\n        n->mac_table.uni_overflow = qemu_get_byte(f);\n    }\n\n    if (version_id >= 10) {\n        n->alluni = qemu_get_byte(f);\n        n->nomulti = qemu_get_byte(f);\n        n->nouni = qemu_get_byte(f);\n        n->nobcast = qemu_get_byte(f);\n    }\n\n    if (version_id >= 11) {\n        if (qemu_get_byte(f) && !peer_has_ufo(n)) {\n            error_report(\"virtio-net: saved image requires TUN_F_UFO support\");\n            return -1;\n        }\n    }\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n         }\n \n         n->curr_queues = qemu_get_be16(f);\n//fix_flaw_line_below:\n//        if (n->curr_queues > n->max_queues) {\n//fix_flaw_line_below:\n//            error_report(\"virtio-net: curr_queues %x > max_queues %x\",\n//fix_flaw_line_below:\n//                         n->curr_queues, n->max_queues);\n//fix_flaw_line_below:\n//            return -1;\n//fix_flaw_line_below:\n//        }\n         for (i = 1; i < n->curr_queues; i++) {\n             n->vqs[i].tx_waiting = qemu_get_be32(f);\n         }\n        n->curr_guest_offloads = virtio_net_supported_guest_offloads(n);\n    }\n\n    if (peer_has_vnet_hdr(n)) {\n        virtio_net_apply_guest_offloads(n);\n    }\n\n    virtio_net_set_queues(n);\n\n    /* Find the first multicast entry in the saved MAC filter */\n    for (i = 0; i < n->mac_table.in_use; i++) {\n        if (n->mac_table.macs[i * ETH_ALEN] & 1) {\n            break;\n        }\n    }\n    n->mac_table.first_multi = i;\n\n    /* nc.link_down can't be migrated, so infer link_down according\n     * to link status bit in n->status */\n    link_down = (n->status & VIRTIO_NET_S_LINK_UP) == 0;\n    for (i = 0; i < n->max_queues; i++) {\n        qemu_get_subqueue(n->nic, i)->link_down = link_down;\n    }\n\n    return 0;\n}\n",
        "linevul": 6.025639595463872e-05,
        "sysevr": 0.48080506920814514,
        "devign": 0.04908966273069382
    },
    {
        "code": "static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n                                int slot)\n{\n    NCQFrame *ncq_fis = (NCQFrame*)cmd_fis;\n    uint8_t tag = ncq_fis->tag >> 3;\n    NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[tag];\n\n    if (ncq_tfs->used) {\n        /* error - already in use */\n        fprintf(stderr, \"%s: tag %d already used\\n\", __FUNCTION__, tag);\n        return;\n    }\n\n    ncq_tfs->used = 1;\n    ncq_tfs->drive = &s->dev[port];\n    ncq_tfs->slot = slot;\n    ncq_tfs->lba = ((uint64_t)ncq_fis->lba5 << 40) |\n                   ((uint64_t)ncq_fis->lba4 << 32) |\n                   ((uint64_t)ncq_fis->lba3 << 24) |\n                   ((uint64_t)ncq_fis->lba2 << 16) |\n                   ((uint64_t)ncq_fis->lba1 << 8) |\n                   (uint64_t)ncq_fis->lba0;\n\n    /* Note: We calculate the sector count, but don't currently rely on it.\n     * The total size of the DMA buffer tells us the transfer size instead. */\n    ncq_tfs->sector_count = ((uint16_t)ncq_fis->sector_count_high << 8) |\n                                ncq_fis->sector_count_low;\n\n    DPRINTF(port, \"NCQ transfer LBA from %\"PRId64\" to %\"PRId64\", \"\n            \"drive max %\"PRId64\"\\n\",\n            ncq_tfs->lba, ncq_tfs->lba + ncq_tfs->sector_count - 2,\n            s->dev[port].port.ifs[0].nb_sectors - 1);\n\n    ahci_populate_sglist(&s->dev[port], &ncq_tfs->sglist, 0);\n    ncq_tfs->tag = tag;\n\n    switch(ncq_fis->command) {\n        case READ_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ reading %d sectors from LBA %\"PRId64\", \"\n                    \"tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio read %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_READ);\n            ncq_tfs->aiocb = dma_bdrv_read(ncq_tfs->drive->port.ifs[0].bs,\n                                           &ncq_tfs->sglist, ncq_tfs->lba,\n                                           ncq_cb, ncq_tfs);\n            break;\n        case WRITE_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ writing %d sectors to LBA %\"PRId64\", tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio write %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_WRITE);\n            ncq_tfs->aiocb = dma_bdrv_write(ncq_tfs->drive->port.ifs[0].bs,\n                                            &ncq_tfs->sglist, ncq_tfs->lba,\n                                            ncq_cb, ncq_tfs);\n            break;\n        default:\n            DPRINTF(port, \"error: tried to process non-NCQ command as NCQ\\n\");\n            qemu_sglist_destroy(&ncq_tfs->sglist);\n            break;\n    }\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ae2158ad6ce0845b2fae2a22aa7f19c0d7a71ce5",
        "vul_func_with_fix": "static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n                                int slot)\n{\n    NCQFrame *ncq_fis = (NCQFrame*)cmd_fis;\n    uint8_t tag = ncq_fis->tag >> 3;\n    NCQTransferState *ncq_tfs = &s->dev[port].ncq_tfs[tag];\n\n    if (ncq_tfs->used) {\n        /* error - already in use */\n        fprintf(stderr, \"%s: tag %d already used\\n\", __FUNCTION__, tag);\n        return;\n    }\n\n    ncq_tfs->used = 1;\n    ncq_tfs->drive = &s->dev[port];\n    ncq_tfs->slot = slot;\n    ncq_tfs->lba = ((uint64_t)ncq_fis->lba5 << 40) |\n                   ((uint64_t)ncq_fis->lba4 << 32) |\n                   ((uint64_t)ncq_fis->lba3 << 24) |\n                   ((uint64_t)ncq_fis->lba2 << 16) |\n                   ((uint64_t)ncq_fis->lba1 << 8) |\n                   (uint64_t)ncq_fis->lba0;\n\n    /* Note: We calculate the sector count, but don't currently rely on it.\n     * The total size of the DMA buffer tells us the transfer size instead. */\n    ncq_tfs->sector_count = ((uint16_t)ncq_fis->sector_count_high << 8) |\n                                ncq_fis->sector_count_low;\n\n    DPRINTF(port, \"NCQ transfer LBA from %\"PRId64\" to %\"PRId64\", \"\n            \"drive max %\"PRId64\"\\n\",\n            ncq_tfs->lba, ncq_tfs->lba + ncq_tfs->sector_count - 2,\n            s->dev[port].port.ifs[0].nb_sectors - 1);\n\n    ahci_populate_sglist(&s->dev[port], &ncq_tfs->sglist, 0);\n    ncq_tfs->tag = tag;\n\n    switch(ncq_fis->command) {\n        case READ_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ reading %d sectors from LBA %\"PRId64\", \"\n                    \"tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio read %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_READ);\n            ncq_tfs->aiocb = dma_bdrv_read(ncq_tfs->drive->port.ifs[0].bs,\n                                           &ncq_tfs->sglist, ncq_tfs->lba,\n                                           ncq_cb, ncq_tfs);\n            break;\n        case WRITE_FPDMA_QUEUED:\n            DPRINTF(port, \"NCQ writing %d sectors to LBA %\"PRId64\", tag %d\\n\",\n                    ncq_tfs->sector_count-1, ncq_tfs->lba, ncq_tfs->tag);\n\n            DPRINTF(port, \"tag %d aio write %\"PRId64\"\\n\",\n                    ncq_tfs->tag, ncq_tfs->lba);\n\n            dma_acct_start(ncq_tfs->drive->port.ifs[0].bs, &ncq_tfs->acct,\n                           &ncq_tfs->sglist, BDRV_ACCT_WRITE);\n            ncq_tfs->aiocb = dma_bdrv_write(ncq_tfs->drive->port.ifs[0].bs,\n                                            &ncq_tfs->sglist, ncq_tfs->lba,\n                                            ncq_cb, ncq_tfs);\n            break;\n        default:\n            DPRINTF(port, \"error: tried to process non-NCQ command as NCQ\\n\");\n            qemu_sglist_destroy(&ncq_tfs->sglist);\n            break;\n    }\n}\n",
        "linevul": 9.115479042520747e-05,
        "sysevr": 0.46970298886299133,
        "devign": 3.72255178071601e-11
    },
    {
        "code": "uint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=e6908bfe8e07f2b452e78e677da1b45b1c0f6829",
        "vul_func_with_fix": "uint32_t read_u32(uint8_t *data, size_t offset)\n{\n    return ((data[offset] << 24) | (data[offset + 1] << 16) |\n            (data[offset + 2] << 8) | data[offset + 3]);\n}\n",
        "linevul": 0.005190023221075535,
        "sysevr": 0.4561067521572113,
        "devign": 2.501207019278695e-10
    },
    {
        "code": "static uint64_t virtio_gpu_get_features(VirtIODevice *vdev, uint64_t features,\n                                        Error **errp)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n\n    if (virtio_gpu_virgl_enabled(g->conf)) {\n        features |= (1 << VIRTIO_GPU_F_VIRGL);\n    }\n    return features;\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "vul_func_with_fix": "static uint64_t virtio_gpu_get_features(VirtIODevice *vdev, uint64_t features,\n                                        Error **errp)\n{\n    VirtIOGPU *g = VIRTIO_GPU(vdev);\n\n    if (virtio_gpu_virgl_enabled(g->conf)) {\n        features |= (1 << VIRTIO_GPU_F_VIRGL);\n    }\n    return features;\n}\n",
        "linevul": 4.6437449782388285e-05,
        "sysevr": 0.46295401453971863,
        "devign": 0.03272852674126625
    },
    {
        "code": "void qemu_spice_create_host_memslot(SimpleSpiceDisplay *ssd)\n{\n    QXLDevMemSlot memslot;\n\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    memset(&memslot, 0, sizeof(memslot));\n    memslot.slot_group_id = MEMSLOT_GROUP_HOST;\n    memslot.virt_end = ~0;\n    qemu_spice_add_memslot(ssd, &memslot, QXL_SYNC);\n}\n",
        "label": "0",
        "addr": "https://git.qemu.org/?p=qemu.git;a=commit;h=ab9509cceabef28071e41bdfa073083859c949a7",
        "vul_func_with_fix": "void qemu_spice_create_host_memslot(SimpleSpiceDisplay *ssd)\n{\n    QXLDevMemSlot memslot;\n\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    memset(&memslot, 0, sizeof(memslot));\n    memslot.slot_group_id = MEMSLOT_GROUP_HOST;\n    memslot.virt_end = ~0;\n    qemu_spice_add_memslot(ssd, &memslot, QXL_SYNC);\n}\n",
        "linevul": 4.544829425867647e-05,
        "sysevr": 0.4604252278804779,
        "devign": 0.004077767953276634
    }
]